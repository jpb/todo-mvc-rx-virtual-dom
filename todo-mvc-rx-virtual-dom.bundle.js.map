{"version":3,"sources":["webpack:///todo-mvc-rx-virtual-dom.bundle.js","webpack:///webpack/bootstrap 3460af023be0bd1c8da3","webpack:///./entry.js","webpack:///./src/app.js?b7a6","webpack:///./src/app.js","webpack:///./~/babel-runtime/helpers/slicedToArray.js","webpack:///./~/babel-runtime/core-js/is-iterable.js","webpack:///./~/core-js/library/fn/is-iterable.js","webpack:///./~/core-js/library/modules/web.dom.iterable.js","webpack:///./~/core-js/library/modules/es6.array.iterator.js","webpack:///./~/core-js/library/modules/$.add-to-unscopables.js","webpack:///./~/core-js/library/modules/$.iter-step.js","webpack:///./~/core-js/library/modules/$.iterators.js","webpack:///./~/core-js/library/modules/$.to-iobject.js","webpack:///./~/core-js/library/modules/$.iobject.js","webpack:///./~/core-js/library/modules/$.cof.js","webpack:///./~/core-js/library/modules/$.defined.js","webpack:///./~/core-js/library/modules/$.iter-define.js","webpack:///./~/core-js/library/modules/$.library.js","webpack:///./~/core-js/library/modules/$.export.js","webpack:///./~/core-js/library/modules/$.global.js","webpack:///./~/core-js/library/modules/$.core.js","webpack:///./~/core-js/library/modules/$.ctx.js","webpack:///./~/core-js/library/modules/$.a-function.js","webpack:///./~/core-js/library/modules/$.redefine.js","webpack:///./~/core-js/library/modules/$.hide.js","webpack:///./~/core-js/library/modules/$.js","webpack:///./~/core-js/library/modules/$.property-desc.js","webpack:///./~/core-js/library/modules/$.descriptors.js","webpack:///./~/core-js/library/modules/$.fails.js","webpack:///./~/core-js/library/modules/$.has.js","webpack:///./~/core-js/library/modules/$.iter-create.js","webpack:///./~/core-js/library/modules/$.set-to-string-tag.js","webpack:///./~/core-js/library/modules/$.wks.js","webpack:///./~/core-js/library/modules/$.shared.js","webpack:///./~/core-js/library/modules/$.uid.js","webpack:///./~/core-js/library/modules/es6.string.iterator.js","webpack:///./~/core-js/library/modules/$.string-at.js","webpack:///./~/core-js/library/modules/$.to-integer.js","webpack:///./~/core-js/library/modules/core.is-iterable.js","webpack:///./~/core-js/library/modules/$.classof.js","webpack:///./~/babel-runtime/core-js/get-iterator.js","webpack:///./~/core-js/library/fn/get-iterator.js","webpack:///./~/core-js/library/modules/core.get-iterator.js","webpack:///./~/core-js/library/modules/$.an-object.js","webpack:///./~/core-js/library/modules/$.is-object.js","webpack:///./~/core-js/library/modules/core.get-iterator-method.js","webpack:///./~/babel-runtime/helpers/classCallCheck.js","webpack:///./~/babel-runtime/helpers/createClass.js","webpack:///./~/babel-runtime/core-js/object/define-property.js","webpack:///./~/core-js/library/fn/object/define-property.js","webpack:///./~/rx/dist/rx.all.js","webpack:///(webpack)/buildin/module.js","webpack:///./~/node-libs-browser/~/process/browser.js","webpack:///./~/seamless-immutable/src/seamless-immutable.js","webpack:///./src/rx-widget.coffee","webpack:///./~/virtual-dom/diff.js","webpack:///./~/virtual-dom/vtree/diff.js","webpack:///./~/x-is-array/index.js","webpack:///./~/virtual-dom/vnode/vpatch.js","webpack:///./~/virtual-dom/vnode/version.js","webpack:///./~/virtual-dom/vnode/is-vnode.js","webpack:///./~/virtual-dom/vnode/is-vtext.js","webpack:///./~/virtual-dom/vnode/is-widget.js","webpack:///./~/virtual-dom/vnode/is-thunk.js","webpack:///./~/virtual-dom/vnode/handle-thunk.js","webpack:///./~/virtual-dom/vtree/diff-props.js","webpack:///./~/is-object/index.js","webpack:///./~/virtual-dom/vnode/is-vhook.js","webpack:///./~/virtual-dom/patch.js","webpack:///./~/virtual-dom/vdom/patch.js","webpack:///./~/global/document.js","webpack:///./~/virtual-dom/vdom/create-element.js","webpack:///./~/virtual-dom/vdom/apply-properties.js","webpack:///./~/virtual-dom/vdom/dom-index.js","webpack:///./~/virtual-dom/vdom/patch-op.js","webpack:///./~/virtual-dom/vdom/update-widget.js","webpack:///./~/virtual-dom/create-element.js","webpack:///./src/todo-list.jsx","webpack:///./~/ub-virtualdom/lib/h.coffee","webpack:///./~/ub-virtualdom/~/lodash/index.js","webpack:///./~/virtual-dom/h.js","webpack:///./~/virtual-dom/virtual-hyperscript/index.js","webpack:///./~/virtual-dom/vnode/vnode.js","webpack:///./~/virtual-dom/vnode/vtext.js","webpack:///./~/virtual-dom/virtual-hyperscript/parse-tag.js","webpack:///./~/browser-split/index.js","webpack:///./~/virtual-dom/virtual-hyperscript/hooks/soft-set-hook.js","webpack:///./~/virtual-dom/virtual-hyperscript/hooks/ev-hook.js","webpack:///./~/ev-store/index.js","webpack:///./~/ev-store/~/individual/one-version.js","webpack:///./~/ev-store/~/individual/index.js","webpack:///./~/dom-delegator/index.js","webpack:///./~/individual/index.js","webpack:///./~/cuid/dist/browser-cuid.js","webpack:///./~/dom-delegator/dom-delegator.js","webpack:///./~/weakmap-shim/create-store.js","webpack:///./~/weakmap-shim/hidden-store.js","webpack:///./~/dom-delegator/add-event.js","webpack:///./~/dom-delegator/remove-event.js","webpack:///./~/dom-delegator/proxy-event.js","webpack:///./~/inherits/inherits_browser.js","webpack:///./~/lodash/index.js","webpack:///./~/lodash/lodash.js","webpack:///./src/todo-item.jsx","webpack:///./src/gen-id.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","global","this","_interopRequireDefault","obj","__esModule","default","_slicedToArray2","_slicedToArray3","_classCallCheck2","_classCallCheck3","_createClass2","_createClass3","Rx","Immutable","RxWidget","TodoList","genId","Todo","container","eventBus","Subject","recording","state","stateSnapshot","key","value","_this","start","Date","takeWhile","event","action","map","set","toArray","subscribe","asMutable","deep","error","console","debug","emit","recording0","options0","_this2","options","_","merge","realTime","speed","undefined","Observable","from","flatMap","just","without","delay","_recordingDelay","onNext","_this3","initial","show","todos","scan","acc","setIn","text","editing","completed","removeIds","toPairs","_ref","_ref2","todo","_ref3","_ref4","asObject","e","root","widget","opts","render","appendChild","init","_isIterable2","_isIterable3","_getIterator2","_getIterator3","sliceIterator","arr","i","_arr","_n","_d","_e","_s","_i","next","done","push","length","err","Array","isArray","Object","TypeError","Iterators","NodeList","HTMLCollection","addToUnscopables","step","toIObject","iterated","kind","_t","_k","O","index","Arguments","IObject","defined","it","cof","propertyIsEnumerable","split","toString","slice","LIBRARY","$export","redefine","hide","has","$iterCreate","setToStringTag","getProto","ITERATOR","BUGGY","keys","FF_ITERATOR","KEYS","VALUES","returnThis","Base","NAME","Constructor","DEFAULT","IS_SET","FORCED","methods","getMethod","proto","TAG","DEF_VALUES","VALUES_BUG","prototype","$native","$default","IteratorPrototype","name","values","entries","P","F","core","ctx","PROTOTYPE","type","source","own","out","IS_FORCED","IS_GLOBAL","G","IS_STATIC","S","IS_PROTO","IS_BIND","B","IS_WRAP","W","target","C","param","Function","window","Math","self","__g","version","__e","aFunction","fn","that","a","b","apply","arguments","$","createDesc","object","setDesc","$Object","create","getPrototypeOf","isEnum","getDesc","getOwnPropertyDescriptor","defineProperty","setDescs","defineProperties","getKeys","getNames","getOwnPropertyNames","getSymbols","getOwnPropertySymbols","each","forEach","bitmap","enumerable","configurable","writable","get","exec","hasOwnProperty","descriptor","def","tag","stat","store","uid","Symbol","SHARED","px","random","concat","$at","String","point","toInteger","TO_STRING","pos","s","l","charCodeAt","charAt","ceil","floor","isNaN","classof","isIterable","ARG","T","callee","anObject","getIterator","iterFn","isObject","getIteratorMethod","instance","_defineProperty","_defineProperty2","props","protoProps","staticProps","desc","__WEBPACK_AMD_DEFINE_RESULT__","process","checkGlobal","cloneArray","len","tryCatcherGen","tryCatchTarget","errorObj","thrower","makeStackTraceLong","observable","hasStacks","stack","indexOf","STACK_JUMP_SEPARATOR","stacks","o","unshift","concatedStacks","join","filterStackString","stackString","lines","desiredLines","line","isInternalFrame","isNodeFrame","stackLine","fileNameAndLineNumber","getFileNameAndLineNumber","fileName","lineNumber","rFileName","rStartingLine","rEndingLine","captureLine","Error","firstLine","attempt1","Number","attempt2","attempt3","equalObjects","other","equalFunc","isLoose","stackA","stackB","objProps","objLength","othProps","othLength","skipCtor","result","objValue","othValue","objCtor","constructor","othCtor","equalByTag","boolTag","dateTag","errorTag","message","numberTag","regexpTag","stringTag","isObjectLike","isLength","MAX_SAFE_INTEGER","isTypedArray","typedArrayTags","objToString","arraySome","array","predicate","equalArrays","arrLength","arrValue","baseIsEqualDeep","objIsArr","othIsArr","objTag","arrayTag","othTag","argsTag","objectTag","objIsObj","isHostObject","othIsObj","isSameTag","objIsWrapped","othIsWrapped","pop","baseIsEqual","arrayInitialize","count","factory","IndexedItem","ScheduledDisposable","scheduler","disposable","isDisposed","scheduleItem","dispose","IsDisposedDisposable","StringIterable","StringIterator","_l","ArrayIterable","_a","ArrayIterator","toLength","numberIsFinite","isFinite","getIterable","$iterator$","sign","number","abs","maxSafeInteger","observableOf","isScheduler","currentThreadScheduler","FromArrayObservable","RepeatSink","observer","parent","amb","falseFactory","argumentsToArray","args","emptyArrayFactory","asObservable","x","notEmpty","concatMap","selector","thisArg","selectorFunc","bindCallback","isPromise","observableFromPromise","isArrayLike","observableFrom","concatAll","arrayIndexOfComparer","item","comparer","HashSet","plucker","currentProp","firstOnly","EmptyError","findValue","yieldIndex","callback","AnonymousObservable","FindValueObserver","toObservable","isObservable","fromPromise","isGeneratorFunction","isGenerator","spawn","isFunction","thunkToObservable","arrayToObservable","objectToObservable","defer","results","observables","forkJoin","res","onError","onCompleted","ctor","displayName","val","createCbObservable","AsyncSubject","createCbHandler","tryCatch","createNodeObservable","createNodeHandler","isNodeList","el","StaticNodeList","ListenDisposable","n","_fn","addEventListener","createEventListener","eventName","handler","disposables","CompositeDisposable","elemToString","add","combineLatestSource","subject","resultSelector","hasValue","hasValueAll","every","identity","isDone","BinaryDisposable","observableWindowWithOpenings","windowOpenings","windowClosingSelector","groupJoin","observableEmpty","win","observableWindowWithBoundaries","windowBoundaries","d","r","RefCountDisposable","addRef","w","observableWindowWithClosingSelector","createWindowClose","windowClose","m1","SingleAssignmentDisposable","setDisposable","take","noop","SerialDisposable","enumerableWhile","condition","WhileEnumerable","Pattern","patterns","Plan","expression","handleOnError","handleOnNext","planCreateObserver","externalSubscriptions","entry","JoinObserver","ActivePlan","joinObserverArray","joinObservers","Map","joinObserver","_observableTimer","dueTime","TimerObservable","observableTimerDateAndPeriod","period","normalizeTime","scheduleRecursiveFuture","now","getTime","observableTimerTimeSpanAndPeriod","schedulePeriodic","observableDefer","observableDelayRelative","subscription","active","cancelable","exception","q","running","materialize","timestamp","notification","shouldRun","recurseDueTime","shouldRecurse","shift","accept","max","observableDelayAbsolute","delayWithSelector","subscriptionDelay","delayDurationSelector","subDelay","delays","remove","atEnd","debounceWithSelector","durationSelector","throttle","currentid","sampleObservable","sampler","sampleSubscribe","sourceSubscription","newValue","timeoutWithSelector","firstTimeout","timeoutDurationSelector","observableNever","observableThrow","TimeoutError","setTimer","timeout","timerWins","switched","myId","timer","oWins","original","defaultScheduler","createTimer","scheduleFuture","transformForObserver","@@transducer/init","@@transducer/step","obs","input","@@transducer/result","OnNextPredicate","OnErrorPredicate","MockPromise","messages","subscriptions","observers","innerNotification","scheduleAbsolute","time","j","jLen","disposableEmpty","objectTypes","function","freeExports","nodeType","freeModule","freeGlobal","freeSelf","freeWindow","moduleExports","thisGlobal","internals","config","Promise","helpers","defaultNow","defaultComparer","y","isEqual","defaultSubComparer","defaultError","defaultKeySerializer","then","isFn","longStackSupport","ObjectDisposedError","ArgumentOutOfRangeError","NotSupportedError","NotImplementedError","notImplemented","notSupported","iterator","Set","doneEnumerator","func","argCount","arg","collection","dontEnums","funcTag","mapTag","setTag","weakMapTag","arrayBufferTag","float32Tag","float64Tag","int8Tag","int16Tag","int32Tag","uint8Tag","uint8ClampedTag","uint16Tag","uint32Tag","objectProto","pow","hasDontEnumBug","dontEnumsLength","prop","inherits","child","__","addProperties","sources","idx","ln","xs","getDisposable","compareTo","PriorityQueue","capacity","items","priorityProto","isHigherPriority","left","right","percolate","temp","heapify","first","peek","removeAt","dequeue","enqueue","CompositeDisposablePrototype","shouldDispose","splice","currentDisposables","Disposable","disposableCreate","empty","isDisposable","checkDisposed","disposableFixup","_fixup","current","old","second","_first","_second","old1","old2","NAryDisposable","_disposables","InnerDisposable","isInnerDisposed","underlyingDisposable","isPrimaryDisposed","schedule","ScheduledItem","invoke","invokeCore","isCancelled","Scheduler","schedulerProto","dt","normalize","_scheduleFuture","timeSpan","invokeRecImmediate","pair","innerAction","state2","scheduleWork","state3","isAdded","group","invokeRecDate","dueTime1","scheduleRecursive","setInterval","clearInterval","catchError","CatchScheduler","scheduleMethod","clearMethod","SchedulePeriodicRecursive","createTick","command","recurse","_period","_action","_state","_cancel","_scheduler","ImmediateScheduler","__super__","immediateScheduler","immediate","CurrentThreadScheduler","runTrampoline","queue","si","scheduleRequired","currentThread","localTimer","localSetTimeout","localClearTimeout","setTimeout","clearTimeout","WScript","Sleep","runTask","handle","currentlyRunning","task","tasksByHandle","postMessageSupported","postMessage","importScripts","isAsync","oldHandler","onmessage","nextHandle","reNative","RegExp","replace","setImmediate","test","nextTick","MSG_PREFIX","onGlobalPostMessage","data","substring","currentId","MessageChannel","channel","port1","port2","document","createElement","scriptElement","onreadystatechange","parentNode","removeChild","documentElement","DefaultScheduler","scheduleAction","ClearDisposable","_id","LocalClearDisposable","async","_handler","_recursiveOriginal","_recursiveWrapper","_wrap","_clone","_getRecursiveWrapper","wrapper","failed","state1","Notification","_accept","_acceptObserver","observerOrOnNext","OnNextNotification","OnErrorNotification","OnCompletedNotification","notificationCreateOnNext","createOnNext","notificationCreateOnError","createOnError","notificationCreateOnCompleted","createOnCompleted","Observer","toNotifier","asObserver","AnonymousObserver","checked","CheckedObserver","observerCreate","fromNotifier","cb","notifyOn","ObserveOnObserver","makeSafe","AnonymousSafeObserver","_onNext","_onError","_onCompleted","observableProto","AbstractObserver","isStopped","fail","_observer","CheckedObserverPrototype","checkAccess","ScheduledObserver","isAcquired","hasFaulted","enqueueNext","enqueueError","enqueueCompleted","work","ensureActive","isOwner","cancel","makeSubscribe","oldOnError","oldSubscribe","_subscribe","oOrOnNext","subscribeOnNext","subscribeOnError","subscribeOnCompleted","ObservableBase","fixSubscriber","subscriber","ado","sub","subscribeCore","AutoDetachObserver","FlatMapObservable","InnerObserver","_wrapResult","i2","Enumerable","ConcatEnumerableObservable","currentItem","currentValue","_recurse","CatchErrorObservable","lastError","catchErrorWhen","notificationHandler","exceptions","notifier","handled","notificationDisposable","outer","inner","exn","ex","RepeatEnumerable","v","RepeatEnumerator","enumerableRepeat","repeat","repeatCount","OfEnumerable","OfEnumerator","enumerableOf","of","ObserveOnObservable","observeOn","SubscribeOnObservable","subscribeOn","FromPromiseObservable","_p","scheduleNext","scheduleError","sad","promise","toPromise","promiseCtor","resolve","reject","ToArrayObservable","Defer","_f","observableFactory","EmptyObservable","EmptySink","sink","run","EMPTY_OBSERVABLE","FromObservable","iterable","_iterable","createScheduleMethod","list","mapFn","mapper","_args","observableFromArray","fromArray","GenerateObservable","cndFn","itrFn","resFn","_cndFn","_itrFn","_resFn","_o","hasResult","generate","initialState","iterate","ofWithScheduler","ofArrayChanges","observe","unobserve","observerFn","changes","ofObjectChanges","NeverObservable","NEVER_OBSERVABLE","never","PairsObservable","_keys","pairs","RangeObservable","rangeCount","loopRecursive","range","RepeatObservable","JustObservable","_value","ThrowObservable","_error","UsingObservable","obsFn","_obsFn","resource","using","resourceFactory","rightSource","leftSource","choiceL","choice","leftChoice","rightSubscription","choiceR","rightChoice","leftSubscription","leftSubscribe","rightSubscribe","CatchObservable","d1","CatchObserver","handlerOrSecond","observableCatch","combineLatest","CombineLatestObservable","params","_params","_cb","CombineLatestObserver","notTheSame","filter","observableConcat","ConcatObserver","ConcatObservable","_sources","MergeObservable","maxConcurrent","g","MergeObserver","activeCount","handleSubscribe","innerSource","maxConcurrentOrOther","observableMerge","mergeAll","MergeAllObservable","MergeAllObserver","CompositeError","errors","innerErrors","MergeDelayErrorObservable","MergeDelayErrorObserver","_group","setCompletion","_inner","mergeDelayError","onErrorResumeNext","OnErrorResumeNextObservable","OnErrorResumeNextObserver","cancellable","SkipUntilObservable","_open","SkipUntilSourceObserver","SkipUntilOtherObserver","_r","skipUntil","SwitchObservable","SwitchObserver","stopped","latest","hasLatest","switchLatest","TakeUntilObservable","TakeUntilObserver","takeUntil","WithLatestFromObservable","_ss","WithLatestFromOtherObserver","outerSad","WithLatestFromSourceObserver","allValues","withLatestFrom","ZipObservable","ZipObserver","_q","shiftEach","queuedValues","zip","ZipIterableObservable","ZipIterableObserver","zipIterable","bufferWithCount","skip","windowWithCount","DematerializeObservable","DematerializeObserver","dematerialize","DistinctUntilChangedObservable","keyFn","DistinctUntilChangedObserver","hasCurrentKey","currentKey","comparerEquals","distinctUntilChanged","TapObservable","_oN","_oE","_oC","t","tap","doAction","doOnNext","tapOnNext","doOnError","tapOnError","doOnCompleted","tapOnCompleted","FinallyObservable","FinallyDisposable","IgnoreElementsObservable","ignoreElements","MaterializeObservable","MaterializeObserver","retry","retryCount","retryWhen","ScanObservable","accumulator","hasSeed","seed","ScanObserver","_hs","_ha","_hv","SkipLastObservable","_c","SkipLastObserver","skipLast","startWith","TakeLastObserver","takeLast","TakeLastBufferObserver","takeLastBuffer","Infinity","createWindow","refCountDisposable","selectConcat","selectorResult","concatMapObserver","selectConcatObserver","onNextFunc","onErrorFunc","onCompletedFunc","DefaultIfEmptyObserver","defaultIfEmpty","defaultValue","retValue","DistinctObservable","cmpFn","_keyFn","_cmpFn","DistinctObserver","_h","distinct","keySelector","groupBy","elementSelector","groupByUntil","groupDisposable","handleError","fireNewMapEntry","writer","GroupedObservable","durationGroup","duration","md","element","MapObservable","innerMap","internalMap","select","selectorFn","pluck","selectMany","flatMapObserver","selectManyObserver","flatMapLatest","SkipObservable","_count","SkipObserver","SkipWhileObservable","SkipWhileObserver","skipWhile","TakeObservable","TakeObserver","TakeWhileObservable","TakeWhileObserver","FilterObservable","innerPredicate","internalFilter","shouldYield","where","ExtremaByObservable","k","ExtremaByObserver","_v","comparison","ReduceObservable","ReduceObserver","reduce","SomeObservable","SomeObserver","Boolean","some","IsEmptyObservable","IsEmptyObserver","isEmpty","EveryObservable","EveryObserver","IncludesObservable","elem","_elem","IncludesObserver","includes","searchElement","fromIndex","CountObservable","CountObserver","IndexOfObservable","IndexOfObserver","SumObservable","SumObserver","sum","minBy","min","maxBy","AverageObservable","AverageObserver","average","sequenceEqual","donel","doner","ql","qr","subscription1","equal","subscription2","ElementAtObservable","ElementAtObserver","elementAt","SingleObserver","_obj","single","FirstObservable","FirstObserver","LastObservable","LastObserver","last","_y","find","findIndex","ToSetObservable","ToSetObserver","toSet","ToMapObservable","ToMapObserver","_m","toMap","SliceObservable","_b","SliceObserver","begin","end","LastIndexOfObservable","LastIndexOfObserver","lastIndexOf","wrap","createObservable","__generatorFunction__","gen","processGenerator","ret","context","observableToAsync","toAsync","fromCallback","fromNodeCallback","removeEventListener","useNativeEvents","EventObservable","_el","createHandler","fromEvent","addListener","fromEventPattern","h","removeListener","on","off","publish","refCount","EventPatternObservable","del","_add","_del","EventPatternDisposable","_ret","returnValue","addHandler","removeHandler","startAsync","functionAsync","PausableObservable","pauser","controller","conn","connection","pausable","connect","pause","resume","PausableBufferedObservable","drainQueue","previousShouldFire","shouldFire","pausableBuffered","ControlledObservable","enableQueue","ControlledSubject","multicast","request","numberOfItems","requestedCount","requestedDisposable","hasFailed","hasCompleted","disposeCurrentRequest","_processRequest","remaining","controlled","StopAndWaitObservable","StopAndWaitObserver","__sub__","scheduleDisposable","innerScheduleMethod","stopAndWait","WindowedObservable","windowSize","WindowedObserver","received","windowed","pipe","dest","onDrain","write","_isStdio","MulticastObservable","fn1","fn2","_fn1","_fn2","connectable","subjectOrSubjectSelector","ConnectableObservable","share","publishLast","publishValue","initialValueOrSelector","initialValue","BehaviorSubject","shareValue","replay","bufferSize","ReplaySubject","shareReplay","InnerSubscription","RefCountObservable","_connectableSubscription","_connection","_source","_subject","ConnectDisposable","singleInstance","getObservable","hasObservable","leftDurationSelector","rightDurationSelector","leftDone","rightDone","leftId","rightId","leftMap","rightMap","size","buffer","windowOpeningsOrClosingSelector","PairwiseObservable","PairwiseObserver","_hp","pairwise","partition","letBind","thenSource","elseSourceOrScheduler","forIn","observableWhileDo","whileDo","doWhile","defaultSourceOrScheduler","ExpandObservable","ExpandObserver","_ensureActive","_m1","expand","ForkJoinObservable","finished","hasResults","ForkJoinObserver","subs","_subs","manySelect","extend","chain","curr","ChainObservable","head","tail","_values","and","thenDo","activate","deactivate","errHandler","activePlan","jlen","removeActivePlan","addActivePlan","match","hasValues","firstValues","isCompleted","activePlans","JoinObserverPrototype","when","plans","outObserver","_dt","observableinterval","interval","periodOrScheduler","firstArg","DebounceObservable","DebounceObserver","debounce","windowWithTime","timeShiftOrScheduler","timeShift","isSpan","isShift","timerD","nextSpan","nextShift","newTotalTime","ts","totalTime","windowWithTimeOrCount","windowId","newId","newWindow","bufferWithTime","bufferWithTimeOrCount","TimeIntervalObservable","TimeIntervalObserver","span","timeInterval","TimestampObservable","TimestampObserver","sample","throttleLatest","intervalOrSampler","GenerateAbsoluteObservable","timeFn","_timeFn","_hasResult","generateWithAbsoluteTime","timeSelector","GenerateRelativeObservable","generateWithRelativeTime","DelaySubscription","delaySubscription","SkipLastWithTimeObservable","SkipLastWithTimeObserver","skipLastWithTime","TakeLastWithTimeObservable","TakeLastWithTimeObserver","takeLastWithTime","takeLastBufferWithTime","TakeWithTimeObservable","takeWithTime","SkipWithTimeObservable","SkipWithTimeObserver","skipWithTime","SkipUntilWithTimeObservable","startTime","_st","SkipUntilWithTimeObserver","skipUntilWithTime","takeUntilWithTime","endTime","windowDuration","RangeError","lastOnNext","TransduceObserver","xform","_xform","transduce","transducer","SwitchFirstObservable","hasCurrent","SwitchFirstObserver","switchFirst","flatMapFirst","selectManyFirst","flatMapWithMaxConcurrent","limit","VirtualTimeScheduler","initialClock","clock","isEnabled","VirtualTimeSchedulerPrototype","toAbsoluteTime","toRelativeTime","scheduleRelative","runAt","getNext","stop","advanceTo","dueToClock","advanceBy","sleep","HistoricalScheduler","cmp","HistoricalSchedulerProto","absolute","relative","equals","ReactiveTest","created","subscribed","disposed","ticks","Recorded","Subscription","unsubscribe","MAX_VALUE","MockDisposable","disposes","MockObserver","MockObserverPrototype","onResolved","onRejected","newPromise","HotObservable","ColdObservable","TestScheduler","baseComparer","startScheduler","createFn","settings","createObserver","createHotObservable","createColdObservable","createResolvedPromise","createRejectedPromise","reason","__subscribe","AutoDetachObserverPrototype","UnderlyingObservable","u","_u","underlyingObservable","mergedDisposable","hasError","hasObservers","os","AnonymousSubject","getValue","createRemovableDisposable","so","_trim","Pauser","webpackPolyfill","deprecate","paths","children","cleanUpNextTick","draining","currentQueue","queueIndex","Item","fun","title","browser","env","argv","versions","once","removeAllListeners","binding","cwd","chdir","dir","umask","addPropertyTo","methodName","banProperty","ImmutableError","addImmutabilityTag","immutabilityTag","isImmutable","isMergableObject","__proto__","makeImmutable","bannedMethods","NODE_ENV","freeze","makeMethodReturnImmutable","currentMethod","arraySet","mutable","asMutableArray","makeImmutableArray","arraySetIn","pth","thisHead","immutableEmptyArray","nonMutatingArrayMethods","mutatingArrayMethods","makeImmutableDate","date","asMutableDate","mutatingDateMethods","iteratorResult","keysToRemove","instantiateEmptyObject","makeImmutableObject","asDeepMutable","quickCopy","src","addToResult","currentObj","otherObj","immutableValue","mergerResult","merger","JSON","stringify","receivedArray","otherFromArray","objectSetIn","path","objectSet","immutableEmptyObject","property","asMutableObject","instantiatePlainObject","mutatingObjectMethods","clone","nonMutatingObjectMethods","createPatcher","diff","patch","calculatePatches","newState","newTree","vTree","patches","_patchObs","domNode","_patcherSubscription","destroy","walk","applyClear","isThunk","thunks","isWidget","clearState","appendPatch","VPatch","REMOVE","isVNode","tagName","namespace","propsPatch","diffProps","properties","PROPS","diffChildren","VNODE","isVText","VTEXT","WIDGET","aChildren","orderedSet","reorder","bChildren","aLen","bLen","leftNode","rightNode","INSERT","moves","ORDER","vNode","unhook","destroyWidgets","hasWidgets","hasThunks","nodes","handleThunk","thunkPatch","hasPatches","THUNK","hooks","undefinedKeys","descendantHooks","bChildIndex","keyIndex","bKeys","bFree","free","aChildIndex","aKeys","aFree","newChildren","freeIndex","freeCount","deletedItems","itemIndex","aItem","lastFreeIndex","newItem","simulateItem","simulate","simulateIndex","removes","inserts","wantedItem","to","nativeIsArray","VirtualPatch","NONE","isVirtualNode","isVirtualText","renderedA","renderedB","renderThunk","thunk","previous","renderedThunk","vnode","aKey","aValue","bValue","getPrototype","isHook","objectDiff","bKey","hook","rootNode","renderOptions","patchRecursive","indices","patchIndices","domIndex","ownerDocument","nodeIndex","applyPatch","patchList","newNode","patchOp","topLevel","minDoc","doccy","doc","warn","createTextNode","node","createElementNS","applyProperties","childNode","propName","propValue","removeProperty","patchObject","previousValue","attrName","removeAttribute","style","replacer","attrValue","setAttribute","tree","sort","ascending","rootIndex","indexInRange","vChildren","childNodes","vChild","noChild","nextIndex","currentIndex","minIndex","maxIndex","vpatch","removeNode","insertNode","stringPatch","widgetPatch","vNodePatch","reorderChildren","replaceRoot","destroyWidget","leftVNode","vText","replaceData","replaceChild","updating","updateWidget","update","insert","keyMap","insertBefore","oldRoot","newRoot","TodoItem","activeItems","completedItems","allItems","todoItems","todoItem","class","ev-click","ev","toggelAll","for","keyCode","ev-keyup","placeholder","todoList","href","clearButton","Delegator","isVHook","origH","topLevelWhitelistedAttrs","normalizedAttributes","origAttributes","secondArg","attributes","className","baseCompareAscending","valIsNull","valIsUndef","valIsReflexive","othIsNull","othIsUndef","othIsReflexive","baseFindIndex","fromRight","baseIndexOf","indexOfNaN","baseIsFunction","baseToString","charsLeftIndex","string","chars","charsRightIndex","compareAscending","criteria","compareMultiple","orders","objCriteria","othCriteria","ordersLength","order","deburrLetter","letter","deburredLetters","escapeHtmlChar","chr","htmlEscapes","escapeRegExpChar","leadingChar","whitespaceChar","regexpEscapes","stringEscapes","escapeStringChar","isSpace","charCode","replaceHolders","resIndex","PLACEHOLDER","sortedUniq","iteratee","seen","computed","trimmedLeftIndex","trimmedRightIndex","unescapeHtmlChar","htmlUnescapes","runInContext","lodash","LazyWrapper","LodashWrapper","wrapperClone","baseLodash","chainAll","actions","__wrapped__","__actions__","__chain__","__dir__","__filtered__","__iteratees__","__takeCount__","POSITIVE_INFINITY","__views__","lazyClone","arrayCopy","lazyReverse","lazyValue","isArr","isRight","view","getView","iteratees","iterLength","takeCount","nativeMin","LARGE_ARRAY_SIZE","baseWrapperValue","reverse","iterIndex","LAZY_MAP_FLAG","LAZY_FILTER_FLAG","MapCache","__data__","mapDelete","mapGet","mapHas","mapSet","SetCache","hash","nativeCreate","cacheIndexOf","cache","cachePush","arrayConcat","othIndex","arrayEach","arrayEachRight","arrayEvery","arrayExtremum","comparator","exValue","arrayFilter","arrayMap","arrayPush","offset","arrayReduce","initFromArray","arrayReduceRight","arraySum","assignDefaults","objectValue","sourceValue","assignOwnDefaults","assignWith","customizer","baseAssign","baseCopy","baseAt","isNil","propsLength","isIndex","baseCallback","baseMatches","baseMatchesProperty","baseClone","isDeep","initCloneArray","isFunc","cloneableTags","initCloneByTag","initCloneObject","baseForOwn","subValue","baseDelay","wait","FUNC_ERROR_TEXT","baseDifference","getIndexOf","isCommon","createCache","valuesLength","valuesIndex","baseEvery","baseEach","baseExtremum","baseFill","baseFilter","baseFind","eachFunc","retKey","baseFlatten","isStrict","isArguments","baseForIn","baseFor","keysIn","baseForOwnRight","baseForRight","baseFunctions","baseGet","pathKey","toObject","baseIsMatch","matchData","noCustomizer","srcValue","baseMap","getMatchData","isKey","isStrictComparable","toPath","baseSlice","baseMerge","isSrcArr","baseMergeDeep","mergeFunc","isPlainObject","toPlainObject","baseProperty","basePropertyDeep","basePullAt","indexes","baseRandom","nativeFloor","nativeRandom","baseReduce","initFromCollection","baseSome","baseSortBy","baseSortByOrder","getCallback","baseSum","baseUniq","isLarge","seenIndex","baseValues","baseWhile","isDrop","binaryIndex","retHighest","low","high","HALF_MAX_ARRAY_LENGTH","mid","binaryIndexBy","valIsNaN","isDef","isReflexive","setLow","MAX_ARRAY_INDEX","bufferClone","ArrayBuffer","byteLength","Uint8Array","composeArgs","partials","holders","holdersLength","argsIndex","argsLength","nativeMax","leftIndex","leftLength","composeArgsRight","holdersIndex","rightIndex","rightLength","createAggregator","setter","initializer","createAssigner","assigner","restParam","guard","isIterateeCall","createBaseEach","getLength","createBaseFor","keysFunc","createBindWrapper","Ctor","createCtorWrapper","createCompounder","words","deburr","thisBinding","baseCreate","createCurry","flag","curryFunc","arity","createWrapper","createDefaults","createExtremum","toIterable","createFind","createFindIndex","createFindKey","objectFunc","createFlow","funcs","thru","getFuncName","funcName","getData","isLaziable","ARY_FLAG","CURRY_FLAG","PARTIAL_FLAG","REARG_FLAG","plant","createForEach","arrayFunc","createForIn","createForOwn","createObjectMapper","isMapKeys","mapped","createPadDir","createPadding","createPartial","partialFunc","createReduce","createHybridWrapper","bitmask","partialsRight","holdersRight","argPos","ary","isCurry","isCurryRight","argsHolders","newArgPos","newArity","newsHolders","newHoldersRight","newPartials","newPartialsRight","PARTIAL_RIGHT_FLAG","isCurryBound","BIND_FLAG","BIND_KEY_FLAG","newData","setData","isBind","isBindKey","isAry","CURRY_BOUND_FLAG","CURRY_RIGHT_FLAG","strLength","nativeIsFinite","padLength","nativeCeil","createPartialWrapper","createRound","precision","createSortedIndex","mergeData","baseSetData","realNames","otherFunc","getNative","isNative","transforms","byteOffset","reFlags","lastIndex","invokePath","reIsUint","reIsPlainProp","reIsDeepProp","srcBitmask","newBitmask","isCombo","mergeDefaults","pickByArray","pickByCallback","oldArray","shimKeys","allowIndexes","rePropName","quote","reEscapeChar","chunk","compact","drop","dropRight","dropRightWhile","dropWhile","fill","flatten","flattenDeep","pull","rest","takeRight","takeRightWhile","uniq","isSorted","unzip","unzipWith","xor","zipObject","interceptor","wrapperChain","wrapperCommit","wrapperPlant","wrapperReverse","wrapped","wrapperToString","wrapperValue","findWhere","isString","rand","shuffle","sortBy","sortByOrder","after","before","timeoutId","maxTimeoutId","lastCalled","trailingCall","complete","isCalled","delayed","stamp","maxDelayed","trailing","debounced","leading","maxWait","leadingCall","memoize","resolver","memoized","Cache","negate","otherArgs","spread","cloneDeep","gt","gte","isBoolean","isDate","isElement","isError","isMatch","isNumber","reIsNative","fnToString","reIsHostCtor","isNull","isRegExp","isUndefined","lt","lte","functions","invert","multiValue","isProto","skipIndexes","nested","transform","valuesIn","inRange","floating","noMin","noMax","parseFloat","capitalize","toUpperCase","reLatin1","reComboMark","endsWith","position","escape","reHasUnescapedHtml","reUnescapedHtml","escapeRegExp","reHasRegExpChars","reRegExpChars","pad","parseInt","radix","trim","nativeParseInt","reHasHexPrefix","startsWith","template","otherOptions","templateSettings","isEscaping","isEvaluating","imports","importsKeys","importsValues","interpolate","reNoMatch","reDelimiters","reInterpolate","reEsTemplate","evaluate","sourceURL","templateCounter","escapeValue","interpolateValue","esTemplateValue","evaluateValue","reUnescapedString","variable","reEmptyStringLeading","reEmptyStringMiddle","reEmptyStringTrailing","attempt","trimLeft","trimRight","trunc","DEFAULT_TRUNC_LENGTH","omission","DEFAULT_TRUNC_OMISSION","separator","search","newEnd","unescape","reHasEscapedHtml","reEscapedHtml","pattern","reWords","matches","constant","matchesProperty","mixin","isObj","methodNames","noConflict","oldDash","propertyOf","times","MAX_ARRAY_LENGTH","uniqueId","prefix","idCounter","augend","addend","defaults","pick","contextProps","arrayProto","stringProto","WeakMap","nativeKeys","nativeNow","NEGATIVE_INFINITY","metaMap","support","reEscape","reEvaluate","baseEachRight","HOT_SPAN","HOT_COUNT","difference","findLastIndex","intersection","arrays","caches","pullAt","sortedIndex","sortedLastIndex","union","zipWith","wrapperConcat","at","countBy","findLast","forEachRight","indexBy","isProp","reduceRight","sortByAll","bind","bindAll","bindKey","curry","curryRight","flow","flowRight","modArgs","partial","partialRight","rearg","assign","defaultsDeep","findKey","findLastKey","forInRight","forOwn","forOwnRight","mapKeys","mapValues","omit","camelCase","word","toLowerCase","kebabCase","padLeft","padRight","snakeCase","startCase","method","methodOf","round","backflow","collect","compose","eachRight","unique","all","any","contains","eq","detect","foldl","foldr","include","inject","VERSION","filtered","isFilter","takeName","dropName","operationName","createCallback","checkIteratee","retUnwrapped","lodashFunc","isHybrid","isLazy","useLazy","onlyLazy","chainName","names","commit","toJSON","valueOf","upper","lower","À","Á","Â","Ã","Ä","Å","à","á","â","ã","ä","å","Ç","ç","Ð","ð","È","É","Ê","Ë","è","é","ê","ë","Ì","Í","Î","Ï","ì","í","î","ï","Ñ","ñ","Ò","Ó","Ô","Õ","Ö","Ø","ò","ó","ô","õ","ö","ø","Ù","Ú","Û","Ü","ù","ú","û","ü","Ý","ý","ÿ","Æ","æ","Þ","þ","ß","&","<",">","\"","'","`","&amp;","&lt;","&gt;","&quot;","&#39;","&#96;","0","1","2","3","4","5","6","7","8","9","A","D","E","f","\\","\n","\r"," "," ","isChildren","parseTag","softSetHook","transformProperties","addChild","VNode","VText","isChild","UnexpectedVirtualElement","foreignObject","parentVnode","substr","evHook","isVThunk","errorString","VirtualNode","noProperties","noChildren","descendants","VirtualText","noId","tagParts","classIdSplit","notClassId","classes","part","undef","nativeSplit","compliantExecNpcg","str","separator2","lastLength","output","flags","ignoreCase","multiline","extended","sticky","lastLastIndex","SoftSetHook","propertyName","EvHook","EvStore","es","hashKey","OneVersionConstraint","MY_VERSION","OneVersion","moduleName","enforceKey","versionValue","Individual","globalDocument","cacheKey","cacheTokenKey","cuid","delegator","delegatorCache","delegators","DOMDelegator","defaultEvents","commonEvents","listenTo","versionKey","allocateHandle","transformHandle","app","blockSize","base","discreteValues","num","randomBlock","safeCounter","api","counter","fingerprint","slug","print","globalCount","navigator","mimeTypes","userAgent","register","applitude","events","rawEventListeners","globalListeners","globalHandlers","globalEvent","ProxyEvent","currentTarget","delegatorTarget","callListeners","findAndInvokeListeners","listener","getListener","handlers","listenerEvent","_bubbles","nextTarget","allHandler","Listener","handleEvent","HANDLER_STORE","Handle","createStore","addEvent","removeEvent","broadcast","addGlobalEventListener","listeners","removeGlobalEventListener","unlistenTo","hiddenStore","rkeyEvent","KeyEvent","rmouseEvent","MouseEvent","ALL_PROPS","propKey","_rawEvent","MOUSE_PROPS","mousePropKey","KEY_PROPS","keyPropKey","preventDefault","startPropagation","superCtor","super_","TempCtor","addMapEntry","addSetEntry","arrayIncludes","arrayIncludesWith","baseTimes","baseToPairs","baseUnary","charsStartIndex","strSymbols","chrSymbols","charsEndIndex","iteratorToArray","mapToArray","setToArray","stringSize","reHasComplexSymbol","reComplexSymbol","stringToArray","__index__","__values__","copyArray","Hash","hashDelete","hashHas","hashGet","HASH_UNDEFINED","hashSet","clear","mapClear","isKeyable","assocDelete","assocGet","assocHas","assocSet","cacheHas","Stack","stackClear","stackDelete","stackGet","stackHas","stackSet","assocIndexOf","assignInDefaults","assignMergeValue","assignValue","copyObject","baseClamp","getTag","genTag","copySymbols","stacked","baseConforms","isArrayLikeObject","baseToPath","baseHas","baseHasIn","baseInRange","baseIntersection","baseInvoke","isPartial","PARTIAL_COMPARE_FLAG","UNORDERED_COMPARE_FLAG","baseIteratee","baseKeys","baseKeysIn","hasIn","baseOrderBy","toIteratee","getIteratee","basePick","basePickBy","basePullAll","basePullAllBy","baseRange","baseSet","baseSortedIndex","baseSortedIndexBy","baseSortedUniq","baseSortedUniqBy","stringToPath","createSet","baseUnset","baseXor","cloneBuffer","cloneMap","cloneRegExp","regexp","cloneSet","cloneSymbol","symbol","_Symbol","symbolValueOf","cloneTypedArray","typedArray","copyObjectWith","createBaseWrapper","createCaseFirst","createCurryWrapper","createRecurryWrapper","prereq","isFlip","FLIP_FLAG","createOver","createRange","toNumber","wrapFunc","isUnordered","compared","convert","symbolTag","objectToString","hasPath","hasFunc","indexKeys","isPrototype","toArrayLikeObject","toFunction","fromPairs","nativeJoin","pullAll","pullAllBy","nativeReverse","sortedIndexBy","sortedIndexOf","sortedLastIndexBy","sortedLastIndexOf","sortedUniqBy","uniqBy","uniqWith","valsLength","wrapperFlatMap","wrapperNext","wrapperToIterator","orderBy","sampleSize","flush","flip","unary","cloneWith","cloneDeepWith","isEqualWith","isInteger","isMatchWith","funcToString","objectCtorString","isSafeInteger","isSymbol","iteratorSymbol","INFINITY","MAX_INTEGER","remainder","reTrim","isBinary","reIsBinary","reIsOctal","freeParseInt","reIsBadHex","NAN","toSafeInteger","symbolToString","functionsIn","multiVal","omitBy","pickBy","setWith","toPairsIn","unset","clamp","freeParseFloat","upperFirst","reHasRegExpChar","reRegExpChar","padEnd","padStart","assignInWith","toLower","toUpper","trimEnd","reTrimEnd","trimStart","reTrimStart","truncate","reHasComplexWord","reComplexWord","reBasicWord","cond","conforms","nthArg","mean","subtract","minuend","subtrahend","sumBy","Reflect","enumerate","mapCtorString","setCtorString","symbolProto","ctorString","differenceBy","differenceWith","intersectionBy","intersectionWith","unionBy","unionWith","xorBy","xorWith","wrapperAt","invokeMap","keyBy","overArgs","funcsLength","assignIn","mergeWith","lowerCase","lowerFirst","upperCase","over","overEvery","overSome","rangeRight","extendWith","LAZY_WHILE_FLAG","isTaker","isUnwrapped","rsAstralRange","rsComboRange","rsDingbatRange","rsLowerRange","rsMathOpRange","rsNonCharRange","rsQuoteRange","rsSpaceRange","rsUpperRange","rsVarRange","rsBreakRange","rsAstral","rsBreak","rsCombo","rsDigits","rsDingbat","rsLower","rsMisc","rsModifier","rsNonAstral","rsRegional","rsSurrPair","rsUpper","rsZWJ","rsLowerMisc","rsUpperMisc","reOptMod","rsOptVar","rsOptJoin","rsSeq","rsEmoji","rsSymbol","cssClass","save","ev-dblclick","ev-blur","autofocus"],"mappings":"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EAAAqT,QACArT,EAAA64B,UACA74B,EAAA84B,YACA94B,EAAAo7B,SACAp7B,EAAAuT,SACAvT,EAAAwT,aACAxT,EAAAlrD,UACAkrD,EAAAwX,YACAxX,EAAA1xD,WACA0xD,EAAAoM,SACApM,EAAA7nB,QACA6nB,EAAAyT,OACAzT,EAAA29B,SACA39B,EAAA49B,WACA59B,EAAA1zB,OACA0zB,EAAA0T,aACA1T,EAAAke,WAGAle,EAAA1nD,KAAAC,GACAynD,EAAA+gB,UAAAxC,GACAve,EAAA5e,OAAA88C,GACAl+B,EAAA2+B,WAAA/C,GAGAhgB,GAAA5b,KAKAA,EAAAl4C,OACAk4C,EAAA0a,WACA1a,EAAAigB,aACAjgB,EAAA8X,cACA9X,EAAA5lD,QACA4lD,EAAAq7B,SACAr7B,EAAAtP,SACAsP,EAAAgW,aACAhW,EAAAy5B,iBACAz5B,EAAAw5B,aACAx5B,EAAAqM,UACArM,EAAAkY,YACAlY,EAAAohB,MACAphB,EAAAoY,UACApY,EAAAuY,gBACAvY,EAAA53C,SACA43C,EAAA9oB,QACA8oB,EAAA7oB,aACA6oB,EAAAyf,WACAzf,EAAAse,YACAte,EAAA0d,iBACA1d,EAAA0f,eACA1f,EAAA3lD,SACA2lD,EAAAznD,WACAynD,EAAAue,gBACAve,EAAA7f,SACA6f,EAAA2f,cACA3f,EAAA4f,UACA5f,EAAA6f,eACA7f,EAAApnD,OACAonD,EAAAiW,MACAjW,EAAAkW,OACAlW,EAAA9sD,OACA8sD,EAAA+0B,SACA/0B,EAAAxe,QACAwe,EAAA33C,YACA23C,EAAAlrB,YACAkrB,EAAA3jD,WACA2jD,EAAAyX,WACAzX,EAAAppC,UACAopC,EAAAyG,eACAzG,EAAA1uD,WACA0uD,EAAAz7C,eACAy7C,EAAAk0B,qBACAl0B,EAAAmW,aACAnW,EAAAoW,UACApW,EAAAqW,aACArW,EAAAzrB,WACAyrB,EAAA/uC,WACA+uC,EAAA05B,eACA15B,EAAAsW,WACAtW,EAAAt9C,YACAs9C,EAAAn6C,cACAm6C,EAAA25B,aACA35B,EAAApgD,YACAogD,EAAAuW,WACAvW,EAAA45B,eACA55B,EAAA1lD,SACA0lD,EAAAmR,YACAnR,EAAAuE,SACAvE,EAAA4W,UACA5W,EAAAwW,YACAxW,EAAAjlD,YACAilD,EAAArgD,gBACAqgD,EAAAiI,iBACAjI,EAAA6W,YACA7W,EAAA+5B,iBACA/5B,EAAAoU,YACApU,EAAAg6B,YACAh6B,EAAAlgD,gBACAkgD,EAAA8W,eACA9W,EAAArjD,QACAqjD,EAAAogB,aACApgB,EAAAhpB,QACAgpB,EAAA9nB,eACA8nB,EAAAo+B,aACAp+B,EAAAq+B,cACAr+B,EAAA+W,MACA/W,EAAAgX,OACAhX,EAAArzC,OACAqzC,EAAAtqB,SACAsqB,EAAA08B,QACA18B,EAAAvqB,OACAuqB,EAAAxqB,SACAwqB,EAAA+b,cACA/b,EAAAp2C,QACAo2C,EAAAz0C,OACAy0C,EAAA0Y,OACA1Y,EAAA07B,UACA17B,EAAA27B,YACA37B,EAAA2Y,YACA3Y,EAAAxmD,UACAwmD,EAAAhsB,UACAgsB,EAAA0e,eACA1e,EAAAz9B,UACAy9B,EAAAllC,WACAklC,EAAAnhD,UACAmhD,EAAA2gB,SACA3gB,EAAAD,eACAC,EAAApb,UACAob,EAAAxgB,QACAwgB,EAAAugB,aACAvgB,EAAA5rB,QACA4rB,EAAA+d,eACA/d,EAAAw4B,iBACAx4B,EAAAy4B,iBACAz4B,EAAAge,mBACAhe,EAAA04B,qBACA14B,EAAA24B,qBACA34B,EAAAwgB,aACAxgB,EAAAgZ,cACAhZ,EAAA28B,YACA38B,EAAAzqB,OACAyqB,EAAA88B,SACA98B,EAAAiZ,YACAjZ,EAAAkc,SACAlc,EAAAnmD,aACAmmD,EAAAx9C,YACAw9C,EAAA67B,WACA77B,EAAAs3B,YACAt3B,EAAA46B,iBACA56B,EAAAptD,YACAotD,EAAA87B,WACA97B,EAAA6Y,QACA7Y,EAAA+7B,WACA/7B,EAAAi8B,aACAj8B,EAAAm8B,YACAn8B,EAAAob,YACApb,EAAAoc,YACApc,EAAAs+B,aACAt+B,EAAAu7B,cAGAv7B,EAAAnrC,MAAA2sB,GAEAo6B,GAAA5b,EAAA,WACA,GAAA1qD,KAMA,OALA8vD,IAAApF,EAAA,SAAA/tC,EAAAo7B,GACAv0C,GAAAnO,KAAAq1D,EAAAvrD,UAAA44C,KACA/3C,EAAA+3C,GAAAp7B,KAGA3c,MACW+rC,OAAA,IAWX2e,EAAA0hB,UAGA1e,GAAA,yEAAA3V,GACA2S,EAAA3S,GAAA2O,YAAAgE,IAIAgD,GAAA,wBAAA3V,EAAAj7C,GACA6tD,EAAAxrD,UAAA44C,GAAA,SAAAhmC,GACA,GAAAs6D,GAAA32E,KAAA21D,YACA,IAAAghB,IAAAvvE,EACA,UAAA6tD,GAAAj1D,KAEAqc,OAAApZ,EAAA,EAAA48D,GAAAhxD,GAAAwN,GAAA,EAEA,IAAAxI,GAAA7T,KAAA0lD,OAMA,OALAixB,GACA9iE,EAAAgiD,cAAAc,GAAAt6C,EAAAxI,EAAAgiD,eAEAhiD,EAAAkiD,UAAA7vD,MAAiCsuC,KAAAmiB,GAAAt6C,EAAA80D,IAAA9mE,KAAAg4C,GAAAxuC,EAAA6hD,QAAA,gBAEjC7hD,GAGAohD,EAAAxrD,UAAA44C,EAAA,kBAAAhmC,GACA,MAAArc,MAAA82D,UAAAzU,GAAAhmC,GAAAy6C,aAKAkB,GAAA,qCAAA3V,EAAAj7C,GACA,GAAAiD,GAAAjD,EAAA,EACAwvE,EAAAvsE,GAAA4sD,IAAA5sD,GAAAupF,EAEA3+B,GAAAxrD,UAAA44C,GAAA,SAAAmS,GACA,GAAA3gD,GAAA7T,KAAA0lD,OAGA,OAFA7xC,GAAA+hD,cAAA1vD,MAAmCsuD,SAAA01B,GAAA11B,EAAA,GAAAnqD,SACnCwJ,EAAA8hD,aAAA9hD,EAAA8hD,cAAAihB,EACA/iE,KAKAmkD,GAAA,wBAAA3V,EAAAj7C,GACA,GAAAyvE,GAAA,QAAAzvE,EAAA,WAEA6tD,GAAAxrD,UAAA44C,GAAA,WACA,MAAAriD,MAAA62E,GAAA,GAAAr1E,QAAA,MAKAw2D,GAAA,2BAAA3V,EAAAj7C,GACA,GAAA0vE,GAAA,QAAA1vE,EAAA,WAEA6tD,GAAAxrD,UAAA44C,GAAA,WACA,MAAAriD,MAAA21D,aAAA,GAAAV,GAAAj1D,WAAA82E,GAAA,MAIA7hB,EAAAxrD,UAAAg+D,QAAA,WACA,MAAAznE,MAAA69B,OAAAxgB,KAGA43C,EAAAxrD,UAAAyiC,KAAA,SAAA/2B,GACA,MAAAnV,MAAA69B,OAAA1oB,GAAAqhC,QAGAye,EAAAxrD,UAAA6pE,SAAA,SAAAn+D,GACA,MAAAnV,MAAA82D,UAAA5qB,KAAA/2B,IAGA8/C,EAAAxrD,UAAAqpF,UAAA5qB,GAAA,SAAA/iB,EAAAxsC,GACA,wBAAAwsC,GACA,GAAA8P,GAAAj1D,MAEAA,KAAA+B,IAAA,SAAAP,GACA,MAAAgoF,IAAAhoF,EAAA2jD,EAAAxsC,OAIAs8C,EAAAxrD,UAAAivB,OAAA,SAAAvjB,GAEA,MADAA,GAAA+0E,GAAA/0E,EAAA,GACAnV,KAAA69B,OAAA,SAAAr8B,GACA,OAAA2T,EAAA3T,MAIAyzD,EAAAxrD,UAAA5B,MAAA,SAAAnG,EAAAqrC,GACArrC,EAAAmN,GAAAnN,EAEA,IAAAmS,GAAA7T,IACA,OAAA6T,GAAA8hD,eAAAj0D,EAAA,KAAAqrC,GACA,GAAAkoB,GAAAphD,IAEA,EAAAnS,EACAmS,IAAAs0D,WAAAzmE,GACOA,IACPmS,IAAA6zD,KAAAhmE,IAEAqrC,IAAA9pC,IACA8pC,EAAAl+B,GAAAk+B,GACAl5B,EAAA,EAAAk5B,EAAAl5B,EAAA8zD,WAAA56B,GAAAl5B,EAAA8K,KAAAouB,EAAArrC,IAEAmS,IAGAohD,EAAAxrD,UAAA2+D,eAAA,SAAAjzD,GACA,MAAAnV,MAAA82D,UAAAl1D,UAAAuT,GAAA2hD,WAGA7B,EAAAxrD,UAAAxH,QAAA,WACA,MAAAjC,MAAA2e,KAAAwyD,KAIA/W,GAAAnF,EAAAxrD,UAAA,SAAAwd,EAAAo7B,GACA,GAAA40B,GAAA,qCAAAjnD,KAAAqyB,GACAwxC,EAAA,kBAAA7jE,KAAAqyB,GACA80B,EAAAniB,EAAA6+B,EAAA,gBAAAxxC,EAAA,YAAAA,GACA60B,EAAA2c,GAAA,QAAA7jE,KAAAqyB,EAEA80B,KAGAniB,EAAAvrD,UAAA44C,GAAA,WACA,GAAA7gD,GAAAxB,KAAAu1D,YACA58C,EAAAk7E,GAAA,GAAA1nF,UACAkrE,EAAA71E,YAAAyzD,GACAT,EAAA77C,EAAA,GACA2+D,EAAAD,GAAA/wE,GAAA9E,GAEAmnE,EAAA,SAAAnnE,GACA,GAAAqS,GAAAsjE,EAAAjrE,MAAA8oD,EAAAwD,GAAAh3D,GAAAmX,GACA,OAAAk7E,IAAAx+B,EAAAxhD,EAAA,GAAAA,EAGAyjE,IAAAL,GAAA,kBAAAziB,IAAA,GAAAA,EAAAruD,SAEAkxE,EAAAC,GAAA,EAEA,IAAAjiB,GAAAr1D,KAAAy1D,UACA2hB,IAAAp3E,KAAAw1D,YAAArvD,OACA2tF,EAAA5c,IAAA7hB,EACAkiB,EAAAF,IAAAD,CAEA,KAAAF,GAAAI,EAAA,CACA91E,EAAA+1E,EAAA/1E,EAAA,GAAAyzD,GAAAj1D,KACA,IAAA6T,GAAAoT,EAAA/a,MAAA1K,EAAAmX,EAEA,OADA9E,GAAA2hD,YAAAtvD,MAAmC+gB,KAAAq7C,GAAA3pD,MAAAgwD,GAAAzvD,QAAAjW,IACnC,GAAAiyD,GAAArhD,EAAAwhD,GAEA,MAAAy+B,IAAAvc,EACAtwD,EAAA/a,MAAAlM,KAAA2Y,IAEA9E,EAAA7T,KAAAsiE,KAAAqG,GACAmrB,EAAAD,EAAAhgF,EAAArS,QAAA,GAAAqS,EAAArS,QAAAqS,OAKAmkD,GAAA,yDAAA3V,GACA,GAAAp7B,GAAA2qD,GAAAvvB,GACAm1B,EAAA,0BAAAxnD,KAAAqyB,GAAA,aACA60B,EAAA,kBAAAlnD,KAAAqyB,EAEA2S,GAAAvrD,UAAA44C,GAAA,WACA,GAAA1pC,GAAAxM,SACA,OAAA+qE,KAAAl3E,KAAAy1D,UACAxuC,EAAA/a,MAAAlM,KAAAwB,QAAAmX,GAEA3Y,KAAAw3E,GAAA,SAAAh2E,GACA,MAAAylB,GAAA/a,MAAA1K,EAAAmX,QAMAyhD,GAAAnF,EAAAxrD,UAAA,SAAAwd,EAAAo7B,GACA,GAAA80B,GAAAniB,EAAA3S,EACA,IAAA80B,EAAA,CACA,GAAA51E,GAAA41E,EAAAttE,KAAA,GACA4tE,EAAAzR,GAAAzkE,KAAAykE,GAAAzkE,MAEAk2E,GAAAvxE,MAAoB2D,KAAAw4C,EAAAp7B,KAAAkwD,OAIpBnR,GAAApC,GAAA3gE,EAAA6hE,GAAAj7D,QAAsEA,KAAA,UAAAod,KAAAhkB,IAGtEgyD,EAAAxrD,UAAAi8C,MAAAsQ,EACAf,EAAAxrD,UAAAqtD,QAAAZ,GACAjB,EAAAxrD,UAAAjI,MAAA20D,GAGAnB,EAAAvrD,UAAA2pE,GAAAyf,GACA79B,EAAAvrD,UAAA4sC,MAAAuyB,GACA5T,EAAAvrD,UAAAiuE,OAAA7O,GACA7T,EAAAvrD,UAAArG,QAAA4qF,GACAh5B,EAAAvrD,UAAAzD,KAAAioF,GACAj5B,EAAAvrD,UAAAs5D,MAAA+F,GACA9T,EAAAvrD,UAAAqtD,QAAAiS,GACA/T,EAAAvrD,UAAAkuE,OAAA3iB,EAAAvrD,UAAAmuE,QAAA5iB,EAAAvrD,UAAAjI,MAAA0nE,GAEA+lB,KACAj6B,EAAAvrD,UAAAwlF,IAAAf,IAEAl5B,EAjhcA,GAAA/xD,GAGAyzE,EAAA,QAGA7R,EAAA,EACAC,EAAA,EACAM,GAAA,EACAxC,GAAA,EACAyC,GAAA,GACAxC,GAAA,GACA8B,GAAA,GACAhC,GAAA,IACAG,GAAA,IACAqpB,GAAA,IAGAxC,GAAA,EACAD,GAAA,EAGA5Z,GAAA,GACAE,GAAA,MAGAwC,GAAA,IACAD,GAAA,GAGA3b,GAAA,IAGAK,GAAA,EACAD,GAAA,EACA48B,GAAA,EAGAp5B,GAAA,sBAGA+sB,GAAA,4BAGA2H,GAAA,IACAr6E,GAAA,iBACAs6E,GAAA,uBACAQ,GAAA,IAGAxe,GAAA,WACAjS,GAAAiS,GAAA,EACAxS,GAAAwS,KAAA,EAGA7c,GAAA,yBAGAz+C,GAAA,qBACAF,GAAA,iBACAvB,GAAA,mBACAC,GAAA,gBACAC,GAAA,iBACAgT,GAAA,oBACAwhE,GAAA,6BACAvhE,GAAA,eACA/S,GAAA,kBACAsB,GAAA,kBACArB,GAAA,kBACA+S,GAAA,eACA9S,GAAA,kBACAi4E,GAAA,kBACAllE,GAAA,mBAEAC,GAAA,uBACAC,GAAA,wBACAC,GAAA,wBACAC,GAAA,qBACAC,GAAA,sBACAC,GAAA,sBACAC,GAAA,sBACAC,GAAA,6BACAC,GAAA,uBACAC,GAAA,uBAGAonD,GAAA,iBACAC,GAAA,qBACAC,GAAA,gCAGAa,GAAA,gCACAhD,GAAA,YACA+C,GAAAxgD,OAAAygD,GAAAhmE,QACA+iE,GAAAx9C,OAAAy9C,GAAAhjE,QAGA8nE,GAAA,mBACAC,GAAA,kBACAzD,GAAA,mBAGAjI,GAAA,mDACAD,GAAA,QACAW,GAAA,sEAGAopB,GAAA,sBACAD,GAAA3gE,OAAA4gE,GAAAnmF,QAGA+kF,GAAA,aACA6B,GAAA,OACAF,GAAA,OAGAzpB,GAAA,WAGAsH,GAAA,kCAGAvI,GAAA,OAGAyH,GAAA,OAGA2hB,GAAA,qBAGAH,GAAA,aAGA5jB,GAAA,8BAGA6jB,GAAA,cAGA/oB,GAAA,mBAGAuG,GAAA,0CAGA0B,GAAA,OAGAW,GAAA,yBAGA0kB,GAAA,kBACAC,GAAA,iCACAC,GAAA,kBACAC,GAAA,4BACAC,GAAA,uBACAC,GAAA,+CACAC,GAAA,+BACAC,GAAA,+JACAC,GAAA,4BACAC,GAAA,iBACAC,GAAAN,GAAAC,GAAAC,GAAAC,GAGAI,GAAA,IAAAX,GAAA,IACAY,GAAA,IAAAF,GAAA,IACAG,GAAA,IAAAZ,GAAA,IACAa,GAAA,OACAC,GAAA,IAAAb,GAAA,IACAc,GAAA,IAAAb,GAAA,IACAc,GAAA,KAAAjB,GAAAU,GAAAI,GAAAZ,GAAAC,GAAAK,GAAA,IACAU,GAAA,+BACAC,GAAA,KAAAnB,GAAA,IACAoB,GAAA,kCACAC,GAAA,qCACAC,GAAA,IAAAd,GAAA,IACAe,GAAA,UAGAC,GAAA,MAAAR,GAAA,IAAAC,GAAA,IACAQ,GAAA,MAAAH,GAAA,IAAAL,GAAA,IACAS,GAAAR,GAAA,IACAS,GAAA,IAAAlB,GAAA,KACAmB,GAAA,MAAAL,GAAA,OAAAJ,GAAAC,GAAAC,IAAAzjF,KAAA,SAAA+jF,GAAAD,GAAA,KACAG,GAAAF,GAAAD,GAAAE,GACAE,GAAA,OAAAf,GAAAK,GAAAC,IAAAzjF,KAAA,SAAAikF,GACAE,GAAA,OAAAZ,GAAAN,GAAA,IAAAA,GAAAO,GAAAC,GAAAV,IAAA/iF,KAAA,SAGAs7D,GAAAp9C,OAAA+kE,GAAA,KAGA9N,GAAAj3D,OAAAimE,GAAAF,GAAA,KAGA/O,GAAAh3D,OAAA,IAAAylE,GAAAvB,GAAAC,GAAAQ,GAAA,KAGAlD,GAAA,gBAGAD,GAAAxhE,QACAwlE,GAAA,IAAAN,GAAA,QAAAJ,GAAAU,GAAA,KAAA1jF,KAAA,SACA6jF,GAAA,QAAAb,GAAAU,GAAAE,GAAA,KAAA5jF,KAAA,SACA0jF,GAAA,IAAAE,GAAA,IACAV,GAAA,MAAAU,GAAA,MACAM,IACAlkF,KAAA,UAGAy/E,GAAA,uDAGAzf,IACA,gEACA,4DACA,oEACA,8DACA,mDAIA3C,GAAA,GAGAj6D;AACAA,GAAA4S,IAAA5S,GAAA6S,IACA7S,GAAA8S,IAAA9S,GAAA+S,IACA/S,GAAAgT,IAAAhT,GAAAiT,IACAjT,GAAAkT,IAAAlT,GAAAmT,IACAnT,GAAAoT,KAAA,EACApT,GAAAc,IAAAd,GAAAY,IACAZ,GAAA2S,IAAA3S,GAAAX,IACAW,GAAAV,IAAAU,GAAAT,IACAS,GAAAuS,IAAAvS,GAAAwS,IACAxS,GAAAP,IAAAO,GAAAe,IACAf,GAAAN,IAAAM,GAAAyS,IACAzS,GAAAL,IAAAK,GAAA0S,KAAA,CAGA,IAAAwyC,MACAA,IAAApkD,IAAAokD,GAAAtkD,IACAskD,GAAAvyC,IAAAuyC,GAAA7lD,IACA6lD,GAAA5lD,IAAA4lD,GAAAtyC,IACAsyC,GAAAryC,IAAAqyC,GAAApyC,IACAoyC,GAAAnyC,IAAAmyC,GAAAlyC,IACAkyC,GAAA1yC,IAAA0yC,GAAAzlD,IACAylD,GAAAnkD,IAAAmkD,GAAAxlD,IACAwlD,GAAAzyC,IAAAyyC,GAAAvlD,IACAulD,GAAA0yB,IAAA1yB,GAAAjyC,IACAiyC,GAAAhyC,IAAAgyC,GAAA/xC,IACA+xC,GAAA9xC,KAAA,EACA8xC,GAAA3lD,IAAA2lD,GAAA3yC,IACA2yC,GAAAxyC,KAAA,CAGA,IAAA+rC,KACAukB,IAAA,IAAAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IACAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IACAC,IAAA,IAAAC,IAAA,IACAC,IAAA,IAAAC,IAAA,IACAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IACAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IACAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IACAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IACAC,IAAA,IAAAC,IAAA,IACAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IACAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IACAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IACAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IACAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IACAC,IAAA,KAAAC,IAAA,KACAC,IAAA,KAAAC,IAAA,KACAC,IAAA,MAIAjoB,IACAkoB,IAAA,QACAC,IAAA,OACAC,IAAA,OACAC,IAAA,SACAC,IAAA,QACAC,IAAA,SAIApnB,IACAqnB,QAAU,IACVC,OAAS,IACTC,OAAS,IACTC,SAAW,IACXC,QAAU,IACVC,QAAU,KAIVx3D,IACAC,YAAA,EACA3Y,QAAA,GAIA0nD,IACAupB,KAAA,KACAtB,IAAA,IACAuB,KAAA,IACAC,KAAA,IACAC,SAAA,QACAC,SAAA,SAIA2S,GAAAzjB,WACA4iB,GAAA9hB,SAGAzoD,GAAAF,SAAAzlB,WAAA4lB,SAAA5lB,EAAA,KAGA6lB,GAAAJ,SAAAxlB,WAAA2lB,SAAA3lB,EAAA,KAGA6lB,GAAA3U,EAAAwU,IAAAE,IAAA,gBAAArlB,OAGAulB,GAAA5U,EAAAsU,SAAAvZ,cAGA8Z,GAAA7U,EAAAsU,SAAAzZ,kBAMAka,IAHAL,OAAA7lB,UAAA2lB,MAAA,KAGAxU,EAAAsU,SAAAhlB,eAQA6E,GAAAwgB,IAAAE,MAAAE,OAAAla,SAAAga,IAAAD,IAAAG,IAAAna,SAAA,iBA+rbAzI,GAAAkyD,KAKAxvC,IAAAD,QAA+BziB,KAM/B2N,EAAA,WACA,MAAA3N,KACKlD,KAAAJ,EAAAH,EAAAG,EAAAC,KAAAgR,IAAAvN,IAAAzD,EAAAD,QAAAiR,MAeJ7Q,KAAAK,QvGoo4B6BL,KAAKJ,EAASH,EAAoB,IAAII,GAAU,WAAa,MAAOQ,WAI5F,SAASR,EAAQD,EAASH,GAE/B,YAcA,SAASa,GAAuBC,GAAO,MAAOA,IAAOA,EAAIC,WAAaD,GAAQE,UAASF,GAZvF,GAAIG,GAAkBjB,EAAoB,GAEtCkB,EAAkBL,EAAuBI,GAEzCE,EAAmBnB,EAAoB,IAEvCoB,EAAmBP,EAAuBM,GAE1CE,EAAgBrB,EAAoB,IAEpCsB,EAAgBT,EAAuBQ,GwGrt0CxC6tC,EAAIlvC,EAAQ,IACV+wD,EAAA,WACJ,QADIA,GACQ3tD,EAAMtB,IxG2t0Cd,EAAGV,cAA0BR,KwG5t0C7BmwD,GAEFnwD,KAAKwC,KAAOA,EACZxC,KAAKkB,SAAWA,ExG6w0CjB,OA9CC,EAAGR,cwGlu0CDyvD,IxGmu0CD5uD,IAAK,WACLC,MAAO,SwG9t0CDmY,GACP,MAAIA,GAAKxV,aAAc,EACd,YACEwV,EAAKzV,WAAY,EACnB,UAEA,MxGku0CR3C,IAAK,SACLC,MAAO,SAAgB8C,GACrB,GAAI7C,GAAQzB,KAERuE,GAAS,EAAGjE,cAAyBgE,EAAM,GwGlu0C5C7E,EAAA8E,EAAA,GAAIoV,EAAApV,EAAA,GACNwxF,EAAW/1F,KAAK+1F,SAASp8E,GACzBq8E,EAAO,SAACrlC,GACW,IAAdA,EAAGG,SACJrvD,EAAKe,MACH/C,GAAIA,EACJqC,OAAQ,OACRmC,KAAM0sD,EAAGxlD,OAAO3J,SAItBgB,EAAO,SAACV,GAAa,MAAO,UAAC6uD,GAASlvD,EAAKe,MAAMV,OAAQA,EAAQrC,GAAIA,KACzE,OACE6uC,GAAE,MAAOmiB,QAAOslC,IACdznD,EAAE,OAAQmiB,QAAO,SACfniB,EAAE,SAAUmiB,QAAO,SACjBpmD,KAAM,WACNqmD,WAAaluD,EAAKmX,EAAKxV,UAAY,aAAe,YAClD+uB,QAAUvZ,EAAKxV,WAAY,EAAOlB,SACpCqrC,EAAE,SAAU2nD,cAAgBzzF,EAAK,UAAamX,EAAK1V,OACnDqqC,EAAE,UAAWmiB,QAAO,UAAWC,WAAaluD,EAAK,eAEnD8rC,EAAE,SAAUmiB,QAAO,OACjBjvD,MAAQmY,EAAK1V,KACb8sD,WAAYilC,EACZE,UAAY1zF,EAAK,UACjB2zF,UAAYx8E,EAAKzV,SAAU,EAAOjB,eA1CtCktD,IAiDN3wD,GAAOD,QAAU4wD,GxGsu0CX,SAAS3wD,EAAQD,GAEtB,YyG1x0CDC,GAAOD,QAAU,WACf,MAAOiM,MAAKgD,SAAS5G,SAAS,IAAIyoB,UAAU,KzGiy0CxC,SAAS7wB,EAAQD","file":"todo-mvc-rx-virtual-dom.bundle.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t__webpack_require__(1);\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {module.exports = global[\"Todo\"] = __webpack_require__(2);\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _slicedToArray2 = __webpack_require__(3);\n\t\n\tvar _slicedToArray3 = _interopRequireDefault(_slicedToArray2);\n\t\n\tvar _classCallCheck2 = __webpack_require__(45);\n\t\n\tvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\t\n\tvar _createClass2 = __webpack_require__(46);\n\t\n\tvar _createClass3 = _interopRequireDefault(_createClass2);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar Rx = __webpack_require__(49),\n\t    Immutable = __webpack_require__(52),\n\t    RxWidget = __webpack_require__(53),\n\t    TodoList = __webpack_require__(77),\n\t    genId = __webpack_require__(104);\n\t\n\t__webpack_require__(105);\n\t\n\tvar Todo = function () {\n\t  function Todo(container) {\n\t    (0, _classCallCheck3.default)(this, Todo);\n\t\n\t    this.container = container;\n\t    this.eventBus = new Rx.Subject();\n\t    this.recording = null;\n\t    this.state = null;\n\t    this.stateSnapshot = null;\n\t  }\n\t\n\t  (0, _createClass3.default)(Todo, [{\n\t    key: 'startRecording',\n\t    value: function startRecording() {\n\t      var _this = this;\n\t\n\t      var start = new Date();\n\t      this.eventBus.takeWhile(function (event) {\n\t        return event.action !== 'stopRecording';\n\t      }).map(function (event) {\n\t        return event.set('_recordingDelay', new Date() - start);\n\t      }).toArray().subscribe(function (recording) {\n\t        _this.recording = Immutable(recording).asMutable({ deep: true });\n\t      }, function (error) {\n\t        console.error('[Recording]', error);\n\t      }, function () {\n\t        console.debug('[Recording] done');\n\t      });\n\t    }\n\t  }, {\n\t    key: 'stopRecording',\n\t    value: function stopRecording() {\n\t      this.emit({ action: 'stopRecording' });\n\t      return this.recording;\n\t    }\n\t  }, {\n\t    key: 'playRecording',\n\t    value: function playRecording(recording0, options0) {\n\t      var _this2 = this;\n\t\n\t      var options = _.merge({ realTime: true, speed: 1 }, options0),\n\t          recording = undefined;\n\t\n\t      if (options.realTime) {\n\t        recording = Rx.Observable.from(recording0).flatMap(function (event) {\n\t          return Rx.Observable.just(Immutable(event).without('_recordingDelay')).delay(event._recordingDelay / options.speed);\n\t        });\n\t      } else {\n\t        recording = Rx.Observable.from(recording0);\n\t      }\n\t\n\t      recording.subscribe(function (event) {\n\t        _this2.eventBus.onNext(event);\n\t      }, function (error) {\n\t        console.error('[Playback]', error);\n\t      }, function () {\n\t        console.debug('[Playback] done');\n\t      });\n\t    }\n\t  }, {\n\t    key: 'currentState',\n\t    value: function currentState() {\n\t      this.emit({ action: 'stateSnapshot' });\n\t      return this.stateSnapshot.asMutable();\n\t    }\n\t  }, {\n\t    key: 'replaceState',\n\t    value: function replaceState(state) {\n\t      this.emit({ action: 'replaceState', state: state });\n\t    }\n\t  }, {\n\t    key: 'emit',\n\t    value: function emit(event) {\n\t      return this.eventBus.onNext(Immutable(event));\n\t    }\n\t  }, {\n\t    key: 'init',\n\t    value: function init() {\n\t      var _this3 = this;\n\t\n\t      var initial = Immutable({\n\t        show: 'all',\n\t        todos: {}\n\t      });\n\t\n\t      this.state = this.eventBus.scan(function (acc, event) {\n\t        switch (event.action) {\n\t          case 'create':\n\t            return acc.setIn(['todos', genId()], {\n\t              text: event.text,\n\t              editing: false,\n\t              completed: false\n\t            });\n\t          case 'edit':\n\t            return acc.setIn(['todos', event.id, 'editing'], true);\n\t          case 'unedit':\n\t            return acc.setIn(['todos', event.id, 'editing'], false);\n\t          case 'save':\n\t            return acc.setIn(['todos', event.id, 'editing'], false).setIn(['todos', event.id, 'text'], event.text);\n\t          case 'uncomplete':\n\t            return acc.setIn(['todos', event.id, 'completed'], false);\n\t          case 'complete':\n\t            return acc.setIn(['todos', event.id, 'completed'], true);\n\t          case 'destroy':\n\t            return acc.setIn(['todos'], acc.todos.without([event.id]));\n\t          case 'clearCompleted':\n\t            var removeIds = _.flatMap(_.toPairs(acc.todos), function (_ref) {\n\t              var _ref2 = (0, _slicedToArray3.default)(_ref, 2);\n\t\n\t              var id = _ref2[0];\n\t              var todo = _ref2[1];\n\t\n\t              if (todo.completed) {\n\t                return [id];\n\t              } else {\n\t                return [];\n\t              }\n\t            });\n\t            return acc.setIn(['todos'], acc.todos.without(removeIds));\n\t          case 'toggelAll':\n\t            return acc.setIn(['todos'], Immutable(_.toPairs(acc.todos)).map(function (_ref3) {\n\t              var _ref4 = (0, _slicedToArray3.default)(_ref3, 2);\n\t\n\t              var id = _ref4[0];\n\t              var todo = _ref4[1];\n\t\n\t              return [id, todo.set('completed', event.completed)];\n\t            }).asObject());\n\t          case 'show':\n\t            return acc.setIn(['show'], event.show);\n\t          case 'stateSnapshot':\n\t            _this3.stateSnapshot = acc;\n\t            return acc;\n\t          case 'replaceState':\n\t            return event.state;\n\t          default:\n\t            return acc;\n\t        }\n\t      }, initial);\n\t\n\t      // if debug\n\t      this.eventBus.subscribe(function (e) {\n\t        console.debug('[Commands]', e);\n\t      }, function (e) {\n\t        console.error('[Commands]', e);\n\t      }, function () {\n\t        console.debug('[Commands]', 'Completed');\n\t      });\n\t\n\t      this.state.subscribe(function (e) {\n\t        console.debug('[View]', e);\n\t      }, function (e) {\n\t        console.error('[View]', e);\n\t      }, function () {\n\t        console.debug('[View]', 'Completed');\n\t      });\n\t\n\t      var root = new TodoList(function (e) {\n\t        return _this3.emit(e);\n\t      }, this.state),\n\t          widget = new RxWidget(this.state, function (opts) {\n\t        return root.render(opts);\n\t      }, initial);\n\t\n\t      this.container.appendChild(widget.init());\n\t    }\n\t  }]);\n\t  return Todo;\n\t}();\n\t\n\tmodule.exports = Todo;\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\texports.__esModule = true;\n\t\n\tvar _isIterable2 = __webpack_require__(4);\n\t\n\tvar _isIterable3 = _interopRequireDefault(_isIterable2);\n\t\n\tvar _getIterator2 = __webpack_require__(39);\n\t\n\tvar _getIterator3 = _interopRequireDefault(_getIterator2);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = (function () {\n\t  function sliceIterator(arr, i) {\n\t    var _arr = [];\n\t    var _n = true;\n\t    var _d = false;\n\t    var _e = undefined;\n\t\n\t    try {\n\t      for (var _i = (0, _getIterator3.default)(arr), _s; !(_n = (_s = _i.next()).done); _n = true) {\n\t        _arr.push(_s.value);\n\t\n\t        if (i && _arr.length === i) break;\n\t      }\n\t    } catch (err) {\n\t      _d = true;\n\t      _e = err;\n\t    } finally {\n\t      try {\n\t        if (!_n && _i[\"return\"]) _i[\"return\"]();\n\t      } finally {\n\t        if (_d) throw _e;\n\t      }\n\t    }\n\t\n\t    return _arr;\n\t  }\n\t\n\t  return function (arr, i) {\n\t    if (Array.isArray(arr)) {\n\t      return arr;\n\t    } else if ((0, _isIterable3.default)(Object(arr))) {\n\t      return sliceIterator(arr, i);\n\t    } else {\n\t      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n\t    }\n\t  };\n\t})();\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = { \"default\": __webpack_require__(5), __esModule: true };\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(6);\n\t__webpack_require__(34);\n\tmodule.exports = __webpack_require__(37);\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(7);\n\tvar Iterators = __webpack_require__(10);\n\tIterators.NodeList = Iterators.HTMLCollection = Iterators.Array;\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tvar addToUnscopables = __webpack_require__(8)\n\t  , step             = __webpack_require__(9)\n\t  , Iterators        = __webpack_require__(10)\n\t  , toIObject        = __webpack_require__(11);\n\t\n\t// 22.1.3.4 Array.prototype.entries()\n\t// 22.1.3.13 Array.prototype.keys()\n\t// 22.1.3.29 Array.prototype.values()\n\t// 22.1.3.30 Array.prototype[@@iterator]()\n\tmodule.exports = __webpack_require__(15)(Array, 'Array', function(iterated, kind){\n\t  this._t = toIObject(iterated); // target\n\t  this._i = 0;                   // next index\n\t  this._k = kind;                // kind\n\t// 22.1.5.2.1 %ArrayIteratorPrototype%.next()\n\t}, function(){\n\t  var O     = this._t\n\t    , kind  = this._k\n\t    , index = this._i++;\n\t  if(!O || index >= O.length){\n\t    this._t = undefined;\n\t    return step(1);\n\t  }\n\t  if(kind == 'keys'  )return step(0, index);\n\t  if(kind == 'values')return step(0, O[index]);\n\t  return step(0, [index, O[index]]);\n\t}, 'values');\n\t\n\t// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)\n\tIterators.Arguments = Iterators.Array;\n\t\n\taddToUnscopables('keys');\n\taddToUnscopables('values');\n\taddToUnscopables('entries');\n\n/***/ },\n/* 8 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function(){ /* empty */ };\n\n/***/ },\n/* 9 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function(done, value){\n\t  return {value: value, done: !!done};\n\t};\n\n/***/ },\n/* 10 */\n/***/ function(module, exports) {\n\n\tmodule.exports = {};\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// to indexed object, toObject with fallback for non-array-like ES3 strings\n\tvar IObject = __webpack_require__(12)\n\t  , defined = __webpack_require__(14);\n\tmodule.exports = function(it){\n\t  return IObject(defined(it));\n\t};\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// fallback for non-array-like ES3 and non-enumerable old V8 strings\n\tvar cof = __webpack_require__(13);\n\tmodule.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){\n\t  return cof(it) == 'String' ? it.split('') : Object(it);\n\t};\n\n/***/ },\n/* 13 */\n/***/ function(module, exports) {\n\n\tvar toString = {}.toString;\n\t\n\tmodule.exports = function(it){\n\t  return toString.call(it).slice(8, -1);\n\t};\n\n/***/ },\n/* 14 */\n/***/ function(module, exports) {\n\n\t// 7.2.1 RequireObjectCoercible(argument)\n\tmodule.exports = function(it){\n\t  if(it == undefined)throw TypeError(\"Can't call method on  \" + it);\n\t  return it;\n\t};\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tvar LIBRARY        = __webpack_require__(16)\n\t  , $export        = __webpack_require__(17)\n\t  , redefine       = __webpack_require__(22)\n\t  , hide           = __webpack_require__(23)\n\t  , has            = __webpack_require__(28)\n\t  , Iterators      = __webpack_require__(10)\n\t  , $iterCreate    = __webpack_require__(29)\n\t  , setToStringTag = __webpack_require__(30)\n\t  , getProto       = __webpack_require__(24).getProto\n\t  , ITERATOR       = __webpack_require__(31)('iterator')\n\t  , BUGGY          = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`\n\t  , FF_ITERATOR    = '@@iterator'\n\t  , KEYS           = 'keys'\n\t  , VALUES         = 'values';\n\t\n\tvar returnThis = function(){ return this; };\n\t\n\tmodule.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){\n\t  $iterCreate(Constructor, NAME, next);\n\t  var getMethod = function(kind){\n\t    if(!BUGGY && kind in proto)return proto[kind];\n\t    switch(kind){\n\t      case KEYS: return function keys(){ return new Constructor(this, kind); };\n\t      case VALUES: return function values(){ return new Constructor(this, kind); };\n\t    } return function entries(){ return new Constructor(this, kind); };\n\t  };\n\t  var TAG        = NAME + ' Iterator'\n\t    , DEF_VALUES = DEFAULT == VALUES\n\t    , VALUES_BUG = false\n\t    , proto      = Base.prototype\n\t    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]\n\t    , $default   = $native || getMethod(DEFAULT)\n\t    , methods, key;\n\t  // Fix native\n\t  if($native){\n\t    var IteratorPrototype = getProto($default.call(new Base));\n\t    // Set @@toStringTag to native iterators\n\t    setToStringTag(IteratorPrototype, TAG, true);\n\t    // FF fix\n\t    if(!LIBRARY && has(proto, FF_ITERATOR))hide(IteratorPrototype, ITERATOR, returnThis);\n\t    // fix Array#{values, @@iterator}.name in V8 / FF\n\t    if(DEF_VALUES && $native.name !== VALUES){\n\t      VALUES_BUG = true;\n\t      $default = function values(){ return $native.call(this); };\n\t    }\n\t  }\n\t  // Define iterator\n\t  if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){\n\t    hide(proto, ITERATOR, $default);\n\t  }\n\t  // Plug for library\n\t  Iterators[NAME] = $default;\n\t  Iterators[TAG]  = returnThis;\n\t  if(DEFAULT){\n\t    methods = {\n\t      values:  DEF_VALUES  ? $default : getMethod(VALUES),\n\t      keys:    IS_SET      ? $default : getMethod(KEYS),\n\t      entries: !DEF_VALUES ? $default : getMethod('entries')\n\t    };\n\t    if(FORCED)for(key in methods){\n\t      if(!(key in proto))redefine(proto, key, methods[key]);\n\t    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);\n\t  }\n\t  return methods;\n\t};\n\n/***/ },\n/* 16 */\n/***/ function(module, exports) {\n\n\tmodule.exports = true;\n\n/***/ },\n/* 17 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar global    = __webpack_require__(18)\n\t  , core      = __webpack_require__(19)\n\t  , ctx       = __webpack_require__(20)\n\t  , PROTOTYPE = 'prototype';\n\t\n\tvar $export = function(type, name, source){\n\t  var IS_FORCED = type & $export.F\n\t    , IS_GLOBAL = type & $export.G\n\t    , IS_STATIC = type & $export.S\n\t    , IS_PROTO  = type & $export.P\n\t    , IS_BIND   = type & $export.B\n\t    , IS_WRAP   = type & $export.W\n\t    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})\n\t    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]\n\t    , key, own, out;\n\t  if(IS_GLOBAL)source = name;\n\t  for(key in source){\n\t    // contains in native\n\t    own = !IS_FORCED && target && key in target;\n\t    if(own && key in exports)continue;\n\t    // export native or passed\n\t    out = own ? target[key] : source[key];\n\t    // prevent global pollution for namespaces\n\t    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]\n\t    // bind timers to global for call from export context\n\t    : IS_BIND && own ? ctx(out, global)\n\t    // wrap global constructors for prevent change them in library\n\t    : IS_WRAP && target[key] == out ? (function(C){\n\t      var F = function(param){\n\t        return this instanceof C ? new C(param) : C(param);\n\t      };\n\t      F[PROTOTYPE] = C[PROTOTYPE];\n\t      return F;\n\t    // make static versions for prototype methods\n\t    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;\n\t    if(IS_PROTO)(exports[PROTOTYPE] || (exports[PROTOTYPE] = {}))[key] = out;\n\t  }\n\t};\n\t// type bitmap\n\t$export.F = 1;  // forced\n\t$export.G = 2;  // global\n\t$export.S = 4;  // static\n\t$export.P = 8;  // proto\n\t$export.B = 16; // bind\n\t$export.W = 32; // wrap\n\tmodule.exports = $export;\n\n/***/ },\n/* 18 */\n/***/ function(module, exports) {\n\n\t// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\n\tvar global = module.exports = typeof window != 'undefined' && window.Math == Math\n\t  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();\n\tif(typeof __g == 'number')__g = global; // eslint-disable-line no-undef\n\n/***/ },\n/* 19 */\n/***/ function(module, exports) {\n\n\tvar core = module.exports = {version: '1.2.6'};\n\tif(typeof __e == 'number')__e = core; // eslint-disable-line no-undef\n\n/***/ },\n/* 20 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// optional / simple context binding\n\tvar aFunction = __webpack_require__(21);\n\tmodule.exports = function(fn, that, length){\n\t  aFunction(fn);\n\t  if(that === undefined)return fn;\n\t  switch(length){\n\t    case 1: return function(a){\n\t      return fn.call(that, a);\n\t    };\n\t    case 2: return function(a, b){\n\t      return fn.call(that, a, b);\n\t    };\n\t    case 3: return function(a, b, c){\n\t      return fn.call(that, a, b, c);\n\t    };\n\t  }\n\t  return function(/* ...args */){\n\t    return fn.apply(that, arguments);\n\t  };\n\t};\n\n/***/ },\n/* 21 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function(it){\n\t  if(typeof it != 'function')throw TypeError(it + ' is not a function!');\n\t  return it;\n\t};\n\n/***/ },\n/* 22 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(23);\n\n/***/ },\n/* 23 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar $          = __webpack_require__(24)\n\t  , createDesc = __webpack_require__(25);\n\tmodule.exports = __webpack_require__(26) ? function(object, key, value){\n\t  return $.setDesc(object, key, createDesc(1, value));\n\t} : function(object, key, value){\n\t  object[key] = value;\n\t  return object;\n\t};\n\n/***/ },\n/* 24 */\n/***/ function(module, exports) {\n\n\tvar $Object = Object;\n\tmodule.exports = {\n\t  create:     $Object.create,\n\t  getProto:   $Object.getPrototypeOf,\n\t  isEnum:     {}.propertyIsEnumerable,\n\t  getDesc:    $Object.getOwnPropertyDescriptor,\n\t  setDesc:    $Object.defineProperty,\n\t  setDescs:   $Object.defineProperties,\n\t  getKeys:    $Object.keys,\n\t  getNames:   $Object.getOwnPropertyNames,\n\t  getSymbols: $Object.getOwnPropertySymbols,\n\t  each:       [].forEach\n\t};\n\n/***/ },\n/* 25 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function(bitmap, value){\n\t  return {\n\t    enumerable  : !(bitmap & 1),\n\t    configurable: !(bitmap & 2),\n\t    writable    : !(bitmap & 4),\n\t    value       : value\n\t  };\n\t};\n\n/***/ },\n/* 26 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// Thank's IE8 for his funny defineProperty\n\tmodule.exports = !__webpack_require__(27)(function(){\n\t  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;\n\t});\n\n/***/ },\n/* 27 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function(exec){\n\t  try {\n\t    return !!exec();\n\t  } catch(e){\n\t    return true;\n\t  }\n\t};\n\n/***/ },\n/* 28 */\n/***/ function(module, exports) {\n\n\tvar hasOwnProperty = {}.hasOwnProperty;\n\tmodule.exports = function(it, key){\n\t  return hasOwnProperty.call(it, key);\n\t};\n\n/***/ },\n/* 29 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tvar $              = __webpack_require__(24)\n\t  , descriptor     = __webpack_require__(25)\n\t  , setToStringTag = __webpack_require__(30)\n\t  , IteratorPrototype = {};\n\t\n\t// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()\n\t__webpack_require__(23)(IteratorPrototype, __webpack_require__(31)('iterator'), function(){ return this; });\n\t\n\tmodule.exports = function(Constructor, NAME, next){\n\t  Constructor.prototype = $.create(IteratorPrototype, {next: descriptor(1, next)});\n\t  setToStringTag(Constructor, NAME + ' Iterator');\n\t};\n\n/***/ },\n/* 30 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar def = __webpack_require__(24).setDesc\n\t  , has = __webpack_require__(28)\n\t  , TAG = __webpack_require__(31)('toStringTag');\n\t\n\tmodule.exports = function(it, tag, stat){\n\t  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});\n\t};\n\n/***/ },\n/* 31 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar store  = __webpack_require__(32)('wks')\n\t  , uid    = __webpack_require__(33)\n\t  , Symbol = __webpack_require__(18).Symbol;\n\tmodule.exports = function(name){\n\t  return store[name] || (store[name] =\n\t    Symbol && Symbol[name] || (Symbol || uid)('Symbol.' + name));\n\t};\n\n/***/ },\n/* 32 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar global = __webpack_require__(18)\n\t  , SHARED = '__core-js_shared__'\n\t  , store  = global[SHARED] || (global[SHARED] = {});\n\tmodule.exports = function(key){\n\t  return store[key] || (store[key] = {});\n\t};\n\n/***/ },\n/* 33 */\n/***/ function(module, exports) {\n\n\tvar id = 0\n\t  , px = Math.random();\n\tmodule.exports = function(key){\n\t  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));\n\t};\n\n/***/ },\n/* 34 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tvar $at  = __webpack_require__(35)(true);\n\t\n\t// 21.1.3.27 String.prototype[@@iterator]()\n\t__webpack_require__(15)(String, 'String', function(iterated){\n\t  this._t = String(iterated); // target\n\t  this._i = 0;                // next index\n\t// 21.1.5.2.1 %StringIteratorPrototype%.next()\n\t}, function(){\n\t  var O     = this._t\n\t    , index = this._i\n\t    , point;\n\t  if(index >= O.length)return {value: undefined, done: true};\n\t  point = $at(O, index);\n\t  this._i += point.length;\n\t  return {value: point, done: false};\n\t});\n\n/***/ },\n/* 35 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar toInteger = __webpack_require__(36)\n\t  , defined   = __webpack_require__(14);\n\t// true  -> String#at\n\t// false -> String#codePointAt\n\tmodule.exports = function(TO_STRING){\n\t  return function(that, pos){\n\t    var s = String(defined(that))\n\t      , i = toInteger(pos)\n\t      , l = s.length\n\t      , a, b;\n\t    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;\n\t    a = s.charCodeAt(i);\n\t    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff\n\t      ? TO_STRING ? s.charAt(i) : a\n\t      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;\n\t  };\n\t};\n\n/***/ },\n/* 36 */\n/***/ function(module, exports) {\n\n\t// 7.1.4 ToInteger\n\tvar ceil  = Math.ceil\n\t  , floor = Math.floor;\n\tmodule.exports = function(it){\n\t  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);\n\t};\n\n/***/ },\n/* 37 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar classof   = __webpack_require__(38)\n\t  , ITERATOR  = __webpack_require__(31)('iterator')\n\t  , Iterators = __webpack_require__(10);\n\tmodule.exports = __webpack_require__(19).isIterable = function(it){\n\t  var O = Object(it);\n\t  return O[ITERATOR] !== undefined\n\t    || '@@iterator' in O\n\t    || Iterators.hasOwnProperty(classof(O));\n\t};\n\n/***/ },\n/* 38 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// getting tag from 19.1.3.6 Object.prototype.toString()\n\tvar cof = __webpack_require__(13)\n\t  , TAG = __webpack_require__(31)('toStringTag')\n\t  // ES3 wrong here\n\t  , ARG = cof(function(){ return arguments; }()) == 'Arguments';\n\t\n\tmodule.exports = function(it){\n\t  var O, T, B;\n\t  return it === undefined ? 'Undefined' : it === null ? 'Null'\n\t    // @@toStringTag case\n\t    : typeof (T = (O = Object(it))[TAG]) == 'string' ? T\n\t    // builtinTag case\n\t    : ARG ? cof(O)\n\t    // ES3 arguments fallback\n\t    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;\n\t};\n\n/***/ },\n/* 39 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = { \"default\": __webpack_require__(40), __esModule: true };\n\n/***/ },\n/* 40 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(6);\n\t__webpack_require__(34);\n\tmodule.exports = __webpack_require__(41);\n\n/***/ },\n/* 41 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar anObject = __webpack_require__(42)\n\t  , get      = __webpack_require__(44);\n\tmodule.exports = __webpack_require__(19).getIterator = function(it){\n\t  var iterFn = get(it);\n\t  if(typeof iterFn != 'function')throw TypeError(it + ' is not iterable!');\n\t  return anObject(iterFn.call(it));\n\t};\n\n/***/ },\n/* 42 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar isObject = __webpack_require__(43);\n\tmodule.exports = function(it){\n\t  if(!isObject(it))throw TypeError(it + ' is not an object!');\n\t  return it;\n\t};\n\n/***/ },\n/* 43 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function(it){\n\t  return typeof it === 'object' ? it !== null : typeof it === 'function';\n\t};\n\n/***/ },\n/* 44 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar classof   = __webpack_require__(38)\n\t  , ITERATOR  = __webpack_require__(31)('iterator')\n\t  , Iterators = __webpack_require__(10);\n\tmodule.exports = __webpack_require__(19).getIteratorMethod = function(it){\n\t  if(it != undefined)return it[ITERATOR]\n\t    || it['@@iterator']\n\t    || Iterators[classof(it)];\n\t};\n\n/***/ },\n/* 45 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\texports.__esModule = true;\n\t\n\texports.default = function (instance, Constructor) {\n\t  if (!(instance instanceof Constructor)) {\n\t    throw new TypeError(\"Cannot call a class as a function\");\n\t  }\n\t};\n\n/***/ },\n/* 46 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\texports.__esModule = true;\n\t\n\tvar _defineProperty = __webpack_require__(47);\n\t\n\tvar _defineProperty2 = _interopRequireDefault(_defineProperty);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = (function () {\n\t  function defineProperties(target, props) {\n\t    for (var i = 0; i < props.length; i++) {\n\t      var descriptor = props[i];\n\t      descriptor.enumerable = descriptor.enumerable || false;\n\t      descriptor.configurable = true;\n\t      if (\"value\" in descriptor) descriptor.writable = true;\n\t      (0, _defineProperty2.default)(target, descriptor.key, descriptor);\n\t    }\n\t  }\n\t\n\t  return function (Constructor, protoProps, staticProps) {\n\t    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n\t    if (staticProps) defineProperties(Constructor, staticProps);\n\t    return Constructor;\n\t  };\n\t})();\n\n/***/ },\n/* 47 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = { \"default\": __webpack_require__(48), __esModule: true };\n\n/***/ },\n/* 48 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar $ = __webpack_require__(24);\n\tmodule.exports = function defineProperty(it, key, desc){\n\t  return $.setDesc(it, key, desc);\n\t};\n\n/***/ },\n/* 49 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global, process) {// Copyright (c) Microsoft, All rights reserved. See License.txt in the project root for license information.\n\t\n\t;(function (undefined) {\n\t\n\t  var objectTypes = {\n\t    'function': true,\n\t    'object': true\n\t  };\n\t\n\t  function checkGlobal(value) {\n\t    return (value && value.Object === Object) ? value : null;\n\t  }\n\t\n\t  var freeExports = (objectTypes[typeof exports] && exports && !exports.nodeType) ? exports : null;\n\t  var freeModule = (objectTypes[typeof module] && module && !module.nodeType) ? module : null;\n\t  var freeGlobal = checkGlobal(freeExports && freeModule && typeof global === 'object' && global);\n\t  var freeSelf = checkGlobal(objectTypes[typeof self] && self);\n\t  var freeWindow = checkGlobal(objectTypes[typeof window] && window);\n\t  var moduleExports = (freeModule && freeModule.exports === freeExports) ? freeExports : null;\n\t  var thisGlobal = checkGlobal(objectTypes[typeof this] && this);\n\t  var root = freeGlobal || ((freeWindow !== (thisGlobal && thisGlobal.window)) && freeWindow) || freeSelf || thisGlobal || Function('return this')();\n\t\n\t  var Rx = {\n\t    internals: {},\n\t    config: {\n\t      Promise: root.Promise\n\t    },\n\t    helpers: { }\n\t  };\n\t\n\t  // Defaults\n\t  var noop = Rx.helpers.noop = function () { },\n\t    identity = Rx.helpers.identity = function (x) { return x; },\n\t    defaultNow = Rx.helpers.defaultNow = Date.now,\n\t    defaultComparer = Rx.helpers.defaultComparer = function (x, y) { return isEqual(x, y); },\n\t    defaultSubComparer = Rx.helpers.defaultSubComparer = function (x, y) { return x > y ? 1 : (x < y ? -1 : 0); },\n\t    defaultKeySerializer = Rx.helpers.defaultKeySerializer = function (x) { return x.toString(); },\n\t    defaultError = Rx.helpers.defaultError = function (err) { throw err; },\n\t    isPromise = Rx.helpers.isPromise = function (p) { return !!p && typeof p.subscribe !== 'function' && typeof p.then === 'function'; },\n\t    isFunction = Rx.helpers.isFunction = (function () {\n\t\n\t      var isFn = function (value) {\n\t        return typeof value == 'function' || false;\n\t      };\n\t\n\t      // fallback for older versions of Chrome and Safari\n\t      if (isFn(/x/)) {\n\t        isFn = function(value) {\n\t          return typeof value == 'function' && toString.call(value) == '[object Function]';\n\t        };\n\t      }\n\t\n\t      return isFn;\n\t    }());\n\t\n\t  function cloneArray(arr) { for(var a = [], i = 0, len = arr.length; i < len; i++) { a.push(arr[i]); } return a;}\n\t\n\t  var errorObj = {e: {}};\n\t  \n\t  function tryCatcherGen(tryCatchTarget) {\n\t    return function tryCatcher() {\n\t      try {\n\t        return tryCatchTarget.apply(this, arguments);\n\t      } catch (e) {\n\t        errorObj.e = e;\n\t        return errorObj;\n\t      }\n\t    };\n\t  }\n\t\n\t  var tryCatch = Rx.internals.tryCatch = function tryCatch(fn) {\n\t    if (!isFunction(fn)) { throw new TypeError('fn must be a function'); }\n\t    return tryCatcherGen(fn);\n\t  };\n\t\n\t  function thrower(e) {\n\t    throw e;\n\t  }\n\t\n\t  Rx.config.longStackSupport = false;\n\t  var hasStacks = false, stacks = tryCatch(function () { throw new Error(); })();\n\t  hasStacks = !!stacks.e && !!stacks.e.stack;\n\t\n\t  // All code after this point will be filtered from stack traces reported by RxJS\n\t  var rStartingLine = captureLine(), rFileName;\n\t\n\t  var STACK_JUMP_SEPARATOR = 'From previous event:';\n\t\n\t  function makeStackTraceLong(error, observable) {\n\t    // If possible, transform the error stack trace by removing Node and RxJS\n\t    // cruft, then concatenating with the stack trace of `observable`.\n\t    if (hasStacks &&\n\t        observable.stack &&\n\t        typeof error === 'object' &&\n\t        error !== null &&\n\t        error.stack &&\n\t        error.stack.indexOf(STACK_JUMP_SEPARATOR) === -1\n\t    ) {\n\t      var stacks = [];\n\t      for (var o = observable; !!o; o = o.source) {\n\t        if (o.stack) {\n\t          stacks.unshift(o.stack);\n\t        }\n\t      }\n\t      stacks.unshift(error.stack);\n\t\n\t      var concatedStacks = stacks.join('\\n' + STACK_JUMP_SEPARATOR + '\\n');\n\t      error.stack = filterStackString(concatedStacks);\n\t    }\n\t  }\n\t\n\t  function filterStackString(stackString) {\n\t    var lines = stackString.split('\\n'), desiredLines = [];\n\t    for (var i = 0, len = lines.length; i < len; i++) {\n\t      var line = lines[i];\n\t\n\t      if (!isInternalFrame(line) && !isNodeFrame(line) && line) {\n\t        desiredLines.push(line);\n\t      }\n\t    }\n\t    return desiredLines.join('\\n');\n\t  }\n\t\n\t  function isInternalFrame(stackLine) {\n\t    var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);\n\t    if (!fileNameAndLineNumber) {\n\t      return false;\n\t    }\n\t    var fileName = fileNameAndLineNumber[0], lineNumber = fileNameAndLineNumber[1];\n\t\n\t    return fileName === rFileName &&\n\t      lineNumber >= rStartingLine &&\n\t      lineNumber <= rEndingLine;\n\t  }\n\t\n\t  function isNodeFrame(stackLine) {\n\t    return stackLine.indexOf('(module.js:') !== -1 ||\n\t      stackLine.indexOf('(node.js:') !== -1;\n\t  }\n\t\n\t  function captureLine() {\n\t    if (!hasStacks) { return; }\n\t\n\t    try {\n\t      throw new Error();\n\t    } catch (e) {\n\t      var lines = e.stack.split('\\n');\n\t      var firstLine = lines[0].indexOf('@') > 0 ? lines[1] : lines[2];\n\t      var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);\n\t      if (!fileNameAndLineNumber) { return; }\n\t\n\t      rFileName = fileNameAndLineNumber[0];\n\t      return fileNameAndLineNumber[1];\n\t    }\n\t  }\n\t\n\t  function getFileNameAndLineNumber(stackLine) {\n\t    // Named functions: 'at functionName (filename:lineNumber:columnNumber)'\n\t    var attempt1 = /at .+ \\((.+):(\\d+):(?:\\d+)\\)$/.exec(stackLine);\n\t    if (attempt1) { return [attempt1[1], Number(attempt1[2])]; }\n\t\n\t    // Anonymous functions: 'at filename:lineNumber:columnNumber'\n\t    var attempt2 = /at ([^ ]+):(\\d+):(?:\\d+)$/.exec(stackLine);\n\t    if (attempt2) { return [attempt2[1], Number(attempt2[2])]; }\n\t\n\t    // Firefox style: 'function@filename:lineNumber or @filename:lineNumber'\n\t    var attempt3 = /.*@(.+):(\\d+)$/.exec(stackLine);\n\t    if (attempt3) { return [attempt3[1], Number(attempt3[2])]; }\n\t  }\n\t\n\t  var EmptyError = Rx.EmptyError = function() {\n\t    this.message = 'Sequence contains no elements.';\n\t    Error.call(this);\n\t  };\n\t  EmptyError.prototype = Object.create(Error.prototype);\n\t  EmptyError.prototype.name = 'EmptyError';\n\t\n\t  var ObjectDisposedError = Rx.ObjectDisposedError = function() {\n\t    this.message = 'Object has been disposed';\n\t    Error.call(this);\n\t  };\n\t  ObjectDisposedError.prototype = Object.create(Error.prototype);\n\t  ObjectDisposedError.prototype.name = 'ObjectDisposedError';\n\t\n\t  var ArgumentOutOfRangeError = Rx.ArgumentOutOfRangeError = function () {\n\t    this.message = 'Argument out of range';\n\t    Error.call(this);\n\t  };\n\t  ArgumentOutOfRangeError.prototype = Object.create(Error.prototype);\n\t  ArgumentOutOfRangeError.prototype.name = 'ArgumentOutOfRangeError';\n\t\n\t  var NotSupportedError = Rx.NotSupportedError = function (message) {\n\t    this.message = message || 'This operation is not supported';\n\t    Error.call(this);\n\t  };\n\t  NotSupportedError.prototype = Object.create(Error.prototype);\n\t  NotSupportedError.prototype.name = 'NotSupportedError';\n\t\n\t  var NotImplementedError = Rx.NotImplementedError = function (message) {\n\t    this.message = message || 'This operation is not implemented';\n\t    Error.call(this);\n\t  };\n\t  NotImplementedError.prototype = Object.create(Error.prototype);\n\t  NotImplementedError.prototype.name = 'NotImplementedError';\n\t\n\t  var notImplemented = Rx.helpers.notImplemented = function () {\n\t    throw new NotImplementedError();\n\t  };\n\t\n\t  var notSupported = Rx.helpers.notSupported = function () {\n\t    throw new NotSupportedError();\n\t  };\n\t\n\t  // Shim in iterator support\n\t  var $iterator$ = (typeof Symbol === 'function' && Symbol.iterator) ||\n\t    '_es6shim_iterator_';\n\t  // Bug for mozilla version\n\t  if (root.Set && typeof new root.Set()['@@iterator'] === 'function') {\n\t    $iterator$ = '@@iterator';\n\t  }\n\t\n\t  var doneEnumerator = Rx.doneEnumerator = { done: true, value: undefined };\n\t\n\t  var isIterable = Rx.helpers.isIterable = function (o) {\n\t    return o && o[$iterator$] !== undefined;\n\t  };\n\t\n\t  var isArrayLike = Rx.helpers.isArrayLike = function (o) {\n\t    return o && o.length !== undefined;\n\t  };\n\t\n\t  Rx.helpers.iterator = $iterator$;\n\t\n\t  var bindCallback = Rx.internals.bindCallback = function (func, thisArg, argCount) {\n\t    if (typeof thisArg === 'undefined') { return func; }\n\t    switch(argCount) {\n\t      case 0:\n\t        return function() {\n\t          return func.call(thisArg)\n\t        };\n\t      case 1:\n\t        return function(arg) {\n\t          return func.call(thisArg, arg);\n\t        };\n\t      case 2:\n\t        return function(value, index) {\n\t          return func.call(thisArg, value, index);\n\t        };\n\t      case 3:\n\t        return function(value, index, collection) {\n\t          return func.call(thisArg, value, index, collection);\n\t        };\n\t    }\n\t\n\t    return function() {\n\t      return func.apply(thisArg, arguments);\n\t    };\n\t  };\n\t\n\t  /** Used to determine if values are of the language type Object */\n\t  var dontEnums = ['toString',\n\t    'toLocaleString',\n\t    'valueOf',\n\t    'hasOwnProperty',\n\t    'isPrototypeOf',\n\t    'propertyIsEnumerable',\n\t    'constructor'],\n\t  dontEnumsLength = dontEnums.length;\n\t\n\tvar argsTag = '[object Arguments]',\n\t    arrayTag = '[object Array]',\n\t    boolTag = '[object Boolean]',\n\t    dateTag = '[object Date]',\n\t    errorTag = '[object Error]',\n\t    funcTag = '[object Function]',\n\t    mapTag = '[object Map]',\n\t    numberTag = '[object Number]',\n\t    objectTag = '[object Object]',\n\t    regexpTag = '[object RegExp]',\n\t    setTag = '[object Set]',\n\t    stringTag = '[object String]',\n\t    weakMapTag = '[object WeakMap]';\n\t\n\tvar arrayBufferTag = '[object ArrayBuffer]',\n\t    float32Tag = '[object Float32Array]',\n\t    float64Tag = '[object Float64Array]',\n\t    int8Tag = '[object Int8Array]',\n\t    int16Tag = '[object Int16Array]',\n\t    int32Tag = '[object Int32Array]',\n\t    uint8Tag = '[object Uint8Array]',\n\t    uint8ClampedTag = '[object Uint8ClampedArray]',\n\t    uint16Tag = '[object Uint16Array]',\n\t    uint32Tag = '[object Uint32Array]';\n\t\n\tvar typedArrayTags = {};\n\ttypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\n\ttypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\n\ttypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\n\ttypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\n\ttypedArrayTags[uint32Tag] = true;\n\ttypedArrayTags[argsTag] = typedArrayTags[arrayTag] =\n\ttypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\n\ttypedArrayTags[dateTag] = typedArrayTags[errorTag] =\n\ttypedArrayTags[funcTag] = typedArrayTags[mapTag] =\n\ttypedArrayTags[numberTag] = typedArrayTags[objectTag] =\n\ttypedArrayTags[regexpTag] = typedArrayTags[setTag] =\n\ttypedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;\n\t\n\tvar objectProto = Object.prototype,\n\t    hasOwnProperty = objectProto.hasOwnProperty,\n\t    objToString = objectProto.toString,\n\t    MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;\n\t\n\tvar keys = Object.keys || (function() {\n\t    var hasOwnProperty = Object.prototype.hasOwnProperty,\n\t        hasDontEnumBug = !({ toString: null }).propertyIsEnumerable('toString'),\n\t        dontEnums = [\n\t          'toString',\n\t          'toLocaleString',\n\t          'valueOf',\n\t          'hasOwnProperty',\n\t          'isPrototypeOf',\n\t          'propertyIsEnumerable',\n\t          'constructor'\n\t        ],\n\t        dontEnumsLength = dontEnums.length;\n\t\n\t    return function(obj) {\n\t      if (typeof obj !== 'object' && (typeof obj !== 'function' || obj === null)) {\n\t        throw new TypeError('Object.keys called on non-object');\n\t      }\n\t\n\t      var result = [], prop, i;\n\t\n\t      for (prop in obj) {\n\t        if (hasOwnProperty.call(obj, prop)) {\n\t          result.push(prop);\n\t        }\n\t      }\n\t\n\t      if (hasDontEnumBug) {\n\t        for (i = 0; i < dontEnumsLength; i++) {\n\t          if (hasOwnProperty.call(obj, dontEnums[i])) {\n\t            result.push(dontEnums[i]);\n\t          }\n\t        }\n\t      }\n\t      return result;\n\t    };\n\t  }());\n\t\n\tfunction equalObjects(object, other, equalFunc, isLoose, stackA, stackB) {\n\t  var objProps = keys(object),\n\t      objLength = objProps.length,\n\t      othProps = keys(other),\n\t      othLength = othProps.length;\n\t\n\t  if (objLength !== othLength && !isLoose) {\n\t    return false;\n\t  }\n\t  var index = objLength, key;\n\t  while (index--) {\n\t    key = objProps[index];\n\t    if (!(isLoose ? key in other : hasOwnProperty.call(other, key))) {\n\t      return false;\n\t    }\n\t  }\n\t  var skipCtor = isLoose;\n\t  while (++index < objLength) {\n\t    key = objProps[index];\n\t    var objValue = object[key],\n\t        othValue = other[key],\n\t        result;\n\t\n\t    if (!(result === undefined ? equalFunc(objValue, othValue, isLoose, stackA, stackB) : result)) {\n\t      return false;\n\t    }\n\t    skipCtor || (skipCtor = key === 'constructor');\n\t  }\n\t  if (!skipCtor) {\n\t    var objCtor = object.constructor,\n\t        othCtor = other.constructor;\n\t\n\t    if (objCtor !== othCtor &&\n\t        ('constructor' in object && 'constructor' in other) &&\n\t        !(typeof objCtor === 'function' && objCtor instanceof objCtor &&\n\t          typeof othCtor === 'function' && othCtor instanceof othCtor)) {\n\t      return false;\n\t    }\n\t  }\n\t  return true;\n\t}\n\t\n\tfunction equalByTag(object, other, tag) {\n\t  switch (tag) {\n\t    case boolTag:\n\t    case dateTag:\n\t      return +object === +other;\n\t\n\t    case errorTag:\n\t      return object.name === other.name && object.message === other.message;\n\t\n\t    case numberTag:\n\t      return (object !== +object) ?\n\t        other !== +other :\n\t        object === +other;\n\t\n\t    case regexpTag:\n\t    case stringTag:\n\t      return object === (other + '');\n\t  }\n\t  return false;\n\t}\n\t\n\tvar isObject = Rx.internals.isObject = function(value) {\n\t  var type = typeof value;\n\t  return !!value && (type === 'object' || type === 'function');\n\t};\n\t\n\tfunction isObjectLike(value) {\n\t  return !!value && typeof value === 'object';\n\t}\n\t\n\tfunction isLength(value) {\n\t  return typeof value === 'number' && value > -1 && value % 1 === 0 && value <= MAX_SAFE_INTEGER;\n\t}\n\t\n\tvar isHostObject = (function() {\n\t  try {\n\t    Object({ 'toString': 0 } + '');\n\t  } catch(e) {\n\t    return function() { return false; };\n\t  }\n\t  return function(value) {\n\t    return typeof value.toString !== 'function' && typeof (value + '') === 'string';\n\t  };\n\t}());\n\t\n\tfunction isTypedArray(value) {\n\t  return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objToString.call(value)];\n\t}\n\t\n\tvar isArray = Array.isArray || function(value) {\n\t  return isObjectLike(value) && isLength(value.length) && objToString.call(value) === arrayTag;\n\t};\n\t\n\tfunction arraySome (array, predicate) {\n\t  var index = -1,\n\t      length = array.length;\n\t\n\t  while (++index < length) {\n\t    if (predicate(array[index], index, array)) {\n\t      return true;\n\t    }\n\t  }\n\t  return false;\n\t}\n\t\n\tfunction equalArrays(array, other, equalFunc, isLoose, stackA, stackB) {\n\t  var index = -1,\n\t      arrLength = array.length,\n\t      othLength = other.length;\n\t\n\t  if (arrLength !== othLength && !(isLoose && othLength > arrLength)) {\n\t    return false;\n\t  }\n\t  // Ignore non-index properties.\n\t  while (++index < arrLength) {\n\t    var arrValue = array[index],\n\t        othValue = other[index],\n\t        result;\n\t\n\t    if (result !== undefined) {\n\t      if (result) {\n\t        continue;\n\t      }\n\t      return false;\n\t    }\n\t    // Recursively compare arrays (susceptible to call stack limits).\n\t    if (isLoose) {\n\t      if (!arraySome(other, function(othValue) {\n\t            return arrValue === othValue || equalFunc(arrValue, othValue, isLoose, stackA, stackB);\n\t          })) {\n\t        return false;\n\t      }\n\t    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, isLoose, stackA, stackB))) {\n\t      return false;\n\t    }\n\t  }\n\t  return true;\n\t}\n\t\n\tfunction baseIsEqualDeep(object, other, equalFunc, isLoose, stackA, stackB) {\n\t  var objIsArr = isArray(object),\n\t      othIsArr = isArray(other),\n\t      objTag = arrayTag,\n\t      othTag = arrayTag;\n\t\n\t  if (!objIsArr) {\n\t    objTag = objToString.call(object);\n\t    if (objTag === argsTag) {\n\t      objTag = objectTag;\n\t    } else if (objTag !== objectTag) {\n\t      objIsArr = isTypedArray(object);\n\t    }\n\t  }\n\t  if (!othIsArr) {\n\t    othTag = objToString.call(other);\n\t    if (othTag === argsTag) {\n\t      othTag = objectTag;\n\t    }\n\t  }\n\t  var objIsObj = objTag === objectTag && !isHostObject(object),\n\t      othIsObj = othTag === objectTag && !isHostObject(other),\n\t      isSameTag = objTag === othTag;\n\t\n\t  if (isSameTag && !(objIsArr || objIsObj)) {\n\t    return equalByTag(object, other, objTag);\n\t  }\n\t  if (!isLoose) {\n\t    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\n\t        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\t\n\t    if (objIsWrapped || othIsWrapped) {\n\t      return equalFunc(objIsWrapped ? object.value() : object, othIsWrapped ? other.value() : other, isLoose, stackA, stackB);\n\t    }\n\t  }\n\t  if (!isSameTag) {\n\t    return false;\n\t  }\n\t  // Assume cyclic values are equal.\n\t  // For more information on detecting circular references see https://es5.github.io/#JO.\n\t  stackA || (stackA = []);\n\t  stackB || (stackB = []);\n\t\n\t  var length = stackA.length;\n\t  while (length--) {\n\t    if (stackA[length] === object) {\n\t      return stackB[length] === other;\n\t    }\n\t  }\n\t  // Add `object` and `other` to the stack of traversed objects.\n\t  stackA.push(object);\n\t  stackB.push(other);\n\t\n\t  var result = (objIsArr ? equalArrays : equalObjects)(object, other, equalFunc, isLoose, stackA, stackB);\n\t\n\t  stackA.pop();\n\t  stackB.pop();\n\t\n\t  return result;\n\t}\n\t\n\tfunction baseIsEqual(value, other, isLoose, stackA, stackB) {\n\t  if (value === other) {\n\t    return true;\n\t  }\n\t  if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {\n\t    return value !== value && other !== other;\n\t  }\n\t  return baseIsEqualDeep(value, other, baseIsEqual, isLoose, stackA, stackB);\n\t}\n\t\n\tvar isEqual = Rx.internals.isEqual = function (value, other) {\n\t  return baseIsEqual(value, other);\n\t};\n\t\n\t  var hasProp = {}.hasOwnProperty,\n\t      slice = Array.prototype.slice;\n\t\n\t  var inherits = Rx.internals.inherits = function (child, parent) {\n\t    function __() { this.constructor = child; }\n\t    __.prototype = parent.prototype;\n\t    child.prototype = new __();\n\t  };\n\t\n\t  var addProperties = Rx.internals.addProperties = function (obj) {\n\t    for(var sources = [], i = 1, len = arguments.length; i < len; i++) { sources.push(arguments[i]); }\n\t    for (var idx = 0, ln = sources.length; idx < ln; idx++) {\n\t      var source = sources[idx];\n\t      for (var prop in source) {\n\t        obj[prop] = source[prop];\n\t      }\n\t    }\n\t  };\n\t\n\t  // Rx Utils\n\t  var addRef = Rx.internals.addRef = function (xs, r) {\n\t    return new AnonymousObservable(function (observer) {\n\t      return new BinaryDisposable(r.getDisposable(), xs.subscribe(observer));\n\t    });\n\t  };\n\t\n\t  function arrayInitialize(count, factory) {\n\t    var a = new Array(count);\n\t    for (var i = 0; i < count; i++) {\n\t      a[i] = factory();\n\t    }\n\t    return a;\n\t  }\n\t\n\t  function IndexedItem(id, value) {\n\t    this.id = id;\n\t    this.value = value;\n\t  }\n\t\n\t  IndexedItem.prototype.compareTo = function (other) {\n\t    var c = this.value.compareTo(other.value);\n\t    c === 0 && (c = this.id - other.id);\n\t    return c;\n\t  };\n\t\n\t  var PriorityQueue = Rx.internals.PriorityQueue = function (capacity) {\n\t    this.items = new Array(capacity);\n\t    this.length = 0;\n\t  };\n\t\n\t  var priorityProto = PriorityQueue.prototype;\n\t  priorityProto.isHigherPriority = function (left, right) {\n\t    return this.items[left].compareTo(this.items[right]) < 0;\n\t  };\n\t\n\t  priorityProto.percolate = function (index) {\n\t    if (index >= this.length || index < 0) { return; }\n\t    var parent = index - 1 >> 1;\n\t    if (parent < 0 || parent === index) { return; }\n\t    if (this.isHigherPriority(index, parent)) {\n\t      var temp = this.items[index];\n\t      this.items[index] = this.items[parent];\n\t      this.items[parent] = temp;\n\t      this.percolate(parent);\n\t    }\n\t  };\n\t\n\t  priorityProto.heapify = function (index) {\n\t    +index || (index = 0);\n\t    if (index >= this.length || index < 0) { return; }\n\t    var left = 2 * index + 1,\n\t        right = 2 * index + 2,\n\t        first = index;\n\t    if (left < this.length && this.isHigherPriority(left, first)) {\n\t      first = left;\n\t    }\n\t    if (right < this.length && this.isHigherPriority(right, first)) {\n\t      first = right;\n\t    }\n\t    if (first !== index) {\n\t      var temp = this.items[index];\n\t      this.items[index] = this.items[first];\n\t      this.items[first] = temp;\n\t      this.heapify(first);\n\t    }\n\t  };\n\t\n\t  priorityProto.peek = function () { return this.items[0].value; };\n\t\n\t  priorityProto.removeAt = function (index) {\n\t    this.items[index] = this.items[--this.length];\n\t    this.items[this.length] = undefined;\n\t    this.heapify();\n\t  };\n\t\n\t  priorityProto.dequeue = function () {\n\t    var result = this.peek();\n\t    this.removeAt(0);\n\t    return result;\n\t  };\n\t\n\t  priorityProto.enqueue = function (item) {\n\t    var index = this.length++;\n\t    this.items[index] = new IndexedItem(PriorityQueue.count++, item);\n\t    this.percolate(index);\n\t  };\n\t\n\t  priorityProto.remove = function (item) {\n\t    for (var i = 0; i < this.length; i++) {\n\t      if (this.items[i].value === item) {\n\t        this.removeAt(i);\n\t        return true;\n\t      }\n\t    }\n\t    return false;\n\t  };\n\t  PriorityQueue.count = 0;\n\t\n\t  /**\n\t   * Represents a group of disposable resources that are disposed together.\n\t   * @constructor\n\t   */\n\t  var CompositeDisposable = Rx.CompositeDisposable = function () {\n\t    var args = [], i, len;\n\t    if (Array.isArray(arguments[0])) {\n\t      args = arguments[0];\n\t    } else {\n\t      len = arguments.length;\n\t      args = new Array(len);\n\t      for(i = 0; i < len; i++) { args[i] = arguments[i]; }\n\t    }\n\t    this.disposables = args;\n\t    this.isDisposed = false;\n\t    this.length = args.length;\n\t  };\n\t\n\t  var CompositeDisposablePrototype = CompositeDisposable.prototype;\n\t\n\t  /**\n\t   * Adds a disposable to the CompositeDisposable or disposes the disposable if the CompositeDisposable is disposed.\n\t   * @param {Mixed} item Disposable to add.\n\t   */\n\t  CompositeDisposablePrototype.add = function (item) {\n\t    if (this.isDisposed) {\n\t      item.dispose();\n\t    } else {\n\t      this.disposables.push(item);\n\t      this.length++;\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Removes and disposes the first occurrence of a disposable from the CompositeDisposable.\n\t   * @param {Mixed} item Disposable to remove.\n\t   * @returns {Boolean} true if found; false otherwise.\n\t   */\n\t  CompositeDisposablePrototype.remove = function (item) {\n\t    var shouldDispose = false;\n\t    if (!this.isDisposed) {\n\t      var idx = this.disposables.indexOf(item);\n\t      if (idx !== -1) {\n\t        shouldDispose = true;\n\t        this.disposables.splice(idx, 1);\n\t        this.length--;\n\t        item.dispose();\n\t      }\n\t    }\n\t    return shouldDispose;\n\t  };\n\t\n\t  /**\n\t   *  Disposes all disposables in the group and removes them from the group.\n\t   */\n\t  CompositeDisposablePrototype.dispose = function () {\n\t    if (!this.isDisposed) {\n\t      this.isDisposed = true;\n\t      var len = this.disposables.length, currentDisposables = new Array(len);\n\t      for(var i = 0; i < len; i++) { currentDisposables[i] = this.disposables[i]; }\n\t      this.disposables = [];\n\t      this.length = 0;\n\t\n\t      for (i = 0; i < len; i++) {\n\t        currentDisposables[i].dispose();\n\t      }\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Provides a set of static methods for creating Disposables.\n\t   * @param {Function} dispose Action to run during the first call to dispose. The action is guaranteed to be run at most once.\n\t   */\n\t  var Disposable = Rx.Disposable = function (action) {\n\t    this.isDisposed = false;\n\t    this.action = action || noop;\n\t  };\n\t\n\t  /** Performs the task of cleaning up resources. */\n\t  Disposable.prototype.dispose = function () {\n\t    if (!this.isDisposed) {\n\t      this.action();\n\t      this.isDisposed = true;\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Creates a disposable object that invokes the specified action when disposed.\n\t   * @param {Function} dispose Action to run during the first call to dispose. The action is guaranteed to be run at most once.\n\t   * @return {Disposable} The disposable object that runs the given action upon disposal.\n\t   */\n\t  var disposableCreate = Disposable.create = function (action) { return new Disposable(action); };\n\t\n\t  /**\n\t   * Gets the disposable that does nothing when disposed.\n\t   */\n\t  var disposableEmpty = Disposable.empty = { dispose: noop };\n\t\n\t  /**\n\t   * Validates whether the given object is a disposable\n\t   * @param {Object} Object to test whether it has a dispose method\n\t   * @returns {Boolean} true if a disposable object, else false.\n\t   */\n\t  var isDisposable = Disposable.isDisposable = function (d) {\n\t    return d && isFunction(d.dispose);\n\t  };\n\t\n\t  var checkDisposed = Disposable.checkDisposed = function (disposable) {\n\t    if (disposable.isDisposed) { throw new ObjectDisposedError(); }\n\t  };\n\t\n\t  var disposableFixup = Disposable._fixup = function (result) {\n\t    return isDisposable(result) ? result : disposableEmpty;\n\t  };\n\t\n\t  // Single assignment\n\t  var SingleAssignmentDisposable = Rx.SingleAssignmentDisposable = function () {\n\t    this.isDisposed = false;\n\t    this.current = null;\n\t  };\n\t  SingleAssignmentDisposable.prototype.getDisposable = function () {\n\t    return this.current;\n\t  };\n\t  SingleAssignmentDisposable.prototype.setDisposable = function (value) {\n\t    if (this.current) { throw new Error('Disposable has already been assigned'); }\n\t    var shouldDispose = this.isDisposed;\n\t    !shouldDispose && (this.current = value);\n\t    shouldDispose && value && value.dispose();\n\t  };\n\t  SingleAssignmentDisposable.prototype.dispose = function () {\n\t    if (!this.isDisposed) {\n\t      this.isDisposed = true;\n\t      var old = this.current;\n\t      this.current = null;\n\t      old && old.dispose();\n\t    }\n\t  };\n\t\n\t  // Multiple assignment disposable\n\t  var SerialDisposable = Rx.SerialDisposable = function () {\n\t    this.isDisposed = false;\n\t    this.current = null;\n\t  };\n\t  SerialDisposable.prototype.getDisposable = function () {\n\t    return this.current;\n\t  };\n\t  SerialDisposable.prototype.setDisposable = function (value) {\n\t    var shouldDispose = this.isDisposed;\n\t    if (!shouldDispose) {\n\t      var old = this.current;\n\t      this.current = value;\n\t    }\n\t    old && old.dispose();\n\t    shouldDispose && value && value.dispose();\n\t  };\n\t  SerialDisposable.prototype.dispose = function () {\n\t    if (!this.isDisposed) {\n\t      this.isDisposed = true;\n\t      var old = this.current;\n\t      this.current = null;\n\t    }\n\t    old && old.dispose();\n\t  };\n\t\n\t  var BinaryDisposable = Rx.BinaryDisposable = function (first, second) {\n\t    this._first = first;\n\t    this._second = second;\n\t    this.isDisposed = false;\n\t  };\n\t\n\t  BinaryDisposable.prototype.dispose = function () {\n\t    if (!this.isDisposed) {\n\t      this.isDisposed = true;\n\t      var old1 = this._first;\n\t      this._first = null;\n\t      old1 && old1.dispose();\n\t      var old2 = this._second;\n\t      this._second = null;\n\t      old2 && old2.dispose();\n\t    }\n\t  };\n\t\n\t  var NAryDisposable = Rx.NAryDisposable = function (disposables) {\n\t    this._disposables = disposables;\n\t    this.isDisposed = false;\n\t  };\n\t\n\t  NAryDisposable.prototype.dispose = function () {\n\t    if (!this.isDisposed) {\n\t      this.isDisposed = true;\n\t      for (var i = 0, len = this._disposables.length; i < len; i++) {\n\t        this._disposables[i].dispose();\n\t      }\n\t      this._disposables.length = 0;\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Represents a disposable resource that only disposes its underlying disposable resource when all dependent disposable objects have been disposed.\n\t   */\n\t  var RefCountDisposable = Rx.RefCountDisposable = (function () {\n\t\n\t    function InnerDisposable(disposable) {\n\t      this.disposable = disposable;\n\t      this.disposable.count++;\n\t      this.isInnerDisposed = false;\n\t    }\n\t\n\t    InnerDisposable.prototype.dispose = function () {\n\t      if (!this.disposable.isDisposed && !this.isInnerDisposed) {\n\t        this.isInnerDisposed = true;\n\t        this.disposable.count--;\n\t        if (this.disposable.count === 0 && this.disposable.isPrimaryDisposed) {\n\t          this.disposable.isDisposed = true;\n\t          this.disposable.underlyingDisposable.dispose();\n\t        }\n\t      }\n\t    };\n\t\n\t    /**\n\t     * Initializes a new instance of the RefCountDisposable with the specified disposable.\n\t     * @constructor\n\t     * @param {Disposable} disposable Underlying disposable.\n\t      */\n\t    function RefCountDisposable(disposable) {\n\t      this.underlyingDisposable = disposable;\n\t      this.isDisposed = false;\n\t      this.isPrimaryDisposed = false;\n\t      this.count = 0;\n\t    }\n\t\n\t    /**\n\t     * Disposes the underlying disposable only when all dependent disposables have been disposed\n\t     */\n\t    RefCountDisposable.prototype.dispose = function () {\n\t      if (!this.isDisposed && !this.isPrimaryDisposed) {\n\t        this.isPrimaryDisposed = true;\n\t        if (this.count === 0) {\n\t          this.isDisposed = true;\n\t          this.underlyingDisposable.dispose();\n\t        }\n\t      }\n\t    };\n\t\n\t    /**\n\t     * Returns a dependent disposable that when disposed decreases the refcount on the underlying disposable.\n\t     * @returns {Disposable} A dependent disposable contributing to the reference count that manages the underlying disposable's lifetime.\n\t     */\n\t    RefCountDisposable.prototype.getDisposable = function () {\n\t      return this.isDisposed ? disposableEmpty : new InnerDisposable(this);\n\t    };\n\t\n\t    return RefCountDisposable;\n\t  })();\n\t\n\t  function ScheduledDisposable(scheduler, disposable) {\n\t    this.scheduler = scheduler;\n\t    this.disposable = disposable;\n\t    this.isDisposed = false;\n\t  }\n\t\n\t  function scheduleItem(s, self) {\n\t    if (!self.isDisposed) {\n\t      self.isDisposed = true;\n\t      self.disposable.dispose();\n\t    }\n\t  }\n\t\n\t  ScheduledDisposable.prototype.dispose = function () {\n\t    this.scheduler.schedule(this, scheduleItem);\n\t  };\n\t\n\t  var ScheduledItem = Rx.internals.ScheduledItem = function (scheduler, state, action, dueTime, comparer) {\n\t    this.scheduler = scheduler;\n\t    this.state = state;\n\t    this.action = action;\n\t    this.dueTime = dueTime;\n\t    this.comparer = comparer || defaultSubComparer;\n\t    this.disposable = new SingleAssignmentDisposable();\n\t  };\n\t\n\t  ScheduledItem.prototype.invoke = function () {\n\t    this.disposable.setDisposable(this.invokeCore());\n\t  };\n\t\n\t  ScheduledItem.prototype.compareTo = function (other) {\n\t    return this.comparer(this.dueTime, other.dueTime);\n\t  };\n\t\n\t  ScheduledItem.prototype.isCancelled = function () {\n\t    return this.disposable.isDisposed;\n\t  };\n\t\n\t  ScheduledItem.prototype.invokeCore = function () {\n\t    return disposableFixup(this.action(this.scheduler, this.state));\n\t  };\n\t\n\t  /** Provides a set of static properties to access commonly used schedulers. */\n\t  var Scheduler = Rx.Scheduler = (function () {\n\t\n\t    function Scheduler() { }\n\t\n\t    /** Determines whether the given object is a scheduler */\n\t    Scheduler.isScheduler = function (s) {\n\t      return s instanceof Scheduler;\n\t    };\n\t\n\t    var schedulerProto = Scheduler.prototype;\n\t\n\t    /**\n\t   * Schedules an action to be executed.\n\t   * @param state State passed to the action to be executed.\n\t   * @param {Function} action Action to be executed.\n\t   * @returns {Disposable} The disposable object used to cancel the scheduled action (best effort).\n\t   */\n\t    schedulerProto.schedule = function (state, action) {\n\t      throw new NotImplementedError();\n\t    };\n\t\n\t  /**\n\t   * Schedules an action to be executed after dueTime.\n\t   * @param state State passed to the action to be executed.\n\t   * @param {Function} action Action to be executed.\n\t   * @param {Number} dueTime Relative time after which to execute the action.\n\t   * @returns {Disposable} The disposable object used to cancel the scheduled action (best effort).\n\t   */\n\t    schedulerProto.scheduleFuture = function (state, dueTime, action) {\n\t      var dt = dueTime;\n\t      dt instanceof Date && (dt = dt - this.now());\n\t      dt = Scheduler.normalize(dt);\n\t\n\t      if (dt === 0) { return this.schedule(state, action); }\n\t\n\t      return this._scheduleFuture(state, dt, action);\n\t    };\n\t\n\t    schedulerProto._scheduleFuture = function (state, dueTime, action) {\n\t      throw new NotImplementedError();\n\t    };\n\t\n\t    /** Gets the current time according to the local machine's system clock. */\n\t    Scheduler.now = defaultNow;\n\t\n\t    /** Gets the current time according to the local machine's system clock. */\n\t    Scheduler.prototype.now = defaultNow;\n\t\n\t    /**\n\t     * Normalizes the specified TimeSpan value to a positive value.\n\t     * @param {Number} timeSpan The time span value to normalize.\n\t     * @returns {Number} The specified TimeSpan value if it is zero or positive; otherwise, 0\n\t     */\n\t    Scheduler.normalize = function (timeSpan) {\n\t      timeSpan < 0 && (timeSpan = 0);\n\t      return timeSpan;\n\t    };\n\t\n\t    return Scheduler;\n\t  }());\n\t\n\t  var normalizeTime = Scheduler.normalize, isScheduler = Scheduler.isScheduler;\n\t\n\t  (function (schedulerProto) {\n\t\n\t    function invokeRecImmediate(scheduler, pair) {\n\t      var state = pair[0], action = pair[1], group = new CompositeDisposable();\n\t      action(state, innerAction);\n\t      return group;\n\t\n\t      function innerAction(state2) {\n\t        var isAdded = false, isDone = false;\n\t\n\t        var d = scheduler.schedule(state2, scheduleWork);\n\t        if (!isDone) {\n\t          group.add(d);\n\t          isAdded = true;\n\t        }\n\t\n\t        function scheduleWork(_, state3) {\n\t          if (isAdded) {\n\t            group.remove(d);\n\t          } else {\n\t            isDone = true;\n\t          }\n\t          action(state3, innerAction);\n\t          return disposableEmpty;\n\t        }\n\t      }\n\t    }\n\t\n\t    function invokeRecDate(scheduler, pair) {\n\t      var state = pair[0], action = pair[1], group = new CompositeDisposable();\n\t      action(state, innerAction);\n\t      return group;\n\t\n\t      function innerAction(state2, dueTime1) {\n\t        var isAdded = false, isDone = false;\n\t\n\t        var d = scheduler.scheduleFuture(state2, dueTime1, scheduleWork);\n\t        if (!isDone) {\n\t          group.add(d);\n\t          isAdded = true;\n\t        }\n\t\n\t        function scheduleWork(_, state3) {\n\t          if (isAdded) {\n\t            group.remove(d);\n\t          } else {\n\t            isDone = true;\n\t          }\n\t          action(state3, innerAction);\n\t          return disposableEmpty;\n\t        }\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Schedules an action to be executed recursively.\n\t     * @param {Mixed} state State passed to the action to be executed.\n\t     * @param {Function} action Action to execute recursively. The last parameter passed to the action is used to trigger recursive scheduling of the action, passing in recursive invocation state.\n\t     * @returns {Disposable} The disposable object used to cancel the scheduled action (best effort).\n\t     */\n\t    schedulerProto.scheduleRecursive = function (state, action) {\n\t      return this.schedule([state, action], invokeRecImmediate);\n\t    };\n\t\n\t    /**\n\t     * Schedules an action to be executed recursively after a specified relative or absolute due time.\n\t     * @param {Mixed} state State passed to the action to be executed.\n\t     * @param {Function} action Action to execute recursively. The last parameter passed to the action is used to trigger recursive scheduling of the action, passing in the recursive due time and invocation state.\n\t     * @param {Number | Date} dueTime Relative or absolute time after which to execute the action for the first time.\n\t     * @returns {Disposable} The disposable object used to cancel the scheduled action (best effort).\n\t     */\n\t    schedulerProto.scheduleRecursiveFuture = function (state, dueTime, action) {\n\t      return this.scheduleFuture([state, action], dueTime, invokeRecDate);\n\t    };\n\t\n\t  }(Scheduler.prototype));\n\t\n\t  (function (schedulerProto) {\n\t\n\t    /**\n\t     * Schedules a periodic piece of work by dynamically discovering the scheduler's capabilities. The periodic task will be scheduled using window.setInterval for the base implementation.\n\t     * @param {Mixed} state Initial state passed to the action upon the first iteration.\n\t     * @param {Number} period Period for running the work periodically.\n\t     * @param {Function} action Action to be executed, potentially updating the state.\n\t     * @returns {Disposable} The disposable object used to cancel the scheduled recurring action (best effort).\n\t     */\n\t    schedulerProto.schedulePeriodic = function(state, period, action) {\n\t      if (typeof root.setInterval === 'undefined') { throw new NotSupportedError(); }\n\t      period = normalizeTime(period);\n\t      var s = state, id = root.setInterval(function () { s = action(s); }, period);\n\t      return disposableCreate(function () { root.clearInterval(id); });\n\t    };\n\t\n\t  }(Scheduler.prototype));\n\t\n\t  (function (schedulerProto) {\n\t    /**\n\t     * Returns a scheduler that wraps the original scheduler, adding exception handling for scheduled actions.\n\t     * @param {Function} handler Handler that's run if an exception is caught. The exception will be rethrown if the handler returns false.\n\t     * @returns {Scheduler} Wrapper around the original scheduler, enforcing exception handling.\n\t     */\n\t    schedulerProto.catchError = schedulerProto['catch'] = function (handler) {\n\t      return new CatchScheduler(this, handler);\n\t    };\n\t  }(Scheduler.prototype));\n\t\n\t  var SchedulePeriodicRecursive = Rx.internals.SchedulePeriodicRecursive = (function () {\n\t    function createTick(self) {\n\t      return function tick(command, recurse) {\n\t        recurse(0, self._period);\n\t        var state = tryCatch(self._action)(self._state);\n\t        if (state === errorObj) {\n\t          self._cancel.dispose();\n\t          thrower(state.e);\n\t        }\n\t        self._state = state;\n\t      };\n\t    }\n\t\n\t    function SchedulePeriodicRecursive(scheduler, state, period, action) {\n\t      this._scheduler = scheduler;\n\t      this._state = state;\n\t      this._period = period;\n\t      this._action = action;\n\t    }\n\t\n\t    SchedulePeriodicRecursive.prototype.start = function () {\n\t      var d = new SingleAssignmentDisposable();\n\t      this._cancel = d;\n\t      d.setDisposable(this._scheduler.scheduleRecursiveFuture(0, this._period, createTick(this)));\n\t\n\t      return d;\n\t    };\n\t\n\t    return SchedulePeriodicRecursive;\n\t  }());\n\t\n\t  /** Gets a scheduler that schedules work immediately on the current thread. */\n\t   var ImmediateScheduler = (function (__super__) {\n\t    inherits(ImmediateScheduler, __super__);\n\t    function ImmediateScheduler() {\n\t      __super__.call(this);\n\t    }\n\t\n\t    ImmediateScheduler.prototype.schedule = function (state, action) {\n\t      return disposableFixup(action(this, state));\n\t    };\n\t\n\t    return ImmediateScheduler;\n\t  }(Scheduler));\n\t\n\t  var immediateScheduler = Scheduler.immediate = new ImmediateScheduler();\n\t\n\t  /**\n\t   * Gets a scheduler that schedules work as soon as possible on the current thread.\n\t   */\n\t  var CurrentThreadScheduler = (function (__super__) {\n\t    var queue;\n\t\n\t    function runTrampoline () {\n\t      while (queue.length > 0) {\n\t        var item = queue.dequeue();\n\t        !item.isCancelled() && item.invoke();\n\t      }\n\t    }\n\t\n\t    inherits(CurrentThreadScheduler, __super__);\n\t    function CurrentThreadScheduler() {\n\t      __super__.call(this);\n\t    }\n\t\n\t    CurrentThreadScheduler.prototype.schedule = function (state, action) {\n\t      var si = new ScheduledItem(this, state, action, this.now());\n\t\n\t      if (!queue) {\n\t        queue = new PriorityQueue(4);\n\t        queue.enqueue(si);\n\t\n\t        var result = tryCatch(runTrampoline)();\n\t        queue = null;\n\t        if (result === errorObj) { thrower(result.e); }\n\t      } else {\n\t        queue.enqueue(si);\n\t      }\n\t      return si.disposable;\n\t    };\n\t\n\t    CurrentThreadScheduler.prototype.scheduleRequired = function () { return !queue; };\n\t\n\t    return CurrentThreadScheduler;\n\t  }(Scheduler));\n\t\n\t  var currentThreadScheduler = Scheduler.currentThread = new CurrentThreadScheduler();\n\t\n\t  var scheduleMethod, clearMethod;\n\t\n\t  var localTimer = (function () {\n\t    var localSetTimeout, localClearTimeout = noop;\n\t    if (!!root.setTimeout) {\n\t      localSetTimeout = root.setTimeout;\n\t      localClearTimeout = root.clearTimeout;\n\t    } else if (!!root.WScript) {\n\t      localSetTimeout = function (fn, time) {\n\t        root.WScript.Sleep(time);\n\t        fn();\n\t      };\n\t    } else {\n\t      throw new NotSupportedError();\n\t    }\n\t\n\t    return {\n\t      setTimeout: localSetTimeout,\n\t      clearTimeout: localClearTimeout\n\t    };\n\t  }());\n\t  var localSetTimeout = localTimer.setTimeout,\n\t    localClearTimeout = localTimer.clearTimeout;\n\t\n\t  (function () {\n\t\n\t    var nextHandle = 1, tasksByHandle = {}, currentlyRunning = false;\n\t\n\t    clearMethod = function (handle) {\n\t      delete tasksByHandle[handle];\n\t    };\n\t\n\t    function runTask(handle) {\n\t      if (currentlyRunning) {\n\t        localSetTimeout(function () { runTask(handle); }, 0);\n\t      } else {\n\t        var task = tasksByHandle[handle];\n\t        if (task) {\n\t          currentlyRunning = true;\n\t          var result = tryCatch(task)();\n\t          clearMethod(handle);\n\t          currentlyRunning = false;\n\t          if (result === errorObj) { thrower(result.e); }\n\t        }\n\t      }\n\t    }\n\t\n\t    var reNative = new RegExp('^' +\n\t      String(toString)\n\t        .replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')\n\t        .replace(/toString| for [^\\]]+/g, '.*?') + '$'\n\t    );\n\t\n\t    var setImmediate = typeof (setImmediate = freeGlobal && moduleExports && freeGlobal.setImmediate) == 'function' &&\n\t      !reNative.test(setImmediate) && setImmediate;\n\t\n\t    function postMessageSupported () {\n\t      // Ensure not in a worker\n\t      if (!root.postMessage || root.importScripts) { return false; }\n\t      var isAsync = false, oldHandler = root.onmessage;\n\t      // Test for async\n\t      root.onmessage = function () { isAsync = true; };\n\t      root.postMessage('', '*');\n\t      root.onmessage = oldHandler;\n\t\n\t      return isAsync;\n\t    }\n\t\n\t    // Use in order, setImmediate, nextTick, postMessage, MessageChannel, script readystatechanged, setTimeout\n\t    if (isFunction(setImmediate)) {\n\t      scheduleMethod = function (action) {\n\t        var id = nextHandle++;\n\t        tasksByHandle[id] = action;\n\t        setImmediate(function () { runTask(id); });\n\t\n\t        return id;\n\t      };\n\t    } else if (typeof process !== 'undefined' && {}.toString.call(process) === '[object process]') {\n\t      scheduleMethod = function (action) {\n\t        var id = nextHandle++;\n\t        tasksByHandle[id] = action;\n\t        process.nextTick(function () { runTask(id); });\n\t\n\t        return id;\n\t      };\n\t    } else if (postMessageSupported()) {\n\t      var MSG_PREFIX = 'ms.rx.schedule' + Math.random();\n\t\n\t      var onGlobalPostMessage = function (event) {\n\t        // Only if we're a match to avoid any other global events\n\t        if (typeof event.data === 'string' && event.data.substring(0, MSG_PREFIX.length) === MSG_PREFIX) {\n\t          runTask(event.data.substring(MSG_PREFIX.length));\n\t        }\n\t      };\n\t\n\t      root.addEventListener('message', onGlobalPostMessage, false);\n\t\n\t      scheduleMethod = function (action) {\n\t        var id = nextHandle++;\n\t        tasksByHandle[id] = action;\n\t        root.postMessage(MSG_PREFIX + currentId, '*');\n\t        return id;\n\t      };\n\t    } else if (!!root.MessageChannel) {\n\t      var channel = new root.MessageChannel();\n\t\n\t      channel.port1.onmessage = function (e) { runTask(e.data); };\n\t\n\t      scheduleMethod = function (action) {\n\t        var id = nextHandle++;\n\t        tasksByHandle[id] = action;\n\t        channel.port2.postMessage(id);\n\t        return id;\n\t      };\n\t    } else if ('document' in root && 'onreadystatechange' in root.document.createElement('script')) {\n\t\n\t      scheduleMethod = function (action) {\n\t        var scriptElement = root.document.createElement('script');\n\t        var id = nextHandle++;\n\t        tasksByHandle[id] = action;\n\t\n\t        scriptElement.onreadystatechange = function () {\n\t          runTask(id);\n\t          scriptElement.onreadystatechange = null;\n\t          scriptElement.parentNode.removeChild(scriptElement);\n\t          scriptElement = null;\n\t        };\n\t        root.document.documentElement.appendChild(scriptElement);\n\t        return id;\n\t      };\n\t\n\t    } else {\n\t      scheduleMethod = function (action) {\n\t        var id = nextHandle++;\n\t        tasksByHandle[id] = action;\n\t        localSetTimeout(function () {\n\t          runTask(id);\n\t        }, 0);\n\t\n\t        return id;\n\t      };\n\t    }\n\t  }());\n\t\n\t  /**\n\t   * Gets a scheduler that schedules work via a timed callback based upon platform.\n\t   */\n\t   var DefaultScheduler = (function (__super__) {\n\t     inherits(DefaultScheduler, __super__);\n\t     function DefaultScheduler() {\n\t       __super__.call(this);\n\t     }\n\t\n\t     function scheduleAction(disposable, action, scheduler, state) {\n\t       return function schedule() {\n\t         disposable.setDisposable(Disposable._fixup(action(scheduler, state)));\n\t       };\n\t     }\n\t\n\t     function ClearDisposable(id) {\n\t       this._id = id;\n\t       this.isDisposed = false;\n\t     }\n\t\n\t     ClearDisposable.prototype.dispose = function () {\n\t       if (!this.isDisposed) {\n\t         this.isDisposed = true;\n\t         clearMethod(this._id);\n\t       }\n\t     };\n\t\n\t     function LocalClearDisposable(id) {\n\t       this._id = id;\n\t       this.isDisposed = false;\n\t     }\n\t\n\t     LocalClearDisposable.prototype.dispose = function () {\n\t       if (!this.isDisposed) {\n\t         this.isDisposed = true;\n\t         localClearTimeout(this._id);\n\t       }\n\t     };\n\t\n\t    DefaultScheduler.prototype.schedule = function (state, action) {\n\t      var disposable = new SingleAssignmentDisposable(),\n\t          id = scheduleMethod(scheduleAction(disposable, action, this, state));\n\t      return new BinaryDisposable(disposable, new ClearDisposable(id));\n\t    };\n\t\n\t    DefaultScheduler.prototype._scheduleFuture = function (state, dueTime, action) {\n\t      if (dueTime === 0) { return this.schedule(state, action); }\n\t      var disposable = new SingleAssignmentDisposable(),\n\t          id = localSetTimeout(scheduleAction(disposable, action, this, state), dueTime);\n\t      return new BinaryDisposable(disposable, new LocalClearDisposable(id));\n\t    };\n\t\n\t    return DefaultScheduler;\n\t  }(Scheduler));\n\t\n\t  var defaultScheduler = Scheduler['default'] = Scheduler.async = new DefaultScheduler();\n\t\n\t  var CatchScheduler = (function (__super__) {\n\t    inherits(CatchScheduler, __super__);\n\t\n\t    function CatchScheduler(scheduler, handler) {\n\t      this._scheduler = scheduler;\n\t      this._handler = handler;\n\t      this._recursiveOriginal = null;\n\t      this._recursiveWrapper = null;\n\t      __super__.call(this);\n\t    }\n\t\n\t    CatchScheduler.prototype.schedule = function (state, action) {\n\t      return this._scheduler.schedule(state, this._wrap(action));\n\t    };\n\t\n\t    CatchScheduler.prototype._scheduleFuture = function (state, dueTime, action) {\n\t      return this._scheduler.schedule(state, dueTime, this._wrap(action));\n\t    };\n\t\n\t    CatchScheduler.prototype.now = function () { return this._scheduler.now(); };\n\t\n\t    CatchScheduler.prototype._clone = function (scheduler) {\n\t        return new CatchScheduler(scheduler, this._handler);\n\t    };\n\t\n\t    CatchScheduler.prototype._wrap = function (action) {\n\t      var parent = this;\n\t      return function (self, state) {\n\t        var res = tryCatch(action)(parent._getRecursiveWrapper(self), state);\n\t        if (res === errorObj) {\n\t          if (!parent._handler(res.e)) { thrower(res.e); }\n\t          return disposableEmpty;\n\t        }\n\t        return disposableFixup(res);\n\t      };\n\t    };\n\t\n\t    CatchScheduler.prototype._getRecursiveWrapper = function (scheduler) {\n\t      if (this._recursiveOriginal !== scheduler) {\n\t        this._recursiveOriginal = scheduler;\n\t        var wrapper = this._clone(scheduler);\n\t        wrapper._recursiveOriginal = scheduler;\n\t        wrapper._recursiveWrapper = wrapper;\n\t        this._recursiveWrapper = wrapper;\n\t      }\n\t      return this._recursiveWrapper;\n\t    };\n\t\n\t    CatchScheduler.prototype.schedulePeriodic = function (state, period, action) {\n\t      var self = this, failed = false, d = new SingleAssignmentDisposable();\n\t\n\t      d.setDisposable(this._scheduler.schedulePeriodic(state, period, function (state1) {\n\t        if (failed) { return null; }\n\t        var res = tryCatch(action)(state1);\n\t        if (res === errorObj) {\n\t          failed = true;\n\t          if (!self._handler(res.e)) { thrower(res.e); }\n\t          d.dispose();\n\t          return null;\n\t        }\n\t        return res;\n\t      }));\n\t\n\t      return d;\n\t    };\n\t\n\t    return CatchScheduler;\n\t  }(Scheduler));\n\t\n\t  /**\n\t   *  Represents a notification to an observer.\n\t   */\n\t  var Notification = Rx.Notification = (function () {\n\t    function Notification() {\n\t\n\t    }\n\t\n\t    Notification.prototype._accept = function (onNext, onError, onCompleted) {\n\t      throw new NotImplementedError();\n\t    };\n\t\n\t    Notification.prototype._acceptObserver = function (onNext, onError, onCompleted) {\n\t      throw new NotImplementedError();\n\t    };\n\t\n\t    /**\n\t     * Invokes the delegate corresponding to the notification or the observer's method corresponding to the notification and returns the produced result.\n\t     * @param {Function | Observer} observerOrOnNext Function to invoke for an OnNext notification or Observer to invoke the notification on..\n\t     * @param {Function} onError Function to invoke for an OnError notification.\n\t     * @param {Function} onCompleted Function to invoke for an OnCompleted notification.\n\t     * @returns {Any} Result produced by the observation.\n\t     */\n\t    Notification.prototype.accept = function (observerOrOnNext, onError, onCompleted) {\n\t      return observerOrOnNext && typeof observerOrOnNext === 'object' ?\n\t        this._acceptObserver(observerOrOnNext) :\n\t        this._accept(observerOrOnNext, onError, onCompleted);\n\t    };\n\t\n\t    /**\n\t     * Returns an observable sequence with a single notification.\n\t     *\n\t     * @memberOf Notifications\n\t     * @param {Scheduler} [scheduler] Scheduler to send out the notification calls on.\n\t     * @returns {Observable} The observable sequence that surfaces the behavior of the notification upon subscription.\n\t     */\n\t    Notification.prototype.toObservable = function (scheduler) {\n\t      var self = this;\n\t      isScheduler(scheduler) || (scheduler = immediateScheduler);\n\t      return new AnonymousObservable(function (o) {\n\t        return scheduler.schedule(self, function (_, notification) {\n\t          notification._acceptObserver(o);\n\t          notification.kind === 'N' && o.onCompleted();\n\t        });\n\t      });\n\t    };\n\t\n\t    return Notification;\n\t  })();\n\t\n\t  var OnNextNotification = (function (__super__) {\n\t    inherits(OnNextNotification, __super__);\n\t    function OnNextNotification(value) {\n\t      this.value = value;\n\t      this.kind = 'N';\n\t    }\n\t\n\t    OnNextNotification.prototype._accept = function (onNext) {\n\t      return onNext(this.value);\n\t    };\n\t\n\t    OnNextNotification.prototype._acceptObserver = function (o) {\n\t      return o.onNext(this.value);\n\t    };\n\t\n\t    OnNextNotification.prototype.toString = function () {\n\t      return 'OnNext(' + this.value + ')';\n\t    };\n\t\n\t    return OnNextNotification;\n\t  }(Notification));\n\t\n\t  var OnErrorNotification = (function (__super__) {\n\t    inherits(OnErrorNotification, __super__);\n\t    function OnErrorNotification(error) {\n\t      this.error = error;\n\t      this.kind = 'E';\n\t    }\n\t\n\t    OnErrorNotification.prototype._accept = function (onNext, onError) {\n\t      return onError(this.error);\n\t    };\n\t\n\t    OnErrorNotification.prototype._acceptObserver = function (o) {\n\t      return o.onError(this.error);\n\t    };\n\t\n\t    OnErrorNotification.prototype.toString = function () {\n\t      return 'OnError(' + this.error + ')';\n\t    };\n\t\n\t    return OnErrorNotification;\n\t  }(Notification));\n\t\n\t  var OnCompletedNotification = (function (__super__) {\n\t    inherits(OnCompletedNotification, __super__);\n\t    function OnCompletedNotification() {\n\t      this.kind = 'C';\n\t    }\n\t\n\t    OnCompletedNotification.prototype._accept = function (onNext, onError, onCompleted) {\n\t      return onCompleted();\n\t    };\n\t\n\t    OnCompletedNotification.prototype._acceptObserver = function (o) {\n\t      return o.onCompleted();\n\t    };\n\t\n\t    OnCompletedNotification.prototype.toString = function () {\n\t      return 'OnCompleted()';\n\t    };\n\t\n\t    return OnCompletedNotification;\n\t  }(Notification));\n\t\n\t  /**\n\t   * Creates an object that represents an OnNext notification to an observer.\n\t   * @param {Any} value The value contained in the notification.\n\t   * @returns {Notification} The OnNext notification containing the value.\n\t   */\n\t  var notificationCreateOnNext = Notification.createOnNext = function (value) {\n\t    return new OnNextNotification(value);\n\t  };\n\t\n\t  /**\n\t   * Creates an object that represents an OnError notification to an observer.\n\t   * @param {Any} error The exception contained in the notification.\n\t   * @returns {Notification} The OnError notification containing the exception.\n\t   */\n\t  var notificationCreateOnError = Notification.createOnError = function (error) {\n\t    return new OnErrorNotification(error);\n\t  };\n\t\n\t  /**\n\t   * Creates an object that represents an OnCompleted notification to an observer.\n\t   * @returns {Notification} The OnCompleted notification.\n\t   */\n\t  var notificationCreateOnCompleted = Notification.createOnCompleted = function () {\n\t    return new OnCompletedNotification();\n\t  };\n\t\n\t  /**\n\t   * Supports push-style iteration over an observable sequence.\n\t   */\n\t  var Observer = Rx.Observer = function () { };\n\t\n\t  /**\n\t   *  Creates a notification callback from an observer.\n\t   * @returns The action that forwards its input notification to the underlying observer.\n\t   */\n\t  Observer.prototype.toNotifier = function () {\n\t    var observer = this;\n\t    return function (n) { return n.accept(observer); };\n\t  };\n\t\n\t  /**\n\t   *  Hides the identity of an observer.\n\t   * @returns An observer that hides the identity of the specified observer.\n\t   */\n\t  Observer.prototype.asObserver = function () {\n\t    var self = this;\n\t    return new AnonymousObserver(\n\t      function (x) { self.onNext(x); },\n\t      function (err) { self.onError(err); },\n\t      function () { self.onCompleted(); });\n\t  };\n\t\n\t  /**\n\t   *  Checks access to the observer for grammar violations. This includes checking for multiple OnError or OnCompleted calls, as well as reentrancy in any of the observer methods.\n\t   *  If a violation is detected, an Error is thrown from the offending observer method call.\n\t   * @returns An observer that checks callbacks invocations against the observer grammar and, if the checks pass, forwards those to the specified observer.\n\t   */\n\t  Observer.prototype.checked = function () { return new CheckedObserver(this); };\n\t\n\t  /**\n\t   *  Creates an observer from the specified OnNext, along with optional OnError, and OnCompleted actions.\n\t   * @param {Function} [onNext] Observer's OnNext action implementation.\n\t   * @param {Function} [onError] Observer's OnError action implementation.\n\t   * @param {Function} [onCompleted] Observer's OnCompleted action implementation.\n\t   * @returns {Observer} The observer object implemented using the given actions.\n\t   */\n\t  var observerCreate = Observer.create = function (onNext, onError, onCompleted) {\n\t    onNext || (onNext = noop);\n\t    onError || (onError = defaultError);\n\t    onCompleted || (onCompleted = noop);\n\t    return new AnonymousObserver(onNext, onError, onCompleted);\n\t  };\n\t\n\t  /**\n\t   *  Creates an observer from a notification callback.\n\t   * @param {Function} handler Action that handles a notification.\n\t   * @returns The observer object that invokes the specified handler using a notification corresponding to each message it receives.\n\t   */\n\t  Observer.fromNotifier = function (handler, thisArg) {\n\t    var cb = bindCallback(handler, thisArg, 1);\n\t    return new AnonymousObserver(function (x) {\n\t      return cb(notificationCreateOnNext(x));\n\t    }, function (e) {\n\t      return cb(notificationCreateOnError(e));\n\t    }, function () {\n\t      return cb(notificationCreateOnCompleted());\n\t    });\n\t  };\n\t\n\t  /**\n\t   * Schedules the invocation of observer methods on the given scheduler.\n\t   * @param {Scheduler} scheduler Scheduler to schedule observer messages on.\n\t   * @returns {Observer} Observer whose messages are scheduled on the given scheduler.\n\t   */\n\t  Observer.prototype.notifyOn = function (scheduler) {\n\t    return new ObserveOnObserver(scheduler, this);\n\t  };\n\t\n\t  Observer.prototype.makeSafe = function(disposable) {\n\t    return new AnonymousSafeObserver(this._onNext, this._onError, this._onCompleted, disposable);\n\t  };\n\t\n\t  /**\n\t   * Abstract base class for implementations of the Observer class.\n\t   * This base class enforces the grammar of observers where OnError and OnCompleted are terminal messages.\n\t   */\n\t  var AbstractObserver = Rx.internals.AbstractObserver = (function (__super__) {\n\t    inherits(AbstractObserver, __super__);\n\t\n\t    /**\n\t     * Creates a new observer in a non-stopped state.\n\t     */\n\t    function AbstractObserver() {\n\t      this.isStopped = false;\n\t    }\n\t\n\t    // Must be implemented by other observers\n\t    AbstractObserver.prototype.next = notImplemented;\n\t    AbstractObserver.prototype.error = notImplemented;\n\t    AbstractObserver.prototype.completed = notImplemented;\n\t\n\t    /**\n\t     * Notifies the observer of a new element in the sequence.\n\t     * @param {Any} value Next element in the sequence.\n\t     */\n\t    AbstractObserver.prototype.onNext = function (value) {\n\t      !this.isStopped && this.next(value);\n\t    };\n\t\n\t    /**\n\t     * Notifies the observer that an exception has occurred.\n\t     * @param {Any} error The error that has occurred.\n\t     */\n\t    AbstractObserver.prototype.onError = function (error) {\n\t      if (!this.isStopped) {\n\t        this.isStopped = true;\n\t        this.error(error);\n\t      }\n\t    };\n\t\n\t    /**\n\t     * Notifies the observer of the end of the sequence.\n\t     */\n\t    AbstractObserver.prototype.onCompleted = function () {\n\t      if (!this.isStopped) {\n\t        this.isStopped = true;\n\t        this.completed();\n\t      }\n\t    };\n\t\n\t    /**\n\t     * Disposes the observer, causing it to transition to the stopped state.\n\t     */\n\t    AbstractObserver.prototype.dispose = function () { this.isStopped = true; };\n\t\n\t    AbstractObserver.prototype.fail = function (e) {\n\t      if (!this.isStopped) {\n\t        this.isStopped = true;\n\t        this.error(e);\n\t        return true;\n\t      }\n\t\n\t      return false;\n\t    };\n\t\n\t    return AbstractObserver;\n\t  }(Observer));\n\t\n\t  /**\n\t   * Class to create an Observer instance from delegate-based implementations of the on* methods.\n\t   */\n\t  var AnonymousObserver = Rx.AnonymousObserver = (function (__super__) {\n\t    inherits(AnonymousObserver, __super__);\n\t\n\t    /**\n\t     * Creates an observer from the specified OnNext, OnError, and OnCompleted actions.\n\t     * @param {Any} onNext Observer's OnNext action implementation.\n\t     * @param {Any} onError Observer's OnError action implementation.\n\t     * @param {Any} onCompleted Observer's OnCompleted action implementation.\n\t     */\n\t    function AnonymousObserver(onNext, onError, onCompleted) {\n\t      __super__.call(this);\n\t      this._onNext = onNext;\n\t      this._onError = onError;\n\t      this._onCompleted = onCompleted;\n\t    }\n\t\n\t    /**\n\t     * Calls the onNext action.\n\t     * @param {Any} value Next element in the sequence.\n\t     */\n\t    AnonymousObserver.prototype.next = function (value) {\n\t      this._onNext(value);\n\t    };\n\t\n\t    /**\n\t     * Calls the onError action.\n\t     * @param {Any} error The error that has occurred.\n\t     */\n\t    AnonymousObserver.prototype.error = function (error) {\n\t      this._onError(error);\n\t    };\n\t\n\t    /**\n\t     *  Calls the onCompleted action.\n\t     */\n\t    AnonymousObserver.prototype.completed = function () {\n\t      this._onCompleted();\n\t    };\n\t\n\t    return AnonymousObserver;\n\t  }(AbstractObserver));\n\t\n\t  var CheckedObserver = (function (__super__) {\n\t    inherits(CheckedObserver, __super__);\n\t\n\t    function CheckedObserver(observer) {\n\t      __super__.call(this);\n\t      this._observer = observer;\n\t      this._state = 0; // 0 - idle, 1 - busy, 2 - done\n\t    }\n\t\n\t    var CheckedObserverPrototype = CheckedObserver.prototype;\n\t\n\t    CheckedObserverPrototype.onNext = function (value) {\n\t      this.checkAccess();\n\t      var res = tryCatch(this._observer.onNext).call(this._observer, value);\n\t      this._state = 0;\n\t      res === errorObj && thrower(res.e);\n\t    };\n\t\n\t    CheckedObserverPrototype.onError = function (err) {\n\t      this.checkAccess();\n\t      var res = tryCatch(this._observer.onError).call(this._observer, err);\n\t      this._state = 2;\n\t      res === errorObj && thrower(res.e);\n\t    };\n\t\n\t    CheckedObserverPrototype.onCompleted = function () {\n\t      this.checkAccess();\n\t      var res = tryCatch(this._observer.onCompleted).call(this._observer);\n\t      this._state = 2;\n\t      res === errorObj && thrower(res.e);\n\t    };\n\t\n\t    CheckedObserverPrototype.checkAccess = function () {\n\t      if (this._state === 1) { throw new Error('Re-entrancy detected'); }\n\t      if (this._state === 2) { throw new Error('Observer completed'); }\n\t      if (this._state === 0) { this._state = 1; }\n\t    };\n\t\n\t    return CheckedObserver;\n\t  }(Observer));\n\t\n\t  var ScheduledObserver = Rx.internals.ScheduledObserver = (function (__super__) {\n\t    inherits(ScheduledObserver, __super__);\n\t\n\t    function ScheduledObserver(scheduler, observer) {\n\t      __super__.call(this);\n\t      this.scheduler = scheduler;\n\t      this.observer = observer;\n\t      this.isAcquired = false;\n\t      this.hasFaulted = false;\n\t      this.queue = [];\n\t      this.disposable = new SerialDisposable();\n\t    }\n\t\n\t    function enqueueNext(observer, x) { return function () { observer.onNext(x); }; }\n\t    function enqueueError(observer, e) { return function () { observer.onError(e); }; }\n\t    function enqueueCompleted(observer) { return function () { observer.onCompleted(); }; }\n\t\n\t    ScheduledObserver.prototype.next = function (x) {\n\t      this.queue.push(enqueueNext(this.observer, x));\n\t    };\n\t\n\t    ScheduledObserver.prototype.error = function (e) {\n\t      this.queue.push(enqueueError(this.observer, e));\n\t    };\n\t\n\t    ScheduledObserver.prototype.completed = function () {\n\t      this.queue.push(enqueueCompleted(this.observer));\n\t    };\n\t\n\t\n\t    function scheduleMethod(state, recurse) {\n\t      var work;\n\t      if (state.queue.length > 0) {\n\t        work = state.queue.shift();\n\t      } else {\n\t        state.isAcquired = false;\n\t        return;\n\t      }\n\t      var res = tryCatch(work)();\n\t      if (res === errorObj) {\n\t        state.queue = [];\n\t        state.hasFaulted = true;\n\t        return thrower(res.e);\n\t      }\n\t      recurse(state);\n\t    }\n\t\n\t    ScheduledObserver.prototype.ensureActive = function () {\n\t      var isOwner = false;\n\t      if (!this.hasFaulted && this.queue.length > 0) {\n\t        isOwner = !this.isAcquired;\n\t        this.isAcquired = true;\n\t      }\n\t      isOwner &&\n\t        this.disposable.setDisposable(this.scheduler.scheduleRecursive(this, scheduleMethod));\n\t    };\n\t\n\t    ScheduledObserver.prototype.dispose = function () {\n\t      __super__.prototype.dispose.call(this);\n\t      this.disposable.dispose();\n\t    };\n\t\n\t    return ScheduledObserver;\n\t  }(AbstractObserver));\n\t\n\t  var ObserveOnObserver = (function (__super__) {\n\t    inherits(ObserveOnObserver, __super__);\n\t\n\t    function ObserveOnObserver(scheduler, observer, cancel) {\n\t      __super__.call(this, scheduler, observer);\n\t      this._cancel = cancel;\n\t    }\n\t\n\t    ObserveOnObserver.prototype.next = function (value) {\n\t      __super__.prototype.next.call(this, value);\n\t      this.ensureActive();\n\t    };\n\t\n\t    ObserveOnObserver.prototype.error = function (e) {\n\t      __super__.prototype.error.call(this, e);\n\t      this.ensureActive();\n\t    };\n\t\n\t    ObserveOnObserver.prototype.completed = function () {\n\t      __super__.prototype.completed.call(this);\n\t      this.ensureActive();\n\t    };\n\t\n\t    ObserveOnObserver.prototype.dispose = function () {\n\t      __super__.prototype.dispose.call(this);\n\t      this._cancel && this._cancel.dispose();\n\t      this._cancel = null;\n\t    };\n\t\n\t    return ObserveOnObserver;\n\t  })(ScheduledObserver);\n\t\n\t  var observableProto;\n\t\n\t  /**\n\t   * Represents a push-style collection.\n\t   */\n\t  var Observable = Rx.Observable = (function () {\n\t\n\t    function makeSubscribe(self, subscribe) {\n\t      return function (o) {\n\t        var oldOnError = o.onError;\n\t        o.onError = function (e) {\n\t          makeStackTraceLong(e, self);\n\t          oldOnError.call(o, e);\n\t        };\n\t\n\t        return subscribe.call(self, o);\n\t      };\n\t    }\n\t\n\t    function Observable() {\n\t      if (Rx.config.longStackSupport && hasStacks) {\n\t        var oldSubscribe = this._subscribe;\n\t        var e = tryCatch(thrower)(new Error()).e;\n\t        this.stack = e.stack.substring(e.stack.indexOf('\\n') + 1);\n\t        this._subscribe = makeSubscribe(this, oldSubscribe);\n\t      }\n\t    }\n\t\n\t    observableProto = Observable.prototype;\n\t\n\t    /**\n\t    * Determines whether the given object is an Observable\n\t    * @param {Any} An object to determine whether it is an Observable\n\t    * @returns {Boolean} true if an Observable, else false.\n\t    */\n\t    Observable.isObservable = function (o) {\n\t      return o && isFunction(o.subscribe);\n\t    };\n\t\n\t    /**\n\t     *  Subscribes an o to the observable sequence.\n\t     *  @param {Mixed} [oOrOnNext] The object that is to receive notifications or an action to invoke for each element in the observable sequence.\n\t     *  @param {Function} [onError] Action to invoke upon exceptional termination of the observable sequence.\n\t     *  @param {Function} [onCompleted] Action to invoke upon graceful termination of the observable sequence.\n\t     *  @returns {Diposable} A disposable handling the subscriptions and unsubscriptions.\n\t     */\n\t    observableProto.subscribe = observableProto.forEach = function (oOrOnNext, onError, onCompleted) {\n\t      return this._subscribe(typeof oOrOnNext === 'object' ?\n\t        oOrOnNext :\n\t        observerCreate(oOrOnNext, onError, onCompleted));\n\t    };\n\t\n\t    /**\n\t     * Subscribes to the next value in the sequence with an optional \"this\" argument.\n\t     * @param {Function} onNext The function to invoke on each element in the observable sequence.\n\t     * @param {Any} [thisArg] Object to use as this when executing callback.\n\t     * @returns {Disposable} A disposable handling the subscriptions and unsubscriptions.\n\t     */\n\t    observableProto.subscribeOnNext = function (onNext, thisArg) {\n\t      return this._subscribe(observerCreate(typeof thisArg !== 'undefined' ? function(x) { onNext.call(thisArg, x); } : onNext));\n\t    };\n\t\n\t    /**\n\t     * Subscribes to an exceptional condition in the sequence with an optional \"this\" argument.\n\t     * @param {Function} onError The function to invoke upon exceptional termination of the observable sequence.\n\t     * @param {Any} [thisArg] Object to use as this when executing callback.\n\t     * @returns {Disposable} A disposable handling the subscriptions and unsubscriptions.\n\t     */\n\t    observableProto.subscribeOnError = function (onError, thisArg) {\n\t      return this._subscribe(observerCreate(null, typeof thisArg !== 'undefined' ? function(e) { onError.call(thisArg, e); } : onError));\n\t    };\n\t\n\t    /**\n\t     * Subscribes to the next value in the sequence with an optional \"this\" argument.\n\t     * @param {Function} onCompleted The function to invoke upon graceful termination of the observable sequence.\n\t     * @param {Any} [thisArg] Object to use as this when executing callback.\n\t     * @returns {Disposable} A disposable handling the subscriptions and unsubscriptions.\n\t     */\n\t    observableProto.subscribeOnCompleted = function (onCompleted, thisArg) {\n\t      return this._subscribe(observerCreate(null, null, typeof thisArg !== 'undefined' ? function() { onCompleted.call(thisArg); } : onCompleted));\n\t    };\n\t\n\t    return Observable;\n\t  })();\n\t\n\t  var ObservableBase = Rx.ObservableBase = (function (__super__) {\n\t    inherits(ObservableBase, __super__);\n\t\n\t    function fixSubscriber(subscriber) {\n\t      return subscriber && isFunction(subscriber.dispose) ? subscriber :\n\t        isFunction(subscriber) ? disposableCreate(subscriber) : disposableEmpty;\n\t    }\n\t\n\t    function setDisposable(s, state) {\n\t      var ado = state[0], self = state[1];\n\t      var sub = tryCatch(self.subscribeCore).call(self, ado);\n\t      if (sub === errorObj && !ado.fail(errorObj.e)) { thrower(errorObj.e); }\n\t      ado.setDisposable(fixSubscriber(sub));\n\t    }\n\t\n\t    function ObservableBase() {\n\t      __super__.call(this);\n\t    }\n\t\n\t    ObservableBase.prototype._subscribe = function (o) {\n\t      var ado = new AutoDetachObserver(o), state = [ado, this];\n\t\n\t      if (currentThreadScheduler.scheduleRequired()) {\n\t        currentThreadScheduler.schedule(state, setDisposable);\n\t      } else {\n\t        setDisposable(null, state);\n\t      }\n\t      return ado;\n\t    };\n\t\n\t    ObservableBase.prototype.subscribeCore = notImplemented;\n\t\n\t    return ObservableBase;\n\t  }(Observable));\n\t\n\tvar FlatMapObservable = Rx.FlatMapObservable = (function(__super__) {\n\t\n\t    inherits(FlatMapObservable, __super__);\n\t\n\t    function FlatMapObservable(source, selector, resultSelector, thisArg) {\n\t      this.resultSelector = isFunction(resultSelector) ? resultSelector : null;\n\t      this.selector = bindCallback(isFunction(selector) ? selector : function() { return selector; }, thisArg, 3);\n\t      this.source = source;\n\t      __super__.call(this);\n\t    }\n\t\n\t    FlatMapObservable.prototype.subscribeCore = function(o) {\n\t      return this.source.subscribe(new InnerObserver(o, this.selector, this.resultSelector, this));\n\t    };\n\t\n\t    inherits(InnerObserver, AbstractObserver);\n\t    function InnerObserver(observer, selector, resultSelector, source) {\n\t      this.i = 0;\n\t      this.selector = selector;\n\t      this.resultSelector = resultSelector;\n\t      this.source = source;\n\t      this.o = observer;\n\t      AbstractObserver.call(this);\n\t    }\n\t\n\t    InnerObserver.prototype._wrapResult = function(result, x, i) {\n\t      return this.resultSelector ?\n\t        result.map(function(y, i2) { return this.resultSelector(x, y, i, i2); }, this) :\n\t        result;\n\t    };\n\t\n\t    InnerObserver.prototype.next = function(x) {\n\t      var i = this.i++;\n\t      var result = tryCatch(this.selector)(x, i, this.source);\n\t      if (result === errorObj) { return this.o.onError(result.e); }\n\t\n\t      isPromise(result) && (result = observableFromPromise(result));\n\t      (isArrayLike(result) || isIterable(result)) && (result = Observable.from(result));\n\t      this.o.onNext(this._wrapResult(result, x, i));\n\t    };\n\t\n\t    InnerObserver.prototype.error = function(e) { this.o.onError(e); };\n\t\n\t    InnerObserver.prototype.completed = function() { this.o.onCompleted(); };\n\t\n\t    return FlatMapObservable;\n\t\n\t}(ObservableBase));\n\t\n\t  var Enumerable = Rx.internals.Enumerable = function () { };\n\t\n\t  function IsDisposedDisposable(state) {\n\t    this._s = state;\n\t    this.isDisposed = false;\n\t  }\n\t\n\t  IsDisposedDisposable.prototype.dispose = function () {\n\t    if (!this.isDisposed) {\n\t      this.isDisposed = true;\n\t      this._s.isDisposed = true;\n\t    }\n\t  };\n\t\n\t  var ConcatEnumerableObservable = (function(__super__) {\n\t    inherits(ConcatEnumerableObservable, __super__);\n\t    function ConcatEnumerableObservable(sources) {\n\t      this.sources = sources;\n\t      __super__.call(this);\n\t    }\n\t\n\t    function scheduleMethod(state, recurse) {\n\t      if (state.isDisposed) { return; }\n\t      var currentItem = tryCatch(state.e.next).call(state.e);\n\t      if (currentItem === errorObj) { return state.o.onError(currentItem.e); }\n\t      if (currentItem.done) { return state.o.onCompleted(); }\n\t\n\t      // Check if promise\n\t      var currentValue = currentItem.value;\n\t      isPromise(currentValue) && (currentValue = observableFromPromise(currentValue));\n\t\n\t      var d = new SingleAssignmentDisposable();\n\t      state.subscription.setDisposable(d);\n\t      d.setDisposable(currentValue.subscribe(new InnerObserver(state, recurse)));\n\t    }\n\t\n\t    ConcatEnumerableObservable.prototype.subscribeCore = function (o) {\n\t      var subscription = new SerialDisposable();\n\t      var state = {\n\t        isDisposed: false,\n\t        o: o,\n\t        subscription: subscription,\n\t        e: this.sources[$iterator$]()\n\t      };\n\t\n\t      var cancelable = currentThreadScheduler.scheduleRecursive(state, scheduleMethod);\n\t      return new NAryDisposable([subscription, cancelable, new IsDisposedDisposable(state)]);\n\t    };\n\t\n\t    function InnerObserver(state, recurse) {\n\t      this._state = state;\n\t      this._recurse = recurse;\n\t      AbstractObserver.call(this);\n\t    }\n\t\n\t    inherits(InnerObserver, AbstractObserver);\n\t\n\t    InnerObserver.prototype.next = function (x) { this._state.o.onNext(x); };\n\t    InnerObserver.prototype.error = function (e) { this._state.o.onError(e); };\n\t    InnerObserver.prototype.completed = function () { this._recurse(this._state); };\n\t\n\t    return ConcatEnumerableObservable;\n\t  }(ObservableBase));\n\t\n\t  Enumerable.prototype.concat = function () {\n\t    return new ConcatEnumerableObservable(this);\n\t  };\n\t\n\t  var CatchErrorObservable = (function(__super__) {\n\t    function CatchErrorObservable(sources) {\n\t      this.sources = sources;\n\t      __super__.call(this);\n\t    }\n\t\n\t    inherits(CatchErrorObservable, __super__);\n\t\n\t    function scheduleMethod(state, recurse) {\n\t      if (state.isDisposed) { return; }\n\t      var currentItem = tryCatch(state.e.next).call(state.e);\n\t      if (currentItem === errorObj) { return state.o.onError(currentItem.e); }\n\t      if (currentItem.done) { return state.lastError !== null ? state.o.onError(state.lastError) : state.o.onCompleted(); }\n\t\n\t      var currentValue = currentItem.value;\n\t      isPromise(currentValue) && (currentValue = observableFromPromise(currentValue));\n\t\n\t      var d = new SingleAssignmentDisposable();\n\t      state.subscription.setDisposable(d);\n\t      d.setDisposable(currentValue.subscribe(new InnerObserver(state, recurse)));\n\t    }\n\t\n\t    CatchErrorObservable.prototype.subscribeCore = function (o) {\n\t      var subscription = new SerialDisposable();\n\t      var state = {\n\t        isDisposed: false,\n\t        e: this.sources[$iterator$](),\n\t        subscription: subscription,\n\t        lastError: null,\n\t        o: o\n\t      };\n\t\n\t      var cancelable = currentThreadScheduler.scheduleRecursive(state, scheduleMethod);\n\t      return new NAryDisposable([subscription, cancelable, new IsDisposedDisposable(state)]);\n\t    };\n\t\n\t    function InnerObserver(state, recurse) {\n\t      this._state = state;\n\t      this._recurse = recurse;\n\t      AbstractObserver.call(this);\n\t    }\n\t\n\t    inherits(InnerObserver, AbstractObserver);\n\t\n\t    InnerObserver.prototype.next = function (x) { this._state.o.onNext(x); };\n\t    InnerObserver.prototype.error = function (e) { this._state.lastError = e; this._recurse(this._state); };\n\t    InnerObserver.prototype.completed = function () { this._state.o.onCompleted(); };\n\t\n\t    return CatchErrorObservable;\n\t  }(ObservableBase));\n\t\n\t  Enumerable.prototype.catchError = function () {\n\t    return new CatchErrorObservable(this);\n\t  };\n\t\n\t  Enumerable.prototype.catchErrorWhen = function (notificationHandler) {\n\t    var sources = this;\n\t    return new AnonymousObservable(function (o) {\n\t      var exceptions = new Subject(),\n\t        notifier = new Subject(),\n\t        handled = notificationHandler(exceptions),\n\t        notificationDisposable = handled.subscribe(notifier);\n\t\n\t      var e = sources[$iterator$]();\n\t\n\t      var state = { isDisposed: false },\n\t        lastError,\n\t        subscription = new SerialDisposable();\n\t      var cancelable = currentThreadScheduler.scheduleRecursive(null, function (_, self) {\n\t        if (state.isDisposed) { return; }\n\t        var currentItem = tryCatch(e.next).call(e);\n\t        if (currentItem === errorObj) { return o.onError(currentItem.e); }\n\t\n\t        if (currentItem.done) {\n\t          if (lastError) {\n\t            o.onError(lastError);\n\t          } else {\n\t            o.onCompleted();\n\t          }\n\t          return;\n\t        }\n\t\n\t        // Check if promise\n\t        var currentValue = currentItem.value;\n\t        isPromise(currentValue) && (currentValue = observableFromPromise(currentValue));\n\t\n\t        var outer = new SingleAssignmentDisposable();\n\t        var inner = new SingleAssignmentDisposable();\n\t        subscription.setDisposable(new BinaryDisposable(inner, outer));\n\t        outer.setDisposable(currentValue.subscribe(\n\t          function(x) { o.onNext(x); },\n\t          function (exn) {\n\t            inner.setDisposable(notifier.subscribe(self, function(ex) {\n\t              o.onError(ex);\n\t            }, function() {\n\t              o.onCompleted();\n\t            }));\n\t\n\t            exceptions.onNext(exn);\n\t          },\n\t          function() { o.onCompleted(); }));\n\t      });\n\t\n\t      return new NAryDisposable([notificationDisposable, subscription, cancelable, new IsDisposedDisposable(state)]);\n\t    });\n\t  };\n\t\n\t  var RepeatEnumerable = (function (__super__) {\n\t    inherits(RepeatEnumerable, __super__);\n\t    function RepeatEnumerable(v, c) {\n\t      this.v = v;\n\t      this.c = c == null ? -1 : c;\n\t    }\n\t\n\t    RepeatEnumerable.prototype[$iterator$] = function () {\n\t      return new RepeatEnumerator(this);\n\t    };\n\t\n\t    function RepeatEnumerator(p) {\n\t      this.v = p.v;\n\t      this.l = p.c;\n\t    }\n\t\n\t    RepeatEnumerator.prototype.next = function () {\n\t      if (this.l === 0) { return doneEnumerator; }\n\t      if (this.l > 0) { this.l--; }\n\t      return { done: false, value: this.v };\n\t    };\n\t\n\t    return RepeatEnumerable;\n\t  }(Enumerable));\n\t\n\t  var enumerableRepeat = Enumerable.repeat = function (value, repeatCount) {\n\t    return new RepeatEnumerable(value, repeatCount);\n\t  };\n\t\n\t  var OfEnumerable = (function(__super__) {\n\t    inherits(OfEnumerable, __super__);\n\t    function OfEnumerable(s, fn, thisArg) {\n\t      this.s = s;\n\t      this.fn = fn ? bindCallback(fn, thisArg, 3) : null;\n\t    }\n\t    OfEnumerable.prototype[$iterator$] = function () {\n\t      return new OfEnumerator(this);\n\t    };\n\t\n\t    function OfEnumerator(p) {\n\t      this.i = -1;\n\t      this.s = p.s;\n\t      this.l = this.s.length;\n\t      this.fn = p.fn;\n\t    }\n\t\n\t    OfEnumerator.prototype.next = function () {\n\t     return ++this.i < this.l ?\n\t       { done: false, value: !this.fn ? this.s[this.i] : this.fn(this.s[this.i], this.i, this.s) } :\n\t       doneEnumerator;\n\t    };\n\t\n\t    return OfEnumerable;\n\t  }(Enumerable));\n\t\n\t  var enumerableOf = Enumerable.of = function (source, selector, thisArg) {\n\t    return new OfEnumerable(source, selector, thisArg);\n\t  };\n\t\n\tvar ObserveOnObservable = (function (__super__) {\n\t  inherits(ObserveOnObservable, __super__);\n\t  function ObserveOnObservable(source, s) {\n\t    this.source = source;\n\t    this._s = s;\n\t    __super__.call(this);\n\t  }\n\t\n\t  ObserveOnObservable.prototype.subscribeCore = function (o) {\n\t    return this.source.subscribe(new ObserveOnObserver(this._s, o));\n\t  };\n\t\n\t  return ObserveOnObservable;\n\t}(ObservableBase));\n\t\n\t   /**\n\t   *  Wraps the source sequence in order to run its observer callbacks on the specified scheduler.\n\t   *\n\t   *  This only invokes observer callbacks on a scheduler. In case the subscription and/or unsubscription actions have side-effects\n\t   *  that require to be run on a scheduler, use subscribeOn.\n\t   *\n\t   *  @param {Scheduler} scheduler Scheduler to notify observers on.\n\t   *  @returns {Observable} The source sequence whose observations happen on the specified scheduler.\n\t   */\n\t  observableProto.observeOn = function (scheduler) {\n\t    return new ObserveOnObservable(this, scheduler);\n\t  };\n\t\n\t  var SubscribeOnObservable = (function (__super__) {\n\t    inherits(SubscribeOnObservable, __super__);\n\t    function SubscribeOnObservable(source, s) {\n\t      this.source = source;\n\t      this._s = s;\n\t      __super__.call(this);\n\t    }\n\t\n\t    function scheduleMethod(scheduler, state) {\n\t      var source = state[0], d = state[1], o = state[2];\n\t      d.setDisposable(new ScheduledDisposable(scheduler, source.subscribe(o)));\n\t    }\n\t\n\t    SubscribeOnObservable.prototype.subscribeCore = function (o) {\n\t      var m = new SingleAssignmentDisposable(), d = new SerialDisposable();\n\t      d.setDisposable(m);\n\t      m.setDisposable(this._s.schedule([this.source, d, o], scheduleMethod));\n\t      return d;\n\t    };\n\t\n\t    return SubscribeOnObservable;\n\t  }(ObservableBase));\n\t\n\t   /**\n\t   *  Wraps the source sequence in order to run its subscription and unsubscription logic on the specified scheduler. This operation is not commonly used;\n\t   *  see the remarks section for more information on the distinction between subscribeOn and observeOn.\n\t\n\t   *  This only performs the side-effects of subscription and unsubscription on the specified scheduler. In order to invoke observer\n\t   *  callbacks on a scheduler, use observeOn.\n\t\n\t   *  @param {Scheduler} scheduler Scheduler to perform subscription and unsubscription actions on.\n\t   *  @returns {Observable} The source sequence whose subscriptions and unsubscriptions happen on the specified scheduler.\n\t   */\n\t  observableProto.subscribeOn = function (scheduler) {\n\t    return new SubscribeOnObservable(this, scheduler);\n\t  };\n\t\n\t  var FromPromiseObservable = (function(__super__) {\n\t    inherits(FromPromiseObservable, __super__);\n\t    function FromPromiseObservable(p, s) {\n\t      this._p = p;\n\t      this._s = s;\n\t      __super__.call(this);\n\t    }\n\t\n\t    function scheduleNext(s, state) {\n\t      var o = state[0], data = state[1];\n\t      o.onNext(data);\n\t      o.onCompleted();\n\t    }\n\t\n\t    function scheduleError(s, state) {\n\t      var o = state[0], err = state[1];\n\t      o.onError(err);\n\t    }\n\t\n\t    FromPromiseObservable.prototype.subscribeCore = function(o) {\n\t      var sad = new SingleAssignmentDisposable(), self = this;\n\t\n\t      this._p\n\t        .then(function (data) {\n\t          sad.setDisposable(self._s.schedule([o, data], scheduleNext));\n\t        }, function (err) {\n\t          sad.setDisposable(self._s.schedule([o, err], scheduleError));\n\t        });\n\t\n\t      return sad;\n\t    };\n\t\n\t    return FromPromiseObservable;\n\t  }(ObservableBase));\n\t\n\t  /**\n\t  * Converts a Promise to an Observable sequence\n\t  * @param {Promise} An ES6 Compliant promise.\n\t  * @returns {Observable} An Observable sequence which wraps the existing promise success and failure.\n\t  */\n\t  var observableFromPromise = Observable.fromPromise = function (promise, scheduler) {\n\t    scheduler || (scheduler = defaultScheduler);\n\t    return new FromPromiseObservable(promise, scheduler);\n\t  };\n\t\n\t  /*\n\t   * Converts an existing observable sequence to an ES6 Compatible Promise\n\t   * @example\n\t   * var promise = Rx.Observable.return(42).toPromise(RSVP.Promise);\n\t   *\n\t   * // With config\n\t   * Rx.config.Promise = RSVP.Promise;\n\t   * var promise = Rx.Observable.return(42).toPromise();\n\t   * @param {Function} [promiseCtor] The constructor of the promise. If not provided, it looks for it in Rx.config.Promise.\n\t   * @returns {Promise} An ES6 compatible promise with the last value from the observable sequence.\n\t   */\n\t  observableProto.toPromise = function (promiseCtor) {\n\t    promiseCtor || (promiseCtor = Rx.config.Promise);\n\t    if (!promiseCtor) { throw new NotSupportedError('Promise type not provided nor in Rx.config.Promise'); }\n\t    var source = this;\n\t    return new promiseCtor(function (resolve, reject) {\n\t      // No cancellation can be done\n\t      var value;\n\t      source.subscribe(function (v) {\n\t        value = v;\n\t      }, reject, function () {\n\t        resolve(value);\n\t      });\n\t    });\n\t  };\n\t\n\t  var ToArrayObservable = (function(__super__) {\n\t    inherits(ToArrayObservable, __super__);\n\t    function ToArrayObservable(source) {\n\t      this.source = source;\n\t      __super__.call(this);\n\t    }\n\t\n\t    ToArrayObservable.prototype.subscribeCore = function(o) {\n\t      return this.source.subscribe(new InnerObserver(o));\n\t    };\n\t\n\t    inherits(InnerObserver, AbstractObserver);\n\t    function InnerObserver(o) {\n\t      this.o = o;\n\t      this.a = [];\n\t      AbstractObserver.call(this);\n\t    }\n\t    \n\t    InnerObserver.prototype.next = function (x) { this.a.push(x); };\n\t    InnerObserver.prototype.error = function (e) { this.o.onError(e);  };\n\t    InnerObserver.prototype.completed = function () { this.o.onNext(this.a); this.o.onCompleted(); };\n\t\n\t    return ToArrayObservable;\n\t  }(ObservableBase));\n\t\n\t  /**\n\t  * Creates an array from an observable sequence.\n\t  * @returns {Observable} An observable sequence containing a single element with a list containing all the elements of the source sequence.\n\t  */\n\t  observableProto.toArray = function () {\n\t    return new ToArrayObservable(this);\n\t  };\n\t\n\t  /**\n\t   *  Creates an observable sequence from a specified subscribe method implementation.\n\t   * @example\n\t   *  var res = Rx.Observable.create(function (observer) { return function () { } );\n\t   *  var res = Rx.Observable.create(function (observer) { return Rx.Disposable.empty; } );\n\t   *  var res = Rx.Observable.create(function (observer) { } );\n\t   * @param {Function} subscribe Implementation of the resulting observable sequence's subscribe method, returning a function that will be wrapped in a Disposable.\n\t   * @returns {Observable} The observable sequence with the specified implementation for the Subscribe method.\n\t   */\n\t  Observable.create = function (subscribe, parent) {\n\t    return new AnonymousObservable(subscribe, parent);\n\t  };\n\t\n\t  var Defer = (function(__super__) {\n\t    inherits(Defer, __super__);\n\t    function Defer(factory) {\n\t      this._f = factory;\n\t      __super__.call(this);\n\t    }\n\t\n\t    Defer.prototype.subscribeCore = function (o) {\n\t      var result = tryCatch(this._f)();\n\t      if (result === errorObj) { return observableThrow(result.e).subscribe(o);}\n\t      isPromise(result) && (result = observableFromPromise(result));\n\t      return result.subscribe(o);\n\t    };\n\t\n\t    return Defer;\n\t  }(ObservableBase));\n\t\n\t  /**\n\t   *  Returns an observable sequence that invokes the specified factory function whenever a new observer subscribes.\n\t   *\n\t   * @example\n\t   *  var res = Rx.Observable.defer(function () { return Rx.Observable.fromArray([1,2,3]); });\n\t   * @param {Function} observableFactory Observable factory function to invoke for each observer that subscribes to the resulting sequence or Promise.\n\t   * @returns {Observable} An observable sequence whose observers trigger an invocation of the given observable factory function.\n\t   */\n\t  var observableDefer = Observable.defer = function (observableFactory) {\n\t    return new Defer(observableFactory);\n\t  };\n\t\n\t  var EmptyObservable = (function(__super__) {\n\t    inherits(EmptyObservable, __super__);\n\t    function EmptyObservable(scheduler) {\n\t      this.scheduler = scheduler;\n\t      __super__.call(this);\n\t    }\n\t\n\t    EmptyObservable.prototype.subscribeCore = function (observer) {\n\t      var sink = new EmptySink(observer, this.scheduler);\n\t      return sink.run();\n\t    };\n\t\n\t    function EmptySink(observer, scheduler) {\n\t      this.observer = observer;\n\t      this.scheduler = scheduler;\n\t    }\n\t\n\t    function scheduleItem(s, state) {\n\t      state.onCompleted();\n\t      return disposableEmpty;\n\t    }\n\t\n\t    EmptySink.prototype.run = function () {\n\t      var state = this.observer;\n\t      return this.scheduler === immediateScheduler ?\n\t        scheduleItem(null, state) :\n\t        this.scheduler.schedule(state, scheduleItem);\n\t    };\n\t\n\t    return EmptyObservable;\n\t  }(ObservableBase));\n\t\n\t  var EMPTY_OBSERVABLE = new EmptyObservable(immediateScheduler);\n\t\n\t  /**\n\t   *  Returns an empty observable sequence, using the specified scheduler to send out the single OnCompleted message.\n\t   *\n\t   * @example\n\t   *  var res = Rx.Observable.empty();\n\t   *  var res = Rx.Observable.empty(Rx.Scheduler.timeout);\n\t   * @param {Scheduler} [scheduler] Scheduler to send the termination call on.\n\t   * @returns {Observable} An observable sequence with no elements.\n\t   */\n\t  var observableEmpty = Observable.empty = function (scheduler) {\n\t    isScheduler(scheduler) || (scheduler = immediateScheduler);\n\t    return scheduler === immediateScheduler ? EMPTY_OBSERVABLE : new EmptyObservable(scheduler);\n\t  };\n\t\n\t  var FromObservable = (function(__super__) {\n\t    inherits(FromObservable, __super__);\n\t    function FromObservable(iterable, fn, scheduler) {\n\t      this._iterable = iterable;\n\t      this._fn = fn;\n\t      this._scheduler = scheduler;\n\t      __super__.call(this);\n\t    }\n\t\n\t    function createScheduleMethod(o, it, fn) {\n\t      return function loopRecursive(i, recurse) {\n\t        var next = tryCatch(it.next).call(it);\n\t        if (next === errorObj) { return o.onError(next.e); }\n\t        if (next.done) { return o.onCompleted(); }\n\t\n\t        var result = next.value;\n\t\n\t        if (isFunction(fn)) {\n\t          result = tryCatch(fn)(result, i);\n\t          if (result === errorObj) { return o.onError(result.e); }\n\t        }\n\t\n\t        o.onNext(result);\n\t        recurse(i + 1);\n\t      };\n\t    }\n\t\n\t    FromObservable.prototype.subscribeCore = function (o) {\n\t      var list = Object(this._iterable),\n\t          it = getIterable(list);\n\t\n\t      return this._scheduler.scheduleRecursive(0, createScheduleMethod(o, it, this._fn));\n\t    };\n\t\n\t    return FromObservable;\n\t  }(ObservableBase));\n\t\n\t  var maxSafeInteger = Math.pow(2, 53) - 1;\n\t\n\t  function StringIterable(s) {\n\t    this._s = s;\n\t  }\n\t\n\t  StringIterable.prototype[$iterator$] = function () {\n\t    return new StringIterator(this._s);\n\t  };\n\t\n\t  function StringIterator(s) {\n\t    this._s = s;\n\t    this._l = s.length;\n\t    this._i = 0;\n\t  }\n\t\n\t  StringIterator.prototype[$iterator$] = function () {\n\t    return this;\n\t  };\n\t\n\t  StringIterator.prototype.next = function () {\n\t    return this._i < this._l ? { done: false, value: this._s.charAt(this._i++) } : doneEnumerator;\n\t  };\n\t\n\t  function ArrayIterable(a) {\n\t    this._a = a;\n\t  }\n\t\n\t  ArrayIterable.prototype[$iterator$] = function () {\n\t    return new ArrayIterator(this._a);\n\t  };\n\t\n\t  function ArrayIterator(a) {\n\t    this._a = a;\n\t    this._l = toLength(a);\n\t    this._i = 0;\n\t  }\n\t\n\t  ArrayIterator.prototype[$iterator$] = function () {\n\t    return this;\n\t  };\n\t\n\t  ArrayIterator.prototype.next = function () {\n\t    return this._i < this._l ? { done: false, value: this._a[this._i++] } : doneEnumerator;\n\t  };\n\t\n\t  function numberIsFinite(value) {\n\t    return typeof value === 'number' && root.isFinite(value);\n\t  }\n\t\n\t  function isNan(n) {\n\t    return n !== n;\n\t  }\n\t\n\t  function getIterable(o) {\n\t    var i = o[$iterator$], it;\n\t    if (!i && typeof o === 'string') {\n\t      it = new StringIterable(o);\n\t      return it[$iterator$]();\n\t    }\n\t    if (!i && o.length !== undefined) {\n\t      it = new ArrayIterable(o);\n\t      return it[$iterator$]();\n\t    }\n\t    if (!i) { throw new TypeError('Object is not iterable'); }\n\t    return o[$iterator$]();\n\t  }\n\t\n\t  function sign(value) {\n\t    var number = +value;\n\t    if (number === 0) { return number; }\n\t    if (isNaN(number)) { return number; }\n\t    return number < 0 ? -1 : 1;\n\t  }\n\t\n\t  function toLength(o) {\n\t    var len = +o.length;\n\t    if (isNaN(len)) { return 0; }\n\t    if (len === 0 || !numberIsFinite(len)) { return len; }\n\t    len = sign(len) * Math.floor(Math.abs(len));\n\t    if (len <= 0) { return 0; }\n\t    if (len > maxSafeInteger) { return maxSafeInteger; }\n\t    return len;\n\t  }\n\t\n\t  /**\n\t  * This method creates a new Observable sequence from an array-like or iterable object.\n\t  * @param {Any} arrayLike An array-like or iterable object to convert to an Observable sequence.\n\t  * @param {Function} [mapFn] Map function to call on every element of the array.\n\t  * @param {Any} [thisArg] The context to use calling the mapFn if provided.\n\t  * @param {Scheduler} [scheduler] Optional scheduler to use for scheduling.  If not provided, defaults to Scheduler.currentThread.\n\t  */\n\t  var observableFrom = Observable.from = function (iterable, mapFn, thisArg, scheduler) {\n\t    if (iterable == null) {\n\t      throw new Error('iterable cannot be null.')\n\t    }\n\t    if (mapFn && !isFunction(mapFn)) {\n\t      throw new Error('mapFn when provided must be a function');\n\t    }\n\t    if (mapFn) {\n\t      var mapper = bindCallback(mapFn, thisArg, 2);\n\t    }\n\t    isScheduler(scheduler) || (scheduler = currentThreadScheduler);\n\t    return new FromObservable(iterable, mapper, scheduler);\n\t  }\n\t\n\t  var FromArrayObservable = (function(__super__) {\n\t    inherits(FromArrayObservable, __super__);\n\t    function FromArrayObservable(args, scheduler) {\n\t      this._args = args;\n\t      this._scheduler = scheduler;\n\t      __super__.call(this);\n\t    }\n\t\n\t    function scheduleMethod(o, args) {\n\t      var len = args.length;\n\t      return function loopRecursive (i, recurse) {\n\t        if (i < len) {\n\t          o.onNext(args[i]);\n\t          recurse(i + 1);\n\t        } else {\n\t          o.onCompleted();\n\t        }\n\t      };\n\t    }\n\t\n\t    FromArrayObservable.prototype.subscribeCore = function (o) {\n\t      return this._scheduler.scheduleRecursive(0, scheduleMethod(o, this._args));\n\t    };\n\t\n\t    return FromArrayObservable;\n\t  }(ObservableBase));\n\t\n\t  /**\n\t  *  Converts an array to an observable sequence, using an optional scheduler to enumerate the array.\n\t  * @deprecated use Observable.from or Observable.of\n\t  * @param {Scheduler} [scheduler] Scheduler to run the enumeration of the input sequence on.\n\t  * @returns {Observable} The observable sequence whose elements are pulled from the given enumerable sequence.\n\t  */\n\t  var observableFromArray = Observable.fromArray = function (array, scheduler) {\n\t    isScheduler(scheduler) || (scheduler = currentThreadScheduler);\n\t    return new FromArrayObservable(array, scheduler)\n\t  };\n\t\n\t  var GenerateObservable = (function (__super__) {\n\t    inherits(GenerateObservable, __super__);\n\t    function GenerateObservable(state, cndFn, itrFn, resFn, s) {\n\t      this._state = state;\n\t      this._cndFn = cndFn;\n\t      this._itrFn = itrFn;\n\t      this._resFn = resFn;\n\t      this._s = s;\n\t      this._first = true;\n\t      __super__.call(this);\n\t    }\n\t\n\t    function scheduleRecursive(self, recurse) {\n\t      if (self._first) {\n\t        self._first = false;\n\t      } else {\n\t        self._state = tryCatch(self._itrFn)(self._state);\n\t        if (self._state === errorObj) { return self._o.onError(self._state.e); }\n\t      }\n\t      var hasResult = tryCatch(self._cndFn)(self._state);\n\t      if (hasResult === errorObj) { return self._o.onError(hasResult.e); }\n\t      if (hasResult) {\n\t        var result = tryCatch(self._resFn)(self._state);\n\t        if (result === errorObj) { return self._o.onError(result.e); }\n\t        self._o.onNext(result);\n\t        recurse(self);\n\t      } else {\n\t        self._o.onCompleted();\n\t      }\n\t    }\n\t\n\t    GenerateObservable.prototype.subscribeCore = function (o) {\n\t      this._o = o;\n\t      return this._s.scheduleRecursive(this, scheduleRecursive);\n\t    };\n\t\n\t    return GenerateObservable;\n\t  }(ObservableBase));\n\t\n\t  /**\n\t   *  Generates an observable sequence by running a state-driven loop producing the sequence's elements, using the specified scheduler to send out observer messages.\n\t   *\n\t   * @example\n\t   *  var res = Rx.Observable.generate(0, function (x) { return x < 10; }, function (x) { return x + 1; }, function (x) { return x; });\n\t   *  var res = Rx.Observable.generate(0, function (x) { return x < 10; }, function (x) { return x + 1; }, function (x) { return x; }, Rx.Scheduler.timeout);\n\t   * @param {Mixed} initialState Initial state.\n\t   * @param {Function} condition Condition to terminate generation (upon returning false).\n\t   * @param {Function} iterate Iteration step function.\n\t   * @param {Function} resultSelector Selector function for results produced in the sequence.\n\t   * @param {Scheduler} [scheduler] Scheduler on which to run the generator loop. If not provided, defaults to Scheduler.currentThread.\n\t   * @returns {Observable} The generated sequence.\n\t   */\n\t  Observable.generate = function (initialState, condition, iterate, resultSelector, scheduler) {\n\t    isScheduler(scheduler) || (scheduler = currentThreadScheduler);\n\t    return new GenerateObservable(initialState, condition, iterate, resultSelector, scheduler);\n\t  };\n\t\n\t  function observableOf (scheduler, array) {\n\t    isScheduler(scheduler) || (scheduler = currentThreadScheduler);\n\t    return new FromArrayObservable(array, scheduler);\n\t  }\n\t\n\t  /**\n\t  *  This method creates a new Observable instance with a variable number of arguments, regardless of number or type of the arguments.\n\t  * @returns {Observable} The observable sequence whose elements are pulled from the given arguments.\n\t  */\n\t  Observable.of = function () {\n\t    var len = arguments.length, args = new Array(len);\n\t    for(var i = 0; i < len; i++) { args[i] = arguments[i]; }\n\t    return new FromArrayObservable(args, currentThreadScheduler);\n\t  };\n\t\n\t  /**\n\t  *  This method creates a new Observable instance with a variable number of arguments, regardless of number or type of the arguments.\n\t  * @param {Scheduler} scheduler A scheduler to use for scheduling the arguments.\n\t  * @returns {Observable} The observable sequence whose elements are pulled from the given arguments.\n\t  */\n\t  Observable.ofWithScheduler = function (scheduler) {\n\t    var len = arguments.length, args = new Array(len - 1);\n\t    for(var i = 1; i < len; i++) { args[i - 1] = arguments[i]; }\n\t    return new FromArrayObservable(args, scheduler);\n\t  };\n\t\n\t  /**\n\t   * Creates an Observable sequence from changes to an array using Array.observe.\n\t   * @param {Array} array An array to observe changes.\n\t   * @returns {Observable} An observable sequence containing changes to an array from Array.observe.\n\t   */\n\t  Observable.ofArrayChanges = function(array) {\n\t    if (!Array.isArray(array)) { throw new TypeError('Array.observe only accepts arrays.'); }\n\t    if (typeof Array.observe !== 'function' && typeof Array.unobserve !== 'function') { throw new TypeError('Array.observe is not supported on your platform') }\n\t    return new AnonymousObservable(function(observer) {\n\t      function observerFn(changes) {\n\t        for(var i = 0, len = changes.length; i < len; i++) {\n\t          observer.onNext(changes[i]);\n\t        }\n\t      }\n\t      \n\t      Array.observe(array, observerFn);\n\t\n\t      return function () {\n\t        Array.unobserve(array, observerFn);\n\t      };\n\t    });\n\t  };\n\t\n\t  /**\n\t   * Creates an Observable sequence from changes to an object using Object.observe.\n\t   * @param {Object} obj An object to observe changes.\n\t   * @returns {Observable} An observable sequence containing changes to an object from Object.observe.\n\t   */\n\t  Observable.ofObjectChanges = function(obj) {\n\t    if (obj == null) { throw new TypeError('object must not be null or undefined.'); }\n\t    if (typeof Object.observe !== 'function' && typeof Object.unobserve !== 'function') { throw new TypeError('Object.observe is not supported on your platform') }\n\t    return new AnonymousObservable(function(observer) {\n\t      function observerFn(changes) {\n\t        for(var i = 0, len = changes.length; i < len; i++) {\n\t          observer.onNext(changes[i]);\n\t        }\n\t      }\n\t\n\t      Object.observe(obj, observerFn);\n\t\n\t      return function () {\n\t        Object.unobserve(obj, observerFn);\n\t      };\n\t    });\n\t  };\n\t\n\t  var NeverObservable = (function(__super__) {\n\t    inherits(NeverObservable, __super__);\n\t    function NeverObservable() {\n\t      __super__.call(this);\n\t    }\n\t\n\t    NeverObservable.prototype.subscribeCore = function (observer) {\n\t      return disposableEmpty;\n\t    };\n\t\n\t    return NeverObservable;\n\t  }(ObservableBase));\n\t\n\t  var NEVER_OBSERVABLE = new NeverObservable();\n\t\n\t  /**\n\t   * Returns a non-terminating observable sequence, which can be used to denote an infinite duration (e.g. when using reactive joins).\n\t   * @returns {Observable} An observable sequence whose observers will never get called.\n\t   */\n\t  var observableNever = Observable.never = function () {\n\t    return NEVER_OBSERVABLE;\n\t  };\n\t\n\t  var PairsObservable = (function(__super__) {\n\t    inherits(PairsObservable, __super__);\n\t    function PairsObservable(o, scheduler) {\n\t      this._o = o;\n\t      this._keys = Object.keys(o);\n\t      this._scheduler = scheduler;\n\t      __super__.call(this);\n\t    }\n\t\n\t    function scheduleMethod(o, obj, keys) {\n\t      return function loopRecursive(i, recurse) {\n\t        if (i < keys.length) {\n\t          var key = keys[i];\n\t          o.onNext([key, obj[key]]);\n\t          recurse(i + 1);\n\t        } else {\n\t          o.onCompleted();\n\t        }\n\t      };\n\t    }\n\t\n\t    PairsObservable.prototype.subscribeCore = function (o) {\n\t      return this._scheduler.scheduleRecursive(0, scheduleMethod(o, this._o, this._keys));\n\t    };\n\t\n\t    return PairsObservable;\n\t  }(ObservableBase));\n\t\n\t  /**\n\t   * Convert an object into an observable sequence of [key, value] pairs.\n\t   * @param {Object} obj The object to inspect.\n\t   * @param {Scheduler} [scheduler] Scheduler to run the enumeration of the input sequence on.\n\t   * @returns {Observable} An observable sequence of [key, value] pairs from the object.\n\t   */\n\t  Observable.pairs = function (obj, scheduler) {\n\t    scheduler || (scheduler = currentThreadScheduler);\n\t    return new PairsObservable(obj, scheduler);\n\t  };\n\t\n\t    var RangeObservable = (function(__super__) {\n\t    inherits(RangeObservable, __super__);\n\t    function RangeObservable(start, count, scheduler) {\n\t      this.start = start;\n\t      this.rangeCount = count;\n\t      this.scheduler = scheduler;\n\t      __super__.call(this);\n\t    }\n\t\n\t    function loopRecursive(start, count, o) {\n\t      return function loop (i, recurse) {\n\t        if (i < count) {\n\t          o.onNext(start + i);\n\t          recurse(i + 1);\n\t        } else {\n\t          o.onCompleted();\n\t        }\n\t      };\n\t    }\n\t\n\t    RangeObservable.prototype.subscribeCore = function (o) {\n\t      return this.scheduler.scheduleRecursive(\n\t        0,\n\t        loopRecursive(this.start, this.rangeCount, o)\n\t      );\n\t    };\n\t\n\t    return RangeObservable;\n\t  }(ObservableBase));\n\t\n\t  /**\n\t  *  Generates an observable sequence of integral numbers within a specified range, using the specified scheduler to send out observer messages.\n\t  * @param {Number} start The value of the first integer in the sequence.\n\t  * @param {Number} count The number of sequential integers to generate.\n\t  * @param {Scheduler} [scheduler] Scheduler to run the generator loop on. If not specified, defaults to Scheduler.currentThread.\n\t  * @returns {Observable} An observable sequence that contains a range of sequential integral numbers.\n\t  */\n\t  Observable.range = function (start, count, scheduler) {\n\t    isScheduler(scheduler) || (scheduler = currentThreadScheduler);\n\t    return new RangeObservable(start, count, scheduler);\n\t  };\n\t\n\t  var RepeatObservable = (function(__super__) {\n\t    inherits(RepeatObservable, __super__);\n\t    function RepeatObservable(value, repeatCount, scheduler) {\n\t      this.value = value;\n\t      this.repeatCount = repeatCount == null ? -1 : repeatCount;\n\t      this.scheduler = scheduler;\n\t      __super__.call(this);\n\t    }\n\t\n\t    RepeatObservable.prototype.subscribeCore = function (observer) {\n\t      var sink = new RepeatSink(observer, this);\n\t      return sink.run();\n\t    };\n\t\n\t    return RepeatObservable;\n\t  }(ObservableBase));\n\t\n\t  function RepeatSink(observer, parent) {\n\t    this.observer = observer;\n\t    this.parent = parent;\n\t  }\n\t\n\t  RepeatSink.prototype.run = function () {\n\t    var observer = this.observer, value = this.parent.value;\n\t    function loopRecursive(i, recurse) {\n\t      if (i === -1 || i > 0) {\n\t        observer.onNext(value);\n\t        i > 0 && i--;\n\t      }\n\t      if (i === 0) { return observer.onCompleted(); }\n\t      recurse(i);\n\t    }\n\t\n\t    return this.parent.scheduler.scheduleRecursive(this.parent.repeatCount, loopRecursive);\n\t  };\n\t\n\t  /**\n\t   *  Generates an observable sequence that repeats the given element the specified number of times, using the specified scheduler to send out observer messages.\n\t   * @param {Mixed} value Element to repeat.\n\t   * @param {Number} repeatCount [Optiona] Number of times to repeat the element. If not specified, repeats indefinitely.\n\t   * @param {Scheduler} scheduler Scheduler to run the producer loop on. If not specified, defaults to Scheduler.immediate.\n\t   * @returns {Observable} An observable sequence that repeats the given element the specified number of times.\n\t   */\n\t  Observable.repeat = function (value, repeatCount, scheduler) {\n\t    isScheduler(scheduler) || (scheduler = currentThreadScheduler);\n\t    return new RepeatObservable(value, repeatCount, scheduler);\n\t  };\n\t\n\t  var JustObservable = (function(__super__) {\n\t    inherits(JustObservable, __super__);\n\t    function JustObservable(value, scheduler) {\n\t      this._value = value;\n\t      this._scheduler = scheduler;\n\t      __super__.call(this);\n\t    }\n\t\n\t    JustObservable.prototype.subscribeCore = function (o) {\n\t      var state = [this._value, o];\n\t      return this._scheduler === immediateScheduler ?\n\t        scheduleItem(null, state) :\n\t        this._scheduler.schedule(state, scheduleItem);\n\t    };\n\t\n\t    function scheduleItem(s, state) {\n\t      var value = state[0], observer = state[1];\n\t      observer.onNext(value);\n\t      observer.onCompleted();\n\t      return disposableEmpty;\n\t    }\n\t\n\t    return JustObservable;\n\t  }(ObservableBase));\n\t\n\t  /**\n\t   *  Returns an observable sequence that contains a single element, using the specified scheduler to send out observer messages.\n\t   *  There is an alias called 'just' or browsers <IE9.\n\t   * @param {Mixed} value Single element in the resulting observable sequence.\n\t   * @param {Scheduler} scheduler Scheduler to send the single element on. If not specified, defaults to Scheduler.immediate.\n\t   * @returns {Observable} An observable sequence containing the single specified element.\n\t   */\n\t  var observableReturn = Observable['return'] = Observable.just = function (value, scheduler) {\n\t    isScheduler(scheduler) || (scheduler = immediateScheduler);\n\t    return new JustObservable(value, scheduler);\n\t  };\n\t\n\t  var ThrowObservable = (function(__super__) {\n\t    inherits(ThrowObservable, __super__);\n\t    function ThrowObservable(error, scheduler) {\n\t      this._error = error;\n\t      this._scheduler = scheduler;\n\t      __super__.call(this);\n\t    }\n\t\n\t    ThrowObservable.prototype.subscribeCore = function (o) {\n\t      var state = [this._error, o];\n\t      return this._scheduler === immediateScheduler ?\n\t        scheduleItem(null, state) :\n\t        this._scheduler.schedule(state, scheduleItem);\n\t    };\n\t\n\t    function scheduleItem(s, state) {\n\t      var e = state[0], o = state[1];\n\t      o.onError(e);\n\t      return disposableEmpty;\n\t    }\n\t\n\t    return ThrowObservable;\n\t  }(ObservableBase));\n\t\n\t  /**\n\t   *  Returns an observable sequence that terminates with an exception, using the specified scheduler to send out the single onError message.\n\t   *  There is an alias to this method called 'throwError' for browsers <IE9.\n\t   * @param {Mixed} error An object used for the sequence's termination.\n\t   * @param {Scheduler} scheduler Scheduler to send the exceptional termination call on. If not specified, defaults to Scheduler.immediate.\n\t   * @returns {Observable} The observable sequence that terminates exceptionally with the specified exception object.\n\t   */\n\t  var observableThrow = Observable['throw'] = function (error, scheduler) {\n\t    isScheduler(scheduler) || (scheduler = immediateScheduler);\n\t    return new ThrowObservable(error, scheduler);\n\t  };\n\t\n\t  var UsingObservable = (function (__super__) {\n\t    inherits(UsingObservable, __super__);\n\t    function UsingObservable(resFn, obsFn) {\n\t      this._resFn = resFn;\n\t      this._obsFn = obsFn;\n\t      __super__.call(this);\n\t    }\n\t\n\t    UsingObservable.prototype.subscribeCore = function (o) {\n\t      var disposable = disposableEmpty;\n\t      var resource = tryCatch(this._resFn)();\n\t      if (resource === errorObj) {\n\t        return new BinaryDisposable(observableThrow(resource.e).subscribe(o), disposable);\n\t      }\n\t      resource && (disposable = resource);\n\t      var source = tryCatch(this._obsFn)(resource);\n\t      if (source === errorObj) {\n\t        return new BinaryDisposable(observableThrow(source.e).subscribe(o), disposable);\n\t      }\n\t      return new BinaryDisposable(source.subscribe(o), disposable);\n\t    };\n\t\n\t    return UsingObservable;\n\t  }(ObservableBase));\n\t\n\t  /**\n\t   * Constructs an observable sequence that depends on a resource object, whose lifetime is tied to the resulting observable sequence's lifetime.\n\t   * @param {Function} resourceFactory Factory function to obtain a resource object.\n\t   * @param {Function} observableFactory Factory function to obtain an observable sequence that depends on the obtained resource.\n\t   * @returns {Observable} An observable sequence whose lifetime controls the lifetime of the dependent resource object.\n\t   */\n\t  Observable.using = function (resourceFactory, observableFactory) {\n\t    return new UsingObservable(resourceFactory, observableFactory);\n\t  };\n\t\n\t  /**\n\t   * Propagates the observable sequence or Promise that reacts first.\n\t   * @param {Observable} rightSource Second observable sequence or Promise.\n\t   * @returns {Observable} {Observable} An observable sequence that surfaces either of the given sequences, whichever reacted first.\n\t   */\n\t  observableProto.amb = function (rightSource) {\n\t    var leftSource = this;\n\t    return new AnonymousObservable(function (observer) {\n\t      var choice,\n\t        leftChoice = 'L', rightChoice = 'R',\n\t        leftSubscription = new SingleAssignmentDisposable(),\n\t        rightSubscription = new SingleAssignmentDisposable();\n\t\n\t      isPromise(rightSource) && (rightSource = observableFromPromise(rightSource));\n\t\n\t      function choiceL() {\n\t        if (!choice) {\n\t          choice = leftChoice;\n\t          rightSubscription.dispose();\n\t        }\n\t      }\n\t\n\t      function choiceR() {\n\t        if (!choice) {\n\t          choice = rightChoice;\n\t          leftSubscription.dispose();\n\t        }\n\t      }\n\t\n\t      var leftSubscribe = observerCreate(\n\t        function (left) {\n\t          choiceL();\n\t          choice === leftChoice && observer.onNext(left);\n\t        },\n\t        function (e) {\n\t          choiceL();\n\t          choice === leftChoice && observer.onError(e);\n\t        },\n\t        function () {\n\t          choiceL();\n\t          choice === leftChoice && observer.onCompleted();\n\t        }\n\t      );\n\t      var rightSubscribe = observerCreate(\n\t        function (right) {\n\t          choiceR();\n\t          choice === rightChoice && observer.onNext(right);\n\t        },\n\t        function (e) {\n\t          choiceR();\n\t          choice === rightChoice && observer.onError(e);\n\t        },\n\t        function () {\n\t          choiceR();\n\t          choice === rightChoice && observer.onCompleted();\n\t        }\n\t      );\n\t\n\t      leftSubscription.setDisposable(leftSource.subscribe(leftSubscribe));\n\t      rightSubscription.setDisposable(rightSource.subscribe(rightSubscribe));\n\t\n\t      return new BinaryDisposable(leftSubscription, rightSubscription);\n\t    });\n\t  };\n\t\n\t  function amb(p, c) { return p.amb(c); }\n\t\n\t  /**\n\t   * Propagates the observable sequence or Promise that reacts first.\n\t   * @returns {Observable} An observable sequence that surfaces any of the given sequences, whichever reacted first.\n\t   */\n\t  Observable.amb = function () {\n\t    var acc = observableNever(), items;\n\t    if (Array.isArray(arguments[0])) {\n\t      items = arguments[0];\n\t    } else {\n\t      var len = arguments.length;\n\t      items = new Array(items);\n\t      for(var i = 0; i < len; i++) { items[i] = arguments[i]; }\n\t    }\n\t    for (var i = 0, len = items.length; i < len; i++) {\n\t      acc = amb(acc, items[i]);\n\t    }\n\t    return acc;\n\t  };\n\t\n\t  var CatchObservable = (function (__super__) {\n\t    inherits(CatchObservable, __super__);\n\t    function CatchObservable(source, fn) {\n\t      this.source = source;\n\t      this._fn = fn;\n\t      __super__.call(this);\n\t    }\n\t\n\t    CatchObservable.prototype.subscribeCore = function (o) {\n\t      var d1 = new SingleAssignmentDisposable(), subscription = new SerialDisposable();\n\t      subscription.setDisposable(d1);\n\t      d1.setDisposable(this.source.subscribe(new CatchObserver(o, subscription, this._fn)));\n\t      return subscription;\n\t    };\n\t\n\t    return CatchObservable;\n\t  }(ObservableBase));\n\t\n\t  var CatchObserver = (function(__super__) {\n\t    inherits(CatchObserver, __super__);\n\t    function CatchObserver(o, s, fn) {\n\t      this._o = o;\n\t      this._s = s;\n\t      this._fn = fn;\n\t      __super__.call(this);\n\t    }\n\t\n\t    CatchObserver.prototype.next = function (x) { this._o.onNext(x); };\n\t    CatchObserver.prototype.completed = function () { return this._o.onCompleted(); };\n\t    CatchObserver.prototype.error = function (e) {\n\t      var result = tryCatch(this._fn)(e);\n\t      if (result === errorObj) { return this._o.onError(result.e); }\n\t      isPromise(result) && (result = observableFromPromise(result));\n\t\n\t      var d = new SingleAssignmentDisposable();\n\t      this._s.setDisposable(d);\n\t      d.setDisposable(result.subscribe(this._o));\n\t    };\n\t\n\t    return CatchObserver;\n\t  }(AbstractObserver));\n\t\n\t  /**\n\t   * Continues an observable sequence that is terminated by an exception with the next observable sequence.\n\t   * @param {Mixed} handlerOrSecond Exception handler function that returns an observable sequence given the error that occurred in the first sequence, or a second observable sequence used to produce results when an error occurred in the first sequence.\n\t   * @returns {Observable} An observable sequence containing the first sequence's elements, followed by the elements of the handler sequence in case an exception occurred.\n\t   */\n\t  observableProto['catch'] = function (handlerOrSecond) {\n\t    return isFunction(handlerOrSecond) ? new CatchObservable(this, handlerOrSecond) : observableCatch([this, handlerOrSecond]);\n\t  };\n\t\n\t  /**\n\t   * Continues an observable sequence that is terminated by an exception with the next observable sequence.\n\t   * @param {Array | Arguments} args Arguments or an array to use as the next sequence if an error occurs.\n\t   * @returns {Observable} An observable sequence containing elements from consecutive source sequences until a source sequence terminates successfully.\n\t   */\n\t  var observableCatch = Observable['catch'] = function () {\n\t    var items;\n\t    if (Array.isArray(arguments[0])) {\n\t      items = arguments[0];\n\t    } else {\n\t      var len = arguments.length;\n\t      items = new Array(len);\n\t      for(var i = 0; i < len; i++) { items[i] = arguments[i]; }\n\t    }\n\t    return enumerableOf(items).catchError();\n\t  };\n\t\n\t  /**\n\t   * Merges the specified observable sequences into one observable sequence by using the selector function whenever any of the observable sequences or Promises produces an element.\n\t   * This can be in the form of an argument list of observables or an array.\n\t   *\n\t   * @example\n\t   * 1 - obs = observable.combineLatest(obs1, obs2, obs3, function (o1, o2, o3) { return o1 + o2 + o3; });\n\t   * 2 - obs = observable.combineLatest([obs1, obs2, obs3], function (o1, o2, o3) { return o1 + o2 + o3; });\n\t   * @returns {Observable} An observable sequence containing the result of combining elements of the sources using the specified result selector function.\n\t   */\n\t  observableProto.combineLatest = function () {\n\t    var len = arguments.length, args = new Array(len);\n\t    for(var i = 0; i < len; i++) { args[i] = arguments[i]; }\n\t    if (Array.isArray(args[0])) {\n\t      args[0].unshift(this);\n\t    } else {\n\t      args.unshift(this);\n\t    }\n\t    return combineLatest.apply(this, args);\n\t  };\n\t\n\t  function falseFactory() { return false; }\n\t  function argumentsToArray() {\n\t    var len = arguments.length, args = new Array(len);\n\t    for(var i = 0; i < len; i++) { args[i] = arguments[i]; }\n\t    return args;\n\t  }\n\t\n\t  var CombineLatestObservable = (function(__super__) {\n\t    inherits(CombineLatestObservable, __super__);\n\t    function CombineLatestObservable(params, cb) {\n\t      this._params = params;\n\t      this._cb = cb;\n\t      __super__.call(this);\n\t    }\n\t\n\t    CombineLatestObservable.prototype.subscribeCore = function(observer) {\n\t      var len = this._params.length,\n\t          subscriptions = new Array(len);\n\t\n\t      var state = {\n\t        hasValue: arrayInitialize(len, falseFactory),\n\t        hasValueAll: false,\n\t        isDone: arrayInitialize(len, falseFactory),\n\t        values: new Array(len)\n\t      };\n\t\n\t      for (var i = 0; i < len; i++) {\n\t        var source = this._params[i], sad = new SingleAssignmentDisposable();\n\t        subscriptions[i] = sad;\n\t        isPromise(source) && (source = observableFromPromise(source));\n\t        sad.setDisposable(source.subscribe(new CombineLatestObserver(observer, i, this._cb, state)));\n\t      }\n\t\n\t      return new NAryDisposable(subscriptions);\n\t    };\n\t\n\t    return CombineLatestObservable;\n\t  }(ObservableBase));\n\t\n\t  var CombineLatestObserver = (function (__super__) {\n\t    inherits(CombineLatestObserver, __super__);\n\t    function CombineLatestObserver(o, i, cb, state) {\n\t      this._o = o;\n\t      this._i = i;\n\t      this._cb = cb;\n\t      this._state = state;\n\t      __super__.call(this);\n\t    }\n\t\n\t    function notTheSame(i) {\n\t      return function (x, j) {\n\t        return j !== i;\n\t      };\n\t    }\n\t\n\t    CombineLatestObserver.prototype.next = function (x) {\n\t      this._state.values[this._i] = x;\n\t      this._state.hasValue[this._i] = true;\n\t      if (this._state.hasValueAll || (this._state.hasValueAll = this._state.hasValue.every(identity))) {\n\t        var res = tryCatch(this._cb).apply(null, this._state.values);\n\t        if (res === errorObj) { return this._o.onError(res.e); }\n\t        this._o.onNext(res);\n\t      } else if (this._state.isDone.filter(notTheSame(this._i)).every(identity)) {\n\t        this._o.onCompleted();\n\t      }\n\t    };\n\t\n\t    CombineLatestObserver.prototype.error = function (e) {\n\t      this._o.onError(e);\n\t    };\n\t\n\t    CombineLatestObserver.prototype.completed = function () {\n\t      this._state.isDone[this._i] = true;\n\t      this._state.isDone.every(identity) && this._o.onCompleted();\n\t    };\n\t\n\t    return CombineLatestObserver;\n\t  }(AbstractObserver));\n\t\n\t  /**\n\t  * Merges the specified observable sequences into one observable sequence by using the selector function whenever any of the observable sequences or Promises produces an element.\n\t  *\n\t  * @example\n\t  * 1 - obs = Rx.Observable.combineLatest(obs1, obs2, obs3, function (o1, o2, o3) { return o1 + o2 + o3; });\n\t  * 2 - obs = Rx.Observable.combineLatest([obs1, obs2, obs3], function (o1, o2, o3) { return o1 + o2 + o3; });\n\t  * @returns {Observable} An observable sequence containing the result of combining elements of the sources using the specified result selector function.\n\t  */\n\t  var combineLatest = Observable.combineLatest = function () {\n\t    var len = arguments.length, args = new Array(len);\n\t    for(var i = 0; i < len; i++) { args[i] = arguments[i]; }\n\t    var resultSelector = isFunction(args[len - 1]) ? args.pop() : argumentsToArray;\n\t    Array.isArray(args[0]) && (args = args[0]);\n\t    return new CombineLatestObservable(args, resultSelector);\n\t  };\n\t\n\t  /**\n\t   * Concatenates all the observable sequences.  This takes in either an array or variable arguments to concatenate.\n\t   * @returns {Observable} An observable sequence that contains the elements of each given sequence, in sequential order.\n\t   */\n\t  observableProto.concat = function () {\n\t    for(var args = [], i = 0, len = arguments.length; i < len; i++) { args.push(arguments[i]); }\n\t    args.unshift(this);\n\t    return observableConcat.apply(null, args);\n\t  };\n\t\n\t  var ConcatObserver = (function(__super__) {\n\t    inherits(ConcatObserver, __super__);\n\t    function ConcatObserver(s, fn) {\n\t      this._s = s;\n\t      this._fn = fn;\n\t      __super__.call(this);\n\t    }\n\t\n\t    ConcatObserver.prototype.next = function (x) { this._s.o.onNext(x); };\n\t    ConcatObserver.prototype.error = function (e) { this._s.o.onError(e); };\n\t    ConcatObserver.prototype.completed = function () { this._s.i++; this._fn(this._s); };\n\t\n\t    return ConcatObserver;\n\t  }(AbstractObserver));\n\t\n\t  var ConcatObservable = (function(__super__) {\n\t    inherits(ConcatObservable, __super__);\n\t    function ConcatObservable(sources) {\n\t      this._sources = sources;\n\t      __super__.call(this);\n\t    }\n\t\n\t    function scheduleRecursive (state, recurse) {\n\t      if (state.disposable.isDisposed) { return; }\n\t      if (state.i === state.sources.length) { return state.o.onCompleted(); }\n\t\n\t      // Check if promise\n\t      var currentValue = state.sources[state.i];\n\t      isPromise(currentValue) && (currentValue = observableFromPromise(currentValue));\n\t\n\t      var d = new SingleAssignmentDisposable();\n\t      state.subscription.setDisposable(d);\n\t      d.setDisposable(currentValue.subscribe(new ConcatObserver(state, recurse)));\n\t    }\n\t\n\t    ConcatObservable.prototype.subscribeCore = function(o) {\n\t      var subscription = new SerialDisposable();\n\t      var disposable = disposableCreate(noop);\n\t      var state = {\n\t        o: o,\n\t        i: 0,\n\t        subscription: subscription,\n\t        disposable: disposable,\n\t        sources: this._sources\n\t      };\n\t\n\t      var cancelable = immediateScheduler.scheduleRecursive(state, scheduleRecursive);\n\t      return new NAryDisposable([subscription, disposable, cancelable]);\n\t    };\n\t\n\t    return ConcatObservable;\n\t  }(ObservableBase));\n\t\n\t  /**\n\t   * Concatenates all the observable sequences.\n\t   * @param {Array | Arguments} args Arguments or an array to concat to the observable sequence.\n\t   * @returns {Observable} An observable sequence that contains the elements of each given sequence, in sequential order.\n\t   */\n\t  var observableConcat = Observable.concat = function () {\n\t    var args;\n\t    if (Array.isArray(arguments[0])) {\n\t      args = arguments[0];\n\t    } else {\n\t      args = new Array(arguments.length);\n\t      for(var i = 0, len = arguments.length; i < len; i++) { args[i] = arguments[i]; }\n\t    }\n\t    return new ConcatObservable(args);\n\t  };\n\t\n\t  /**\n\t   * Concatenates an observable sequence of observable sequences.\n\t   * @returns {Observable} An observable sequence that contains the elements of each observed inner sequence, in sequential order.\n\t   */\n\t  observableProto.concatAll = function () {\n\t    return this.merge(1);\n\t  };\n\t\n\t  var MergeObservable = (function (__super__) {\n\t    inherits(MergeObservable, __super__);\n\t\n\t    function MergeObservable(source, maxConcurrent) {\n\t      this.source = source;\n\t      this.maxConcurrent = maxConcurrent;\n\t      __super__.call(this);\n\t    }\n\t\n\t    MergeObservable.prototype.subscribeCore = function(observer) {\n\t      var g = new CompositeDisposable();\n\t      g.add(this.source.subscribe(new MergeObserver(observer, this.maxConcurrent, g)));\n\t      return g;\n\t    };\n\t\n\t    return MergeObservable;\n\t\n\t  }(ObservableBase));\n\t\n\t  var MergeObserver = (function (__super__) {\n\t    function MergeObserver(o, max, g) {\n\t      this.o = o;\n\t      this.max = max;\n\t      this.g = g;\n\t      this.done = false;\n\t      this.q = [];\n\t      this.activeCount = 0;\n\t      __super__.call(this);\n\t    }\n\t\n\t    inherits(MergeObserver, __super__);\n\t\n\t    MergeObserver.prototype.handleSubscribe = function (xs) {\n\t      var sad = new SingleAssignmentDisposable();\n\t      this.g.add(sad);\n\t      isPromise(xs) && (xs = observableFromPromise(xs));\n\t      sad.setDisposable(xs.subscribe(new InnerObserver(this, sad)));\n\t    };\n\t\n\t    MergeObserver.prototype.next = function (innerSource) {\n\t      if(this.activeCount < this.max) {\n\t        this.activeCount++;\n\t        this.handleSubscribe(innerSource);\n\t      } else {\n\t        this.q.push(innerSource);\n\t      }\n\t    };\n\t    MergeObserver.prototype.error = function (e) { this.o.onError(e); };\n\t    MergeObserver.prototype.completed = function () { this.done = true; this.activeCount === 0 && this.o.onCompleted(); };\n\t\n\t    function InnerObserver(parent, sad) {\n\t      this.parent = parent;\n\t      this.sad = sad;\n\t      __super__.call(this);\n\t    }\n\t\n\t    inherits(InnerObserver, __super__);\n\t\n\t    InnerObserver.prototype.next = function (x) { this.parent.o.onNext(x); };\n\t    InnerObserver.prototype.error = function (e) { this.parent.o.onError(e); };\n\t    InnerObserver.prototype.completed = function () {\n\t      this.parent.g.remove(this.sad);\n\t      if (this.parent.q.length > 0) {\n\t        this.parent.handleSubscribe(this.parent.q.shift());\n\t      } else {\n\t        this.parent.activeCount--;\n\t        this.parent.done && this.parent.activeCount === 0 && this.parent.o.onCompleted();\n\t      }\n\t    };\n\t\n\t    return MergeObserver;\n\t  }(AbstractObserver));\n\t\n\t  /**\n\t  * Merges an observable sequence of observable sequences into an observable sequence, limiting the number of concurrent subscriptions to inner sequences.\n\t  * Or merges two observable sequences into a single observable sequence.\n\t  * @param {Mixed} [maxConcurrentOrOther] Maximum number of inner observable sequences being subscribed to concurrently or the second observable sequence.\n\t  * @returns {Observable} The observable sequence that merges the elements of the inner sequences.\n\t  */\n\t  observableProto.merge = function (maxConcurrentOrOther) {\n\t    return typeof maxConcurrentOrOther !== 'number' ?\n\t      observableMerge(this, maxConcurrentOrOther) :\n\t      new MergeObservable(this, maxConcurrentOrOther);\n\t  };\n\t\n\t  /**\n\t   * Merges all the observable sequences into a single observable sequence.\n\t   * The scheduler is optional and if not specified, the immediate scheduler is used.\n\t   * @returns {Observable} The observable sequence that merges the elements of the observable sequences.\n\t   */\n\t  var observableMerge = Observable.merge = function () {\n\t    var scheduler, sources = [], i, len = arguments.length;\n\t    if (!arguments[0]) {\n\t      scheduler = immediateScheduler;\n\t      for(i = 1; i < len; i++) { sources.push(arguments[i]); }\n\t    } else if (isScheduler(arguments[0])) {\n\t      scheduler = arguments[0];\n\t      for(i = 1; i < len; i++) { sources.push(arguments[i]); }\n\t    } else {\n\t      scheduler = immediateScheduler;\n\t      for(i = 0; i < len; i++) { sources.push(arguments[i]); }\n\t    }\n\t    if (Array.isArray(sources[0])) {\n\t      sources = sources[0];\n\t    }\n\t    return observableOf(scheduler, sources).mergeAll();\n\t  };\n\t\n\t  var MergeAllObservable = (function (__super__) {\n\t    inherits(MergeAllObservable, __super__);\n\t\n\t    function MergeAllObservable(source) {\n\t      this.source = source;\n\t      __super__.call(this);\n\t    }\n\t\n\t    MergeAllObservable.prototype.subscribeCore = function (o) {\n\t      var g = new CompositeDisposable(), m = new SingleAssignmentDisposable();\n\t      g.add(m);\n\t      m.setDisposable(this.source.subscribe(new MergeAllObserver(o, g)));\n\t      return g;\n\t    };\n\t\n\t    return MergeAllObservable;\n\t  }(ObservableBase));\n\t\n\t  var MergeAllObserver = (function (__super__) {\n\t    function MergeAllObserver(o, g) {\n\t      this.o = o;\n\t      this.g = g;\n\t      this.done = false;\n\t      __super__.call(this);\n\t    }\n\t\n\t    inherits(MergeAllObserver, __super__);\n\t\n\t    MergeAllObserver.prototype.next = function(innerSource) {\n\t      var sad = new SingleAssignmentDisposable();\n\t      this.g.add(sad);\n\t      isPromise(innerSource) && (innerSource = observableFromPromise(innerSource));\n\t      sad.setDisposable(innerSource.subscribe(new InnerObserver(this, sad)));\n\t    };\n\t\n\t    MergeAllObserver.prototype.error = function (e) {\n\t      this.o.onError(e);\n\t    };\n\t\n\t    MergeAllObserver.prototype.completed = function () {\n\t      this.done = true;\n\t      this.g.length === 1 && this.o.onCompleted();\n\t    };\n\t\n\t    function InnerObserver(parent, sad) {\n\t      this.parent = parent;\n\t      this.sad = sad;\n\t      __super__.call(this);\n\t    }\n\t\n\t    inherits(InnerObserver, __super__);\n\t\n\t    InnerObserver.prototype.next = function (x) {\n\t      this.parent.o.onNext(x);\n\t    };\n\t    InnerObserver.prototype.error = function (e) {\n\t      this.parent.o.onError(e);\n\t    };\n\t    InnerObserver.prototype.completed = function () {\n\t      this.parent.g.remove(this.sad);\n\t      this.parent.done && this.parent.g.length === 1 && this.parent.o.onCompleted();\n\t    };\n\t\n\t    return MergeAllObserver;\n\t  }(AbstractObserver));\n\t\n\t  /**\n\t  * Merges an observable sequence of observable sequences into an observable sequence.\n\t  * @returns {Observable} The observable sequence that merges the elements of the inner sequences.\n\t  */\n\t  observableProto.mergeAll = function () {\n\t    return new MergeAllObservable(this);\n\t  };\n\t\n\t  var CompositeError = Rx.CompositeError = function(errors) {\n\t    this.innerErrors = errors;\n\t    this.message = 'This contains multiple errors. Check the innerErrors';\n\t    Error.call(this);\n\t  };\n\t  CompositeError.prototype = Object.create(Error.prototype);\n\t  CompositeError.prototype.name = 'CompositeError';\n\t\n\t  var MergeDelayErrorObservable = (function(__super__) {\n\t    inherits(MergeDelayErrorObservable, __super__);\n\t    function MergeDelayErrorObservable(source) {\n\t      this.source = source;\n\t      __super__.call(this);\n\t    }\n\t\n\t    MergeDelayErrorObservable.prototype.subscribeCore = function (o) {\n\t      var group = new CompositeDisposable(),\n\t        m = new SingleAssignmentDisposable(),\n\t        state = { isStopped: false, errors: [], o: o };\n\t\n\t      group.add(m);\n\t      m.setDisposable(this.source.subscribe(new MergeDelayErrorObserver(group, state)));\n\t\n\t      return group;\n\t    };\n\t\n\t    return MergeDelayErrorObservable;\n\t  }(ObservableBase));\n\t\n\t  var MergeDelayErrorObserver = (function(__super__) {\n\t    inherits(MergeDelayErrorObserver, __super__);\n\t    function MergeDelayErrorObserver(group, state) {\n\t      this._group = group;\n\t      this._state = state;\n\t      __super__.call(this);\n\t    }\n\t\n\t    function setCompletion(o, errors) {\n\t      if (errors.length === 0) {\n\t        o.onCompleted();\n\t      } else if (errors.length === 1) {\n\t        o.onError(errors[0]);\n\t      } else {\n\t        o.onError(new CompositeError(errors));\n\t      }\n\t    }\n\t\n\t    MergeDelayErrorObserver.prototype.next = function (x) {\n\t      var inner = new SingleAssignmentDisposable();\n\t      this._group.add(inner);\n\t\n\t      // Check for promises support\n\t      isPromise(x) && (x = observableFromPromise(x));\n\t      inner.setDisposable(x.subscribe(new InnerObserver(inner, this._group, this._state)));\n\t    };\n\t\n\t    MergeDelayErrorObserver.prototype.error = function (e) {\n\t      this._state.errors.push(e);\n\t      this._state.isStopped = true;\n\t      this._group.length === 1 && setCompletion(this._state.o, this._state.errors);\n\t    };\n\t\n\t    MergeDelayErrorObserver.prototype.completed = function () {\n\t      this._state.isStopped = true;\n\t      this._group.length === 1 && setCompletion(this._state.o, this._state.errors);\n\t    };\n\t\n\t    inherits(InnerObserver, __super__);\n\t    function InnerObserver(inner, group, state) {\n\t      this._inner = inner;\n\t      this._group = group;\n\t      this._state = state;\n\t      __super__.call(this);\n\t    }\n\t\n\t    InnerObserver.prototype.next = function (x) { this._state.o.onNext(x); };\n\t    InnerObserver.prototype.error = function (e) {\n\t      this._state.errors.push(e);\n\t      this._group.remove(this._inner);\n\t      this._state.isStopped && this._group.length === 1 && setCompletion(this._state.o, this._state.errors);\n\t    };\n\t    InnerObserver.prototype.completed = function () {\n\t      this._group.remove(this._inner);\n\t      this._state.isStopped && this._group.length === 1 && setCompletion(this._state.o, this._state.errors);\n\t    };\n\t\n\t    return MergeDelayErrorObserver;\n\t  }(AbstractObserver));\n\t\n\t  /**\n\t  * Flattens an Observable that emits Observables into one Observable, in a way that allows an Observer to\n\t  * receive all successfully emitted items from all of the source Observables without being interrupted by\n\t  * an error notification from one of them.\n\t  *\n\t  * This behaves like Observable.prototype.mergeAll except that if any of the merged Observables notify of an\n\t  * error via the Observer's onError, mergeDelayError will refrain from propagating that\n\t  * error notification until all of the merged Observables have finished emitting items.\n\t  * @param {Array | Arguments} args Arguments or an array to merge.\n\t  * @returns {Observable} an Observable that emits all of the items emitted by the Observables emitted by the Observable\n\t  */\n\t  Observable.mergeDelayError = function() {\n\t    var args;\n\t    if (Array.isArray(arguments[0])) {\n\t      args = arguments[0];\n\t    } else {\n\t      var len = arguments.length;\n\t      args = new Array(len);\n\t      for(var i = 0; i < len; i++) { args[i] = arguments[i]; }\n\t    }\n\t    var source = observableOf(null, args);\n\t    return new MergeDelayErrorObservable(source);\n\t  };\n\t\n\t  /**\n\t   * Continues an observable sequence that is terminated normally or by an exception with the next observable sequence.\n\t   * @param {Observable} second Second observable sequence used to produce results after the first sequence terminates.\n\t   * @returns {Observable} An observable sequence that concatenates the first and second sequence, even if the first sequence terminates exceptionally.\n\t   */\n\t  observableProto.onErrorResumeNext = function (second) {\n\t    if (!second) { throw new Error('Second observable is required'); }\n\t    return onErrorResumeNext([this, second]);\n\t  };\n\t\n\t  var OnErrorResumeNextObservable = (function(__super__) {\n\t    inherits(OnErrorResumeNextObservable, __super__);\n\t    function OnErrorResumeNextObservable(sources) {\n\t      this.sources = sources;\n\t      __super__.call(this);\n\t    }\n\t\n\t    function scheduleMethod(state, recurse) {\n\t      if (state.pos < state.sources.length) {\n\t        var current = state.sources[state.pos++];\n\t        isPromise(current) && (current = observableFromPromise(current));\n\t        var d = new SingleAssignmentDisposable();\n\t        state.subscription.setDisposable(d);\n\t        d.setDisposable(current.subscribe(new OnErrorResumeNextObserver(state, recurse)));\n\t      } else {\n\t        state.o.onCompleted();\n\t      }\n\t    }\n\t\n\t    OnErrorResumeNextObservable.prototype.subscribeCore = function (o) {\n\t      var subscription = new SerialDisposable(),\n\t          state = {pos: 0, subscription: subscription, o: o, sources: this.sources },\n\t          cancellable = immediateScheduler.scheduleRecursive(state, scheduleMethod);\n\t\n\t      return new BinaryDisposable(subscription, cancellable);\n\t    };\n\t\n\t    return OnErrorResumeNextObservable;\n\t  }(ObservableBase));\n\t\n\t  var OnErrorResumeNextObserver = (function(__super__) {\n\t    inherits(OnErrorResumeNextObserver, __super__);\n\t    function OnErrorResumeNextObserver(state, recurse) {\n\t      this._state = state;\n\t      this._recurse = recurse;\n\t      __super__.call(this);\n\t    }\n\t\n\t    OnErrorResumeNextObserver.prototype.next = function (x) { this._state.o.onNext(x); };\n\t    OnErrorResumeNextObserver.prototype.error = function () { this._recurse(this._state); };\n\t    OnErrorResumeNextObserver.prototype.completed = function () { this._recurse(this._state); };\n\t\n\t    return OnErrorResumeNextObserver;\n\t  }(AbstractObserver));\n\t\n\t  /**\n\t   * Continues an observable sequence that is terminated normally or by an exception with the next observable sequence.\n\t   * @returns {Observable} An observable sequence that concatenates the source sequences, even if a sequence terminates exceptionally.\n\t   */\n\t  var onErrorResumeNext = Observable.onErrorResumeNext = function () {\n\t    var sources = [];\n\t    if (Array.isArray(arguments[0])) {\n\t      sources = arguments[0];\n\t    } else {\n\t      var len = arguments.length;\n\t      sources = new Array(len);\n\t      for(var i = 0; i < len; i++) { sources[i] = arguments[i]; }\n\t    }\n\t    return new OnErrorResumeNextObservable(sources);\n\t  };\n\t\n\t  var SkipUntilObservable = (function(__super__) {\n\t    inherits(SkipUntilObservable, __super__);\n\t\n\t    function SkipUntilObservable(source, other) {\n\t      this._s = source;\n\t      this._o = isPromise(other) ? observableFromPromise(other) : other;\n\t      this._open = false;\n\t      __super__.call(this);\n\t    }\n\t\n\t    SkipUntilObservable.prototype.subscribeCore = function(o) {\n\t      var leftSubscription = new SingleAssignmentDisposable();\n\t      leftSubscription.setDisposable(this._s.subscribe(new SkipUntilSourceObserver(o, this)));\n\t\n\t      isPromise(this._o) && (this._o = observableFromPromise(this._o));\n\t\n\t      var rightSubscription = new SingleAssignmentDisposable();\n\t      rightSubscription.setDisposable(this._o.subscribe(new SkipUntilOtherObserver(o, this, rightSubscription)));\n\t\n\t      return new BinaryDisposable(leftSubscription, rightSubscription);\n\t    };\n\t\n\t    return SkipUntilObservable;\n\t  }(ObservableBase));\n\t\n\t  var SkipUntilSourceObserver = (function(__super__) {\n\t    inherits(SkipUntilSourceObserver, __super__);\n\t    function SkipUntilSourceObserver(o, p) {\n\t      this._o = o;\n\t      this._p = p;\n\t      __super__.call(this);\n\t    }\n\t\n\t    SkipUntilSourceObserver.prototype.next = function (x) {\n\t      this._p._open && this._o.onNext(x);\n\t    };\n\t\n\t    SkipUntilSourceObserver.prototype.error = function (err) {\n\t      this._o.onError(err);\n\t    };\n\t\n\t    SkipUntilSourceObserver.prototype.onCompleted = function () {\n\t      this._p._open && this._o.onCompleted();\n\t    };\n\t\n\t    return SkipUntilSourceObserver;\n\t  }(AbstractObserver));\n\t\n\t  var SkipUntilOtherObserver = (function(__super__) {\n\t    inherits(SkipUntilOtherObserver, __super__);\n\t    function SkipUntilOtherObserver(o, p, r) {\n\t      this._o = o;\n\t      this._p = p;\n\t      this._r = r;\n\t      __super__.call(this);\n\t    }\n\t\n\t    SkipUntilOtherObserver.prototype.next = function () {\n\t      this._p._open = true;\n\t      this._r.dispose();\n\t    };\n\t\n\t    SkipUntilOtherObserver.prototype.error = function (err) {\n\t      this._o.onError(err);\n\t    };\n\t\n\t    SkipUntilOtherObserver.prototype.onCompleted = function () {\n\t      this._r.dispose();\n\t    };\n\t\n\t    return SkipUntilOtherObserver;\n\t  }(AbstractObserver));\n\t\n\t  /**\n\t   * Returns the values from the source observable sequence only after the other observable sequence produces a value.\n\t   * @param {Observable | Promise} other The observable sequence or Promise that triggers propagation of elements of the source sequence.\n\t   * @returns {Observable} An observable sequence containing the elements of the source sequence starting from the point the other sequence triggered propagation.\n\t   */\n\t  observableProto.skipUntil = function (other) {\n\t    return new SkipUntilObservable(this, other);\n\t  };\n\t\n\t  var SwitchObservable = (function(__super__) {\n\t    inherits(SwitchObservable, __super__);\n\t    function SwitchObservable(source) {\n\t      this.source = source;\n\t      __super__.call(this);\n\t    }\n\t\n\t    SwitchObservable.prototype.subscribeCore = function (o) {\n\t      var inner = new SerialDisposable(), s = this.source.subscribe(new SwitchObserver(o, inner));\n\t      return new BinaryDisposable(s, inner);\n\t    };\n\t\n\t    inherits(SwitchObserver, AbstractObserver);\n\t    function SwitchObserver(o, inner) {\n\t      this.o = o;\n\t      this.inner = inner;\n\t      this.stopped = false;\n\t      this.latest = 0;\n\t      this.hasLatest = false;\n\t      AbstractObserver.call(this);\n\t    }\n\t\n\t    SwitchObserver.prototype.next = function (innerSource) {\n\t      var d = new SingleAssignmentDisposable(), id = ++this.latest;\n\t      this.hasLatest = true;\n\t      this.inner.setDisposable(d);\n\t      isPromise(innerSource) && (innerSource = observableFromPromise(innerSource));\n\t      d.setDisposable(innerSource.subscribe(new InnerObserver(this, id)));\n\t    };\n\t\n\t    SwitchObserver.prototype.error = function (e) {\n\t      this.o.onError(e);\n\t    };\n\t\n\t    SwitchObserver.prototype.completed = function () {\n\t      this.stopped = true;\n\t      !this.hasLatest && this.o.onCompleted();\n\t    };\n\t\n\t    inherits(InnerObserver, AbstractObserver);\n\t    function InnerObserver(parent, id) {\n\t      this.parent = parent;\n\t      this.id = id;\n\t      AbstractObserver.call(this);\n\t    }\n\t    InnerObserver.prototype.next = function (x) {\n\t      this.parent.latest === this.id && this.parent.o.onNext(x);\n\t    };\n\t\n\t    InnerObserver.prototype.error = function (e) {\n\t      this.parent.latest === this.id && this.parent.o.onError(e);\n\t    };\n\t\n\t    InnerObserver.prototype.completed = function () {\n\t      if (this.parent.latest === this.id) {\n\t        this.parent.hasLatest = false;\n\t        this.parent.stopped && this.parent.o.onCompleted();\n\t      }\n\t    };\n\t\n\t    return SwitchObservable;\n\t  }(ObservableBase));\n\t\n\t  /**\n\t  * Transforms an observable sequence of observable sequences into an observable sequence producing values only from the most recent observable sequence.\n\t  * @returns {Observable} The observable sequence that at any point in time produces the elements of the most recent inner observable sequence that has been received.\n\t  */\n\t  observableProto['switch'] = observableProto.switchLatest = function () {\n\t    return new SwitchObservable(this);\n\t  };\n\t\n\t  var TakeUntilObservable = (function(__super__) {\n\t    inherits(TakeUntilObservable, __super__);\n\t\n\t    function TakeUntilObservable(source, other) {\n\t      this.source = source;\n\t      this.other = isPromise(other) ? observableFromPromise(other) : other;\n\t      __super__.call(this);\n\t    }\n\t\n\t    TakeUntilObservable.prototype.subscribeCore = function(o) {\n\t      return new BinaryDisposable(\n\t        this.source.subscribe(o),\n\t        this.other.subscribe(new TakeUntilObserver(o))\n\t      );\n\t    };\n\t\n\t    return TakeUntilObservable;\n\t  }(ObservableBase));\n\t\n\t  var TakeUntilObserver = (function(__super__) {\n\t    inherits(TakeUntilObserver, __super__);\n\t    function TakeUntilObserver(o) {\n\t      this._o = o;\n\t      __super__.call(this);\n\t    }\n\t\n\t    TakeUntilObserver.prototype.next = function () {\n\t      this._o.onCompleted();\n\t    };\n\t\n\t    TakeUntilObserver.prototype.error = function (err) {\n\t      this._o.onError(err);\n\t    };\n\t\n\t    TakeUntilObserver.prototype.onCompleted = noop;\n\t\n\t    return TakeUntilObserver;\n\t  }(AbstractObserver));\n\t\n\t  /**\n\t   * Returns the values from the source observable sequence until the other observable sequence produces a value.\n\t   * @param {Observable | Promise} other Observable sequence or Promise that terminates propagation of elements of the source sequence.\n\t   * @returns {Observable} An observable sequence containing the elements of the source sequence up to the point the other sequence interrupted further propagation.\n\t   */\n\t  observableProto.takeUntil = function (other) {\n\t    return new TakeUntilObservable(this, other);\n\t  };\n\t\n\t  function falseFactory() { return false; }\n\t  function argumentsToArray() {\n\t    var len = arguments.length, args = new Array(len);\n\t    for(var i = 0; i < len; i++) { args[i] = arguments[i]; }\n\t    return args;\n\t  }\n\t\n\t  var WithLatestFromObservable = (function(__super__) {\n\t    inherits(WithLatestFromObservable, __super__);\n\t    function WithLatestFromObservable(source, sources, resultSelector) {\n\t      this._s = source;\n\t      this._ss = sources;\n\t      this._cb = resultSelector;\n\t      __super__.call(this);\n\t    }\n\t\n\t    WithLatestFromObservable.prototype.subscribeCore = function (o) {\n\t      var len = this._ss.length;\n\t      var state = {\n\t        hasValue: arrayInitialize(len, falseFactory),\n\t        hasValueAll: false,\n\t        values: new Array(len)\n\t      };\n\t\n\t      var n = this._ss.length, subscriptions = new Array(n + 1);\n\t      for (var i = 0; i < n; i++) {\n\t        var other = this._ss[i], sad = new SingleAssignmentDisposable();\n\t        isPromise(other) && (other = observableFromPromise(other));\n\t        sad.setDisposable(other.subscribe(new WithLatestFromOtherObserver(o, i, state)));\n\t        subscriptions[i] = sad;\n\t      }\n\t\n\t      var outerSad = new SingleAssignmentDisposable();\n\t      outerSad.setDisposable(this._s.subscribe(new WithLatestFromSourceObserver(o, this._cb, state)));\n\t      subscriptions[n] = outerSad;\n\t\n\t      return new NAryDisposable(subscriptions);\n\t    };\n\t\n\t    return WithLatestFromObservable;\n\t  }(ObservableBase));\n\t\n\t  var WithLatestFromOtherObserver = (function (__super__) {\n\t    inherits(WithLatestFromOtherObserver, __super__);\n\t    function WithLatestFromOtherObserver(o, i, state) {\n\t      this._o = o;\n\t      this._i = i;\n\t      this._state = state;\n\t      __super__.call(this);\n\t    }\n\t\n\t    WithLatestFromOtherObserver.prototype.next = function (x) {\n\t      this._state.values[this._i] = x;\n\t      this._state.hasValue[this._i] = true;\n\t      this._state.hasValueAll = this._state.hasValue.every(identity);\n\t    };\n\t\n\t    WithLatestFromOtherObserver.prototype.error = function (e) {\n\t      this._o.onError(e);\n\t    };\n\t\n\t    WithLatestFromOtherObserver.prototype.completed = noop;\n\t\n\t    return WithLatestFromOtherObserver;\n\t  }(AbstractObserver));\n\t\n\t  var WithLatestFromSourceObserver = (function (__super__) {\n\t    inherits(WithLatestFromSourceObserver, __super__);\n\t    function WithLatestFromSourceObserver(o, cb, state) {\n\t      this._o = o;\n\t      this._cb = cb;\n\t      this._state = state;\n\t      __super__.call(this);\n\t    }\n\t\n\t    WithLatestFromSourceObserver.prototype.next = function (x) {\n\t      var allValues = [x].concat(this._state.values);\n\t      if (!this._state.hasValueAll) { return; }\n\t      var res = tryCatch(this._cb).apply(null, allValues);\n\t      if (res === errorObj) { return this._o.onError(res.e); }\n\t      this._o.onNext(res);\n\t    };\n\t\n\t    WithLatestFromSourceObserver.prototype.error = function (e) {\n\t      this._o.onError(e);\n\t    };\n\t\n\t    WithLatestFromSourceObserver.prototype.completed = function () {\n\t      this._o.onCompleted();\n\t    };\n\t\n\t    return WithLatestFromSourceObserver;\n\t  }(AbstractObserver));\n\t\n\t  /**\n\t   * Merges the specified observable sequences into one observable sequence by using the selector function only when the (first) source observable sequence produces an element.\n\t   * @returns {Observable} An observable sequence containing the result of combining elements of the sources using the specified result selector function.\n\t   */\n\t  observableProto.withLatestFrom = function () {\n\t    if (arguments.length === 0) { throw new Error('invalid arguments'); }\n\t\n\t    var len = arguments.length, args = new Array(len);\n\t    for(var i = 0; i < len; i++) { args[i] = arguments[i]; }\n\t    var resultSelector = isFunction(args[len - 1]) ? args.pop() : argumentsToArray;\n\t    Array.isArray(args[0]) && (args = args[0]);\n\t\n\t    return new WithLatestFromObservable(this, args, resultSelector);\n\t  };\n\t\n\t  function falseFactory() { return false; }\n\t  function emptyArrayFactory() { return []; }\n\t\n\t  var ZipObservable = (function(__super__) {\n\t    inherits(ZipObservable, __super__);\n\t    function ZipObservable(sources, resultSelector) {\n\t      this._s = sources;\n\t      this._cb = resultSelector;\n\t      __super__.call(this);\n\t    }\n\t\n\t    ZipObservable.prototype.subscribeCore = function(observer) {\n\t      var n = this._s.length,\n\t          subscriptions = new Array(n),\n\t          done = arrayInitialize(n, falseFactory),\n\t          q = arrayInitialize(n, emptyArrayFactory);\n\t\n\t      for (var i = 0; i < n; i++) {\n\t        var source = this._s[i], sad = new SingleAssignmentDisposable();\n\t        subscriptions[i] = sad;\n\t        isPromise(source) && (source = observableFromPromise(source));\n\t        sad.setDisposable(source.subscribe(new ZipObserver(observer, i, this, q, done)));\n\t      }\n\t\n\t      return new NAryDisposable(subscriptions);\n\t    };\n\t\n\t    return ZipObservable;\n\t  }(ObservableBase));\n\t\n\t  var ZipObserver = (function (__super__) {\n\t    inherits(ZipObserver, __super__);\n\t    function ZipObserver(o, i, p, q, d) {\n\t      this._o = o;\n\t      this._i = i;\n\t      this._p = p;\n\t      this._q = q;\n\t      this._d = d;\n\t      __super__.call(this);\n\t    }\n\t\n\t    function notEmpty(x) { return x.length > 0; }\n\t    function shiftEach(x) { return x.shift(); }\n\t    function notTheSame(i) {\n\t      return function (x, j) {\n\t        return j !== i;\n\t      };\n\t    }\n\t\n\t    ZipObserver.prototype.next = function (x) {\n\t      this._q[this._i].push(x);\n\t      if (this._q.every(notEmpty)) {\n\t        var queuedValues = this._q.map(shiftEach);\n\t        var res = tryCatch(this._p._cb).apply(null, queuedValues);\n\t        if (res === errorObj) { return this._o.onError(res.e); }\n\t        this._o.onNext(res);\n\t      } else if (this._d.filter(notTheSame(this._i)).every(identity)) {\n\t        this._o.onCompleted();\n\t      }\n\t    };\n\t\n\t    ZipObserver.prototype.error = function (e) {\n\t      this._o.onError(e);\n\t    };\n\t\n\t    ZipObserver.prototype.completed = function () {\n\t      this._d[this._i] = true;\n\t      this._d.every(identity) && this._o.onCompleted();\n\t    };\n\t\n\t    return ZipObserver;\n\t  }(AbstractObserver));\n\t\n\t  /**\n\t   * Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences or an array have produced an element at a corresponding index.\n\t   * The last element in the arguments must be a function to invoke for each series of elements at corresponding indexes in the args.\n\t   * @returns {Observable} An observable sequence containing the result of combining elements of the args using the specified result selector function.\n\t   */\n\t  observableProto.zip = function () {\n\t    if (arguments.length === 0) { throw new Error('invalid arguments'); }\n\t\n\t    var len = arguments.length, args = new Array(len);\n\t    for(var i = 0; i < len; i++) { args[i] = arguments[i]; }\n\t    var resultSelector = isFunction(args[len - 1]) ? args.pop() : argumentsToArray;\n\t    Array.isArray(args[0]) && (args = args[0]);\n\t\n\t    var parent = this;\n\t    args.unshift(parent);\n\t\n\t    return new ZipObservable(args, resultSelector);\n\t  };\n\t\n\t  /**\n\t   * Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences have produced an element at a corresponding index.\n\t   * @param arguments Observable sources.\n\t   * @param {Function} resultSelector Function to invoke for each series of elements at corresponding indexes in the sources.\n\t   * @returns {Observable} An observable sequence containing the result of combining elements of the sources using the specified result selector function.\n\t   */\n\t  Observable.zip = function () {\n\t    var len = arguments.length, args = new Array(len);\n\t    for(var i = 0; i < len; i++) { args[i] = arguments[i]; }\n\t    if (Array.isArray(args[0])) {\n\t      args = isFunction(args[1]) ? args[0].concat(args[1]) : args[0];\n\t    }\n\t    var first = args.shift();\n\t    return first.zip.apply(first, args);\n\t  };\n\t\n\tfunction falseFactory() { return false; }\n\tfunction emptyArrayFactory() { return []; }\n\tfunction argumentsToArray() {\n\t  var len = arguments.length, args = new Array(len);\n\t  for(var i = 0; i < len; i++) { args[i] = arguments[i]; }\n\t  return args;\n\t}\n\t\n\tvar ZipIterableObservable = (function(__super__) {\n\t  inherits(ZipIterableObservable, __super__);\n\t  function ZipIterableObservable(sources, cb) {\n\t    this.sources = sources;\n\t    this._cb = cb;\n\t    __super__.call(this);\n\t  }\n\t\n\t  ZipIterableObservable.prototype.subscribeCore = function (o) {\n\t    var sources = this.sources, len = sources.length, subscriptions = new Array(len);\n\t\n\t    var state = {\n\t      q: arrayInitialize(len, emptyArrayFactory),\n\t      done: arrayInitialize(len, falseFactory),\n\t      cb: this._cb,\n\t      o: o\n\t    };\n\t\n\t    for (var i = 0; i < len; i++) {\n\t      (function (i) {\n\t        var source = sources[i], sad = new SingleAssignmentDisposable();\n\t        (isArrayLike(source) || isIterable(source)) && (source = observableFrom(source));\n\t\n\t        subscriptions[i] = sad;\n\t        sad.setDisposable(source.subscribe(new ZipIterableObserver(state, i)));\n\t      }(i));\n\t    }\n\t\n\t    return new NAryDisposable(subscriptions);\n\t  };\n\t\n\t  return ZipIterableObservable;\n\t}(ObservableBase));\n\t\n\tvar ZipIterableObserver = (function (__super__) {\n\t  inherits(ZipIterableObserver, __super__);\n\t  function ZipIterableObserver(s, i) {\n\t    this._s = s;\n\t    this._i = i;\n\t    __super__.call(this);\n\t  }\n\t\n\t  function notEmpty(x) { return x.length > 0; }\n\t  function shiftEach(x) { return x.shift(); }\n\t  function notTheSame(i) {\n\t    return function (x, j) {\n\t      return j !== i;\n\t    };\n\t  }\n\t\n\t  ZipIterableObserver.prototype.next = function (x) {\n\t    this._s.q[this._i].push(x);\n\t    if (this._s.q.every(notEmpty)) {\n\t      var queuedValues = this._s.q.map(shiftEach),\n\t          res = tryCatch(this._s.cb).apply(null, queuedValues);\n\t      if (res === errorObj) { return this._s.o.onError(res.e); }\n\t      this._s.o.onNext(res);\n\t    } else if (this._s.done.filter(notTheSame(this._i)).every(identity)) {\n\t      this._s.o.onCompleted();\n\t    }\n\t  };\n\t\n\t  ZipIterableObserver.prototype.error = function (e) { this._s.o.onError(e); };\n\t\n\t  ZipIterableObserver.prototype.completed = function () {\n\t    this._s.done[this._i] = true;\n\t    this._s.done.every(identity) && this._s.o.onCompleted();\n\t  };\n\t\n\t  return ZipIterableObserver;\n\t}(AbstractObserver));\n\t\n\t/**\n\t * Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences or an array have produced an element at a corresponding index.\n\t * The last element in the arguments must be a function to invoke for each series of elements at corresponding indexes in the args.\n\t * @returns {Observable} An observable sequence containing the result of combining elements of the args using the specified result selector function.\n\t */\n\tobservableProto.zipIterable = function () {\n\t  if (arguments.length === 0) { throw new Error('invalid arguments'); }\n\t\n\t  var len = arguments.length, args = new Array(len);\n\t  for(var i = 0; i < len; i++) { args[i] = arguments[i]; }\n\t  var resultSelector = isFunction(args[len - 1]) ? args.pop() : argumentsToArray;\n\t\n\t  var parent = this;\n\t  args.unshift(parent);\n\t  return new ZipIterableObservable(args, resultSelector);\n\t};\n\t\n\t  function asObservable(source) {\n\t    return function subscribe(o) { return source.subscribe(o); };\n\t  }\n\t\n\t  /**\n\t   *  Hides the identity of an observable sequence.\n\t   * @returns {Observable} An observable sequence that hides the identity of the source sequence.\n\t   */\n\t  observableProto.asObservable = function () {\n\t    return new AnonymousObservable(asObservable(this), this);\n\t  };\n\t\n\t  function toArray(x) { return x.toArray(); }\n\t  function notEmpty(x) { return x.length > 0; }\n\t\n\t  /**\n\t   *  Projects each element of an observable sequence into zero or more buffers which are produced based on element count information.\n\t   * @param {Number} count Length of each buffer.\n\t   * @param {Number} [skip] Number of elements to skip between creation of consecutive buffers. If not provided, defaults to the count.\n\t   * @returns {Observable} An observable sequence of buffers.\n\t   */\n\t  observableProto.bufferWithCount = function (count, skip) {\n\t    typeof skip !== 'number' && (skip = count);\n\t    return this.windowWithCount(count, skip)\n\t      .flatMap(toArray)\n\t      .filter(notEmpty);\n\t  };\n\t\n\t  var DematerializeObservable = (function (__super__) {\n\t    inherits(DematerializeObservable, __super__);\n\t    function DematerializeObservable(source) {\n\t      this.source = source;\n\t      __super__.call(this);\n\t    }\n\t\n\t    DematerializeObservable.prototype.subscribeCore = function (o) {\n\t      return this.source.subscribe(new DematerializeObserver(o));\n\t    };\n\t\n\t    return DematerializeObservable;\n\t  }(ObservableBase));\n\t\n\t  var DematerializeObserver = (function (__super__) {\n\t    inherits(DematerializeObserver, __super__);\n\t\n\t    function DematerializeObserver(o) {\n\t      this._o = o;\n\t      __super__.call(this);\n\t    }\n\t\n\t    DematerializeObserver.prototype.next = function (x) { x.accept(this._o); };\n\t    DematerializeObserver.prototype.error = function (e) { this._o.onError(e); };\n\t    DematerializeObserver.prototype.completed = function () { this._o.onCompleted(); };\n\t\n\t    return DematerializeObserver;\n\t  }(AbstractObserver));\n\t\n\t  /**\n\t   * Dematerializes the explicit notification values of an observable sequence as implicit notifications.\n\t   * @returns {Observable} An observable sequence exhibiting the behavior corresponding to the source sequence's notification values.\n\t   */\n\t  observableProto.dematerialize = function () {\n\t    return new DematerializeObservable(this);\n\t  };\n\t\n\t  var DistinctUntilChangedObservable = (function(__super__) {\n\t    inherits(DistinctUntilChangedObservable, __super__);\n\t    function DistinctUntilChangedObservable(source, keyFn, comparer) {\n\t      this.source = source;\n\t      this.keyFn = keyFn;\n\t      this.comparer = comparer;\n\t      __super__.call(this);\n\t    }\n\t\n\t    DistinctUntilChangedObservable.prototype.subscribeCore = function (o) {\n\t      return this.source.subscribe(new DistinctUntilChangedObserver(o, this.keyFn, this.comparer));\n\t    };\n\t\n\t    return DistinctUntilChangedObservable;\n\t  }(ObservableBase));\n\t\n\t  var DistinctUntilChangedObserver = (function(__super__) {\n\t    inherits(DistinctUntilChangedObserver, __super__);\n\t    function DistinctUntilChangedObserver(o, keyFn, comparer) {\n\t      this.o = o;\n\t      this.keyFn = keyFn;\n\t      this.comparer = comparer;\n\t      this.hasCurrentKey = false;\n\t      this.currentKey = null;\n\t      __super__.call(this);\n\t    }\n\t\n\t    DistinctUntilChangedObserver.prototype.next = function (x) {\n\t      var key = x, comparerEquals;\n\t      if (isFunction(this.keyFn)) {\n\t        key = tryCatch(this.keyFn)(x);\n\t        if (key === errorObj) { return this.o.onError(key.e); }\n\t      }\n\t      if (this.hasCurrentKey) {\n\t        comparerEquals = tryCatch(this.comparer)(this.currentKey, key);\n\t        if (comparerEquals === errorObj) { return this.o.onError(comparerEquals.e); }\n\t      }\n\t      if (!this.hasCurrentKey || !comparerEquals) {\n\t        this.hasCurrentKey = true;\n\t        this.currentKey = key;\n\t        this.o.onNext(x);\n\t      }\n\t    };\n\t    DistinctUntilChangedObserver.prototype.error = function(e) {\n\t      this.o.onError(e);\n\t    };\n\t    DistinctUntilChangedObserver.prototype.completed = function () {\n\t      this.o.onCompleted();\n\t    };\n\t\n\t    return DistinctUntilChangedObserver;\n\t  }(AbstractObserver));\n\t\n\t  /**\n\t  *  Returns an observable sequence that contains only distinct contiguous elements according to the keyFn and the comparer.\n\t  * @param {Function} [keyFn] A function to compute the comparison key for each element. If not provided, it projects the value.\n\t  * @param {Function} [comparer] Equality comparer for computed key values. If not provided, defaults to an equality comparer function.\n\t  * @returns {Observable} An observable sequence only containing the distinct contiguous elements, based on a computed key value, from the source sequence.\n\t  */\n\t  observableProto.distinctUntilChanged = function (keyFn, comparer) {\n\t    comparer || (comparer = defaultComparer);\n\t    return new DistinctUntilChangedObservable(this, keyFn, comparer);\n\t  };\n\t\n\t  var TapObservable = (function(__super__) {\n\t    inherits(TapObservable,__super__);\n\t    function TapObservable(source, observerOrOnNext, onError, onCompleted) {\n\t      this.source = source;\n\t      this._oN = observerOrOnNext;\n\t      this._oE = onError;\n\t      this._oC = onCompleted;\n\t      __super__.call(this);\n\t    }\n\t\n\t    TapObservable.prototype.subscribeCore = function(o) {\n\t      return this.source.subscribe(new InnerObserver(o, this));\n\t    };\n\t\n\t    inherits(InnerObserver, AbstractObserver);\n\t    function InnerObserver(o, p) {\n\t      this.o = o;\n\t      this.t = !p._oN || isFunction(p._oN) ?\n\t        observerCreate(p._oN || noop, p._oE || noop, p._oC || noop) :\n\t        p._oN;\n\t      this.isStopped = false;\n\t      AbstractObserver.call(this);\n\t    }\n\t    InnerObserver.prototype.next = function(x) {\n\t      var res = tryCatch(this.t.onNext).call(this.t, x);\n\t      if (res === errorObj) { this.o.onError(res.e); }\n\t      this.o.onNext(x);\n\t    };\n\t    InnerObserver.prototype.error = function(err) {\n\t      var res = tryCatch(this.t.onError).call(this.t, err);\n\t      if (res === errorObj) { return this.o.onError(res.e); }\n\t      this.o.onError(err);\n\t    };\n\t    InnerObserver.prototype.completed = function() {\n\t      var res = tryCatch(this.t.onCompleted).call(this.t);\n\t      if (res === errorObj) { return this.o.onError(res.e); }\n\t      this.o.onCompleted();\n\t    };\n\t\n\t    return TapObservable;\n\t  }(ObservableBase));\n\t\n\t  /**\n\t  *  Invokes an action for each element in the observable sequence and invokes an action upon graceful or exceptional termination of the observable sequence.\n\t  *  This method can be used for debugging, logging, etc. of query behavior by intercepting the message stream to run arbitrary actions for messages on the pipeline.\n\t  * @param {Function | Observer} observerOrOnNext Action to invoke for each element in the observable sequence or an o.\n\t  * @param {Function} [onError]  Action to invoke upon exceptional termination of the observable sequence. Used if only the observerOrOnNext parameter is also a function.\n\t  * @param {Function} [onCompleted]  Action to invoke upon graceful termination of the observable sequence. Used if only the observerOrOnNext parameter is also a function.\n\t  * @returns {Observable} The source sequence with the side-effecting behavior applied.\n\t  */\n\t  observableProto['do'] = observableProto.tap = observableProto.doAction = function (observerOrOnNext, onError, onCompleted) {\n\t    return new TapObservable(this, observerOrOnNext, onError, onCompleted);\n\t  };\n\t\n\t  /**\n\t  *  Invokes an action for each element in the observable sequence.\n\t  *  This method can be used for debugging, logging, etc. of query behavior by intercepting the message stream to run arbitrary actions for messages on the pipeline.\n\t  * @param {Function} onNext Action to invoke for each element in the observable sequence.\n\t  * @param {Any} [thisArg] Object to use as this when executing callback.\n\t  * @returns {Observable} The source sequence with the side-effecting behavior applied.\n\t  */\n\t  observableProto.doOnNext = observableProto.tapOnNext = function (onNext, thisArg) {\n\t    return this.tap(typeof thisArg !== 'undefined' ? function (x) { onNext.call(thisArg, x); } : onNext);\n\t  };\n\t\n\t  /**\n\t  *  Invokes an action upon exceptional termination of the observable sequence.\n\t  *  This method can be used for debugging, logging, etc. of query behavior by intercepting the message stream to run arbitrary actions for messages on the pipeline.\n\t  * @param {Function} onError Action to invoke upon exceptional termination of the observable sequence.\n\t  * @param {Any} [thisArg] Object to use as this when executing callback.\n\t  * @returns {Observable} The source sequence with the side-effecting behavior applied.\n\t  */\n\t  observableProto.doOnError = observableProto.tapOnError = function (onError, thisArg) {\n\t    return this.tap(noop, typeof thisArg !== 'undefined' ? function (e) { onError.call(thisArg, e); } : onError);\n\t  };\n\t\n\t  /**\n\t  *  Invokes an action upon graceful termination of the observable sequence.\n\t  *  This method can be used for debugging, logging, etc. of query behavior by intercepting the message stream to run arbitrary actions for messages on the pipeline.\n\t  * @param {Function} onCompleted Action to invoke upon graceful termination of the observable sequence.\n\t  * @param {Any} [thisArg] Object to use as this when executing callback.\n\t  * @returns {Observable} The source sequence with the side-effecting behavior applied.\n\t  */\n\t  observableProto.doOnCompleted = observableProto.tapOnCompleted = function (onCompleted, thisArg) {\n\t    return this.tap(noop, null, typeof thisArg !== 'undefined' ? function () { onCompleted.call(thisArg); } : onCompleted);\n\t  };\n\t\n\t  var FinallyObservable = (function (__super__) {\n\t    inherits(FinallyObservable, __super__);\n\t    function FinallyObservable(source, fn, thisArg) {\n\t      this.source = source;\n\t      this._fn = bindCallback(fn, thisArg, 0);\n\t      __super__.call(this);\n\t    }\n\t\n\t    FinallyObservable.prototype.subscribeCore = function (o) {\n\t      var d = tryCatch(this.source.subscribe).call(this.source, o);\n\t      if (d === errorObj) {\n\t        this._fn();\n\t        thrower(d.e);\n\t      }\n\t\n\t      return new FinallyDisposable(d, this._fn);\n\t    };\n\t\n\t    function FinallyDisposable(s, fn) {\n\t      this.isDisposed = false;\n\t      this._s = s;\n\t      this._fn = fn;\n\t    }\n\t    FinallyDisposable.prototype.dispose = function () {\n\t      if (!this.isDisposed) {\n\t        var res = tryCatch(this._s.dispose).call(this._s);\n\t        this._fn();\n\t        res === errorObj && thrower(res.e);\n\t      }\n\t    };\n\t\n\t    return FinallyObservable;\n\t\n\t  }(ObservableBase));\n\t\n\t  /**\n\t   *  Invokes a specified action after the source observable sequence terminates gracefully or exceptionally.\n\t   * @param {Function} finallyAction Action to invoke after the source observable sequence terminates.\n\t   * @returns {Observable} Source sequence with the action-invoking termination behavior applied.\n\t   */\n\t  observableProto['finally'] = function (action, thisArg) {\n\t    return new FinallyObservable(this, action, thisArg);\n\t  };\n\t\n\t  var IgnoreElementsObservable = (function(__super__) {\n\t    inherits(IgnoreElementsObservable, __super__);\n\t\n\t    function IgnoreElementsObservable(source) {\n\t      this.source = source;\n\t      __super__.call(this);\n\t    }\n\t\n\t    IgnoreElementsObservable.prototype.subscribeCore = function (o) {\n\t      return this.source.subscribe(new InnerObserver(o));\n\t    };\n\t\n\t    function InnerObserver(o) {\n\t      this.o = o;\n\t      this.isStopped = false;\n\t    }\n\t    InnerObserver.prototype.onNext = noop;\n\t    InnerObserver.prototype.onError = function (err) {\n\t      if(!this.isStopped) {\n\t        this.isStopped = true;\n\t        this.o.onError(err);\n\t      }\n\t    };\n\t    InnerObserver.prototype.onCompleted = function () {\n\t      if(!this.isStopped) {\n\t        this.isStopped = true;\n\t        this.o.onCompleted();\n\t      }\n\t    };\n\t    InnerObserver.prototype.dispose = function() { this.isStopped = true; };\n\t    InnerObserver.prototype.fail = function (e) {\n\t      if (!this.isStopped) {\n\t        this.isStopped = true;\n\t        this.observer.onError(e);\n\t        return true;\n\t      }\n\t\n\t      return false;\n\t    };\n\t\n\t    return IgnoreElementsObservable;\n\t  }(ObservableBase));\n\t\n\t  /**\n\t   *  Ignores all elements in an observable sequence leaving only the termination messages.\n\t   * @returns {Observable} An empty observable sequence that signals termination, successful or exceptional, of the source sequence.\n\t   */\n\t  observableProto.ignoreElements = function () {\n\t    return new IgnoreElementsObservable(this);\n\t  };\n\t\n\t  var MaterializeObservable = (function (__super__) {\n\t    inherits(MaterializeObservable, __super__);\n\t    function MaterializeObservable(source, fn) {\n\t      this.source = source;\n\t      __super__.call(this);\n\t    }\n\t\n\t    MaterializeObservable.prototype.subscribeCore = function (o) {\n\t      return this.source.subscribe(new MaterializeObserver(o));\n\t    };\n\t\n\t    return MaterializeObservable;\n\t  }(ObservableBase));\n\t\n\t  var MaterializeObserver = (function (__super__) {\n\t    inherits(MaterializeObserver, __super__);\n\t\n\t    function MaterializeObserver(o) {\n\t      this._o = o;\n\t      __super__.call(this);\n\t    }\n\t\n\t    MaterializeObserver.prototype.next = function (x) { this._o.onNext(notificationCreateOnNext(x)) };\n\t    MaterializeObserver.prototype.error = function (e) { this._o.onNext(notificationCreateOnError(e)); this._o.onCompleted(); };\n\t    MaterializeObserver.prototype.completed = function () { this._o.onNext(notificationCreateOnCompleted()); this._o.onCompleted(); };\n\t\n\t    return MaterializeObserver;\n\t  }(AbstractObserver));\n\t\n\t  /**\n\t   *  Materializes the implicit notifications of an observable sequence as explicit notification values.\n\t   * @returns {Observable} An observable sequence containing the materialized notification values from the source sequence.\n\t   */\n\t  observableProto.materialize = function () {\n\t    return new MaterializeObservable(this);\n\t  };\n\t\n\t  /**\n\t   *  Repeats the observable sequence a specified number of times. If the repeat count is not specified, the sequence repeats indefinitely.\n\t   * @param {Number} [repeatCount]  Number of times to repeat the sequence. If not provided, repeats the sequence indefinitely.\n\t   * @returns {Observable} The observable sequence producing the elements of the given sequence repeatedly.\n\t   */\n\t  observableProto.repeat = function (repeatCount) {\n\t    return enumerableRepeat(this, repeatCount).concat();\n\t  };\n\t\n\t  /**\n\t   *  Repeats the source observable sequence the specified number of times or until it successfully terminates. If the retry count is not specified, it retries indefinitely.\n\t   *  Note if you encounter an error and want it to retry once, then you must use .retry(2);\n\t   *\n\t   * @example\n\t   *  var res = retried = retry.repeat();\n\t   *  var res = retried = retry.repeat(2);\n\t   * @param {Number} [retryCount]  Number of times to retry the sequence. If not provided, retry the sequence indefinitely.\n\t   * @returns {Observable} An observable sequence producing the elements of the given sequence repeatedly until it terminates successfully.\n\t   */\n\t  observableProto.retry = function (retryCount) {\n\t    return enumerableRepeat(this, retryCount).catchError();\n\t  };\n\t\n\t  /**\n\t   *  Repeats the source observable sequence upon error each time the notifier emits or until it successfully terminates. \n\t   *  if the notifier completes, the observable sequence completes.\n\t   *\n\t   * @example\n\t   *  var timer = Observable.timer(500);\n\t   *  var source = observable.retryWhen(timer);\n\t   * @param {Observable} [notifier] An observable that triggers the retries or completes the observable with onNext or onCompleted respectively.\n\t   * @returns {Observable} An observable sequence producing the elements of the given sequence repeatedly until it terminates successfully.\n\t   */\n\t  observableProto.retryWhen = function (notifier) {\n\t    return enumerableRepeat(this).catchErrorWhen(notifier);\n\t  };\n\t  var ScanObservable = (function(__super__) {\n\t    inherits(ScanObservable, __super__);\n\t    function ScanObservable(source, accumulator, hasSeed, seed) {\n\t      this.source = source;\n\t      this.accumulator = accumulator;\n\t      this.hasSeed = hasSeed;\n\t      this.seed = seed;\n\t      __super__.call(this);\n\t    }\n\t\n\t    ScanObservable.prototype.subscribeCore = function(o) {\n\t      return this.source.subscribe(new ScanObserver(o,this));\n\t    };\n\t\n\t    return ScanObservable;\n\t  }(ObservableBase));\n\t\n\t  var ScanObserver = (function (__super__) {\n\t    inherits(ScanObserver, __super__);\n\t    function ScanObserver(o, parent) {\n\t      this._o = o;\n\t      this._p = parent;\n\t      this._fn = parent.accumulator;\n\t      this._hs = parent.hasSeed;\n\t      this._s = parent.seed;\n\t      this._ha = false;\n\t      this._a = null;\n\t      this._hv = false;\n\t      this._i = 0;\n\t      __super__.call(this);\n\t    }\n\t\n\t    ScanObserver.prototype.next = function (x) {\n\t      !this._hv && (this._hv = true);\n\t      if (this._ha) {\n\t        this._a = tryCatch(this._fn)(this._a, x, this._i, this._p);\n\t      } else {\n\t        this._a = this._hs ? tryCatch(this._fn)(this._s, x, this._i, this._p) : x;\n\t        this._ha = true;\n\t      }\n\t      if (this._a === errorObj) { return this._o.onError(this._a.e); }\n\t      this._o.onNext(this._a);\n\t      this._i++;\n\t    };\n\t\n\t    ScanObserver.prototype.error = function (e) {\n\t      this._o.onError(e);\n\t    };\n\t\n\t    ScanObserver.prototype.completed = function () {\n\t      !this._hv && this._hs && this._o.onNext(this._s);\n\t      this._o.onCompleted();\n\t    };\n\t\n\t    return ScanObserver;\n\t  }(AbstractObserver));\n\t\n\t  /**\n\t  *  Applies an accumulator function over an observable sequence and returns each intermediate result. The optional seed value is used as the initial accumulator value.\n\t  *  For aggregation behavior with no intermediate results, see Observable.aggregate.\n\t  * @param {Mixed} [seed] The initial accumulator value.\n\t  * @param {Function} accumulator An accumulator function to be invoked on each element.\n\t  * @returns {Observable} An observable sequence containing the accumulated values.\n\t  */\n\t  observableProto.scan = function () {\n\t    var hasSeed = false, seed, accumulator = arguments[0];\n\t    if (arguments.length === 2) {\n\t      hasSeed = true;\n\t      seed = arguments[1];\n\t    }\n\t    return new ScanObservable(this, accumulator, hasSeed, seed);\n\t  };\n\t\n\t  var SkipLastObservable = (function (__super__) {\n\t    inherits(SkipLastObservable, __super__);\n\t    function SkipLastObservable(source, c) {\n\t      this.source = source;\n\t      this._c = c;\n\t      __super__.call(this);\n\t    }\n\t\n\t    SkipLastObservable.prototype.subscribeCore = function (o) {\n\t      return this.source.subscribe(new SkipLastObserver(o, this._c));\n\t    };\n\t\n\t    return SkipLastObservable;\n\t  }(ObservableBase));\n\t\n\t  var SkipLastObserver = (function (__super__) {\n\t    inherits(SkipLastObserver, __super__);\n\t    function SkipLastObserver(o, c) {\n\t      this._o = o;\n\t      this._c = c;\n\t      this._q = [];\n\t      __super__.call(this);\n\t    }\n\t\n\t    SkipLastObserver.prototype.next = function (x) {\n\t      this._q.push(x);\n\t      this._q.length > this._c && this._o.onNext(this._q.shift());\n\t    };\n\t\n\t    SkipLastObserver.prototype.error = function (e) {\n\t      this._o.onError(e);\n\t    };\n\t\n\t    SkipLastObserver.prototype.completed = function () {\n\t      this._o.onCompleted();\n\t    };\n\t\n\t    return SkipLastObserver;\n\t  }(AbstractObserver));\n\t\n\t  /**\n\t   *  Bypasses a specified number of elements at the end of an observable sequence.\n\t   * @description\n\t   *  This operator accumulates a queue with a length enough to store the first `count` elements. As more elements are\n\t   *  received, elements are taken from the front of the queue and produced on the result sequence. This causes elements to be delayed.\n\t   * @param count Number of elements to bypass at the end of the source sequence.\n\t   * @returns {Observable} An observable sequence containing the source sequence elements except for the bypassed ones at the end.\n\t   */\n\t  observableProto.skipLast = function (count) {\n\t    if (count < 0) { throw new ArgumentOutOfRangeError(); }\n\t    return new SkipLastObservable(this, count);\n\t  };\n\t\n\t  /**\n\t   *  Prepends a sequence of values to an observable sequence with an optional scheduler and an argument list of values to prepend.\n\t   *  @example\n\t   *  var res = source.startWith(1, 2, 3);\n\t   *  var res = source.startWith(Rx.Scheduler.timeout, 1, 2, 3);\n\t   * @param {Arguments} args The specified values to prepend to the observable sequence\n\t   * @returns {Observable} The source sequence prepended with the specified values.\n\t   */\n\t  observableProto.startWith = function () {\n\t    var values, scheduler, start = 0;\n\t    if (!!arguments.length && isScheduler(arguments[0])) {\n\t      scheduler = arguments[0];\n\t      start = 1;\n\t    } else {\n\t      scheduler = immediateScheduler;\n\t    }\n\t    for(var args = [], i = start, len = arguments.length; i < len; i++) { args.push(arguments[i]); }\n\t    return enumerableOf([observableFromArray(args, scheduler), this]).concat();\n\t  };\n\t\n\t  var TakeLastObserver = (function (__super__) {\n\t    inherits(TakeLastObserver, __super__);\n\t    function TakeLastObserver(o, c) {\n\t      this._o = o;\n\t      this._c = c;\n\t      this._q = [];\n\t      __super__.call(this);\n\t    }\n\t\n\t    TakeLastObserver.prototype.next = function (x) {\n\t      this._q.push(x);\n\t      this._q.length > this._c && this._q.shift();\n\t    };\n\t\n\t    TakeLastObserver.prototype.error = function (e) {\n\t      this._o.onError(e);\n\t    };\n\t\n\t    TakeLastObserver.prototype.completed = function () {\n\t      while (this._q.length > 0) { this._o.onNext(this._q.shift()); }\n\t      this._o.onCompleted();\n\t    };\n\t\n\t    return TakeLastObserver;\n\t  }(AbstractObserver));\n\t\n\t  /**\n\t   *  Returns a specified number of contiguous elements from the end of an observable sequence.\n\t   * @description\n\t   *  This operator accumulates a buffer with a length enough to store elements count elements. Upon completion of\n\t   *  the source sequence, this buffer is drained on the result sequence. This causes the elements to be delayed.\n\t   * @param {Number} count Number of elements to take from the end of the source sequence.\n\t   * @returns {Observable} An observable sequence containing the specified number of elements from the end of the source sequence.\n\t   */\n\t  observableProto.takeLast = function (count) {\n\t    if (count < 0) { throw new ArgumentOutOfRangeError(); }\n\t    var source = this;\n\t    return new AnonymousObservable(function (o) {\n\t      return source.subscribe(new TakeLastObserver(o, count));\n\t    }, source);\n\t  };\n\t\n\t  var TakeLastBufferObserver = (function (__super__) {\n\t    inherits(TakeLastBufferObserver, __super__);\n\t    function TakeLastBufferObserver(o, c) {\n\t      this._o = o;\n\t      this._c = c;\n\t      this._q = [];\n\t      __super__.call(this);\n\t    }\n\t\n\t    TakeLastBufferObserver.prototype.next = function (x) {\n\t      this._q.push(x);\n\t      this._q.length > this._c && this._q.shift();\n\t    };\n\t\n\t    TakeLastBufferObserver.prototype.error = function (e) {\n\t      this._o.onError(e);\n\t    };\n\t\n\t    TakeLastBufferObserver.prototype.completed = function () {\n\t      this._o.onNext(this._q);\n\t      this._o.onCompleted();\n\t    };\n\t\n\t    return TakeLastBufferObserver;\n\t  }(AbstractObserver));\n\t\n\t  /**\n\t   *  Returns an array with the specified number of contiguous elements from the end of an observable sequence.\n\t   *\n\t   * @description\n\t   *  This operator accumulates a buffer with a length enough to store count elements. Upon completion of the\n\t   *  source sequence, this buffer is produced on the result sequence.\n\t   * @param {Number} count Number of elements to take from the end of the source sequence.\n\t   * @returns {Observable} An observable sequence containing a single array with the specified number of elements from the end of the source sequence.\n\t   */\n\t  observableProto.takeLastBuffer = function (count) {\n\t    if (count < 0) { throw new ArgumentOutOfRangeError(); }\n\t    var source = this;\n\t    return new AnonymousObservable(function (o) {\n\t      return source.subscribe(new TakeLastBufferObserver(o, count));\n\t    }, source);\n\t  };\n\t\n\t  /**\n\t   *  Projects each element of an observable sequence into zero or more windows which are produced based on element count information.\n\t   * @param {Number} count Length of each window.\n\t   * @param {Number} [skip] Number of elements to skip between creation of consecutive windows. If not specified, defaults to the count.\n\t   * @returns {Observable} An observable sequence of windows.\n\t   */\n\t  observableProto.windowWithCount = function (count, skip) {\n\t    var source = this;\n\t    +count || (count = 0);\n\t    Math.abs(count) === Infinity && (count = 0);\n\t    if (count <= 0) { throw new ArgumentOutOfRangeError(); }\n\t    skip == null && (skip = count);\n\t    +skip || (skip = 0);\n\t    Math.abs(skip) === Infinity && (skip = 0);\n\t\n\t    if (skip <= 0) { throw new ArgumentOutOfRangeError(); }\n\t    return new AnonymousObservable(function (observer) {\n\t      var m = new SingleAssignmentDisposable(),\n\t        refCountDisposable = new RefCountDisposable(m),\n\t        n = 0,\n\t        q = [];\n\t\n\t      function createWindow () {\n\t        var s = new Subject();\n\t        q.push(s);\n\t        observer.onNext(addRef(s, refCountDisposable));\n\t      }\n\t\n\t      createWindow();\n\t\n\t      m.setDisposable(source.subscribe(\n\t        function (x) {\n\t          for (var i = 0, len = q.length; i < len; i++) { q[i].onNext(x); }\n\t          var c = n - count + 1;\n\t          c >= 0 && c % skip === 0 && q.shift().onCompleted();\n\t          ++n % skip === 0 && createWindow();\n\t        },\n\t        function (e) {\n\t          while (q.length > 0) { q.shift().onError(e); }\n\t          observer.onError(e);\n\t        },\n\t        function () {\n\t          while (q.length > 0) { q.shift().onCompleted(); }\n\t          observer.onCompleted();\n\t        }\n\t      ));\n\t      return refCountDisposable;\n\t    }, source);\n\t  };\n\t\n\t  function concatMap(source, selector, thisArg) {\n\t    var selectorFunc = bindCallback(selector, thisArg, 3);\n\t    return source.map(function (x, i) {\n\t      var result = selectorFunc(x, i, source);\n\t      isPromise(result) && (result = observableFromPromise(result));\n\t      (isArrayLike(result) || isIterable(result)) && (result = observableFrom(result));\n\t      return result;\n\t    }).concatAll();\n\t  }\n\t\n\t  /**\n\t   *  One of the Following:\n\t   *  Projects each element of an observable sequence to an observable sequence and merges the resulting observable sequences into one observable sequence.\n\t   *\n\t   * @example\n\t   *  var res = source.concatMap(function (x) { return Rx.Observable.range(0, x); });\n\t   *  Or:\n\t   *  Projects each element of an observable sequence to an observable sequence, invokes the result selector for the source element and each of the corresponding inner sequence's elements, and merges the results into one observable sequence.\n\t   *\n\t   *  var res = source.concatMap(function (x) { return Rx.Observable.range(0, x); }, function (x, y) { return x + y; });\n\t   *  Or:\n\t   *  Projects each element of the source observable sequence to the other observable sequence and merges the resulting observable sequences into one observable sequence.\n\t   *\n\t   *  var res = source.concatMap(Rx.Observable.fromArray([1,2,3]));\n\t   * @param {Function} selector A transform function to apply to each element or an observable sequence to project each element from the\n\t   * source sequence onto which could be either an observable or Promise.\n\t   * @param {Function} [resultSelector]  A transform function to apply to each element of the intermediate sequence.\n\t   * @returns {Observable} An observable sequence whose elements are the result of invoking the one-to-many transform function collectionSelector on each element of the input sequence and then mapping each of those sequence elements and their corresponding source element to a result element.\n\t   */\n\t  observableProto.selectConcat = observableProto.concatMap = function (selector, resultSelector, thisArg) {\n\t    if (isFunction(selector) && isFunction(resultSelector)) {\n\t      return this.concatMap(function (x, i) {\n\t        var selectorResult = selector(x, i);\n\t        isPromise(selectorResult) && (selectorResult = observableFromPromise(selectorResult));\n\t        (isArrayLike(selectorResult) || isIterable(selectorResult)) && (selectorResult = observableFrom(selectorResult));\n\t\n\t        return selectorResult.map(function (y, i2) {\n\t          return resultSelector(x, y, i, i2);\n\t        });\n\t      });\n\t    }\n\t    return isFunction(selector) ?\n\t      concatMap(this, selector, thisArg) :\n\t      concatMap(this, function () { return selector; });\n\t  };\n\t\n\t  /**\n\t   * Projects each notification of an observable sequence to an observable sequence and concats the resulting observable sequences into one observable sequence.\n\t   * @param {Function} onNext A transform function to apply to each element; the second parameter of the function represents the index of the source element.\n\t   * @param {Function} onError A transform function to apply when an error occurs in the source sequence.\n\t   * @param {Function} onCompleted A transform function to apply when the end of the source sequence is reached.\n\t   * @param {Any} [thisArg] An optional \"this\" to use to invoke each transform.\n\t   * @returns {Observable} An observable sequence whose elements are the result of invoking the one-to-many transform function corresponding to each notification in the input sequence.\n\t   */\n\t  observableProto.concatMapObserver = observableProto.selectConcatObserver = function(onNext, onError, onCompleted, thisArg) {\n\t    var source = this,\n\t        onNextFunc = bindCallback(onNext, thisArg, 2),\n\t        onErrorFunc = bindCallback(onError, thisArg, 1),\n\t        onCompletedFunc = bindCallback(onCompleted, thisArg, 0);\n\t    return new AnonymousObservable(function (observer) {\n\t      var index = 0;\n\t      return source.subscribe(\n\t        function (x) {\n\t          var result;\n\t          try {\n\t            result = onNextFunc(x, index++);\n\t          } catch (e) {\n\t            observer.onError(e);\n\t            return;\n\t          }\n\t          isPromise(result) && (result = observableFromPromise(result));\n\t          observer.onNext(result);\n\t        },\n\t        function (err) {\n\t          var result;\n\t          try {\n\t            result = onErrorFunc(err);\n\t          } catch (e) {\n\t            observer.onError(e);\n\t            return;\n\t          }\n\t          isPromise(result) && (result = observableFromPromise(result));\n\t          observer.onNext(result);\n\t          observer.onCompleted();\n\t        },\n\t        function () {\n\t          var result;\n\t          try {\n\t            result = onCompletedFunc();\n\t          } catch (e) {\n\t            observer.onError(e);\n\t            return;\n\t          }\n\t          isPromise(result) && (result = observableFromPromise(result));\n\t          observer.onNext(result);\n\t          observer.onCompleted();\n\t        });\n\t    }, this).concatAll();\n\t  };\n\t\n\t  var DefaultIfEmptyObserver = (function (__super__) {\n\t    inherits(DefaultIfEmptyObserver, __super__);\n\t    function DefaultIfEmptyObserver(o, d) {\n\t      this._o = o;\n\t      this._d = d;\n\t      this._f = false;\n\t      __super__.call(this);\n\t    }\n\t\n\t    DefaultIfEmptyObserver.prototype.next = function (x) {\n\t      this._f = true;\n\t      this._o.onNext(x);\n\t    };\n\t\n\t    DefaultIfEmptyObserver.prototype.error = function (e) {\n\t      this._o.onError(e);\n\t    };\n\t\n\t    DefaultIfEmptyObserver.prototype.completed = function () {\n\t      !this._f && this._o.onNext(this._d);\n\t      this._o.onCompleted();\n\t    };\n\t\n\t    return DefaultIfEmptyObserver;\n\t  }(AbstractObserver));\n\t\n\t  /**\n\t   *  Returns the elements of the specified sequence or the specified value in a singleton sequence if the sequence is empty.\n\t   *\n\t   *  var res = obs = xs.defaultIfEmpty();\n\t   *  2 - obs = xs.defaultIfEmpty(false);\n\t   *\n\t   * @memberOf Observable#\n\t   * @param defaultValue The value to return if the sequence is empty. If not provided, this defaults to null.\n\t   * @returns {Observable} An observable sequence that contains the specified default value if the source is empty; otherwise, the elements of the source itself.\n\t   */\n\t    observableProto.defaultIfEmpty = function (defaultValue) {\n\t      var source = this;\n\t      defaultValue === undefined && (defaultValue = null);\n\t      return new AnonymousObservable(function (o) {\n\t        return source.subscribe(new DefaultIfEmptyObserver(o, defaultValue));\n\t      }, source);\n\t    };\n\t\n\t  // Swap out for Array.findIndex\n\t  function arrayIndexOfComparer(array, item, comparer) {\n\t    for (var i = 0, len = array.length; i < len; i++) {\n\t      if (comparer(array[i], item)) { return i; }\n\t    }\n\t    return -1;\n\t  }\n\t\n\t  function HashSet(comparer) {\n\t    this.comparer = comparer;\n\t    this.set = [];\n\t  }\n\t  HashSet.prototype.push = function(value) {\n\t    var retValue = arrayIndexOfComparer(this.set, value, this.comparer) === -1;\n\t    retValue && this.set.push(value);\n\t    return retValue;\n\t  };\n\t\n\t  var DistinctObservable = (function (__super__) {\n\t    inherits(DistinctObservable, __super__);\n\t    function DistinctObservable(source, keyFn, cmpFn) {\n\t      this.source = source;\n\t      this._keyFn = keyFn;\n\t      this._cmpFn = cmpFn;\n\t      __super__.call(this);\n\t    }\n\t\n\t    DistinctObservable.prototype.subscribeCore = function (o) {\n\t      return this.source.subscribe(new DistinctObserver(o, this._keyFn, this._cmpFn));\n\t    };\n\t\n\t    return DistinctObservable;\n\t  }(ObservableBase));\n\t\n\t  var DistinctObserver = (function (__super__) {\n\t    inherits(DistinctObserver, __super__);\n\t    function DistinctObserver(o, keyFn, cmpFn) {\n\t      this._o = o;\n\t      this._keyFn = keyFn;\n\t      this._h = new HashSet(cmpFn);\n\t      __super__.call(this);\n\t    }\n\t\n\t    DistinctObserver.prototype.next = function (x) {\n\t      var key = x;\n\t      if (isFunction(this._keyFn)) {\n\t        key = tryCatch(this._keyFn)(x);\n\t        if (key === errorObj) { return this._o.onError(key.e); }\n\t      }\n\t      this._h.push(key) && this._o.onNext(x);\n\t    };\n\t\n\t    DistinctObserver.prototype.error = function (e) { this._o.onError(e); };\n\t    DistinctObserver.prototype.completed = function () { this._o.onCompleted(); };\n\t\n\t    return DistinctObserver;\n\t  }(AbstractObserver));\n\t\n\t  /**\n\t   *  Returns an observable sequence that contains only distinct elements according to the keySelector and the comparer.\n\t   *  Usage of this operator should be considered carefully due to the maintenance of an internal lookup structure which can grow large.\n\t   *\n\t   * @example\n\t   *  var res = obs = xs.distinct();\n\t   *  2 - obs = xs.distinct(function (x) { return x.id; });\n\t   *  2 - obs = xs.distinct(function (x) { return x.id; }, function (a,b) { return a === b; });\n\t   * @param {Function} [keySelector]  A function to compute the comparison key for each element.\n\t   * @param {Function} [comparer]  Used to compare items in the collection.\n\t   * @returns {Observable} An observable sequence only containing the distinct elements, based on a computed key value, from the source sequence.\n\t   */\n\t  observableProto.distinct = function (keySelector, comparer) {\n\t    comparer || (comparer = defaultComparer);\n\t    return new DistinctObservable(this, keySelector, comparer);\n\t  };\n\t\n\t  /**\n\t   *  Groups the elements of an observable sequence according to a specified key selector function and comparer and selects the resulting elements by using a specified function.\n\t   *\n\t   * @example\n\t   *  var res = observable.groupBy(function (x) { return x.id; });\n\t   *  2 - observable.groupBy(function (x) { return x.id; }), function (x) { return x.name; });\n\t   *  3 - observable.groupBy(function (x) { return x.id; }), function (x) { return x.name; }, function (x) { return x.toString(); });\n\t   * @param {Function} keySelector A function to extract the key for each element.\n\t   * @param {Function} [elementSelector]  A function to map each source element to an element in an observable group.\n\t   * @returns {Observable} A sequence of observable groups, each of which corresponds to a unique key value, containing all elements that share that same key value.\n\t   */\n\t  observableProto.groupBy = function (keySelector, elementSelector) {\n\t    return this.groupByUntil(keySelector, elementSelector, observableNever);\n\t  };\n\t\n\t    /**\n\t     *  Groups the elements of an observable sequence according to a specified key selector function.\n\t     *  A duration selector function is used to control the lifetime of groups. When a group expires, it receives an OnCompleted notification. When a new element with the same\n\t     *  key value as a reclaimed group occurs, the group will be reborn with a new lifetime request.\n\t     *\n\t     * @example\n\t     *  var res = observable.groupByUntil(function (x) { return x.id; }, null,  function () { return Rx.Observable.never(); });\n\t     *  2 - observable.groupBy(function (x) { return x.id; }), function (x) { return x.name; },  function () { return Rx.Observable.never(); });\n\t     *  3 - observable.groupBy(function (x) { return x.id; }), function (x) { return x.name; },  function () { return Rx.Observable.never(); }, function (x) { return x.toString(); });\n\t     * @param {Function} keySelector A function to extract the key for each element.\n\t     * @param {Function} durationSelector A function to signal the expiration of a group.\n\t     * @returns {Observable}\n\t     *  A sequence of observable groups, each of which corresponds to a unique key value, containing all elements that share that same key value.\n\t     *  If a group's lifetime expires, a new group with the same key value can be created once an element with such a key value is encoutered.\n\t     *\n\t     */\n\t    observableProto.groupByUntil = function (keySelector, elementSelector, durationSelector) {\n\t      var source = this;\n\t      return new AnonymousObservable(function (o) {\n\t        var map = new Map(),\n\t          groupDisposable = new CompositeDisposable(),\n\t          refCountDisposable = new RefCountDisposable(groupDisposable),\n\t          handleError = function (e) { return function (item) { item.onError(e); }; };\n\t\n\t        groupDisposable.add(\n\t          source.subscribe(function (x) {\n\t            var key = tryCatch(keySelector)(x);\n\t            if (key === errorObj) {\n\t              map.forEach(handleError(key.e));\n\t              return o.onError(key.e);\n\t            }\n\t\n\t            var fireNewMapEntry = false, writer = map.get(key);\n\t            if (writer === undefined) {\n\t              writer = new Subject();\n\t              map.set(key, writer);\n\t              fireNewMapEntry = true;\n\t            }\n\t\n\t            if (fireNewMapEntry) {\n\t              var group = new GroupedObservable(key, writer, refCountDisposable),\n\t                durationGroup = new GroupedObservable(key, writer);\n\t              var duration = tryCatch(durationSelector)(durationGroup);\n\t              if (duration === errorObj) {\n\t                map.forEach(handleError(duration.e));\n\t                return o.onError(duration.e);\n\t              }\n\t\n\t              o.onNext(group);\n\t\n\t              var md = new SingleAssignmentDisposable();\n\t              groupDisposable.add(md);\n\t\n\t              md.setDisposable(duration.take(1).subscribe(\n\t                noop,\n\t                function (e) {\n\t                  map.forEach(handleError(e));\n\t                  o.onError(e);\n\t                },\n\t                function () {\n\t                  if (map['delete'](key)) { writer.onCompleted(); }\n\t                  groupDisposable.remove(md);\n\t                }));\n\t            }\n\t\n\t            var element = x;\n\t            if (isFunction(elementSelector)) {\n\t              element = tryCatch(elementSelector)(x);\n\t              if (element === errorObj) {\n\t                map.forEach(handleError(element.e));\n\t                return o.onError(element.e);\n\t              }\n\t            }\n\t\n\t            writer.onNext(element);\n\t        }, function (e) {\n\t          map.forEach(handleError(e));\n\t          o.onError(e);\n\t        }, function () {\n\t          map.forEach(function (item) { item.onCompleted(); });\n\t          o.onCompleted();\n\t        }));\n\t\n\t      return refCountDisposable;\n\t    }, source);\n\t  };\n\t\n\t  var MapObservable = (function (__super__) {\n\t    inherits(MapObservable, __super__);\n\t\n\t    function MapObservable(source, selector, thisArg) {\n\t      this.source = source;\n\t      this.selector = bindCallback(selector, thisArg, 3);\n\t      __super__.call(this);\n\t    }\n\t\n\t    function innerMap(selector, self) {\n\t      return function (x, i, o) { return selector.call(this, self.selector(x, i, o), i, o); };\n\t    }\n\t\n\t    MapObservable.prototype.internalMap = function (selector, thisArg) {\n\t      return new MapObservable(this.source, innerMap(selector, this), thisArg);\n\t    };\n\t\n\t    MapObservable.prototype.subscribeCore = function (o) {\n\t      return this.source.subscribe(new InnerObserver(o, this.selector, this));\n\t    };\n\t\n\t    inherits(InnerObserver, AbstractObserver);\n\t    function InnerObserver(o, selector, source) {\n\t      this.o = o;\n\t      this.selector = selector;\n\t      this.source = source;\n\t      this.i = 0;\n\t      AbstractObserver.call(this);\n\t    }\n\t\n\t    InnerObserver.prototype.next = function(x) {\n\t      var result = tryCatch(this.selector)(x, this.i++, this.source);\n\t      if (result === errorObj) { return this.o.onError(result.e); }\n\t      this.o.onNext(result);\n\t    };\n\t\n\t    InnerObserver.prototype.error = function (e) {\n\t      this.o.onError(e);\n\t    };\n\t\n\t    InnerObserver.prototype.completed = function () {\n\t      this.o.onCompleted();\n\t    };\n\t\n\t    return MapObservable;\n\t\n\t  }(ObservableBase));\n\t\n\t  /**\n\t  * Projects each element of an observable sequence into a new form by incorporating the element's index.\n\t  * @param {Function} selector A transform function to apply to each source element; the second parameter of the function represents the index of the source element.\n\t  * @param {Any} [thisArg] Object to use as this when executing callback.\n\t  * @returns {Observable} An observable sequence whose elements are the result of invoking the transform function on each element of source.\n\t  */\n\t  observableProto.map = observableProto.select = function (selector, thisArg) {\n\t    var selectorFn = typeof selector === 'function' ? selector : function () { return selector; };\n\t    return this instanceof MapObservable ?\n\t      this.internalMap(selectorFn, thisArg) :\n\t      new MapObservable(this, selectorFn, thisArg);\n\t  };\n\t\n\t  function plucker(args, len) {\n\t    return function mapper(x) {\n\t      var currentProp = x;\n\t      for (var i = 0; i < len; i++) {\n\t        var p = currentProp[args[i]];\n\t        if (typeof p !== 'undefined') {\n\t          currentProp = p;\n\t        } else {\n\t          return undefined;\n\t        }\n\t      }\n\t      return currentProp;\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Retrieves the value of a specified nested property from all elements in\n\t   * the Observable sequence.\n\t   * @param {Arguments} arguments The nested properties to pluck.\n\t   * @returns {Observable} Returns a new Observable sequence of property values.\n\t   */\n\t  observableProto.pluck = function () {\n\t    var len = arguments.length, args = new Array(len);\n\t    if (len === 0) { throw new Error('List of properties cannot be empty.'); }\n\t    for(var i = 0; i < len; i++) { args[i] = arguments[i]; }\n\t    return this.map(plucker(args, len));\n\t  };\n\t\n\tobservableProto.flatMap = observableProto.selectMany = function(selector, resultSelector, thisArg) {\n\t    return new FlatMapObservable(this, selector, resultSelector, thisArg).mergeAll();\n\t};\n\t\n\t  /**\n\t   * Projects each notification of an observable sequence to an observable sequence and merges the resulting observable sequences into one observable sequence.\n\t   * @param {Function} onNext A transform function to apply to each element; the second parameter of the function represents the index of the source element.\n\t   * @param {Function} onError A transform function to apply when an error occurs in the source sequence.\n\t   * @param {Function} onCompleted A transform function to apply when the end of the source sequence is reached.\n\t   * @param {Any} [thisArg] An optional \"this\" to use to invoke each transform.\n\t   * @returns {Observable} An observable sequence whose elements are the result of invoking the one-to-many transform function corresponding to each notification in the input sequence.\n\t   */\n\t  observableProto.flatMapObserver = observableProto.selectManyObserver = function (onNext, onError, onCompleted, thisArg) {\n\t    var source = this;\n\t    return new AnonymousObservable(function (observer) {\n\t      var index = 0;\n\t\n\t      return source.subscribe(\n\t        function (x) {\n\t          var result;\n\t          try {\n\t            result = onNext.call(thisArg, x, index++);\n\t          } catch (e) {\n\t            observer.onError(e);\n\t            return;\n\t          }\n\t          isPromise(result) && (result = observableFromPromise(result));\n\t          observer.onNext(result);\n\t        },\n\t        function (err) {\n\t          var result;\n\t          try {\n\t            result = onError.call(thisArg, err);\n\t          } catch (e) {\n\t            observer.onError(e);\n\t            return;\n\t          }\n\t          isPromise(result) && (result = observableFromPromise(result));\n\t          observer.onNext(result);\n\t          observer.onCompleted();\n\t        },\n\t        function () {\n\t          var result;\n\t          try {\n\t            result = onCompleted.call(thisArg);\n\t          } catch (e) {\n\t            observer.onError(e);\n\t            return;\n\t          }\n\t          isPromise(result) && (result = observableFromPromise(result));\n\t          observer.onNext(result);\n\t          observer.onCompleted();\n\t        });\n\t    }, source).mergeAll();\n\t  };\n\t\n\tRx.Observable.prototype.flatMapLatest = function(selector, resultSelector, thisArg) {\n\t    return new FlatMapObservable(this, selector, resultSelector, thisArg).switchLatest();\n\t};\n\t  var SkipObservable = (function(__super__) {\n\t    inherits(SkipObservable, __super__);\n\t    function SkipObservable(source, count) {\n\t      this.source = source;\n\t      this._count = count;\n\t      __super__.call(this);\n\t    }\n\t\n\t    SkipObservable.prototype.subscribeCore = function (o) {\n\t      return this.source.subscribe(new SkipObserver(o, this._count));\n\t    };\n\t\n\t    function SkipObserver(o, c) {\n\t      this._o = o;\n\t      this._r = c;\n\t      AbstractObserver.call(this);\n\t    }\n\t\n\t    inherits(SkipObserver, AbstractObserver);\n\t\n\t    SkipObserver.prototype.next = function (x) {\n\t      if (this._r <= 0) {\n\t        this._o.onNext(x);\n\t      } else {\n\t        this._r--;\n\t      }\n\t    };\n\t    SkipObserver.prototype.error = function(e) { this._o.onError(e); };\n\t    SkipObserver.prototype.completed = function() { this._o.onCompleted(); };\n\t\n\t    return SkipObservable;\n\t  }(ObservableBase));\n\t\n\t  /**\n\t   * Bypasses a specified number of elements in an observable sequence and then returns the remaining elements.\n\t   * @param {Number} count The number of elements to skip before returning the remaining elements.\n\t   * @returns {Observable} An observable sequence that contains the elements that occur after the specified index in the input sequence.\n\t   */\n\t  observableProto.skip = function (count) {\n\t    if (count < 0) { throw new ArgumentOutOfRangeError(); }\n\t    return new SkipObservable(this, count);\n\t  };\n\t\n\t  var SkipWhileObservable = (function (__super__) {\n\t    inherits(SkipWhileObservable, __super__);\n\t    function SkipWhileObservable(source, fn) {\n\t      this.source = source;\n\t      this._fn = fn;\n\t      __super__.call(this);\n\t    }\n\t\n\t    SkipWhileObservable.prototype.subscribeCore = function (o) {\n\t      return this.source.subscribe(new SkipWhileObserver(o, this));\n\t    };\n\t\n\t    return SkipWhileObservable;\n\t  }(ObservableBase));\n\t\n\t  var SkipWhileObserver = (function (__super__) {\n\t    inherits(SkipWhileObserver, __super__);\n\t\n\t    function SkipWhileObserver(o, p) {\n\t      this._o = o;\n\t      this._p = p;\n\t      this._i = 0;\n\t      this._r = false;\n\t      __super__.call(this);\n\t    }\n\t\n\t    SkipWhileObserver.prototype.next = function (x) {\n\t      if (!this._r) {\n\t        var res = tryCatch(this._p._fn)(x, this._i++, this._p);\n\t        if (res === errorObj) { return this._o.onError(res.e); }\n\t        this._r = !res;\n\t      }\n\t      this._r && this._o.onNext(x);\n\t    };\n\t    SkipWhileObserver.prototype.error = function (e) { this._o.onError(e); };\n\t    SkipWhileObserver.prototype.completed = function () { this._o.onCompleted(); };\n\t\n\t    return SkipWhileObserver;\n\t  }(AbstractObserver));\n\t\n\t  /**\n\t   *  Bypasses elements in an observable sequence as long as a specified condition is true and then returns the remaining elements.\n\t   *  The element's index is used in the logic of the predicate function.\n\t   *\n\t   *  var res = source.skipWhile(function (value) { return value < 10; });\n\t   *  var res = source.skipWhile(function (value, index) { return value < 10 || index < 10; });\n\t   * @param {Function} predicate A function to test each element for a condition; the second parameter of the function represents the index of the source element.\n\t   * @param {Any} [thisArg] Object to use as this when executing callback.\n\t   * @returns {Observable} An observable sequence that contains the elements from the input sequence starting at the first element in the linear series that does not pass the test specified by predicate.\n\t   */\n\t  observableProto.skipWhile = function (predicate, thisArg) {\n\t    var fn = bindCallback(predicate, thisArg, 3);\n\t    return new SkipWhileObservable(this, fn);\n\t  };\n\t\n\t  var TakeObservable = (function(__super__) {\n\t    inherits(TakeObservable, __super__);\n\t    function TakeObservable(source, count) {\n\t      this.source = source;\n\t      this._count = count;\n\t      __super__.call(this);\n\t    }\n\t\n\t    TakeObservable.prototype.subscribeCore = function (o) {\n\t      return this.source.subscribe(new TakeObserver(o, this._count));\n\t    };\n\t\n\t    function TakeObserver(o, c) {\n\t      this._o = o;\n\t      this._c = c;\n\t      this._r = c;\n\t      AbstractObserver.call(this);\n\t    }\n\t\n\t    inherits(TakeObserver, AbstractObserver);\n\t\n\t    TakeObserver.prototype.next = function (x) {\n\t      if (this._r-- > 0) {\n\t        this._o.onNext(x);\n\t        this._r <= 0 && this._o.onCompleted();\n\t      }\n\t    };\n\t\n\t    TakeObserver.prototype.error = function (e) { this._o.onError(e); };\n\t    TakeObserver.prototype.completed = function () { this._o.onCompleted(); };\n\t\n\t    return TakeObservable;\n\t  }(ObservableBase));\n\t\n\t  /**\n\t   *  Returns a specified number of contiguous elements from the start of an observable sequence, using the specified scheduler for the edge case of take(0).\n\t   * @param {Number} count The number of elements to return.\n\t   * @param {Scheduler} [scheduler] Scheduler used to produce an OnCompleted message in case <paramref name=\"count count</paramref> is set to 0.\n\t   * @returns {Observable} An observable sequence that contains the specified number of elements from the start of the input sequence.\n\t   */\n\t  observableProto.take = function (count, scheduler) {\n\t    if (count < 0) { throw new ArgumentOutOfRangeError(); }\n\t    if (count === 0) { return observableEmpty(scheduler); }\n\t    return new TakeObservable(this, count);\n\t  };\n\t\n\t  var TakeWhileObservable = (function (__super__) {\n\t    inherits(TakeWhileObservable, __super__);\n\t    function TakeWhileObservable(source, fn) {\n\t      this.source = source;\n\t      this._fn = fn;\n\t      __super__.call(this);\n\t    }\n\t\n\t    TakeWhileObservable.prototype.subscribeCore = function (o) {\n\t      return this.source.subscribe(new TakeWhileObserver(o, this));\n\t    };\n\t\n\t    return TakeWhileObservable;\n\t  }(ObservableBase));\n\t\n\t  var TakeWhileObserver = (function (__super__) {\n\t    inherits(TakeWhileObserver, __super__);\n\t\n\t    function TakeWhileObserver(o, p) {\n\t      this._o = o;\n\t      this._p = p;\n\t      this._i = 0;\n\t      this._r = true;\n\t      __super__.call(this);\n\t    }\n\t\n\t    TakeWhileObserver.prototype.next = function (x) {\n\t      if (this._r) {\n\t        this._r = tryCatch(this._p._fn)(x, this._i++, this._p);\n\t        if (this._r === errorObj) { return this._o.onError(this._r.e); }\n\t      }\n\t      if (this._r) {\n\t        this._o.onNext(x);\n\t      } else {\n\t        this._o.onCompleted();\n\t      }\n\t    };\n\t    TakeWhileObserver.prototype.error = function (e) { this._o.onError(e); };\n\t    TakeWhileObserver.prototype.completed = function () { this._o.onCompleted(); };\n\t\n\t    return TakeWhileObserver;\n\t  }(AbstractObserver));\n\t\n\t  /**\n\t   *  Returns elements from an observable sequence as long as a specified condition is true.\n\t   *  The element's index is used in the logic of the predicate function.\n\t   * @param {Function} predicate A function to test each element for a condition; the second parameter of the function represents the index of the source element.\n\t   * @param {Any} [thisArg] Object to use as this when executing callback.\n\t   * @returns {Observable} An observable sequence that contains the elements from the input sequence that occur before the element at which the test no longer passes.\n\t   */\n\t  observableProto.takeWhile = function (predicate, thisArg) {\n\t    var fn = bindCallback(predicate, thisArg, 3);\n\t    return new TakeWhileObservable(this, fn);\n\t  };\n\t\n\t  var FilterObservable = (function (__super__) {\n\t    inherits(FilterObservable, __super__);\n\t\n\t    function FilterObservable(source, predicate, thisArg) {\n\t      this.source = source;\n\t      this.predicate = bindCallback(predicate, thisArg, 3);\n\t      __super__.call(this);\n\t    }\n\t\n\t    FilterObservable.prototype.subscribeCore = function (o) {\n\t      return this.source.subscribe(new InnerObserver(o, this.predicate, this));\n\t    };\n\t\n\t    function innerPredicate(predicate, self) {\n\t      return function(x, i, o) { return self.predicate(x, i, o) && predicate.call(this, x, i, o); }\n\t    }\n\t\n\t    FilterObservable.prototype.internalFilter = function(predicate, thisArg) {\n\t      return new FilterObservable(this.source, innerPredicate(predicate, this), thisArg);\n\t    };\n\t\n\t    inherits(InnerObserver, AbstractObserver);\n\t    function InnerObserver(o, predicate, source) {\n\t      this.o = o;\n\t      this.predicate = predicate;\n\t      this.source = source;\n\t      this.i = 0;\n\t      AbstractObserver.call(this);\n\t    }\n\t\n\t    InnerObserver.prototype.next = function(x) {\n\t      var shouldYield = tryCatch(this.predicate)(x, this.i++, this.source);\n\t      if (shouldYield === errorObj) {\n\t        return this.o.onError(shouldYield.e);\n\t      }\n\t      shouldYield && this.o.onNext(x);\n\t    };\n\t\n\t    InnerObserver.prototype.error = function (e) {\n\t      this.o.onError(e);\n\t    };\n\t\n\t    InnerObserver.prototype.completed = function () {\n\t      this.o.onCompleted();\n\t    };\n\t\n\t    return FilterObservable;\n\t\n\t  }(ObservableBase));\n\t\n\t  /**\n\t  *  Filters the elements of an observable sequence based on a predicate by incorporating the element's index.\n\t  * @param {Function} predicate A function to test each source element for a condition; the second parameter of the function represents the index of the source element.\n\t  * @param {Any} [thisArg] Object to use as this when executing callback.\n\t  * @returns {Observable} An observable sequence that contains elements from the input sequence that satisfy the condition.\n\t  */\n\t  observableProto.filter = observableProto.where = function (predicate, thisArg) {\n\t    return this instanceof FilterObservable ? this.internalFilter(predicate, thisArg) :\n\t      new FilterObservable(this, predicate, thisArg);\n\t  };\n\t\n\t  var ExtremaByObservable = (function (__super__) {\n\t    inherits(ExtremaByObservable, __super__);\n\t    function ExtremaByObservable(source, k, c) {\n\t      this.source = source;\n\t      this._k = k;\n\t      this._c = c;\n\t      __super__.call(this);\n\t    }\n\t\n\t    ExtremaByObservable.prototype.subscribeCore = function (o) {\n\t      return this.source.subscribe(new ExtremaByObserver(o, this._k, this._c));\n\t    };\n\t\n\t    return ExtremaByObservable;\n\t  }(ObservableBase));\n\t\n\t  var ExtremaByObserver = (function (__super__) {\n\t    inherits(ExtremaByObserver, __super__);\n\t    function ExtremaByObserver(o, k, c) {\n\t      this._o = o;\n\t      this._k = k;\n\t      this._c = c;\n\t      this._v = null;\n\t      this._hv = false;\n\t      this._l = [];\n\t      __super__.call(this);\n\t    }\n\t\n\t    ExtremaByObserver.prototype.next = function (x) {\n\t      var key = tryCatch(this._k)(x);\n\t      if (key === errorObj) { return this._o.onError(key.e); }\n\t      var comparison = 0;\n\t      if (!this._hv) {\n\t        this._hv = true;\n\t        this._v = key;\n\t      } else {\n\t        comparison = tryCatch(this._c)(key, this._v);\n\t        if (comparison === errorObj) { return this._o.onError(comparison.e); }\n\t      }\n\t      if (comparison > 0) {\n\t        this._v = key;\n\t        this._l = [];\n\t      }\n\t      if (comparison >= 0) { this._l.push(x); }\n\t    };\n\t\n\t    ExtremaByObserver.prototype.error = function (e) {\n\t      this._o.onError(e);\n\t    };\n\t\n\t    ExtremaByObserver.prototype.completed = function () {\n\t      this._o.onNext(this._l);\n\t      this._o.onCompleted();\n\t    };\n\t\n\t    return ExtremaByObserver;\n\t  }(AbstractObserver));\n\t\n\t  function firstOnly(x) {\n\t    if (x.length === 0) { throw new EmptyError(); }\n\t    return x[0];\n\t  }\n\t\n\t  var ReduceObservable = (function(__super__) {\n\t    inherits(ReduceObservable, __super__);\n\t    function ReduceObservable(source, accumulator, hasSeed, seed) {\n\t      this.source = source;\n\t      this.accumulator = accumulator;\n\t      this.hasSeed = hasSeed;\n\t      this.seed = seed;\n\t      __super__.call(this);\n\t    }\n\t\n\t    ReduceObservable.prototype.subscribeCore = function(observer) {\n\t      return this.source.subscribe(new ReduceObserver(observer,this));\n\t    };\n\t\n\t    return ReduceObservable;\n\t  }(ObservableBase));\n\t\n\t  var ReduceObserver = (function (__super__) {\n\t    inherits(ReduceObserver, __super__);\n\t    function ReduceObserver(o, parent) {\n\t      this._o = o;\n\t      this._p = parent;\n\t      this._fn = parent.accumulator;\n\t      this._hs = parent.hasSeed;\n\t      this._s = parent.seed;\n\t      this._ha = false;\n\t      this._a = null;\n\t      this._hv = false;\n\t      this._i = 0;\n\t      __super__.call(this);\n\t    }\n\t\n\t    ReduceObserver.prototype.next = function (x) {\n\t      !this._hv && (this._hv = true);\n\t      if (this._ha) {\n\t        this._a = tryCatch(this._fn)(this._a, x, this._i, this._p);\n\t      } else {\n\t        this._a = this._hs ? tryCatch(this._fn)(this._s, x, this._i, this._p) : x;\n\t        this._ha = true;\n\t      }\n\t      if (this._a === errorObj) { return this._o.onError(this._a.e); }\n\t      this._i++;\n\t    };\n\t\n\t    ReduceObserver.prototype.error = function (e) {\n\t      this._o.onError(e);\n\t    };\n\t\n\t    ReduceObserver.prototype.completed = function () {\n\t      this._hv && this._o.onNext(this._a);\n\t      !this._hv && this._hs && this._o.onNext(this._s);\n\t      !this._hv && !this._hs && this._o.onError(new EmptyError());\n\t      this._o.onCompleted();\n\t    };\n\t\n\t    return ReduceObserver;\n\t  }(AbstractObserver));\n\t\n\t  /**\n\t  * Applies an accumulator function over an observable sequence, returning the result of the aggregation as a single element in the result sequence. The specified seed value is used as the initial accumulator value.\n\t  * For aggregation behavior with incremental intermediate results, see Observable.scan.\n\t  * @param {Function} accumulator An accumulator function to be invoked on each element.\n\t  * @param {Any} [seed] The initial accumulator value.\n\t  * @returns {Observable} An observable sequence containing a single element with the final accumulator value.\n\t  */\n\t  observableProto.reduce = function () {\n\t    var hasSeed = false, seed, accumulator = arguments[0];\n\t    if (arguments.length === 2) {\n\t      hasSeed = true;\n\t      seed = arguments[1];\n\t    }\n\t    return new ReduceObservable(this, accumulator, hasSeed, seed);\n\t  };\n\t\n\t  var SomeObservable = (function (__super__) {\n\t    inherits(SomeObservable, __super__);\n\t    function SomeObservable(source, fn) {\n\t      this.source = source;\n\t      this._fn = fn;\n\t      __super__.call(this);\n\t    }\n\t\n\t    SomeObservable.prototype.subscribeCore = function (o) {\n\t      return this.source.subscribe(new SomeObserver(o, this._fn, this.source));\n\t    };\n\t\n\t    return SomeObservable;\n\t  }(ObservableBase));\n\t\n\t  var SomeObserver = (function (__super__) {\n\t    inherits(SomeObserver, __super__);\n\t\n\t    function SomeObserver(o, fn, s) {\n\t      this._o = o;\n\t      this._fn = fn;\n\t      this._s = s;\n\t      this._i = 0;\n\t      __super__.call(this);\n\t    }\n\t\n\t    SomeObserver.prototype.next = function (x) {\n\t      var result = tryCatch(this._fn)(x, this._i++, this._s);\n\t      if (result === errorObj) { return this._o.onError(result.e); }\n\t      if (Boolean(result)) {\n\t        this._o.onNext(true);\n\t        this._o.onCompleted();\n\t      }\n\t    };\n\t    SomeObserver.prototype.error = function (e) { this._o.onError(e); };\n\t    SomeObserver.prototype.completed = function () {\n\t      this._o.onNext(false);\n\t      this._o.onCompleted();\n\t    };\n\t\n\t    return SomeObserver;\n\t  }(AbstractObserver));\n\t\n\t  /**\n\t   * Determines whether any element of an observable sequence satisfies a condition if present, else if any items are in the sequence.\n\t   * @param {Function} [predicate] A function to test each element for a condition.\n\t   * @returns {Observable} An observable sequence containing a single element determining whether any elements in the source sequence pass the test in the specified predicate if given, else if any items are in the sequence.\n\t   */\n\t  observableProto.some = function (predicate, thisArg) {\n\t    var fn = bindCallback(predicate, thisArg, 3);\n\t    return new SomeObservable(this, fn);\n\t  };\n\t\n\t  var IsEmptyObservable = (function (__super__) {\n\t    inherits(IsEmptyObservable, __super__);\n\t    function IsEmptyObservable(source) {\n\t      this.source = source;\n\t      __super__.call(this);\n\t    }\n\t\n\t    IsEmptyObservable.prototype.subscribeCore = function (o) {\n\t      return this.source.subscribe(new IsEmptyObserver(o));\n\t    };\n\t\n\t    return IsEmptyObservable;\n\t  }(ObservableBase));\n\t\n\t  var IsEmptyObserver = (function(__super__) {\n\t    inherits(IsEmptyObserver, __super__);\n\t    function IsEmptyObserver(o) {\n\t      this._o = o;\n\t      __super__.call(this);\n\t    }\n\t\n\t    IsEmptyObserver.prototype.next = function () {\n\t      this._o.onNext(false);\n\t      this._o.onCompleted();\n\t    };\n\t    IsEmptyObserver.prototype.error = function (e) { this._o.onError(e); };\n\t    IsEmptyObserver.prototype.completed = function () {\n\t      this._o.onNext(true);\n\t      this._o.onCompleted();\n\t    };\n\t\n\t    return IsEmptyObserver;\n\t  }(AbstractObserver));\n\t\n\t  /**\n\t   * Determines whether an observable sequence is empty.\n\t   * @returns {Observable} An observable sequence containing a single element determining whether the source sequence is empty.\n\t   */\n\t  observableProto.isEmpty = function () {\n\t    return new IsEmptyObservable(this);\n\t  };\n\t\n\t  var EveryObservable = (function (__super__) {\n\t    inherits(EveryObservable, __super__);\n\t    function EveryObservable(source, fn) {\n\t      this.source = source;\n\t      this._fn = fn;\n\t      __super__.call(this);\n\t    }\n\t\n\t    EveryObservable.prototype.subscribeCore = function (o) {\n\t      return this.source.subscribe(new EveryObserver(o, this._fn, this.source));\n\t    };\n\t\n\t    return EveryObservable;\n\t  }(ObservableBase));\n\t\n\t  var EveryObserver = (function (__super__) {\n\t    inherits(EveryObserver, __super__);\n\t\n\t    function EveryObserver(o, fn, s) {\n\t      this._o = o;\n\t      this._fn = fn;\n\t      this._s = s;\n\t      this._i = 0;\n\t      __super__.call(this);\n\t    }\n\t\n\t    EveryObserver.prototype.next = function (x) {\n\t      var result = tryCatch(this._fn)(x, this._i++, this._s);\n\t      if (result === errorObj) { return this._o.onError(result.e); }\n\t      if (!Boolean(result)) {\n\t        this._o.onNext(false);\n\t        this._o.onCompleted();\n\t      }\n\t    };\n\t    EveryObserver.prototype.error = function (e) { this._o.onError(e); };\n\t    EveryObserver.prototype.completed = function () {\n\t      this._o.onNext(true);\n\t      this._o.onCompleted();\n\t    };\n\t\n\t    return EveryObserver;\n\t  }(AbstractObserver));\n\t\n\t  /**\n\t   * Determines whether all elements of an observable sequence satisfy a condition.\n\t   * @param {Function} [predicate] A function to test each element for a condition.\n\t   * @param {Any} [thisArg] Object to use as this when executing callback.\n\t   * @returns {Observable} An observable sequence containing a single element determining whether all elements in the source sequence pass the test in the specified predicate.\n\t   */\n\t  observableProto.every = function (predicate, thisArg) {\n\t    var fn = bindCallback(predicate, thisArg, 3);\n\t    return new EveryObservable(this, fn);\n\t  };\n\t\n\t  var IncludesObservable = (function (__super__) {\n\t    inherits(IncludesObservable, __super__);\n\t    function IncludesObservable(source, elem, idx) {\n\t      var n = +idx || 0;\n\t      Math.abs(n) === Infinity && (n = 0);\n\t\n\t      this.source = source;\n\t      this._elem = elem;\n\t      this._n = n;\n\t      __super__.call(this);\n\t    }\n\t\n\t    IncludesObservable.prototype.subscribeCore = function (o) {\n\t      if (this._n < 0) {\n\t        o.onNext(false);\n\t        o.onCompleted();\n\t        return disposableEmpty;\n\t      }\n\t\n\t      return this.source.subscribe(new IncludesObserver(o, this._elem, this._n));\n\t    };\n\t\n\t    return IncludesObservable;\n\t  }(ObservableBase));\n\t\n\t  var IncludesObserver = (function (__super__) {\n\t    inherits(IncludesObserver, __super__);\n\t    function IncludesObserver(o, elem, n) {\n\t      this._o = o;\n\t      this._elem = elem;\n\t      this._n = n;\n\t      this._i = 0;\n\t      __super__.call(this);\n\t    }\n\t\n\t    function comparer(a, b) {\n\t      return (a === 0 && b === 0) || (a === b || (isNaN(a) && isNaN(b)));\n\t    }\n\t\n\t    IncludesObserver.prototype.next = function (x) {\n\t      if (this._i++ >= this._n && comparer(x, this._elem)) {\n\t        this._o.onNext(true);\n\t        this._o.onCompleted();\n\t      }\n\t    };\n\t    IncludesObserver.prototype.error = function (e) { this._o.onError(e); };\n\t    IncludesObserver.prototype.completed = function () { this._o.onNext(false); this._o.onCompleted(); };\n\t\n\t    return IncludesObserver;\n\t  }(AbstractObserver));\n\t\n\t  /**\n\t   * Determines whether an observable sequence includes a specified element with an optional equality comparer.\n\t   * @param searchElement The value to locate in the source sequence.\n\t   * @param {Number} [fromIndex] An equality comparer to compare elements.\n\t   * @returns {Observable} An observable sequence containing a single element determining whether the source sequence includes an element that has the specified value from the given index.\n\t   */\n\t  observableProto.includes = function (searchElement, fromIndex) {\n\t    return new IncludesObservable(this, searchElement, fromIndex);\n\t  };\n\t\n\t  var CountObservable = (function (__super__) {\n\t    inherits(CountObservable, __super__);\n\t    function CountObservable(source, fn) {\n\t      this.source = source;\n\t      this._fn = fn;\n\t      __super__.call(this);\n\t    }\n\t\n\t    CountObservable.prototype.subscribeCore = function (o) {\n\t      return this.source.subscribe(new CountObserver(o, this._fn, this.source));\n\t    };\n\t\n\t    return CountObservable;\n\t  }(ObservableBase));\n\t\n\t  var CountObserver = (function (__super__) {\n\t    inherits(CountObserver, __super__);\n\t\n\t    function CountObserver(o, fn, s) {\n\t      this._o = o;\n\t      this._fn = fn;\n\t      this._s = s;\n\t      this._i = 0;\n\t      this._c = 0;\n\t      __super__.call(this);\n\t    }\n\t\n\t    CountObserver.prototype.next = function (x) {\n\t      if (this._fn) {\n\t        var result = tryCatch(this._fn)(x, this._i++, this._s);\n\t        if (result === errorObj) { return this._o.onError(result.e); }\n\t        Boolean(result) && (this._c++);\n\t      } else {\n\t        this._c++;\n\t      }\n\t    };\n\t    CountObserver.prototype.error = function (e) { this._o.onError(e); };\n\t    CountObserver.prototype.completed = function () {\n\t      this._o.onNext(this._c);\n\t      this._o.onCompleted();\n\t    };\n\t\n\t    return CountObserver;\n\t  }(AbstractObserver));\n\t\n\t  /**\n\t   * Returns an observable sequence containing a value that represents how many elements in the specified observable sequence satisfy a condition if provided, else the count of items.\n\t   * @example\n\t   * res = source.count();\n\t   * res = source.count(function (x) { return x > 3; });\n\t   * @param {Function} [predicate]A function to test each element for a condition.\n\t   * @param {Any} [thisArg] Object to use as this when executing callback.\n\t   * @returns {Observable} An observable sequence containing a single element with a number that represents how many elements in the input sequence satisfy the condition in the predicate function if provided, else the count of items in the sequence.\n\t   */\n\t  observableProto.count = function (predicate, thisArg) {\n\t    var fn = bindCallback(predicate, thisArg, 3);\n\t    return new CountObservable(this, fn);\n\t  };\n\t\n\t  var IndexOfObservable = (function (__super__) {\n\t    inherits(IndexOfObservable, __super__);\n\t    function IndexOfObservable(source, e, n) {\n\t      this.source = source;\n\t      this._e = e;\n\t      this._n = n;\n\t      __super__.call(this);\n\t    }\n\t\n\t    IndexOfObservable.prototype.subscribeCore = function (o) {\n\t      if (this._n < 0) {\n\t        o.onNext(-1);\n\t        o.onCompleted();\n\t        return disposableEmpty;\n\t      }\n\t\n\t      return this.source.subscribe(new IndexOfObserver(o, this._e, this._n));\n\t    };\n\t\n\t    return IndexOfObservable;\n\t  }(ObservableBase));\n\t\n\t  var IndexOfObserver = (function (__super__) {\n\t    inherits(IndexOfObserver, __super__);\n\t    function IndexOfObserver(o, e, n) {\n\t      this._o = o;\n\t      this._e = e;\n\t      this._n = n;\n\t      this._i = 0;\n\t      __super__.call(this);\n\t    }\n\t\n\t    IndexOfObserver.prototype.next = function (x) {\n\t      if (this._i >= this._n && x === this._e) {\n\t        this._o.onNext(this._i);\n\t        this._o.onCompleted();\n\t      }\n\t      this._i++;\n\t    };\n\t    IndexOfObserver.prototype.error = function (e) { this._o.onError(e); };\n\t    IndexOfObserver.prototype.completed = function () { this._o.onNext(-1); this._o.onCompleted(); };\n\t\n\t    return IndexOfObserver;\n\t  }(AbstractObserver));\n\t\n\t  /**\n\t   * Returns the first index at which a given element can be found in the observable sequence, or -1 if it is not present.\n\t   * @param {Any} searchElement Element to locate in the array.\n\t   * @param {Number} [fromIndex] The index to start the search.  If not specified, defaults to 0.\n\t   * @returns {Observable} And observable sequence containing the first index at which a given element can be found in the observable sequence, or -1 if it is not present.\n\t   */\n\t  observableProto.indexOf = function(searchElement, fromIndex) {\n\t    var n = +fromIndex || 0;\n\t    Math.abs(n) === Infinity && (n = 0);\n\t    return new IndexOfObservable(this, searchElement, n);\n\t  };\n\t\n\t  var SumObservable = (function (__super__) {\n\t    inherits(SumObservable, __super__);\n\t    function SumObservable(source, fn) {\n\t      this.source = source;\n\t      this._fn = fn;\n\t      __super__.call(this);\n\t    }\n\t\n\t    SumObservable.prototype.subscribeCore = function (o) {\n\t      return this.source.subscribe(new SumObserver(o, this._fn, this.source));\n\t    };\n\t\n\t    return SumObservable;\n\t  }(ObservableBase));\n\t\n\t  var SumObserver = (function (__super__) {\n\t    inherits(SumObserver, __super__);\n\t\n\t    function SumObserver(o, fn, s) {\n\t      this._o = o;\n\t      this._fn = fn;\n\t      this._s = s;\n\t      this._i = 0;\n\t      this._c = 0;\n\t      __super__.call(this);\n\t    }\n\t\n\t    SumObserver.prototype.next = function (x) {\n\t      if (this._fn) {\n\t        var result = tryCatch(this._fn)(x, this._i++, this._s);\n\t        if (result === errorObj) { return this._o.onError(result.e); }\n\t        this._c += result;\n\t      } else {\n\t        this._c += x;\n\t      }\n\t    };\n\t    SumObserver.prototype.error = function (e) { this._o.onError(e); };\n\t    SumObserver.prototype.completed = function () {\n\t      this._o.onNext(this._c);\n\t      this._o.onCompleted();\n\t    };\n\t\n\t    return SumObserver;\n\t  }(AbstractObserver));\n\t\n\t  /**\n\t   * Computes the sum of a sequence of values that are obtained by invoking an optional transform function on each element of the input sequence, else if not specified computes the sum on each item in the sequence.\n\t   * @param {Function} [selector] A transform function to apply to each element.\n\t   * @param {Any} [thisArg] Object to use as this when executing callback.\n\t   * @returns {Observable} An observable sequence containing a single element with the sum of the values in the source sequence.\n\t   */\n\t  observableProto.sum = function (keySelector, thisArg) {\n\t    var fn = bindCallback(keySelector, thisArg, 3);\n\t    return new SumObservable(this, fn);\n\t  };\n\t\n\t  /**\n\t   * Returns the elements in an observable sequence with the minimum key value according to the specified comparer.\n\t   * @example\n\t   * var res = source.minBy(function (x) { return x.value; });\n\t   * var res = source.minBy(function (x) { return x.value; }, function (x, y) { return x - y; });\n\t   * @param {Function} keySelector Key selector function.\n\t   * @param {Function} [comparer] Comparer used to compare key values.\n\t   * @returns {Observable} An observable sequence containing a list of zero or more elements that have a minimum key value.\n\t   */\n\t  observableProto.minBy = function (keySelector, comparer) {\n\t    comparer || (comparer = defaultSubComparer);\n\t    return new ExtremaByObservable(this, keySelector, function (x, y) { return comparer(x, y) * -1; });\n\t  };\n\t\n\t  /**\n\t   * Returns the minimum element in an observable sequence according to the optional comparer else a default greater than less than check.\n\t   * @example\n\t   * var res = source.min();\n\t   * var res = source.min(function (x, y) { return x.value - y.value; });\n\t   * @param {Function} [comparer] Comparer used to compare elements.\n\t   * @returns {Observable} An observable sequence containing a single element with the minimum element in the source sequence.\n\t   */\n\t  observableProto.min = function (comparer) {\n\t    return this.minBy(identity, comparer).map(function (x) { return firstOnly(x); });\n\t  };\n\t\n\t  /**\n\t   * Returns the elements in an observable sequence with the maximum  key value according to the specified comparer.\n\t   * @example\n\t   * var res = source.maxBy(function (x) { return x.value; });\n\t   * var res = source.maxBy(function (x) { return x.value; }, function (x, y) { return x - y;; });\n\t   * @param {Function} keySelector Key selector function.\n\t   * @param {Function} [comparer]  Comparer used to compare key values.\n\t   * @returns {Observable} An observable sequence containing a list of zero or more elements that have a maximum key value.\n\t   */\n\t  observableProto.maxBy = function (keySelector, comparer) {\n\t    comparer || (comparer = defaultSubComparer);\n\t    return new ExtremaByObservable(this, keySelector, comparer);\n\t  };\n\t\n\t  /**\n\t   * Returns the maximum value in an observable sequence according to the specified comparer.\n\t   * @example\n\t   * var res = source.max();\n\t   * var res = source.max(function (x, y) { return x.value - y.value; });\n\t   * @param {Function} [comparer] Comparer used to compare elements.\n\t   * @returns {Observable} An observable sequence containing a single element with the maximum element in the source sequence.\n\t   */\n\t  observableProto.max = function (comparer) {\n\t    return this.maxBy(identity, comparer).map(function (x) { return firstOnly(x); });\n\t  };\n\t\n\t  var AverageObservable = (function (__super__) {\n\t    inherits(AverageObservable, __super__);\n\t    function AverageObservable(source, fn) {\n\t      this.source = source;\n\t      this._fn = fn;\n\t      __super__.call(this);\n\t    }\n\t\n\t    AverageObservable.prototype.subscribeCore = function (o) {\n\t      return this.source.subscribe(new AverageObserver(o, this._fn, this.source));\n\t    };\n\t\n\t    return AverageObservable;\n\t  }(ObservableBase));\n\t\n\t  var AverageObserver = (function(__super__) {\n\t    inherits(AverageObserver, __super__);\n\t    function AverageObserver(o, fn, s) {\n\t      this._o = o;\n\t      this._fn = fn;\n\t      this._s = s;\n\t      this._c = 0;\n\t      this._t = 0;\n\t      __super__.call(this);\n\t    }\n\t\n\t    AverageObserver.prototype.next = function (x) {\n\t      if(this._fn) {\n\t        var r = tryCatch(this._fn)(x, this._c++, this._s);\n\t        if (r === errorObj) { return this._o.onError(r.e); }\n\t        this._t += r;\n\t      } else {\n\t        this._c++;\n\t        this._t += x;\n\t      }\n\t    };\n\t    AverageObserver.prototype.error = function (e) { this._o.onError(e); };\n\t    AverageObserver.prototype.completed = function () {\n\t      if (this._c === 0) { return this._o.onError(new EmptyError()); }\n\t      this._o.onNext(this._t / this._c);\n\t      this._o.onCompleted();\n\t    };\n\t\n\t    return AverageObserver;\n\t  }(AbstractObserver));\n\t\n\t  /**\n\t   * Computes the average of an observable sequence of values that are in the sequence or obtained by invoking a transform function on each element of the input sequence if present.\n\t   * @param {Function} [selector] A transform function to apply to each element.\n\t   * @param {Any} [thisArg] Object to use as this when executing callback.\n\t   * @returns {Observable} An observable sequence containing a single element with the average of the sequence of values.\n\t   */\n\t  observableProto.average = function (keySelector, thisArg) {\n\t    var source = this, fn;\n\t    if (isFunction(keySelector)) {\n\t      fn = bindCallback(keySelector, thisArg, 3);\n\t    }\n\t    return new AverageObservable(source, fn);\n\t  };\n\t\n\t  /**\n\t   *  Determines whether two sequences are equal by comparing the elements pairwise using a specified equality comparer.\n\t   *\n\t   * @example\n\t   * var res = res = source.sequenceEqual([1,2,3]);\n\t   * var res = res = source.sequenceEqual([{ value: 42 }], function (x, y) { return x.value === y.value; });\n\t   * 3 - res = source.sequenceEqual(Rx.Observable.returnValue(42));\n\t   * 4 - res = source.sequenceEqual(Rx.Observable.returnValue({ value: 42 }), function (x, y) { return x.value === y.value; });\n\t   * @param {Observable} second Second observable sequence or array to compare.\n\t   * @param {Function} [comparer] Comparer used to compare elements of both sequences.\n\t   * @returns {Observable} An observable sequence that contains a single element which indicates whether both sequences are of equal length and their corresponding elements are equal according to the specified equality comparer.\n\t   */\n\t  observableProto.sequenceEqual = function (second, comparer) {\n\t    var first = this;\n\t    comparer || (comparer = defaultComparer);\n\t    return new AnonymousObservable(function (o) {\n\t      var donel = false, doner = false, ql = [], qr = [];\n\t      var subscription1 = first.subscribe(function (x) {\n\t        if (qr.length > 0) {\n\t          var v = qr.shift();\n\t          var equal = tryCatch(comparer)(v, x);\n\t          if (equal === errorObj) { return o.onError(equal.e); }\n\t          if (!equal) {\n\t            o.onNext(false);\n\t            o.onCompleted();\n\t          }\n\t        } else if (doner) {\n\t          o.onNext(false);\n\t          o.onCompleted();\n\t        } else {\n\t          ql.push(x);\n\t        }\n\t      }, function(e) { o.onError(e); }, function () {\n\t        donel = true;\n\t        if (ql.length === 0) {\n\t          if (qr.length > 0) {\n\t            o.onNext(false);\n\t            o.onCompleted();\n\t          } else if (doner) {\n\t            o.onNext(true);\n\t            o.onCompleted();\n\t          }\n\t        }\n\t      });\n\t\n\t      (isArrayLike(second) || isIterable(second)) && (second = observableFrom(second));\n\t      isPromise(second) && (second = observableFromPromise(second));\n\t      var subscription2 = second.subscribe(function (x) {\n\t        if (ql.length > 0) {\n\t          var v = ql.shift();\n\t          var equal = tryCatch(comparer)(v, x);\n\t          if (equal === errorObj) { return o.onError(equal.e); }\n\t          if (!equal) {\n\t            o.onNext(false);\n\t            o.onCompleted();\n\t          }\n\t        } else if (donel) {\n\t          o.onNext(false);\n\t          o.onCompleted();\n\t        } else {\n\t          qr.push(x);\n\t        }\n\t      }, function(e) { o.onError(e); }, function () {\n\t        doner = true;\n\t        if (qr.length === 0) {\n\t          if (ql.length > 0) {\n\t            o.onNext(false);\n\t            o.onCompleted();\n\t          } else if (donel) {\n\t            o.onNext(true);\n\t            o.onCompleted();\n\t          }\n\t        }\n\t      });\n\t      return new BinaryDisposable(subscription1, subscription2);\n\t    }, first);\n\t  };\n\t\n\t  var ElementAtObservable = (function (__super__) {\n\t    inherits(ElementAtObservable, __super__);\n\t    function ElementAtObservable(source, i, d) {\n\t      this.source = source;\n\t      this._i = i;\n\t      this._d = d;\n\t      __super__.call(this);\n\t    }\n\t\n\t    ElementAtObservable.prototype.subscribeCore = function (o) {\n\t      return this.source.subscribe(new ElementAtObserver(o, this._i, this._d));\n\t    };\n\t\n\t    return ElementAtObservable;\n\t  }(ObservableBase));\n\t\n\t  var ElementAtObserver = (function (__super__) {\n\t    inherits(ElementAtObserver, __super__);\n\t\n\t    function ElementAtObserver(o, i, d) {\n\t      this._o = o;\n\t      this._i = i;\n\t      this._d = d;\n\t      __super__.call(this);\n\t    }\n\t\n\t    ElementAtObserver.prototype.next = function (x) {\n\t      if (this._i-- === 0) {\n\t        this._o.onNext(x);\n\t        this._o.onCompleted();\n\t      }\n\t    };\n\t    ElementAtObserver.prototype.error = function (e) { this._o.onError(e); };\n\t    ElementAtObserver.prototype.completed = function () {\n\t      if (this._d === undefined) {\n\t        this._o.onError(new ArgumentOutOfRangeError());\n\t      } else {\n\t        this._o.onNext(this._d);\n\t        this._o.onCompleted();\n\t      }\n\t    };\n\t\n\t    return ElementAtObserver;\n\t  }(AbstractObserver));\n\t\n\t  /**\n\t   * Returns the element at a specified index in a sequence or default value if not found.\n\t   * @param {Number} index The zero-based index of the element to retrieve.\n\t   * @param {Any} [defaultValue] The default value to use if elementAt does not find a value.\n\t   * @returns {Observable} An observable sequence that produces the element at the specified position in the source sequence.\n\t   */\n\t  observableProto.elementAt =  function (index, defaultValue) {\n\t    if (index < 0) { throw new ArgumentOutOfRangeError(); }\n\t    return new ElementAtObservable(this, index, defaultValue);\n\t  };\n\t\n\t  var SingleObserver = (function(__super__) {\n\t    inherits(SingleObserver, __super__);\n\t    function SingleObserver(o, obj, s) {\n\t      this._o = o;\n\t      this._obj = obj;\n\t      this._s = s;\n\t      this._i = 0;\n\t      this._hv = false;\n\t      this._v = null;\n\t      __super__.call(this);\n\t    }\n\t\n\t    SingleObserver.prototype.next = function (x) {\n\t      var shouldYield = false;\n\t      if (this._obj.predicate) {\n\t        var res = tryCatch(this._obj.predicate)(x, this._i++, this._s);\n\t        if (res === errorObj) { return this._o.onError(res.e); }\n\t        Boolean(res) && (shouldYield = true);\n\t      } else if (!this._obj.predicate) {\n\t        shouldYield = true;\n\t      }\n\t      if (shouldYield) {\n\t        if (this._hv) {\n\t          return this._o.onError(new Error('Sequence contains more than one matching element'));\n\t        }\n\t        this._hv = true;\n\t        this._v = x;\n\t      }\n\t    };\n\t    SingleObserver.prototype.error = function (e) { this._o.onError(e); };\n\t    SingleObserver.prototype.completed = function () {\n\t      if (this._hv) {\n\t        this._o.onNext(this._v);\n\t        this._o.onCompleted();\n\t      }\n\t      else if (this._obj.defaultValue === undefined) {\n\t        this._o.onError(new EmptyError());\n\t      } else {\n\t        this._o.onNext(this._obj.defaultValue);\n\t        this._o.onCompleted();\n\t      }\n\t    };\n\t\n\t    return SingleObserver;\n\t  }(AbstractObserver));\n\t\n\t\n\t    /**\n\t     * Returns the only element of an observable sequence that satisfies the condition in the optional predicate, and reports an exception if there is not exactly one element in the observable sequence.\n\t     * @returns {Observable} Sequence containing the single element in the observable sequence that satisfies the condition in the predicate.\n\t     */\n\t    observableProto.single = function (predicate, thisArg) {\n\t      var obj = {}, source = this;\n\t      if (typeof arguments[0] === 'object') {\n\t        obj = arguments[0];\n\t      } else {\n\t        obj = {\n\t          predicate: arguments[0],\n\t          thisArg: arguments[1],\n\t          defaultValue: arguments[2]\n\t        };\n\t      }\n\t      if (isFunction (obj.predicate)) {\n\t        var fn = obj.predicate;\n\t        obj.predicate = bindCallback(fn, obj.thisArg, 3);\n\t      }\n\t      return new AnonymousObservable(function (o) {\n\t        return source.subscribe(new SingleObserver(o, obj, source));\n\t      }, source);\n\t    };\n\t\n\t  var FirstObservable = (function (__super__) {\n\t    inherits(FirstObservable, __super__);\n\t    function FirstObservable(source, obj) {\n\t      this.source = source;\n\t      this._obj = obj;\n\t      __super__.call(this);\n\t    }\n\t\n\t    FirstObservable.prototype.subscribeCore = function (o) {\n\t      return this.source.subscribe(new FirstObserver(o, this._obj, this.source));\n\t    };\n\t\n\t    return FirstObservable;\n\t  }(ObservableBase));\n\t\n\t  var FirstObserver = (function(__super__) {\n\t    inherits(FirstObserver, __super__);\n\t    function FirstObserver(o, obj, s) {\n\t      this._o = o;\n\t      this._obj = obj;\n\t      this._s = s;\n\t      this._i = 0;\n\t      __super__.call(this);\n\t    }\n\t\n\t    FirstObserver.prototype.next = function (x) {\n\t      if (this._obj.predicate) {\n\t        var res = tryCatch(this._obj.predicate)(x, this._i++, this._s);\n\t        if (res === errorObj) { return this._o.onError(res.e); }\n\t        if (Boolean(res)) {\n\t          this._o.onNext(x);\n\t          this._o.onCompleted();\n\t        }\n\t      } else if (!this._obj.predicate) {\n\t        this._o.onNext(x);\n\t        this._o.onCompleted();\n\t      }\n\t    };\n\t    FirstObserver.prototype.error = function (e) { this._o.onError(e); };\n\t    FirstObserver.prototype.completed = function () {\n\t      if (this._obj.defaultValue === undefined) {\n\t        this._o.onError(new EmptyError());\n\t      } else {\n\t        this._o.onNext(this._obj.defaultValue);\n\t        this._o.onCompleted();\n\t      }\n\t    };\n\t\n\t    return FirstObserver;\n\t  }(AbstractObserver));\n\t\n\t  /**\n\t   * Returns the first element of an observable sequence that satisfies the condition in the predicate if present else the first item in the sequence.\n\t   * @returns {Observable} Sequence containing the first element in the observable sequence that satisfies the condition in the predicate if provided, else the first item in the sequence.\n\t   */\n\t  observableProto.first = function () {\n\t    var obj = {}, source = this;\n\t    if (typeof arguments[0] === 'object') {\n\t      obj = arguments[0];\n\t    } else {\n\t      obj = {\n\t        predicate: arguments[0],\n\t        thisArg: arguments[1],\n\t        defaultValue: arguments[2]\n\t      };\n\t    }\n\t    if (isFunction (obj.predicate)) {\n\t      var fn = obj.predicate;\n\t      obj.predicate = bindCallback(fn, obj.thisArg, 3);\n\t    }\n\t    return new FirstObservable(this, obj);\n\t  };\n\t\n\t  var LastObservable = (function (__super__) {\n\t    inherits(LastObservable, __super__);\n\t    function LastObservable(source, obj) {\n\t      this.source = source;\n\t      this._obj = obj;\n\t      __super__.call(this);\n\t    }\n\t\n\t    LastObservable.prototype.subscribeCore = function (o) {\n\t      return this.source.subscribe(new LastObserver(o, this._obj, this.source));\n\t    };\n\t\n\t    return LastObservable;\n\t  }(ObservableBase));\n\t\n\t  var LastObserver = (function(__super__) {\n\t    inherits(LastObserver, __super__);\n\t    function LastObserver(o, obj, s) {\n\t      this._o = o;\n\t      this._obj = obj;\n\t      this._s = s;\n\t      this._i = 0;\n\t      this._hv = false;\n\t      this._v = null;\n\t      __super__.call(this);\n\t    }\n\t\n\t    LastObserver.prototype.next = function (x) {\n\t      var shouldYield = false;\n\t      if (this._obj.predicate) {\n\t        var res = tryCatch(this._obj.predicate)(x, this._i++, this._s);\n\t        if (res === errorObj) { return this._o.onError(res.e); }\n\t        Boolean(res) && (shouldYield = true);\n\t      } else if (!this._obj.predicate) {\n\t        shouldYield = true;\n\t      }\n\t      if (shouldYield) {\n\t        this._hv = true;\n\t        this._v = x;\n\t      }\n\t    };\n\t    LastObserver.prototype.error = function (e) { this._o.onError(e); };\n\t    LastObserver.prototype.completed = function () {\n\t      if (this._hv) {\n\t        this._o.onNext(this._v);\n\t        this._o.onCompleted();\n\t      }\n\t      else if (this._obj.defaultValue === undefined) {\n\t        this._o.onError(new EmptyError());\n\t      } else {\n\t        this._o.onNext(this._obj.defaultValue);\n\t        this._o.onCompleted();\n\t      }\n\t    };\n\t\n\t    return LastObserver;\n\t  }(AbstractObserver));\n\t\n\t  /**\n\t   * Returns the last element of an observable sequence that satisfies the condition in the predicate if specified, else the last element.\n\t   * @returns {Observable} Sequence containing the last element in the observable sequence that satisfies the condition in the predicate.\n\t   */\n\t  observableProto.last = function () {\n\t    var obj = {}, source = this;\n\t    if (typeof arguments[0] === 'object') {\n\t      obj = arguments[0];\n\t    } else {\n\t      obj = {\n\t        predicate: arguments[0],\n\t        thisArg: arguments[1],\n\t        defaultValue: arguments[2]\n\t      };\n\t    }\n\t    if (isFunction (obj.predicate)) {\n\t      var fn = obj.predicate;\n\t      obj.predicate = bindCallback(fn, obj.thisArg, 3);\n\t    }\n\t    return new LastObservable(this, obj);\n\t  };\n\t\n\t  var FindValueObserver = (function(__super__) {\n\t    inherits(FindValueObserver, __super__);\n\t    function FindValueObserver(observer, source, callback, yieldIndex) {\n\t      this._o = observer;\n\t      this._s = source;\n\t      this._cb = callback;\n\t      this._y = yieldIndex;\n\t      this._i = 0;\n\t      __super__.call(this);\n\t    }\n\t\n\t    FindValueObserver.prototype.next = function (x) {\n\t      var shouldRun = tryCatch(this._cb)(x, this._i, this._s);\n\t      if (shouldRun === errorObj) { return this._o.onError(shouldRun.e); }\n\t      if (shouldRun) {\n\t        this._o.onNext(this._y ? this._i : x);\n\t        this._o.onCompleted();\n\t      } else {\n\t        this._i++;\n\t      }\n\t    };\n\t\n\t    FindValueObserver.prototype.error = function (e) {\n\t      this._o.onError(e);\n\t    };\n\t\n\t    FindValueObserver.prototype.completed = function () {\n\t      this._y && this._o.onNext(-1);\n\t      this._o.onCompleted();\n\t    };\n\t\n\t    return FindValueObserver;\n\t  }(AbstractObserver));\n\t\n\t  function findValue (source, predicate, thisArg, yieldIndex) {\n\t    var callback = bindCallback(predicate, thisArg, 3);\n\t    return new AnonymousObservable(function (o) {\n\t      return source.subscribe(new FindValueObserver(o, source, callback, yieldIndex));\n\t    }, source);\n\t  }\n\t\n\t  /**\n\t   * Searches for an element that matches the conditions defined by the specified predicate, and returns the first occurrence within the entire Observable sequence.\n\t   * @param {Function} predicate The predicate that defines the conditions of the element to search for.\n\t   * @param {Any} [thisArg] Object to use as `this` when executing the predicate.\n\t   * @returns {Observable} An Observable sequence with the first element that matches the conditions defined by the specified predicate, if found; otherwise, undefined.\n\t   */\n\t  observableProto.find = function (predicate, thisArg) {\n\t    return findValue(this, predicate, thisArg, false);\n\t  };\n\t\n\t  /**\n\t   * Searches for an element that matches the conditions defined by the specified predicate, and returns\n\t   * an Observable sequence with the zero-based index of the first occurrence within the entire Observable sequence.\n\t   * @param {Function} predicate The predicate that defines the conditions of the element to search for.\n\t   * @param {Any} [thisArg] Object to use as `this` when executing the predicate.\n\t   * @returns {Observable} An Observable sequence with the zero-based index of the first occurrence of an element that matches the conditions defined by match, if found; otherwise, –1.\n\t  */\n\t  observableProto.findIndex = function (predicate, thisArg) {\n\t    return findValue(this, predicate, thisArg, true);\n\t  };\n\t\n\t  var ToSetObservable = (function (__super__) {\n\t    inherits(ToSetObservable, __super__);\n\t    function ToSetObservable(source) {\n\t      this.source = source;\n\t      __super__.call(this);\n\t    }\n\t\n\t    ToSetObservable.prototype.subscribeCore = function (o) {\n\t      return this.source.subscribe(new ToSetObserver(o));\n\t    };\n\t\n\t    return ToSetObservable;\n\t  }(ObservableBase));\n\t\n\t  var ToSetObserver = (function (__super__) {\n\t    inherits(ToSetObserver, __super__);\n\t    function ToSetObserver(o) {\n\t      this._o = o;\n\t      this._s = new root.Set();\n\t      __super__.call(this);\n\t    }\n\t\n\t    ToSetObserver.prototype.next = function (x) {\n\t      this._s.add(x);\n\t    };\n\t\n\t    ToSetObserver.prototype.error = function (e) {\n\t      this._o.onError(e);\n\t    };\n\t\n\t    ToSetObserver.prototype.completed = function () {\n\t      this._o.onNext(this._s);\n\t      this._o.onCompleted();\n\t    };\n\t\n\t    return ToSetObserver;\n\t  }(AbstractObserver));\n\t\n\t  /**\n\t   * Converts the observable sequence to a Set if it exists.\n\t   * @returns {Observable} An observable sequence with a single value of a Set containing the values from the observable sequence.\n\t   */\n\t  observableProto.toSet = function () {\n\t    if (typeof root.Set === 'undefined') { throw new TypeError(); }\n\t    return new ToSetObservable(this);\n\t  };\n\t\n\t  var ToMapObservable = (function (__super__) {\n\t    inherits(ToMapObservable, __super__);\n\t    function ToMapObservable(source, k, e) {\n\t      this.source = source;\n\t      this._k = k;\n\t      this._e = e;\n\t      __super__.call(this);\n\t    }\n\t\n\t    ToMapObservable.prototype.subscribeCore = function (o) {\n\t      return this.source.subscribe(new ToMapObserver(o, this._k, this._e));\n\t    };\n\t\n\t    return ToMapObservable;\n\t  }(ObservableBase));\n\t\n\t  var ToMapObserver = (function (__super__) {\n\t    inherits(ToMapObserver, __super__);\n\t    function ToMapObserver(o, k, e) {\n\t      this._o = o;\n\t      this._k = k;\n\t      this._e = e;\n\t      this._m = new root.Map();\n\t      __super__.call(this);\n\t    }\n\t\n\t    ToMapObserver.prototype.next = function (x) {\n\t      var key = tryCatch(this._k)(x);\n\t      if (key === errorObj) { return this._o.onError(key.e); }\n\t      var elem = x;\n\t      if (this._e) {\n\t        elem = tryCatch(this._e)(x);\n\t        if (elem === errorObj) { return this._o.onError(elem.e); }\n\t      }\n\t\n\t      this._m.set(key, elem);\n\t    };\n\t\n\t    ToMapObserver.prototype.error = function (e) {\n\t      this._o.onError(e);\n\t    };\n\t\n\t    ToMapObserver.prototype.completed = function () {\n\t      this._o.onNext(this._m);\n\t      this._o.onCompleted();\n\t    };\n\t\n\t    return ToMapObserver;\n\t  }(AbstractObserver));\n\t\n\t  /**\n\t  * Converts the observable sequence to a Map if it exists.\n\t  * @param {Function} keySelector A function which produces the key for the Map.\n\t  * @param {Function} [elementSelector] An optional function which produces the element for the Map. If not present, defaults to the value from the observable sequence.\n\t  * @returns {Observable} An observable sequence with a single value of a Map containing the values from the observable sequence.\n\t  */\n\t  observableProto.toMap = function (keySelector, elementSelector) {\n\t    if (typeof root.Map === 'undefined') { throw new TypeError(); }\n\t    return new ToMapObservable(this, keySelector, elementSelector);\n\t  };\n\t\n\t  var SliceObservable = (function (__super__) {\n\t    inherits(SliceObservable, __super__);\n\t    function SliceObservable(source, b, e) {\n\t      this.source = source;\n\t      this._b = b;\n\t      this._e = e;\n\t      __super__.call(this);\n\t    }\n\t\n\t    SliceObservable.prototype.subscribeCore = function (o) {\n\t      return this.source.subscribe(new SliceObserver(o, this._b, this._e));\n\t    };\n\t\n\t    return SliceObservable;\n\t  }(ObservableBase));\n\t\n\t  var SliceObserver = (function (__super__) {\n\t    inherits(SliceObserver, __super__);\n\t\n\t    function SliceObserver(o, b, e) {\n\t      this._o = o;\n\t      this._b = b;\n\t      this._e = e;\n\t      this._i = 0;\n\t      __super__.call(this);\n\t    }\n\t\n\t    SliceObserver.prototype.next = function (x) {\n\t      if (this._i >= this._b) {\n\t        if (this._e === this._i) {\n\t          this._o.onCompleted();\n\t        } else {\n\t          this._o.onNext(x);\n\t        }\n\t      }\n\t      this._i++;\n\t    };\n\t    SliceObserver.prototype.error = function (e) { this._o.onError(e); };\n\t    SliceObserver.prototype.completed = function () { this._o.onCompleted(); };\n\t\n\t    return SliceObserver;\n\t  }(AbstractObserver));\n\t\n\t  /*\n\t  * The slice() method returns a shallow copy of a portion of an Observable into a new Observable object.\n\t  * Unlike the array version, this does not support negative numbers for being or end.\n\t  * @param {Number} [begin] Zero-based index at which to begin extraction. If omitted, this will default to zero.\n\t  * @param {Number} [end] Zero-based index at which to end extraction. slice extracts up to but not including end.\n\t  * If omitted, this will emit the rest of the Observable object.\n\t  * @returns {Observable} A shallow copy of a portion of an Observable into a new Observable object.\n\t  */\n\t  observableProto.slice = function (begin, end) {\n\t    var start = begin || 0;\n\t    if (start < 0) { throw new Rx.ArgumentOutOfRangeError(); }\n\t    if (typeof end === 'number' && end < start) {\n\t      throw new Rx.ArgumentOutOfRangeError();\n\t    }\n\t    return new SliceObservable(this, start, end);\n\t  };\n\t\n\t  var LastIndexOfObservable = (function (__super__) {\n\t    inherits(LastIndexOfObservable, __super__);\n\t    function LastIndexOfObservable(source, e, n) {\n\t      this.source = source;\n\t      this._e = e;\n\t      this._n = n;\n\t      __super__.call(this);\n\t    }\n\t\n\t    LastIndexOfObservable.prototype.subscribeCore = function (o) {\n\t      if (this._n < 0) {\n\t        o.onNext(-1);\n\t        o.onCompleted();\n\t        return disposableEmpty;\n\t      }\n\t\n\t      return this.source.subscribe(new LastIndexOfObserver(o, this._e, this._n));\n\t    };\n\t\n\t    return LastIndexOfObservable;\n\t  }(ObservableBase));\n\t\n\t  var LastIndexOfObserver = (function (__super__) {\n\t    inherits(LastIndexOfObserver, __super__);\n\t    function LastIndexOfObserver(o, e, n) {\n\t      this._o = o;\n\t      this._e = e;\n\t      this._n = n;\n\t      this._v = 0;\n\t      this._hv = false;\n\t      this._i = 0;\n\t      __super__.call(this);\n\t    }\n\t\n\t    LastIndexOfObserver.prototype.next = function (x) {\n\t      if (this._i >= this._n && x === this._e) {\n\t        this._hv = true;\n\t        this._v = this._i;\n\t      }\n\t      this._i++;\n\t    };\n\t    LastIndexOfObserver.prototype.error = function (e) { this._o.onError(e); };\n\t    LastIndexOfObserver.prototype.completed = function () {\n\t      if (this._hv) {\n\t        this._o.onNext(this._v);\n\t      } else {\n\t        this._o.onNext(-1);\n\t      }\n\t      this._o.onCompleted();\n\t    };\n\t\n\t    return LastIndexOfObserver;\n\t  }(AbstractObserver));\n\t\n\t  /**\n\t   * Returns the last index at which a given element can be found in the observable sequence, or -1 if it is not present.\n\t   * @param {Any} searchElement Element to locate in the array.\n\t   * @param {Number} [fromIndex] The index to start the search.  If not specified, defaults to 0.\n\t   * @returns {Observable} And observable sequence containing the last index at which a given element can be found in the observable sequence, or -1 if it is not present.\n\t   */\n\t  observableProto.lastIndexOf = function(searchElement, fromIndex) {\n\t    var n = +fromIndex || 0;\n\t    Math.abs(n) === Infinity && (n = 0);\n\t    return new LastIndexOfObservable(this, searchElement, n);\n\t  };\n\t\n\t  Observable.wrap = function (fn) {\n\t    function createObservable() {\n\t      return Observable.spawn.call(this, fn.apply(this, arguments));\n\t    }\n\t\n\t    createObservable.__generatorFunction__ = fn;\n\t    return createObservable;\n\t  };\n\t\n\t  var spawn = Observable.spawn = function () {\n\t    var gen = arguments[0], self = this, args = [];\n\t    for (var i = 1, len = arguments.length; i < len; i++) { args.push(arguments[i]); }\n\t\n\t    return new AnonymousObservable(function (o) {\n\t      var g = new CompositeDisposable();\n\t\n\t      if (isFunction(gen)) { gen = gen.apply(self, args); }\n\t      if (!gen || !isFunction(gen.next)) {\n\t        o.onNext(gen);\n\t        return o.onCompleted();\n\t      }\n\t\n\t      function processGenerator(res) {\n\t        var ret = tryCatch(gen.next).call(gen, res);\n\t        if (ret === errorObj) { return o.onError(ret.e); }\n\t        next(ret);\n\t      }\n\t\n\t      processGenerator();\n\t\n\t      function onError(err) {\n\t        var ret = tryCatch(gen.next).call(gen, err);\n\t        if (ret === errorObj) { return o.onError(ret.e); }\n\t        next(ret);\n\t      }\n\t\n\t      function next(ret) {\n\t        if (ret.done) {\n\t          o.onNext(ret.value);\n\t          o.onCompleted();\n\t          return;\n\t        }\n\t        var obs = toObservable.call(self, ret.value);\n\t        var value = null;\n\t        var hasValue = false;\n\t        if (Observable.isObservable(obs)) {\n\t          g.add(obs.subscribe(function(val) {\n\t            hasValue = true;\n\t            value = val;\n\t          }, onError, function() {\n\t            hasValue && processGenerator(value);\n\t          }));\n\t        } else {\n\t          onError(new TypeError('type not supported'));\n\t        }\n\t      }\n\t\n\t      return g;\n\t    });\n\t  };\n\t\n\t  function toObservable(obj) {\n\t    if (!obj) { return obj; }\n\t    if (Observable.isObservable(obj)) { return obj; }\n\t    if (isPromise(obj)) { return Observable.fromPromise(obj); }\n\t    if (isGeneratorFunction(obj) || isGenerator(obj)) { return spawn.call(this, obj); }\n\t    if (isFunction(obj)) { return thunkToObservable.call(this, obj); }\n\t    if (isArrayLike(obj) || isIterable(obj)) { return arrayToObservable.call(this, obj); }\n\t    if (isObject(obj)) {return objectToObservable.call(this, obj);}\n\t    return obj;\n\t  }\n\t\n\t  function arrayToObservable (obj) {\n\t    return Observable.from(obj).concatMap(function(o) {\n\t      if(Observable.isObservable(o) || isObject(o)) {\n\t        return toObservable.call(null, o);\n\t      } else {\n\t        return Rx.Observable.just(o);\n\t      }\n\t    }).toArray();\n\t  }\n\t\n\t  function objectToObservable (obj) {\n\t    var results = new obj.constructor(), keys = Object.keys(obj), observables = [];\n\t    for (var i = 0, len = keys.length; i < len; i++) {\n\t      var key = keys[i];\n\t      var observable = toObservable.call(this, obj[key]);\n\t\n\t      if(observable && Observable.isObservable(observable)) {\n\t        defer(observable, key);\n\t      } else {\n\t        results[key] = obj[key];\n\t      }\n\t    }\n\t\n\t    return Observable.forkJoin.apply(Observable, observables).map(function() {\n\t      return results;\n\t    });\n\t\n\t\n\t    function defer (observable, key) {\n\t      results[key] = undefined;\n\t      observables.push(observable.map(function (next) {\n\t        results[key] = next;\n\t      }));\n\t    }\n\t  }\n\t\n\t  function thunkToObservable(fn) {\n\t    var self = this;\n\t    return new AnonymousObservable(function (o) {\n\t      fn.call(self, function () {\n\t        var err = arguments[0], res = arguments[1];\n\t        if (err) { return o.onError(err); }\n\t        if (arguments.length > 2) {\n\t          var args = [];\n\t          for (var i = 1, len = arguments.length; i < len; i++) { args.push(arguments[i]); }\n\t          res = args;\n\t        }\n\t        o.onNext(res);\n\t        o.onCompleted();\n\t      });\n\t    });\n\t  }\n\t\n\t  function isGenerator(obj) {\n\t    return isFunction (obj.next) && isFunction (obj['throw']);\n\t  }\n\t\n\t  function isGeneratorFunction(obj) {\n\t    var ctor = obj.constructor;\n\t    if (!ctor) { return false; }\n\t    if (ctor.name === 'GeneratorFunction' || ctor.displayName === 'GeneratorFunction') { return true; }\n\t    return isGenerator(ctor.prototype);\n\t  }\n\t\n\t  function isObject(val) {\n\t    return Object == val.constructor;\n\t  }\n\t\n\t  /**\n\t   * Invokes the specified function asynchronously on the specified scheduler, surfacing the result through an observable sequence.\n\t   *\n\t   * @example\n\t   * var res = Rx.Observable.start(function () { console.log('hello'); });\n\t   * var res = Rx.Observable.start(function () { console.log('hello'); }, Rx.Scheduler.timeout);\n\t   * var res = Rx.Observable.start(function () { this.log('hello'); }, Rx.Scheduler.timeout, console);\n\t   *\n\t   * @param {Function} func Function to run asynchronously.\n\t   * @param {Scheduler} [scheduler]  Scheduler to run the function on. If not specified, defaults to Scheduler.timeout.\n\t   * @param [context]  The context for the func parameter to be executed.  If not specified, defaults to undefined.\n\t   * @returns {Observable} An observable sequence exposing the function's result value, or an exception.\n\t   *\n\t   * Remarks\n\t   * * The function is called immediately, not during the subscription of the resulting sequence.\n\t   * * Multiple subscriptions to the resulting sequence can observe the function's result.\n\t   */\n\t  Observable.start = function (func, context, scheduler) {\n\t    return observableToAsync(func, context, scheduler)();\n\t  };\n\t\n\t  /**\n\t   * Converts the function into an asynchronous function. Each invocation of the resulting asynchronous function causes an invocation of the original synchronous function on the specified scheduler.\n\t   * @param {Function} function Function to convert to an asynchronous function.\n\t   * @param {Scheduler} [scheduler] Scheduler to run the function on. If not specified, defaults to Scheduler.timeout.\n\t   * @param {Mixed} [context] The context for the func parameter to be executed.  If not specified, defaults to undefined.\n\t   * @returns {Function} Asynchronous function.\n\t   */\n\t  var observableToAsync = Observable.toAsync = function (func, context, scheduler) {\n\t    isScheduler(scheduler) || (scheduler = defaultScheduler);\n\t    return function () {\n\t      var args = arguments,\n\t        subject = new AsyncSubject();\n\t\n\t      scheduler.schedule(null, function () {\n\t        var result;\n\t        try {\n\t          result = func.apply(context, args);\n\t        } catch (e) {\n\t          subject.onError(e);\n\t          return;\n\t        }\n\t        subject.onNext(result);\n\t        subject.onCompleted();\n\t      });\n\t      return subject.asObservable();\n\t    };\n\t  };\n\t\n\tfunction createCbObservable(fn, ctx, selector, args) {\n\t  var o = new AsyncSubject();\n\t\n\t  args.push(createCbHandler(o, ctx, selector));\n\t  fn.apply(ctx, args);\n\t\n\t  return o.asObservable();\n\t}\n\t\n\tfunction createCbHandler(o, ctx, selector) {\n\t  return function handler () {\n\t    var len = arguments.length, results = new Array(len);\n\t    for(var i = 0; i < len; i++) { results[i] = arguments[i]; }\n\t\n\t    if (isFunction(selector)) {\n\t      results = tryCatch(selector).apply(ctx, results);\n\t      if (results === errorObj) { return o.onError(results.e); }\n\t      o.onNext(results);\n\t    } else {\n\t      if (results.length <= 1) {\n\t        o.onNext(results[0]);\n\t      } else {\n\t        o.onNext(results);\n\t      }\n\t    }\n\t\n\t    o.onCompleted();\n\t  };\n\t}\n\t\n\t/**\n\t * Converts a callback function to an observable sequence.\n\t *\n\t * @param {Function} fn Function with a callback as the last parameter to convert to an Observable sequence.\n\t * @param {Mixed} [ctx] The context for the func parameter to be executed.  If not specified, defaults to undefined.\n\t * @param {Function} [selector] A selector which takes the arguments from the callback to produce a single item to yield on next.\n\t * @returns {Function} A function, when executed with the required parameters minus the callback, produces an Observable sequence with a single value of the arguments to the callback as an array.\n\t */\n\tObservable.fromCallback = function (fn, ctx, selector) {\n\t  return function () {\n\t    typeof ctx === 'undefined' && (ctx = this); \n\t\n\t    var len = arguments.length, args = new Array(len)\n\t    for(var i = 0; i < len; i++) { args[i] = arguments[i]; }\n\t    return createCbObservable(fn, ctx, selector, args);\n\t  };\n\t};\n\t\n\tfunction createNodeObservable(fn, ctx, selector, args) {\n\t  var o = new AsyncSubject();\n\t\n\t  args.push(createNodeHandler(o, ctx, selector));\n\t  fn.apply(ctx, args);\n\t\n\t  return o.asObservable();\n\t}\n\t\n\tfunction createNodeHandler(o, ctx, selector) {\n\t  return function handler () {\n\t    var err = arguments[0];\n\t    if (err) { return o.onError(err); }\n\t\n\t    var len = arguments.length, results = [];\n\t    for(var i = 1; i < len; i++) { results[i - 1] = arguments[i]; }\n\t\n\t    if (isFunction(selector)) {\n\t      var results = tryCatch(selector).apply(ctx, results);\n\t      if (results === errorObj) { return o.onError(results.e); }\n\t      o.onNext(results);\n\t    } else {\n\t      if (results.length <= 1) {\n\t        o.onNext(results[0]);\n\t      } else {\n\t        o.onNext(results);\n\t      }\n\t    }\n\t\n\t    o.onCompleted();\n\t  };\n\t}\n\t\n\t/**\n\t * Converts a Node.js callback style function to an observable sequence.  This must be in function (err, ...) format.\n\t * @param {Function} fn The function to call\n\t * @param {Mixed} [ctx] The context for the func parameter to be executed.  If not specified, defaults to undefined.\n\t * @param {Function} [selector] A selector which takes the arguments from the callback minus the error to produce a single item to yield on next.\n\t * @returns {Function} An async function which when applied, returns an observable sequence with the callback arguments as an array.\n\t */\n\tObservable.fromNodeCallback = function (fn, ctx, selector) {\n\t  return function () {\n\t    typeof ctx === 'undefined' && (ctx = this); \n\t    var len = arguments.length, args = new Array(len);\n\t    for(var i = 0; i < len; i++) { args[i] = arguments[i]; }\n\t    return createNodeObservable(fn, ctx, selector, args);\n\t  };\n\t};\n\t\n\t  function isNodeList(el) {\n\t    if (root.StaticNodeList) {\n\t      // IE8 Specific\n\t      // instanceof is slower than Object#toString, but Object#toString will not work as intended in IE8\n\t      return el instanceof root.StaticNodeList || el instanceof root.NodeList;\n\t    } else {\n\t      return Object.prototype.toString.call(el) === '[object NodeList]';\n\t    }\n\t  }\n\t\n\t  function ListenDisposable(e, n, fn) {\n\t    this._e = e;\n\t    this._n = n;\n\t    this._fn = fn;\n\t    this._e.addEventListener(this._n, this._fn, false);\n\t    this.isDisposed = false;\n\t  }\n\t  ListenDisposable.prototype.dispose = function () {\n\t    if (!this.isDisposed) {\n\t      this._e.removeEventListener(this._n, this._fn, false);\n\t      this.isDisposed = true;\n\t    }\n\t  };\n\t\n\t  function createEventListener (el, eventName, handler) {\n\t    var disposables = new CompositeDisposable();\n\t\n\t    // Asume NodeList or HTMLCollection\n\t    var elemToString = Object.prototype.toString.call(el);\n\t    if (isNodeList(el) || elemToString === '[object HTMLCollection]') {\n\t      for (var i = 0, len = el.length; i < len; i++) {\n\t        disposables.add(createEventListener(el.item(i), eventName, handler));\n\t      }\n\t    } else if (el) {\n\t      disposables.add(new ListenDisposable(el, eventName, handler));\n\t    }\n\t\n\t    return disposables;\n\t  }\n\t\n\t  /**\n\t   * Configuration option to determine whether to use native events only\n\t   */\n\t  Rx.config.useNativeEvents = false;\n\t\n\t  var EventObservable = (function(__super__) {\n\t    inherits(EventObservable, __super__);\n\t    function EventObservable(el, name, fn) {\n\t      this._el = el;\n\t      this._n = name;\n\t      this._fn = fn;\n\t      __super__.call(this);\n\t    }\n\t\n\t    function createHandler(o, fn) {\n\t      return function handler () {\n\t        var results = arguments[0];\n\t        if (isFunction(fn)) {\n\t          results = tryCatch(fn).apply(null, arguments);\n\t          if (results === errorObj) { return o.onError(results.e); }\n\t        }\n\t        o.onNext(results);\n\t      };\n\t    }\n\t\n\t    EventObservable.prototype.subscribeCore = function (o) {\n\t      return createEventListener(\n\t        this._el,\n\t        this._n,\n\t        createHandler(o, this._fn));\n\t    };\n\t\n\t    return EventObservable;\n\t  }(ObservableBase));\n\t\n\t  /**\n\t   * Creates an observable sequence by adding an event listener to the matching DOMElement or each item in the NodeList.\n\t   * @param {Object} element The DOMElement or NodeList to attach a listener.\n\t   * @param {String} eventName The event name to attach the observable sequence.\n\t   * @param {Function} [selector] A selector which takes the arguments from the event handler to produce a single item to yield on next.\n\t   * @returns {Observable} An observable sequence of events from the specified element and the specified event.\n\t   */\n\t  Observable.fromEvent = function (element, eventName, selector) {\n\t    // Node.js specific\n\t    if (element.addListener) {\n\t      return fromEventPattern(\n\t        function (h) { element.addListener(eventName, h); },\n\t        function (h) { element.removeListener(eventName, h); },\n\t        selector);\n\t    }\n\t\n\t    // Use only if non-native events are allowed\n\t    if (!Rx.config.useNativeEvents) {\n\t      // Handles jq, Angular.js, Zepto, Marionette, Ember.js\n\t      if (typeof element.on === 'function' && typeof element.off === 'function') {\n\t        return fromEventPattern(\n\t          function (h) { element.on(eventName, h); },\n\t          function (h) { element.off(eventName, h); },\n\t          selector);\n\t      }\n\t    }\n\t\n\t    return new EventObservable(element, eventName, selector).publish().refCount();\n\t  };\n\t\n\t  var EventPatternObservable = (function(__super__) {\n\t    inherits(EventPatternObservable, __super__);\n\t    function EventPatternObservable(add, del, fn) {\n\t      this._add = add;\n\t      this._del = del;\n\t      this._fn = fn;\n\t      __super__.call(this);\n\t    }\n\t\n\t    function createHandler(o, fn) {\n\t      return function handler () {\n\t        var results = arguments[0];\n\t        if (isFunction(fn)) {\n\t          results = tryCatch(fn).apply(null, arguments);\n\t          if (results === errorObj) { return o.onError(results.e); }\n\t        }\n\t        o.onNext(results);\n\t      };\n\t    }\n\t\n\t    EventPatternObservable.prototype.subscribeCore = function (o) {\n\t      var fn = createHandler(o, this._fn);\n\t      var returnValue = this._add(fn);\n\t      return new EventPatternDisposable(this._del, fn, returnValue);\n\t    };\n\t\n\t    function EventPatternDisposable(del, fn, ret) {\n\t      this._del = del;\n\t      this._fn = fn;\n\t      this._ret = ret;\n\t      this.isDisposed = false;\n\t    }\n\t\n\t    EventPatternDisposable.prototype.dispose = function () {\n\t      if(!this.isDisposed) {\n\t        isFunction(this._del) && this._del(this._fn, this._ret);\n\t      }\n\t    };\n\t\n\t    return EventPatternObservable;\n\t  }(ObservableBase));\n\t\n\t  /**\n\t   * Creates an observable sequence from an event emitter via an addHandler/removeHandler pair.\n\t   * @param {Function} addHandler The function to add a handler to the emitter.\n\t   * @param {Function} [removeHandler] The optional function to remove a handler from an emitter.\n\t   * @param {Function} [selector] A selector which takes the arguments from the event handler to produce a single item to yield on next.\n\t   * @returns {Observable} An observable sequence which wraps an event from an event emitter\n\t   */\n\t  var fromEventPattern = Observable.fromEventPattern = function (addHandler, removeHandler, selector) {\n\t    return new EventPatternObservable(addHandler, removeHandler, selector).publish().refCount();\n\t  };\n\t\n\t  /**\n\t   * Invokes the asynchronous function, surfacing the result through an observable sequence.\n\t   * @param {Function} functionAsync Asynchronous function which returns a Promise to run.\n\t   * @returns {Observable} An observable sequence exposing the function's result value, or an exception.\n\t   */\n\t  Observable.startAsync = function (functionAsync) {\n\t    var promise = tryCatch(functionAsync)();\n\t    if (promise === errorObj) { return observableThrow(promise.e); }\n\t    return observableFromPromise(promise);\n\t  };\n\t\n\t  var PausableObservable = (function (__super__) {\n\t    inherits(PausableObservable, __super__);\n\t    function PausableObservable(source, pauser) {\n\t      this.source = source;\n\t      this.controller = new Subject();\n\t\n\t      if (pauser && pauser.subscribe) {\n\t        this.pauser = this.controller.merge(pauser);\n\t      } else {\n\t        this.pauser = this.controller;\n\t      }\n\t\n\t      __super__.call(this);\n\t    }\n\t\n\t    PausableObservable.prototype._subscribe = function (o) {\n\t      var conn = this.source.publish(),\n\t        subscription = conn.subscribe(o),\n\t        connection = disposableEmpty;\n\t\n\t      var pausable = this.pauser.distinctUntilChanged().subscribe(function (b) {\n\t        if (b) {\n\t          connection = conn.connect();\n\t        } else {\n\t          connection.dispose();\n\t          connection = disposableEmpty;\n\t        }\n\t      });\n\t\n\t      return new NAryDisposable([subscription, connection, pausable]);\n\t    };\n\t\n\t    PausableObservable.prototype.pause = function () {\n\t      this.controller.onNext(false);\n\t    };\n\t\n\t    PausableObservable.prototype.resume = function () {\n\t      this.controller.onNext(true);\n\t    };\n\t\n\t    return PausableObservable;\n\t\n\t  }(Observable));\n\t\n\t  /**\n\t   * Pauses the underlying observable sequence based upon the observable sequence which yields true/false.\n\t   * @example\n\t   * var pauser = new Rx.Subject();\n\t   * var source = Rx.Observable.interval(100).pausable(pauser);\n\t   * @param {Observable} pauser The observable sequence used to pause the underlying sequence.\n\t   * @returns {Observable} The observable sequence which is paused based upon the pauser.\n\t   */\n\t  observableProto.pausable = function (pauser) {\n\t    return new PausableObservable(this, pauser);\n\t  };\n\t\n\t  function combineLatestSource(source, subject, resultSelector) {\n\t    return new AnonymousObservable(function (o) {\n\t      var hasValue = [false, false],\n\t        hasValueAll = false,\n\t        isDone = false,\n\t        values = new Array(2),\n\t        err;\n\t\n\t      function next(x, i) {\n\t        values[i] = x;\n\t        hasValue[i] = true;\n\t        if (hasValueAll || (hasValueAll = hasValue.every(identity))) {\n\t          if (err) { return o.onError(err); }\n\t          var res = tryCatch(resultSelector).apply(null, values);\n\t          if (res === errorObj) { return o.onError(res.e); }\n\t          o.onNext(res);\n\t        }\n\t        isDone && values[1] && o.onCompleted();\n\t      }\n\t\n\t      return new BinaryDisposable(\n\t        source.subscribe(\n\t          function (x) {\n\t            next(x, 0);\n\t          },\n\t          function (e) {\n\t            if (values[1]) {\n\t              o.onError(e);\n\t            } else {\n\t              err = e;\n\t            }\n\t          },\n\t          function () {\n\t            isDone = true;\n\t            values[1] && o.onCompleted();\n\t          }),\n\t        subject.subscribe(\n\t          function (x) {\n\t            next(x, 1);\n\t          },\n\t          function (e) { o.onError(e); },\n\t          function () {\n\t            isDone = true;\n\t            next(true, 1);\n\t          })\n\t        );\n\t    }, source);\n\t  }\n\t\n\t  var PausableBufferedObservable = (function (__super__) {\n\t    inherits(PausableBufferedObservable, __super__);\n\t    function PausableBufferedObservable(source, pauser) {\n\t      this.source = source;\n\t      this.controller = new Subject();\n\t\n\t      if (pauser && pauser.subscribe) {\n\t        this.pauser = this.controller.merge(pauser);\n\t      } else {\n\t        this.pauser = this.controller;\n\t      }\n\t\n\t      __super__.call(this);\n\t    }\n\t\n\t    PausableBufferedObservable.prototype._subscribe = function (o) {\n\t      var q = [], previousShouldFire;\n\t\n\t      function drainQueue() { while (q.length > 0) { o.onNext(q.shift()); } }\n\t\n\t      var subscription =\n\t        combineLatestSource(\n\t          this.source,\n\t          this.pauser.startWith(false).distinctUntilChanged(),\n\t          function (data, shouldFire) {\n\t            return { data: data, shouldFire: shouldFire };\n\t          })\n\t          .subscribe(\n\t            function (results) {\n\t              if (previousShouldFire !== undefined && results.shouldFire !== previousShouldFire) {\n\t                previousShouldFire = results.shouldFire;\n\t                // change in shouldFire\n\t                if (results.shouldFire) { drainQueue(); }\n\t              } else {\n\t                previousShouldFire = results.shouldFire;\n\t                // new data\n\t                if (results.shouldFire) {\n\t                  o.onNext(results.data);\n\t                } else {\n\t                  q.push(results.data);\n\t                }\n\t              }\n\t            },\n\t            function (err) {\n\t              drainQueue();\n\t              o.onError(err);\n\t            },\n\t            function () {\n\t              drainQueue();\n\t              o.onCompleted();\n\t            }\n\t          );\n\t      return subscription;      \n\t    };\n\t\n\t    PausableBufferedObservable.prototype.pause = function () {\n\t      this.controller.onNext(false);\n\t    };\n\t\n\t    PausableBufferedObservable.prototype.resume = function () {\n\t      this.controller.onNext(true);\n\t    };\n\t\n\t    return PausableBufferedObservable;\n\t\n\t  }(Observable));\n\t\n\t  /**\n\t   * Pauses the underlying observable sequence based upon the observable sequence which yields true/false,\n\t   * and yields the values that were buffered while paused.\n\t   * @example\n\t   * var pauser = new Rx.Subject();\n\t   * var source = Rx.Observable.interval(100).pausableBuffered(pauser);\n\t   * @param {Observable} pauser The observable sequence used to pause the underlying sequence.\n\t   * @returns {Observable} The observable sequence which is paused based upon the pauser.\n\t   */\n\t  observableProto.pausableBuffered = function (pauser) {\n\t    return new PausableBufferedObservable(this, pauser);\n\t  };\n\t\n\t  var ControlledObservable = (function (__super__) {\n\t    inherits(ControlledObservable, __super__);\n\t    function ControlledObservable (source, enableQueue, scheduler) {\n\t      __super__.call(this);\n\t      this.subject = new ControlledSubject(enableQueue, scheduler);\n\t      this.source = source.multicast(this.subject).refCount();\n\t    }\n\t\n\t    ControlledObservable.prototype._subscribe = function (o) {\n\t      return this.source.subscribe(o);\n\t    };\n\t\n\t    ControlledObservable.prototype.request = function (numberOfItems) {\n\t      return this.subject.request(numberOfItems == null ? -1 : numberOfItems);\n\t    };\n\t\n\t    return ControlledObservable;\n\t\n\t  }(Observable));\n\t\n\t  var ControlledSubject = (function (__super__) {\n\t    inherits(ControlledSubject, __super__);\n\t    function ControlledSubject(enableQueue, scheduler) {\n\t      enableQueue == null && (enableQueue = true);\n\t\n\t      __super__.call(this);\n\t      this.subject = new Subject();\n\t      this.enableQueue = enableQueue;\n\t      this.queue = enableQueue ? [] : null;\n\t      this.requestedCount = 0;\n\t      this.requestedDisposable = null;\n\t      this.error = null;\n\t      this.hasFailed = false;\n\t      this.hasCompleted = false;\n\t      this.scheduler = scheduler || currentThreadScheduler;\n\t    }\n\t\n\t    addProperties(ControlledSubject.prototype, Observer, {\n\t      _subscribe: function (o) {\n\t        return this.subject.subscribe(o);\n\t      },\n\t      onCompleted: function () {\n\t        this.hasCompleted = true;\n\t        if (!this.enableQueue || this.queue.length === 0) {\n\t          this.subject.onCompleted();\n\t          this.disposeCurrentRequest();\n\t        } else {\n\t          this.queue.push(Notification.createOnCompleted());\n\t        }\n\t      },\n\t      onError: function (error) {\n\t        this.hasFailed = true;\n\t        this.error = error;\n\t        if (!this.enableQueue || this.queue.length === 0) {\n\t          this.subject.onError(error);\n\t          this.disposeCurrentRequest();\n\t        } else {\n\t          this.queue.push(Notification.createOnError(error));\n\t        }\n\t      },\n\t      onNext: function (value) {\n\t        if (this.requestedCount <= 0) {\n\t          this.enableQueue && this.queue.push(Notification.createOnNext(value));\n\t        } else {\n\t          (this.requestedCount-- === 0) && this.disposeCurrentRequest();\n\t          this.subject.onNext(value);\n\t        }\n\t      },\n\t      _processRequest: function (numberOfItems) {\n\t        if (this.enableQueue) {\n\t          while (this.queue.length > 0 && (numberOfItems > 0 || this.queue[0].kind !== 'N')) {\n\t            var first = this.queue.shift();\n\t            first.accept(this.subject);\n\t            if (first.kind === 'N') {\n\t              numberOfItems--;\n\t            } else {\n\t              this.disposeCurrentRequest();\n\t              this.queue = [];\n\t            }\n\t          }\n\t        }\n\t\n\t        return numberOfItems;\n\t      },\n\t      request: function (number) {\n\t        this.disposeCurrentRequest();\n\t        var self = this;\n\t\n\t        this.requestedDisposable = this.scheduler.schedule(number,\n\t        function(s, i) {\n\t          var remaining = self._processRequest(i);\n\t          var stopped = self.hasCompleted || self.hasFailed;\n\t          if (!stopped && remaining > 0) {\n\t            self.requestedCount = remaining;\n\t\n\t            return disposableCreate(function () {\n\t              self.requestedCount = 0;\n\t            });\n\t              // Scheduled item is still in progress. Return a new\n\t              // disposable to allow the request to be interrupted\n\t              // via dispose.\n\t          }\n\t        });\n\t\n\t        return this.requestedDisposable;\n\t      },\n\t      disposeCurrentRequest: function () {\n\t        if (this.requestedDisposable) {\n\t          this.requestedDisposable.dispose();\n\t          this.requestedDisposable = null;\n\t        }\n\t      }\n\t    });\n\t\n\t    return ControlledSubject;\n\t  }(Observable));\n\t\n\t  /**\n\t   * Attaches a controller to the observable sequence with the ability to queue.\n\t   * @example\n\t   * var source = Rx.Observable.interval(100).controlled();\n\t   * source.request(3); // Reads 3 values\n\t   * @param {bool} enableQueue truthy value to determine if values should be queued pending the next request\n\t   * @param {Scheduler} scheduler determines how the requests will be scheduled\n\t   * @returns {Observable} The observable sequence which only propagates values on request.\n\t   */\n\t  observableProto.controlled = function (enableQueue, scheduler) {\n\t\n\t    if (enableQueue && isScheduler(enableQueue)) {\n\t      scheduler = enableQueue;\n\t      enableQueue = true;\n\t    }\n\t\n\t    if (enableQueue == null) {  enableQueue = true; }\n\t    return new ControlledObservable(this, enableQueue, scheduler);\n\t  };\n\t\n\t  var StopAndWaitObservable = (function (__super__) {\n\t    inherits(StopAndWaitObservable, __super__);\n\t    function StopAndWaitObservable (source) {\n\t      __super__.call(this);\n\t      this.source = source;\n\t    }\n\t\n\t    function scheduleMethod(s, self) {\n\t      self.source.request(1);\n\t    }\n\t\n\t    StopAndWaitObservable.prototype._subscribe = function (o) {\n\t      this.subscription = this.source.subscribe(new StopAndWaitObserver(o, this, this.subscription));\n\t      return new BinaryDisposable(\n\t        this.subscription,\n\t        defaultScheduler.schedule(this, scheduleMethod)\n\t      );\n\t    };\n\t\n\t    var StopAndWaitObserver = (function (__sub__) {\n\t      inherits(StopAndWaitObserver, __sub__);\n\t      function StopAndWaitObserver (observer, observable, cancel) {\n\t        __sub__.call(this);\n\t        this.observer = observer;\n\t        this.observable = observable;\n\t        this.cancel = cancel;\n\t        this.scheduleDisposable = null;\n\t      }\n\t\n\t      StopAndWaitObserver.prototype.completed = function () {\n\t        this.observer.onCompleted();\n\t        this.dispose();\n\t      };\n\t\n\t      StopAndWaitObserver.prototype.error = function (error) {\n\t        this.observer.onError(error);\n\t        this.dispose();\n\t      };\n\t\n\t      function innerScheduleMethod(s, self) {\n\t        self.observable.source.request(1);\n\t      }\n\t\n\t      StopAndWaitObserver.prototype.next = function (value) {\n\t        this.observer.onNext(value);\n\t        this.scheduleDisposable = defaultScheduler.schedule(this, innerScheduleMethod);\n\t      };\n\t\n\t      StopAndWaitObservable.dispose = function () {\n\t        this.observer = null;\n\t        if (this.cancel) {\n\t          this.cancel.dispose();\n\t          this.cancel = null;\n\t        }\n\t        if (this.scheduleDisposable) {\n\t          this.scheduleDisposable.dispose();\n\t          this.scheduleDisposable = null;\n\t        }\n\t        __sub__.prototype.dispose.call(this);\n\t      };\n\t\n\t      return StopAndWaitObserver;\n\t    }(AbstractObserver));\n\t\n\t    return StopAndWaitObservable;\n\t  }(Observable));\n\t\n\t\n\t  /**\n\t   * Attaches a stop and wait observable to the current observable.\n\t   * @returns {Observable} A stop and wait observable.\n\t   */\n\t  ControlledObservable.prototype.stopAndWait = function () {\n\t    return new StopAndWaitObservable(this);\n\t  };\n\t\n\t  var WindowedObservable = (function (__super__) {\n\t    inherits(WindowedObservable, __super__);\n\t    function WindowedObservable(source, windowSize) {\n\t      __super__.call(this);\n\t      this.source = source;\n\t      this.windowSize = windowSize;\n\t    }\n\t\n\t    function scheduleMethod(s, self) {\n\t      self.source.request(self.windowSize);\n\t    }\n\t\n\t    WindowedObservable.prototype._subscribe = function (o) {\n\t      this.subscription = this.source.subscribe(new WindowedObserver(o, this, this.subscription));\n\t      return new BinaryDisposable(\n\t        this.subscription,\n\t        defaultScheduler.schedule(this, scheduleMethod)\n\t      );\n\t    };\n\t\n\t    var WindowedObserver = (function (__sub__) {\n\t      inherits(WindowedObserver, __sub__);\n\t      function WindowedObserver(observer, observable, cancel) {\n\t        this.observer = observer;\n\t        this.observable = observable;\n\t        this.cancel = cancel;\n\t        this.received = 0;\n\t        this.scheduleDisposable = null;\n\t        __sub__.call(this);\n\t      }\n\t\n\t      WindowedObserver.prototype.completed = function () {\n\t        this.observer.onCompleted();\n\t        this.dispose();\n\t      };\n\t\n\t      WindowedObserver.prototype.error = function (error) {\n\t        this.observer.onError(error);\n\t        this.dispose();\n\t      };\n\t\n\t      function innerScheduleMethod(s, self) {\n\t        self.observable.source.request(self.observable.windowSize);\n\t      }\n\t\n\t      WindowedObserver.prototype.next = function (value) {\n\t        this.observer.onNext(value);\n\t        this.received = ++this.received % this.observable.windowSize;\n\t        this.received === 0 && (this.scheduleDisposable = defaultScheduler.schedule(this, innerScheduleMethod));\n\t      };\n\t\n\t      WindowedObserver.prototype.dispose = function () {\n\t        this.observer = null;\n\t        if (this.cancel) {\n\t          this.cancel.dispose();\n\t          this.cancel = null;\n\t        }\n\t        if (this.scheduleDisposable) {\n\t          this.scheduleDisposable.dispose();\n\t          this.scheduleDisposable = null;\n\t        }\n\t        __sub__.prototype.dispose.call(this);\n\t      };\n\t\n\t      return WindowedObserver;\n\t    }(AbstractObserver));\n\t\n\t    return WindowedObservable;\n\t  }(Observable));\n\t\n\t  /**\n\t   * Creates a sliding windowed observable based upon the window size.\n\t   * @param {Number} windowSize The number of items in the window\n\t   * @returns {Observable} A windowed observable based upon the window size.\n\t   */\n\t  ControlledObservable.prototype.windowed = function (windowSize) {\n\t    return new WindowedObservable(this, windowSize);\n\t  };\n\t\n\t  /**\n\t   * Pipes the existing Observable sequence into a Node.js Stream.\n\t   * @param {Stream} dest The destination Node.js stream.\n\t   * @returns {Stream} The destination stream.\n\t   */\n\t  observableProto.pipe = function (dest) {\n\t    var source = this.pausableBuffered();\n\t\n\t    function onDrain() {\n\t      source.resume();\n\t    }\n\t\n\t    dest.addListener('drain', onDrain);\n\t\n\t    source.subscribe(\n\t      function (x) {\n\t        !dest.write(String(x)) && source.pause();\n\t      },\n\t      function (err) {\n\t        dest.emit('error', err);\n\t      },\n\t      function () {\n\t        // Hack check because STDIO is not closable\n\t        !dest._isStdio && dest.end();\n\t        dest.removeListener('drain', onDrain);\n\t      });\n\t\n\t    source.resume();\n\t\n\t    return dest;\n\t  };\n\t\n\t  var MulticastObservable = (function (__super__) {\n\t    inherits(MulticastObservable, __super__);\n\t    function MulticastObservable(source, fn1, fn2) {\n\t      this.source = source;\n\t      this._fn1 = fn1;\n\t      this._fn2 = fn2;\n\t      __super__.call(this);\n\t    }\n\t\n\t    MulticastObservable.prototype.subscribeCore = function (o) {\n\t      var connectable = this.source.multicast(this._fn1());\n\t      return new BinaryDisposable(this._fn2(connectable).subscribe(o), connectable.connect());\n\t    };\n\t\n\t    return MulticastObservable;\n\t  }(ObservableBase));\n\t\n\t  /**\n\t   * Multicasts the source sequence notifications through an instantiated subject into all uses of the sequence within a selector function. Each\n\t   * subscription to the resulting sequence causes a separate multicast invocation, exposing the sequence resulting from the selector function's\n\t   * invocation. For specializations with fixed subject types, see Publish, PublishLast, and Replay.\n\t   *\n\t   * @example\n\t   * 1 - res = source.multicast(observable);\n\t   * 2 - res = source.multicast(function () { return new Subject(); }, function (x) { return x; });\n\t   *\n\t   * @param {Function|Subject} subjectOrSubjectSelector\n\t   * Factory function to create an intermediate subject through which the source sequence's elements will be multicast to the selector function.\n\t   * Or:\n\t   * Subject to push source elements into.\n\t   *\n\t   * @param {Function} [selector] Optional selector function which can use the multicasted source sequence subject to the policies enforced by the created subject. Specified only if <paramref name=\"subjectOrSubjectSelector\" is a factory function.\n\t   * @returns {Observable} An observable sequence that contains the elements of a sequence produced by multicasting the source sequence within a selector function.\n\t   */\n\t  observableProto.multicast = function (subjectOrSubjectSelector, selector) {\n\t    return isFunction(subjectOrSubjectSelector) ?\n\t      new MulticastObservable(this, subjectOrSubjectSelector, selector) :\n\t      new ConnectableObservable(this, subjectOrSubjectSelector);\n\t  };\n\t\n\t  /**\n\t   * Returns an observable sequence that is the result of invoking the selector on a connectable observable sequence that shares a single subscription to the underlying sequence.\n\t   * This operator is a specialization of Multicast using a regular Subject.\n\t   *\n\t   * @example\n\t   * var resres = source.publish();\n\t   * var res = source.publish(function (x) { return x; });\n\t   *\n\t   * @param {Function} [selector] Selector function which can use the multicasted source sequence as many times as needed, without causing multiple subscriptions to the source sequence. Subscribers to the given source will receive all notifications of the source from the time of the subscription on.\n\t   * @returns {Observable} An observable sequence that contains the elements of a sequence produced by multicasting the source sequence within a selector function.\n\t   */\n\t  observableProto.publish = function (selector) {\n\t    return selector && isFunction(selector) ?\n\t      this.multicast(function () { return new Subject(); }, selector) :\n\t      this.multicast(new Subject());\n\t  };\n\t\n\t  /**\n\t   * Returns an observable sequence that shares a single subscription to the underlying sequence.\n\t   * This operator is a specialization of publish which creates a subscription when the number of observers goes from zero to one, then shares that subscription with all subsequent observers until the number of observers returns to zero, at which point the subscription is disposed.\n\t   * @returns {Observable} An observable sequence that contains the elements of a sequence produced by multicasting the source sequence.\n\t   */\n\t  observableProto.share = function () {\n\t    return this.publish().refCount();\n\t  };\n\t\n\t  /**\n\t   * Returns an observable sequence that is the result of invoking the selector on a connectable observable sequence that shares a single subscription to the underlying sequence containing only the last notification.\n\t   * This operator is a specialization of Multicast using a AsyncSubject.\n\t   *\n\t   * @example\n\t   * var res = source.publishLast();\n\t   * var res = source.publishLast(function (x) { return x; });\n\t   *\n\t   * @param selector [Optional] Selector function which can use the multicasted source sequence as many times as needed, without causing multiple subscriptions to the source sequence. Subscribers to the given source will only receive the last notification of the source.\n\t   * @returns {Observable} An observable sequence that contains the elements of a sequence produced by multicasting the source sequence within a selector function.\n\t   */\n\t  observableProto.publishLast = function (selector) {\n\t    return selector && isFunction(selector) ?\n\t      this.multicast(function () { return new AsyncSubject(); }, selector) :\n\t      this.multicast(new AsyncSubject());\n\t  };\n\t\n\t  /**\n\t   * Returns an observable sequence that is the result of invoking the selector on a connectable observable sequence that shares a single subscription to the underlying sequence and starts with initialValue.\n\t   * This operator is a specialization of Multicast using a BehaviorSubject.\n\t   *\n\t   * @example\n\t   * var res = source.publishValue(42);\n\t   * var res = source.publishValue(function (x) { return x.select(function (y) { return y * y; }) }, 42);\n\t   *\n\t   * @param {Function} [selector] Optional selector function which can use the multicasted source sequence as many times as needed, without causing multiple subscriptions to the source sequence. Subscribers to the given source will receive immediately receive the initial value, followed by all notifications of the source from the time of the subscription on.\n\t   * @param {Mixed} initialValue Initial value received by observers upon subscription.\n\t   * @returns {Observable} An observable sequence that contains the elements of a sequence produced by multicasting the source sequence within a selector function.\n\t   */\n\t  observableProto.publishValue = function (initialValueOrSelector, initialValue) {\n\t    return arguments.length === 2 ?\n\t      this.multicast(function () {\n\t        return new BehaviorSubject(initialValue);\n\t      }, initialValueOrSelector) :\n\t      this.multicast(new BehaviorSubject(initialValueOrSelector));\n\t  };\n\t\n\t  /**\n\t   * Returns an observable sequence that shares a single subscription to the underlying sequence and starts with an initialValue.\n\t   * This operator is a specialization of publishValue which creates a subscription when the number of observers goes from zero to one, then shares that subscription with all subsequent observers until the number of observers returns to zero, at which point the subscription is disposed.\n\t   * @param {Mixed} initialValue Initial value received by observers upon subscription.\n\t   * @returns {Observable} An observable sequence that contains the elements of a sequence produced by multicasting the source sequence.\n\t   */\n\t  observableProto.shareValue = function (initialValue) {\n\t    return this.publishValue(initialValue).refCount();\n\t  };\n\t\n\t  /**\n\t   * Returns an observable sequence that is the result of invoking the selector on a connectable observable sequence that shares a single subscription to the underlying sequence replaying notifications subject to a maximum time length for the replay buffer.\n\t   * This operator is a specialization of Multicast using a ReplaySubject.\n\t   *\n\t   * @example\n\t   * var res = source.replay(null, 3);\n\t   * var res = source.replay(null, 3, 500);\n\t   * var res = source.replay(null, 3, 500, scheduler);\n\t   * var res = source.replay(function (x) { return x.take(6).repeat(); }, 3, 500, scheduler);\n\t   *\n\t   * @param selector [Optional] Selector function which can use the multicasted source sequence as many times as needed, without causing multiple subscriptions to the source sequence. Subscribers to the given source will receive all the notifications of the source subject to the specified replay buffer trimming policy.\n\t   * @param bufferSize [Optional] Maximum element count of the replay buffer.\n\t   * @param windowSize [Optional] Maximum time length of the replay buffer.\n\t   * @param scheduler [Optional] Scheduler where connected observers within the selector function will be invoked on.\n\t   * @returns {Observable} An observable sequence that contains the elements of a sequence produced by multicasting the source sequence within a selector function.\n\t   */\n\t  observableProto.replay = function (selector, bufferSize, windowSize, scheduler) {\n\t    return selector && isFunction(selector) ?\n\t      this.multicast(function () { return new ReplaySubject(bufferSize, windowSize, scheduler); }, selector) :\n\t      this.multicast(new ReplaySubject(bufferSize, windowSize, scheduler));\n\t  };\n\t\n\t  /**\n\t   * Returns an observable sequence that shares a single subscription to the underlying sequence replaying notifications subject to a maximum time length for the replay buffer.\n\t   * This operator is a specialization of replay which creates a subscription when the number of observers goes from zero to one, then shares that subscription with all subsequent observers until the number of observers returns to zero, at which point the subscription is disposed.\n\t   *\n\t   * @example\n\t   * var res = source.shareReplay(3);\n\t   * var res = source.shareReplay(3, 500);\n\t   * var res = source.shareReplay(3, 500, scheduler);\n\t   *\n\t\n\t   * @param bufferSize [Optional] Maximum element count of the replay buffer.\n\t   * @param window [Optional] Maximum time length of the replay buffer.\n\t   * @param scheduler [Optional] Scheduler where connected observers within the selector function will be invoked on.\n\t   * @returns {Observable} An observable sequence that contains the elements of a sequence produced by multicasting the source sequence.\n\t   */\n\t  observableProto.shareReplay = function (bufferSize, windowSize, scheduler) {\n\t    return this.replay(null, bufferSize, windowSize, scheduler).refCount();\n\t  };\n\t\n\t  var InnerSubscription = function (s, o) {\n\t    this._s = s;\n\t    this._o = o;\n\t  };\n\t\n\t  InnerSubscription.prototype.dispose = function () {\n\t    if (!this._s.isDisposed && this._o !== null) {\n\t      var idx = this._s.observers.indexOf(this._o);\n\t      this._s.observers.splice(idx, 1);\n\t      this._o = null;\n\t    }\n\t  };\n\t\n\t  var RefCountObservable = (function (__super__) {\n\t    inherits(RefCountObservable, __super__);\n\t    function RefCountObservable(source) {\n\t      this.source = source;\n\t      this._count = 0;\n\t      this._connectableSubscription = null;\n\t      __super__.call(this);\n\t    }\n\t\n\t    RefCountObservable.prototype.subscribeCore = function (o) {\n\t      var subscription = this.source.subscribe(o);\n\t      ++this._count === 1 && (this._connectableSubscription = this.source.connect());\n\t      return new RefCountDisposable(this, subscription);\n\t    };\n\t\n\t    function RefCountDisposable(p, s) {\n\t      this._p = p;\n\t      this._s = s;\n\t      this.isDisposed = false;\n\t    }\n\t\n\t    RefCountDisposable.prototype.dispose = function () {\n\t      if (!this.isDisposed) {\n\t        this.isDisposed = true;\n\t        this._s.dispose();\n\t        --this._p._count === 0 && this._p._connectableSubscription.dispose();\n\t      }\n\t    };\n\t\n\t    return RefCountObservable;\n\t  }(ObservableBase));\n\t\n\t  var ConnectableObservable = Rx.ConnectableObservable = (function (__super__) {\n\t    inherits(ConnectableObservable, __super__);\n\t    function ConnectableObservable(source, subject) {\n\t      this.source = source;\n\t      this._connection = null;\n\t      this._source = source.asObservable();\n\t      this._subject = subject;\n\t      __super__.call(this);\n\t    }\n\t\n\t    function ConnectDisposable(parent, subscription) {\n\t      this._p = parent;\n\t      this._s = subscription;\n\t    }\n\t\n\t    ConnectDisposable.prototype.dispose = function () {\n\t      if (this._s) {\n\t        this._s.dispose();\n\t        this._s = null;\n\t        this._p._connection = null;\n\t      }\n\t    };\n\t\n\t    ConnectableObservable.prototype.connect = function () {\n\t      if (!this._connection) {\n\t        var subscription = this._source.subscribe(this._subject);\n\t        this._connection = new ConnectDisposable(this, subscription);\n\t      }\n\t      return this._connection;\n\t    };\n\t\n\t    ConnectableObservable.prototype._subscribe = function (o) {\n\t      return this._subject.subscribe(o);\n\t    };\n\t\n\t    ConnectableObservable.prototype.refCount = function () {\n\t      return new RefCountObservable(this);\n\t    };\n\t\n\t    return ConnectableObservable;\n\t  }(Observable));\n\t\n\t  /**\n\t   * Returns an observable sequence that shares a single subscription to the underlying sequence. This observable sequence\n\t   * can be resubscribed to, even if all prior subscriptions have ended. (unlike `.publish().refCount()`)\n\t   * @returns {Observable} An observable sequence that contains the elements of a sequence produced by multicasting the source.\n\t   */\n\t  observableProto.singleInstance = function() {\n\t    var source = this, hasObservable = false, observable;\n\t\n\t    function getObservable() {\n\t      if (!hasObservable) {\n\t        hasObservable = true;\n\t        observable = source['finally'](function() { hasObservable = false; }).publish().refCount();\n\t      }\n\t      return observable;\n\t    }\n\t\n\t    return new AnonymousObservable(function(o) {\n\t      return getObservable().subscribe(o);\n\t    });\n\t  };\n\t\n\t  /**\n\t   *  Correlates the elements of two sequences based on overlapping durations.\n\t   *\n\t   *  @param {Observable} right The right observable sequence to join elements for.\n\t   *  @param {Function} leftDurationSelector A function to select the duration (expressed as an observable sequence) of each element of the left observable sequence, used to determine overlap.\n\t   *  @param {Function} rightDurationSelector A function to select the duration (expressed as an observable sequence) of each element of the right observable sequence, used to determine overlap.\n\t   *  @param {Function} resultSelector A function invoked to compute a result element for any two overlapping elements of the left and right observable sequences. The parameters passed to the function correspond with the elements from the left and right source sequences for which overlap occurs.\n\t   *  @returns {Observable} An observable sequence that contains result elements computed from source elements that have an overlapping duration.\n\t   */\n\t  observableProto.join = function (right, leftDurationSelector, rightDurationSelector, resultSelector) {\n\t    var left = this;\n\t    return new AnonymousObservable(function (o) {\n\t      var group = new CompositeDisposable();\n\t      var leftDone = false, rightDone = false;\n\t      var leftId = 0, rightId = 0;\n\t      var leftMap = new Map(), rightMap = new Map();\n\t      var handleError = function (e) { o.onError(e); };\n\t\n\t      group.add(left.subscribe(\n\t        function (value) {\n\t          var id = leftId++, md = new SingleAssignmentDisposable();\n\t\n\t          leftMap.set(id, value);\n\t          group.add(md);\n\t\n\t          var duration = tryCatch(leftDurationSelector)(value);\n\t          if (duration === errorObj) { return o.onError(duration.e); }\n\t\n\t          md.setDisposable(duration.take(1).subscribe(\n\t            noop,\n\t            handleError,\n\t            function () {\n\t              leftMap['delete'](id) && leftMap.size === 0 && leftDone && o.onCompleted();\n\t              group.remove(md);\n\t            }));\n\t\n\t          rightMap.forEach(function (v) {\n\t            var result = tryCatch(resultSelector)(value, v);\n\t            if (result === errorObj) { return o.onError(result.e); }\n\t            o.onNext(result);\n\t          });\n\t        },\n\t        handleError,\n\t        function () {\n\t          leftDone = true;\n\t          (rightDone || leftMap.size === 0) && o.onCompleted();\n\t        })\n\t      );\n\t\n\t      group.add(right.subscribe(\n\t        function (value) {\n\t          var id = rightId++, md = new SingleAssignmentDisposable();\n\t\n\t          rightMap.set(id, value);\n\t          group.add(md);\n\t\n\t          var duration = tryCatch(rightDurationSelector)(value);\n\t          if (duration === errorObj) { return o.onError(duration.e); }\n\t\n\t          md.setDisposable(duration.take(1).subscribe(\n\t            noop,\n\t            handleError,\n\t            function () {\n\t              rightMap['delete'](id) && rightMap.size === 0 && rightDone && o.onCompleted();\n\t              group.remove(md);\n\t            }));\n\t\n\t          leftMap.forEach(function (v) {\n\t            var result = tryCatch(resultSelector)(v, value);\n\t            if (result === errorObj) { return o.onError(result.e); }\n\t            o.onNext(result);\n\t          });\n\t        },\n\t        handleError,\n\t        function () {\n\t          rightDone = true;\n\t          (leftDone || rightMap.size === 0) && o.onCompleted();\n\t        })\n\t      );\n\t      return group;\n\t    }, left);\n\t  };\n\t\n\t  /**\n\t   *  Correlates the elements of two sequences based on overlapping durations, and groups the results.\n\t   *\n\t   *  @param {Observable} right The right observable sequence to join elements for.\n\t   *  @param {Function} leftDurationSelector A function to select the duration (expressed as an observable sequence) of each element of the left observable sequence, used to determine overlap.\n\t   *  @param {Function} rightDurationSelector A function to select the duration (expressed as an observable sequence) of each element of the right observable sequence, used to determine overlap.\n\t   *  @param {Function} resultSelector A function invoked to compute a result element for any element of the left sequence with overlapping elements from the right observable sequence. The first parameter passed to the function is an element of the left sequence. The second parameter passed to the function is an observable sequence with elements from the right sequence that overlap with the left sequence's element.\n\t   *  @returns {Observable} An observable sequence that contains result elements computed from source elements that have an overlapping duration.\n\t   */\n\t  observableProto.groupJoin = function (right, leftDurationSelector, rightDurationSelector, resultSelector) {\n\t    var left = this;\n\t    return new AnonymousObservable(function (o) {\n\t      var group = new CompositeDisposable();\n\t      var r = new RefCountDisposable(group);\n\t      var leftMap = new Map(), rightMap = new Map();\n\t      var leftId = 0, rightId = 0;\n\t      var handleError = function (e) { return function (v) { v.onError(e); }; };\n\t\n\t      function handleError(e) { };\n\t\n\t      group.add(left.subscribe(\n\t        function (value) {\n\t          var s = new Subject();\n\t          var id = leftId++;\n\t          leftMap.set(id, s);\n\t\n\t          var result = tryCatch(resultSelector)(value, addRef(s, r));\n\t          if (result === errorObj) {\n\t            leftMap.forEach(handleError(result.e));\n\t            return o.onError(result.e);\n\t          }\n\t          o.onNext(result);\n\t\n\t          rightMap.forEach(function (v) { s.onNext(v); });\n\t\n\t          var md = new SingleAssignmentDisposable();\n\t          group.add(md);\n\t\n\t          var duration = tryCatch(leftDurationSelector)(value);\n\t          if (duration === errorObj) {\n\t            leftMap.forEach(handleError(duration.e));\n\t            return o.onError(duration.e);\n\t          }\n\t\n\t          md.setDisposable(duration.take(1).subscribe(\n\t            noop,\n\t            function (e) {\n\t              leftMap.forEach(handleError(e));\n\t              o.onError(e);\n\t            },\n\t            function () {\n\t              leftMap['delete'](id) && s.onCompleted();\n\t              group.remove(md);\n\t            }));\n\t        },\n\t        function (e) {\n\t          leftMap.forEach(handleError(e));\n\t          o.onError(e);\n\t        },\n\t        function () { o.onCompleted(); })\n\t      );\n\t\n\t      group.add(right.subscribe(\n\t        function (value) {\n\t          var id = rightId++;\n\t          rightMap.set(id, value);\n\t\n\t          var md = new SingleAssignmentDisposable();\n\t          group.add(md);\n\t\n\t          var duration = tryCatch(rightDurationSelector)(value);\n\t          if (duration === errorObj) {\n\t            leftMap.forEach(handleError(duration.e));\n\t            return o.onError(duration.e);\n\t          }\n\t\n\t          md.setDisposable(duration.take(1).subscribe(\n\t            noop,\n\t            function (e) {\n\t              leftMap.forEach(handleError(e));\n\t              o.onError(e);\n\t            },\n\t            function () {\n\t              rightMap['delete'](id);\n\t              group.remove(md);\n\t            }));\n\t\n\t          leftMap.forEach(function (v) { v.onNext(value); });\n\t        },\n\t        function (e) {\n\t          leftMap.forEach(handleError(e));\n\t          o.onError(e);\n\t        })\n\t      );\n\t\n\t      return r;\n\t    }, left);\n\t  };\n\t\n\t  function toArray(x) { return x.toArray(); }\n\t\n\t  /**\n\t   *  Projects each element of an observable sequence into zero or more buffers.\n\t   *  @param {Mixed} bufferOpeningsOrClosingSelector Observable sequence whose elements denote the creation of new windows, or, a function invoked to define the boundaries of the produced windows (a new window is started when the previous one is closed, resulting in non-overlapping windows).\n\t   *  @param {Function} [bufferClosingSelector] A function invoked to define the closing of each produced window. If a closing selector function is specified for the first parameter, this parameter is ignored.\n\t   *  @returns {Observable} An observable sequence of windows.\n\t   */\n\t  observableProto.buffer = function () {\n\t    return this.window.apply(this, arguments)\n\t      .flatMap(toArray);\n\t  };\n\t\n\t  /**\n\t   *  Projects each element of an observable sequence into zero or more windows.\n\t   *\n\t   *  @param {Mixed} windowOpeningsOrClosingSelector Observable sequence whose elements denote the creation of new windows, or, a function invoked to define the boundaries of the produced windows (a new window is started when the previous one is closed, resulting in non-overlapping windows).\n\t   *  @param {Function} [windowClosingSelector] A function invoked to define the closing of each produced window. If a closing selector function is specified for the first parameter, this parameter is ignored.\n\t   *  @returns {Observable} An observable sequence of windows.\n\t   */\n\t  observableProto.window = function (windowOpeningsOrClosingSelector, windowClosingSelector) {\n\t    if (arguments.length === 1 && typeof arguments[0] !== 'function') {\n\t      return observableWindowWithBoundaries.call(this, windowOpeningsOrClosingSelector);\n\t    }\n\t    return typeof windowOpeningsOrClosingSelector === 'function' ?\n\t      observableWindowWithClosingSelector.call(this, windowOpeningsOrClosingSelector) :\n\t      observableWindowWithOpenings.call(this, windowOpeningsOrClosingSelector, windowClosingSelector);\n\t  };\n\t\n\t  function observableWindowWithOpenings(windowOpenings, windowClosingSelector) {\n\t    return windowOpenings.groupJoin(this, windowClosingSelector, observableEmpty, function (_, win) {\n\t      return win;\n\t    });\n\t  }\n\t\n\t  function observableWindowWithBoundaries(windowBoundaries) {\n\t    var source = this;\n\t    return new AnonymousObservable(function (observer) {\n\t      var win = new Subject(),\n\t        d = new CompositeDisposable(),\n\t        r = new RefCountDisposable(d);\n\t\n\t      observer.onNext(addRef(win, r));\n\t\n\t      d.add(source.subscribe(function (x) {\n\t        win.onNext(x);\n\t      }, function (err) {\n\t        win.onError(err);\n\t        observer.onError(err);\n\t      }, function () {\n\t        win.onCompleted();\n\t        observer.onCompleted();\n\t      }));\n\t\n\t      isPromise(windowBoundaries) && (windowBoundaries = observableFromPromise(windowBoundaries));\n\t\n\t      d.add(windowBoundaries.subscribe(function (w) {\n\t        win.onCompleted();\n\t        win = new Subject();\n\t        observer.onNext(addRef(win, r));\n\t      }, function (err) {\n\t        win.onError(err);\n\t        observer.onError(err);\n\t      }, function () {\n\t        win.onCompleted();\n\t        observer.onCompleted();\n\t      }));\n\t\n\t      return r;\n\t    }, source);\n\t  }\n\t\n\t  function observableWindowWithClosingSelector(windowClosingSelector) {\n\t    var source = this;\n\t    return new AnonymousObservable(function (observer) {\n\t      var m = new SerialDisposable(),\n\t        d = new CompositeDisposable(m),\n\t        r = new RefCountDisposable(d),\n\t        win = new Subject();\n\t      observer.onNext(addRef(win, r));\n\t      d.add(source.subscribe(function (x) {\n\t          win.onNext(x);\n\t      }, function (err) {\n\t          win.onError(err);\n\t          observer.onError(err);\n\t      }, function () {\n\t          win.onCompleted();\n\t          observer.onCompleted();\n\t      }));\n\t\n\t      function createWindowClose () {\n\t        var windowClose;\n\t        try {\n\t          windowClose = windowClosingSelector();\n\t        } catch (e) {\n\t          observer.onError(e);\n\t          return;\n\t        }\n\t\n\t        isPromise(windowClose) && (windowClose = observableFromPromise(windowClose));\n\t\n\t        var m1 = new SingleAssignmentDisposable();\n\t        m.setDisposable(m1);\n\t        m1.setDisposable(windowClose.take(1).subscribe(noop, function (err) {\n\t          win.onError(err);\n\t          observer.onError(err);\n\t        }, function () {\n\t          win.onCompleted();\n\t          win = new Subject();\n\t          observer.onNext(addRef(win, r));\n\t          createWindowClose();\n\t        }));\n\t      }\n\t\n\t      createWindowClose();\n\t      return r;\n\t    }, source);\n\t  }\n\t\n\t  var PairwiseObservable = (function (__super__) {\n\t    inherits(PairwiseObservable, __super__);\n\t    function PairwiseObservable(source) {\n\t      this.source = source;\n\t      __super__.call(this);\n\t    }\n\t\n\t    PairwiseObservable.prototype.subscribeCore = function (o) {\n\t      return this.source.subscribe(new PairwiseObserver(o));\n\t    };\n\t\n\t    return PairwiseObservable;\n\t  }(ObservableBase));\n\t\n\t  var PairwiseObserver = (function(__super__) {\n\t    inherits(PairwiseObserver, __super__);\n\t    function PairwiseObserver(o) {\n\t      this._o = o;\n\t      this._p = null;\n\t      this._hp = false;\n\t    }\n\t\n\t    PairwiseObserver.prototype.next = function (x) {\n\t      if (this._hp) {\n\t        this._o.onNext([this._p, x]);\n\t      } else {\n\t        this._hp = true;\n\t      }\n\t      this._p = x;\n\t    };\n\t    PairwiseObserver.prototype.error = function (err) { this._o.onError(err); };\n\t    PairwiseObserver.prototype.completed = function () { this._o.onCompleted(); };\n\t\n\t    return PairwiseObserver;\n\t  }(AbstractObserver));\n\t\n\t  /**\n\t   * Returns a new observable that triggers on the second and subsequent triggerings of the input observable.\n\t   * The Nth triggering of the input observable passes the arguments from the N-1th and Nth triggering as a pair.\n\t   * The argument passed to the N-1th triggering is held in hidden internal state until the Nth triggering occurs.\n\t   * @returns {Observable} An observable that triggers on successive pairs of observations from the input observable as an array.\n\t   */\n\t  observableProto.pairwise = function () {\n\t    return new PairwiseObservable(this);\n\t  };\n\t\n\t  /**\n\t   * Returns two observables which partition the observations of the source by the given function.\n\t   * The first will trigger observations for those values for which the predicate returns true.\n\t   * The second will trigger observations for those values where the predicate returns false.\n\t   * The predicate is executed once for each subscribed observer.\n\t   * Both also propagate all error observations arising from the source and each completes\n\t   * when the source completes.\n\t   * @param {Function} predicate\n\t   *    The function to determine which output Observable will trigger a particular observation.\n\t   * @returns {Array}\n\t   *    An array of observables. The first triggers when the predicate returns true,\n\t   *    and the second triggers when the predicate returns false.\n\t  */\n\t  observableProto.partition = function(predicate, thisArg) {\n\t    var fn = bindCallback(predicate, thisArg, 3);\n\t    return [\n\t      this.filter(predicate, thisArg),\n\t      this.filter(function (x, i, o) { return !fn(x, i, o); })\n\t    ];\n\t  };\n\t\n\t  var WhileEnumerable = (function(__super__) {\n\t    inherits(WhileEnumerable, __super__);\n\t    function WhileEnumerable(c, s) {\n\t      this.c = c;\n\t      this.s = s;\n\t    }\n\t    WhileEnumerable.prototype[$iterator$] = function () {\n\t      var self = this;\n\t      return {\n\t        next: function () {\n\t          return self.c() ?\n\t           { done: false, value: self.s } :\n\t           { done: true, value: void 0 };\n\t        }\n\t      };\n\t    };\n\t    return WhileEnumerable;\n\t  }(Enumerable));\n\t  \n\t  function enumerableWhile(condition, source) {\n\t    return new WhileEnumerable(condition, source);\n\t  }  \n\t\n\t   /**\n\t   *  Returns an observable sequence that is the result of invoking the selector on the source sequence, without sharing subscriptions.\n\t   *  This operator allows for a fluent style of writing queries that use the same sequence multiple times.\n\t   *\n\t   * @param {Function} selector Selector function which can use the source sequence as many times as needed, without sharing subscriptions to the source sequence.\n\t   * @returns {Observable} An observable sequence that contains the elements of a sequence produced by multicasting the source sequence within a selector function.\n\t   */\n\t  observableProto.letBind = observableProto['let'] = function (func) {\n\t    return func(this);\n\t  };\n\t\n\t   /**\n\t   *  Determines whether an observable collection contains values. \n\t   *\n\t   * @example\n\t   *  1 - res = Rx.Observable.if(condition, obs1);\n\t   *  2 - res = Rx.Observable.if(condition, obs1, obs2);\n\t   *  3 - res = Rx.Observable.if(condition, obs1, scheduler);\n\t   * @param {Function} condition The condition which determines if the thenSource or elseSource will be run.\n\t   * @param {Observable} thenSource The observable sequence or Promise that will be run if the condition function returns true.\n\t   * @param {Observable} [elseSource] The observable sequence or Promise that will be run if the condition function returns false. If this is not provided, it defaults to Rx.Observabe.Empty with the specified scheduler.\n\t   * @returns {Observable} An observable sequence which is either the thenSource or elseSource.\n\t   */\n\t  Observable['if'] = function (condition, thenSource, elseSourceOrScheduler) {\n\t    return observableDefer(function () {\n\t      elseSourceOrScheduler || (elseSourceOrScheduler = observableEmpty());\n\t\n\t      isPromise(thenSource) && (thenSource = observableFromPromise(thenSource));\n\t      isPromise(elseSourceOrScheduler) && (elseSourceOrScheduler = observableFromPromise(elseSourceOrScheduler));\n\t\n\t      // Assume a scheduler for empty only\n\t      typeof elseSourceOrScheduler.now === 'function' && (elseSourceOrScheduler = observableEmpty(elseSourceOrScheduler));\n\t      return condition() ? thenSource : elseSourceOrScheduler;\n\t    });\n\t  };\n\t\n\t   /**\n\t   *  Concatenates the observable sequences obtained by running the specified result selector for each element in source.\n\t   * There is an alias for this method called 'forIn' for browsers <IE9\n\t   * @param {Array} sources An array of values to turn into an observable sequence.\n\t   * @param {Function} resultSelector A function to apply to each item in the sources array to turn it into an observable sequence.\n\t   * @returns {Observable} An observable sequence from the concatenated observable sequences.\n\t   */\n\t  Observable['for'] = Observable.forIn = function (sources, resultSelector, thisArg) {\n\t    return enumerableOf(sources, resultSelector, thisArg).concat();\n\t  };\n\t\n\t   /**\n\t   *  Repeats source as long as condition holds emulating a while loop.\n\t   * There is an alias for this method called 'whileDo' for browsers <IE9\n\t   *\n\t   * @param {Function} condition The condition which determines if the source will be repeated.\n\t   * @param {Observable} source The observable sequence that will be run if the condition function returns true.\n\t   * @returns {Observable} An observable sequence which is repeated as long as the condition holds.\n\t   */\n\t  var observableWhileDo = Observable['while'] = Observable.whileDo = function (condition, source) {\n\t    isPromise(source) && (source = observableFromPromise(source));\n\t    return enumerableWhile(condition, source).concat();\n\t  };\n\t\n\t   /**\n\t   *  Repeats source as long as condition holds emulating a do while loop.\n\t   *\n\t   * @param {Function} condition The condition which determines if the source will be repeated.\n\t   * @param {Observable} source The observable sequence that will be run if the condition function returns true.\n\t   * @returns {Observable} An observable sequence which is repeated as long as the condition holds.\n\t   */\n\t  observableProto.doWhile = function (condition) {\n\t    return observableConcat([this, observableWhileDo(condition, this)]);\n\t  };\n\t\n\t   /**\n\t   *  Uses selector to determine which source in sources to use.\n\t   * @param {Function} selector The function which extracts the value for to test in a case statement.\n\t   * @param {Array} sources A object which has keys which correspond to the case statement labels.\n\t   * @param {Observable} [elseSource] The observable sequence or Promise that will be run if the sources are not matched. If this is not provided, it defaults to Rx.Observabe.empty with the specified scheduler.\n\t   *\n\t   * @returns {Observable} An observable sequence which is determined by a case statement.\n\t   */\n\t  Observable['case'] = function (selector, sources, defaultSourceOrScheduler) {\n\t    return observableDefer(function () {\n\t      isPromise(defaultSourceOrScheduler) && (defaultSourceOrScheduler = observableFromPromise(defaultSourceOrScheduler));\n\t      defaultSourceOrScheduler || (defaultSourceOrScheduler = observableEmpty());\n\t\n\t      isScheduler(defaultSourceOrScheduler) && (defaultSourceOrScheduler = observableEmpty(defaultSourceOrScheduler));\n\t\n\t      var result = sources[selector()];\n\t      isPromise(result) && (result = observableFromPromise(result));\n\t\n\t      return result || defaultSourceOrScheduler;\n\t    });\n\t  };\n\t\n\t  var ExpandObservable = (function(__super__) {\n\t    inherits(ExpandObservable, __super__);\n\t    function ExpandObservable(source, fn, scheduler) {\n\t      this.source = source;\n\t      this._fn = fn;\n\t      this._scheduler = scheduler;\n\t      __super__.call(this);\n\t    }\n\t\n\t    function scheduleRecursive(args, recurse) {\n\t      var state = args[0], self = args[1];\n\t      var work;\n\t      if (state.q.length > 0) {\n\t        work = state.q.shift();\n\t      } else {\n\t        state.isAcquired = false;\n\t        return;\n\t      }\n\t      var m1 = new SingleAssignmentDisposable();\n\t      state.d.add(m1);\n\t      m1.setDisposable(work.subscribe(new ExpandObserver(state, self, m1)));\n\t      recurse([state, self]);\n\t    }\n\t\n\t    ExpandObservable.prototype._ensureActive = function (state) {\n\t      var isOwner = false;\n\t      if (state.q.length > 0) {\n\t        isOwner = !state.isAcquired;\n\t        state.isAcquired = true;\n\t      }\n\t      isOwner && state.m.setDisposable(this._scheduler.scheduleRecursive([state, this], scheduleRecursive));\n\t    };\n\t\n\t    ExpandObservable.prototype.subscribeCore = function (o) {\n\t      var m = new SerialDisposable(),\n\t        d = new CompositeDisposable(m),\n\t        state = {\n\t          q: [],\n\t          m: m,\n\t          d: d,\n\t          activeCount: 0,\n\t          isAcquired: false,\n\t          o: o\n\t        };\n\t\n\t      state.q.push(this.source);\n\t      state.activeCount++;\n\t      this._ensureActive(state);\n\t      return d;\n\t    };\n\t\n\t    return ExpandObservable;\n\t  }(ObservableBase));\n\t\n\t  var ExpandObserver = (function(__super__) {\n\t    inherits(ExpandObserver, __super__);\n\t    function ExpandObserver(state, parent, m1) {\n\t      this._s = state;\n\t      this._p = parent;\n\t      this._m1 = m1;\n\t      __super__.call(this);\n\t    }\n\t\n\t    ExpandObserver.prototype.next = function (x) {\n\t      this._s.o.onNext(x);\n\t      var result = tryCatch(this._p._fn)(x);\n\t      if (result === errorObj) { return this._s.o.onError(result.e); }\n\t      this._s.q.push(result);\n\t      this._s.activeCount++;\n\t      this._p._ensureActive(this._s);\n\t    };\n\t\n\t    ExpandObserver.prototype.error = function (e) {\n\t      this._s.o.onError(e);\n\t    };\n\t\n\t    ExpandObserver.prototype.completed = function () {\n\t      this._s.d.remove(this._m1);\n\t      this._s.activeCount--;\n\t      this._s.activeCount === 0 && this._s.o.onCompleted();\n\t    };\n\t\n\t    return ExpandObserver;\n\t  }(AbstractObserver));\n\t\n\t   /**\n\t   *  Expands an observable sequence by recursively invoking selector.\n\t   *\n\t   * @param {Function} selector Selector function to invoke for each produced element, resulting in another sequence to which the selector will be invoked recursively again.\n\t   * @param {Scheduler} [scheduler] Scheduler on which to perform the expansion. If not provided, this defaults to the current thread scheduler.\n\t   * @returns {Observable} An observable sequence containing all the elements produced by the recursive expansion.\n\t   */\n\t  observableProto.expand = function (selector, scheduler) {\n\t    isScheduler(scheduler) || (scheduler = currentThreadScheduler);\n\t    return new ExpandObservable(this, selector, scheduler);\n\t  };\n\t\n\t  function argumentsToArray() {\n\t    var len = arguments.length, args = new Array(len);\n\t    for(var i = 0; i < len; i++) { args[i] = arguments[i]; }\n\t    return args;\n\t  }\n\t\n\t  var ForkJoinObservable = (function (__super__) {\n\t    inherits(ForkJoinObservable, __super__);\n\t    function ForkJoinObservable(sources, cb) {\n\t      this._sources = sources;\n\t      this._cb = cb;\n\t      __super__.call(this);\n\t    }\n\t\n\t    ForkJoinObservable.prototype.subscribeCore = function (o) {\n\t      if (this._sources.length === 0) {\n\t        o.onCompleted();\n\t        return disposableEmpty;\n\t      }\n\t\n\t      var count = this._sources.length;\n\t      var state = {\n\t        finished: false,\n\t        hasResults: new Array(count),\n\t        hasCompleted: new Array(count),\n\t        results: new Array(count)\n\t      };\n\t\n\t      var subscriptions = new CompositeDisposable();\n\t      for (var i = 0, len = this._sources.length; i < len; i++) {\n\t        var source = this._sources[i];\n\t        isPromise(source) && (source = observableFromPromise(source));\n\t        subscriptions.add(source.subscribe(new ForkJoinObserver(o, state, i, this._cb, subscriptions)));\n\t      }\n\t\n\t      return subscriptions;\n\t    };\n\t\n\t    return ForkJoinObservable;\n\t  }(ObservableBase));\n\t\n\t  var ForkJoinObserver = (function(__super__) {\n\t    inherits(ForkJoinObserver, __super__);\n\t    function ForkJoinObserver(o, s, i, cb, subs) {\n\t      this._o = o;\n\t      this._s = s;\n\t      this._i = i;\n\t      this._cb = cb;\n\t      this._subs = subs;\n\t      __super__.call(this);\n\t    }\n\t\n\t    ForkJoinObserver.prototype.next = function (x) {\n\t      if (!this._s.finished) {\n\t        this._s.hasResults[this._i] = true;\n\t        this._s.results[this._i] = x;\n\t      }\n\t    };\n\t\n\t    ForkJoinObserver.prototype.error = function (e) {\n\t      this._s.finished = true;\n\t      this._o.onError(e);\n\t      this._subs.dispose();\n\t    };\n\t\n\t    ForkJoinObserver.prototype.completed = function () {\n\t      if (!this._s.finished) {\n\t        if (!this._s.hasResults[this._i]) {\n\t          return this._o.onCompleted();\n\t        }\n\t        this._s.hasCompleted[this._i] = true;\n\t        for (var i = 0; i < this._s.results.length; i++) {\n\t          if (!this._s.hasCompleted[i]) { return; }\n\t        }\n\t        this._s.finished = true;\n\t\n\t        var res = tryCatch(this._cb).apply(null, this._s.results);\n\t        if (res === errorObj) { return this._o.onError(res.e); }\n\t\n\t        this._o.onNext(res);\n\t        this._o.onCompleted();\n\t      }\n\t    };\n\t\n\t    return ForkJoinObserver;\n\t  }(AbstractObserver));\n\t\n\t   /**\n\t   *  Runs all observable sequences in parallel and collect their last elements.\n\t   *\n\t   * @example\n\t   *  1 - res = Rx.Observable.forkJoin([obs1, obs2]);\n\t   *  1 - res = Rx.Observable.forkJoin(obs1, obs2, ...);\n\t   * @returns {Observable} An observable sequence with an array collecting the last elements of all the input sequences.\n\t   */\n\t  Observable.forkJoin = function () {\n\t    var len = arguments.length, args = new Array(len);\n\t    for(var i = 0; i < len; i++) { args[i] = arguments[i]; }\n\t    var resultSelector = isFunction(args[len - 1]) ? args.pop() : argumentsToArray;\n\t    Array.isArray(args[0]) && (args = args[0]);\n\t    return new ForkJoinObservable(args, resultSelector);\n\t  };\n\t\n\t   /**\n\t   *  Runs two observable sequences in parallel and combines their last elemenets.\n\t   * @param {Observable} second Second observable sequence.\n\t   * @param {Function} resultSelector Result selector function to invoke with the last elements of both sequences.\n\t   * @returns {Observable} An observable sequence with the result of calling the selector function with the last elements of both input sequences.\n\t   */\n\t  observableProto.forkJoin = function () {\n\t    var len = arguments.length, args = new Array(len);\n\t    for(var i = 0; i < len; i++) { args[i] = arguments[i]; }\n\t    if (Array.isArray(args[0])) {\n\t      args[0].unshift(this);\n\t    } else {\n\t      args.unshift(this);\n\t    }\n\t    return Observable.forkJoin.apply(null, args);\n\t  };\n\t\n\t  /**\n\t   * Comonadic bind operator.\n\t   * @param {Function} selector A transform function to apply to each element.\n\t   * @param {Object} scheduler Scheduler used to execute the operation. If not specified, defaults to the ImmediateScheduler.\n\t   * @returns {Observable} An observable sequence which results from the comonadic bind operation.\n\t   */\n\t  observableProto.manySelect = observableProto.extend = function (selector, scheduler) {\n\t    isScheduler(scheduler) || (scheduler = Rx.Scheduler.immediate);\n\t    var source = this;\n\t    return observableDefer(function () {\n\t      var chain;\n\t\n\t      return source\n\t        .map(function (x) {\n\t          var curr = new ChainObservable(x);\n\t\n\t          chain && chain.onNext(x);\n\t          chain = curr;\n\t\n\t          return curr;\n\t        })\n\t        .tap(\n\t          noop,\n\t          function (e) { chain && chain.onError(e); },\n\t          function () { chain && chain.onCompleted(); }\n\t        )\n\t        .observeOn(scheduler)\n\t        .map(selector);\n\t    }, source);\n\t  };\n\t\n\t  var ChainObservable = (function (__super__) {\n\t    inherits(ChainObservable, __super__);\n\t    function ChainObservable(head) {\n\t      __super__.call(this);\n\t      this.head = head;\n\t      this.tail = new AsyncSubject();\n\t    }\n\t\n\t    addProperties(ChainObservable.prototype, Observer, {\n\t      _subscribe: function (o) {\n\t        var g = new CompositeDisposable();\n\t        g.add(currentThreadScheduler.schedule(this, function (_, self) {\n\t          o.onNext(self.head);\n\t          g.add(self.tail.mergeAll().subscribe(o));\n\t        }));\n\t\n\t        return g;\n\t      },\n\t      onCompleted: function () {\n\t        this.onNext(Observable.empty());\n\t      },\n\t      onError: function (e) {\n\t        this.onNext(Observable['throw'](e));\n\t      },\n\t      onNext: function (v) {\n\t        this.tail.onNext(v);\n\t        this.tail.onCompleted();\n\t      }\n\t    });\n\t\n\t    return ChainObservable;\n\t\n\t  }(Observable));\n\t\n\t  var Map = root.Map || (function () {\n\t    function Map() {\n\t      this.size = 0;\n\t      this._values = [];\n\t      this._keys = [];\n\t    }\n\t\n\t    Map.prototype['delete'] = function (key) {\n\t      var i = this._keys.indexOf(key);\n\t      if (i === -1) { return false; }\n\t      this._values.splice(i, 1);\n\t      this._keys.splice(i, 1);\n\t      this.size--;\n\t      return true;\n\t    };\n\t\n\t    Map.prototype.get = function (key) {\n\t      var i = this._keys.indexOf(key);\n\t      return i === -1 ? undefined : this._values[i];\n\t    };\n\t\n\t    Map.prototype.set = function (key, value) {\n\t      var i = this._keys.indexOf(key);\n\t      if (i === -1) {\n\t        this._keys.push(key);\n\t        this._values.push(value);\n\t        this.size++;\n\t      } else {\n\t        this._values[i] = value;\n\t      }\n\t      return this;\n\t    };\n\t\n\t    Map.prototype.forEach = function (cb, thisArg) {\n\t      for (var i = 0; i < this.size; i++) {\n\t        cb.call(thisArg, this._values[i], this._keys[i]);\n\t      }\n\t    };\n\t\n\t    return Map;\n\t  }());\n\t\n\t  /**\n\t   * @constructor\n\t   * Represents a join pattern over observable sequences.\n\t   */\n\t  function Pattern(patterns) {\n\t    this.patterns = patterns;\n\t  }\n\t\n\t  /**\n\t   *  Creates a pattern that matches the current plan matches and when the specified observable sequences has an available value.\n\t   *  @param other Observable sequence to match in addition to the current pattern.\n\t   *  @return {Pattern} Pattern object that matches when all observable sequences in the pattern have an available value.\n\t   */\n\t  Pattern.prototype.and = function (other) {\n\t    return new Pattern(this.patterns.concat(other));\n\t  };\n\t\n\t  /**\n\t   *  Matches when all observable sequences in the pattern (specified using a chain of and operators) have an available value and projects the values.\n\t   *  @param {Function} selector Selector that will be invoked with available values from the source sequences, in the same order of the sequences in the pattern.\n\t   *  @return {Plan} Plan that produces the projected values, to be fed (with other plans) to the when operator.\n\t   */\n\t  Pattern.prototype.thenDo = function (selector) {\n\t    return new Plan(this, selector);\n\t  };\n\t\n\t  function Plan(expression, selector) {\n\t    this.expression = expression;\n\t    this.selector = selector;\n\t  }\n\t\n\t  function handleOnError(o) { return function (e) { o.onError(e); }; }\n\t  function handleOnNext(self, observer) {\n\t    return function onNext () {\n\t      var result = tryCatch(self.selector).apply(self, arguments);\n\t      if (result === errorObj) { return observer.onError(result.e); }\n\t      observer.onNext(result);\n\t    };\n\t  }\n\t\n\t  Plan.prototype.activate = function (externalSubscriptions, observer, deactivate) {\n\t    var joinObservers = [], errHandler = handleOnError(observer);\n\t    for (var i = 0, len = this.expression.patterns.length; i < len; i++) {\n\t      joinObservers.push(planCreateObserver(externalSubscriptions, this.expression.patterns[i], errHandler));\n\t    }\n\t    var activePlan = new ActivePlan(joinObservers, handleOnNext(this, observer), function () {\n\t      for (var j = 0, jlen = joinObservers.length; j < jlen; j++) {\n\t        joinObservers[j].removeActivePlan(activePlan);\n\t      }\n\t      deactivate(activePlan);\n\t    });\n\t    for (i = 0, len = joinObservers.length; i < len; i++) {\n\t      joinObservers[i].addActivePlan(activePlan);\n\t    }\n\t    return activePlan;\n\t  };\n\t\n\t  function planCreateObserver(externalSubscriptions, observable, onError) {\n\t    var entry = externalSubscriptions.get(observable);\n\t    if (!entry) {\n\t      var observer = new JoinObserver(observable, onError);\n\t      externalSubscriptions.set(observable, observer);\n\t      return observer;\n\t    }\n\t    return entry;\n\t  }\n\t\n\t  function ActivePlan(joinObserverArray, onNext, onCompleted) {\n\t    this.joinObserverArray = joinObserverArray;\n\t    this.onNext = onNext;\n\t    this.onCompleted = onCompleted;\n\t    this.joinObservers = new Map();\n\t    for (var i = 0, len = this.joinObserverArray.length; i < len; i++) {\n\t      var joinObserver = this.joinObserverArray[i];\n\t      this.joinObservers.set(joinObserver, joinObserver);\n\t    }\n\t  }\n\t\n\t  ActivePlan.prototype.dequeue = function () {\n\t    this.joinObservers.forEach(function (v) { v.queue.shift(); });\n\t  };\n\t\n\t  ActivePlan.prototype.match = function () {\n\t    var i, len, hasValues = true;\n\t    for (i = 0, len = this.joinObserverArray.length; i < len; i++) {\n\t      if (this.joinObserverArray[i].queue.length === 0) {\n\t        hasValues = false;\n\t        break;\n\t      }\n\t    }\n\t    if (hasValues) {\n\t      var firstValues = [],\n\t          isCompleted = false;\n\t      for (i = 0, len = this.joinObserverArray.length; i < len; i++) {\n\t        firstValues.push(this.joinObserverArray[i].queue[0]);\n\t        this.joinObserverArray[i].queue[0].kind === 'C' && (isCompleted = true);\n\t      }\n\t      if (isCompleted) {\n\t        this.onCompleted();\n\t      } else {\n\t        this.dequeue();\n\t        var values = [];\n\t        for (i = 0, len = firstValues.length; i < firstValues.length; i++) {\n\t          values.push(firstValues[i].value);\n\t        }\n\t        this.onNext.apply(this, values);\n\t      }\n\t    }\n\t  };\n\t\n\t  var JoinObserver = (function (__super__) {\n\t    inherits(JoinObserver, __super__);\n\t\n\t    function JoinObserver(source, onError) {\n\t      __super__.call(this);\n\t      this.source = source;\n\t      this.onError = onError;\n\t      this.queue = [];\n\t      this.activePlans = [];\n\t      this.subscription = new SingleAssignmentDisposable();\n\t      this.isDisposed = false;\n\t    }\n\t\n\t    var JoinObserverPrototype = JoinObserver.prototype;\n\t\n\t    JoinObserverPrototype.next = function (notification) {\n\t      if (!this.isDisposed) {\n\t        if (notification.kind === 'E') {\n\t          return this.onError(notification.error);\n\t        }\n\t        this.queue.push(notification);\n\t        var activePlans = this.activePlans.slice(0);\n\t        for (var i = 0, len = activePlans.length; i < len; i++) {\n\t          activePlans[i].match();\n\t        }\n\t      }\n\t    };\n\t\n\t    JoinObserverPrototype.error = noop;\n\t    JoinObserverPrototype.completed = noop;\n\t\n\t    JoinObserverPrototype.addActivePlan = function (activePlan) {\n\t      this.activePlans.push(activePlan);\n\t    };\n\t\n\t    JoinObserverPrototype.subscribe = function () {\n\t      this.subscription.setDisposable(this.source.materialize().subscribe(this));\n\t    };\n\t\n\t    JoinObserverPrototype.removeActivePlan = function (activePlan) {\n\t      this.activePlans.splice(this.activePlans.indexOf(activePlan), 1);\n\t      this.activePlans.length === 0 && this.dispose();\n\t    };\n\t\n\t    JoinObserverPrototype.dispose = function () {\n\t      __super__.prototype.dispose.call(this);\n\t      if (!this.isDisposed) {\n\t        this.isDisposed = true;\n\t        this.subscription.dispose();\n\t      }\n\t    };\n\t\n\t    return JoinObserver;\n\t  } (AbstractObserver));\n\t\n\t  /**\n\t   *  Creates a pattern that matches when both observable sequences have an available value.\n\t   *\n\t   *  @param right Observable sequence to match with the current sequence.\n\t   *  @return {Pattern} Pattern object that matches when both observable sequences have an available value.\n\t   */\n\t  observableProto.and = function (right) {\n\t    return new Pattern([this, right]);\n\t  };\n\t\n\t  /**\n\t   *  Matches when the observable sequence has an available value and projects the value.\n\t   *\n\t   *  @param {Function} selector Selector that will be invoked for values in the source sequence.\n\t   *  @returns {Plan} Plan that produces the projected values, to be fed (with other plans) to the when operator.\n\t   */\n\t  observableProto.thenDo = function (selector) {\n\t    return new Pattern([this]).thenDo(selector);\n\t  };\n\t\n\t  /**\n\t   *  Joins together the results from several patterns.\n\t   *\n\t   *  @param plans A series of plans (specified as an Array of as a series of arguments) created by use of the Then operator on patterns.\n\t   *  @returns {Observable} Observable sequence with the results form matching several patterns.\n\t   */\n\t  Observable.when = function () {\n\t    var len = arguments.length, plans;\n\t    if (Array.isArray(arguments[0])) {\n\t      plans = arguments[0];\n\t    } else {\n\t      plans = new Array(len);\n\t      for(var i = 0; i < len; i++) { plans[i] = arguments[i]; }\n\t    }\n\t    return new AnonymousObservable(function (o) {\n\t      var activePlans = [],\n\t          externalSubscriptions = new Map();\n\t      var outObserver = observerCreate(\n\t        function (x) { o.onNext(x); },\n\t        function (err) {\n\t          externalSubscriptions.forEach(function (v) { v.onError(err); });\n\t          o.onError(err);\n\t        },\n\t        function (x) { o.onCompleted(); }\n\t      );\n\t      try {\n\t        for (var i = 0, len = plans.length; i < len; i++) {\n\t          activePlans.push(plans[i].activate(externalSubscriptions, outObserver, function (activePlan) {\n\t            var idx = activePlans.indexOf(activePlan);\n\t            activePlans.splice(idx, 1);\n\t            activePlans.length === 0 && o.onCompleted();\n\t          }));\n\t        }\n\t      } catch (e) {\n\t        observableThrow(e).subscribe(o);\n\t      }\n\t      var group = new CompositeDisposable();\n\t      externalSubscriptions.forEach(function (joinObserver) {\n\t        joinObserver.subscribe();\n\t        group.add(joinObserver);\n\t      });\n\t\n\t      return group;\n\t    });\n\t  };\n\t\n\t  var TimerObservable = (function(__super__) {\n\t    inherits(TimerObservable, __super__);\n\t    function TimerObservable(dt, s) {\n\t      this._dt = dt;\n\t      this._s = s;\n\t      __super__.call(this);\n\t    }\n\t\n\t    TimerObservable.prototype.subscribeCore = function (o) {\n\t      return this._s.scheduleFuture(o, this._dt, scheduleMethod);\n\t    };\n\t\n\t    function scheduleMethod(s, o) {\n\t      o.onNext(0);\n\t      o.onCompleted();\n\t    }\n\t\n\t    return TimerObservable;\n\t  }(ObservableBase));\n\t\n\t  function _observableTimer(dueTime, scheduler) {\n\t    return new TimerObservable(dueTime, scheduler);\n\t  }\n\t\n\t  function observableTimerDateAndPeriod(dueTime, period, scheduler) {\n\t    return new AnonymousObservable(function (observer) {\n\t      var d = dueTime, p = normalizeTime(period);\n\t      return scheduler.scheduleRecursiveFuture(0, d, function (count, self) {\n\t        if (p > 0) {\n\t          var now = scheduler.now();\n\t          d = new Date(d.getTime() + p);\n\t          d.getTime() <= now && (d = new Date(now + p));\n\t        }\n\t        observer.onNext(count);\n\t        self(count + 1, new Date(d));\n\t      });\n\t    });\n\t  }\n\t\n\t  function observableTimerTimeSpanAndPeriod(dueTime, period, scheduler) {\n\t    return dueTime === period ?\n\t      new AnonymousObservable(function (observer) {\n\t        return scheduler.schedulePeriodic(0, period, function (count) {\n\t          observer.onNext(count);\n\t          return count + 1;\n\t        });\n\t      }) :\n\t      observableDefer(function () {\n\t        return observableTimerDateAndPeriod(new Date(scheduler.now() + dueTime), period, scheduler);\n\t      });\n\t  }\n\t\n\t  /**\n\t   *  Returns an observable sequence that produces a value after each period.\n\t   *\n\t   * @example\n\t   *  1 - res = Rx.Observable.interval(1000);\n\t   *  2 - res = Rx.Observable.interval(1000, Rx.Scheduler.timeout);\n\t   *\n\t   * @param {Number} period Period for producing the values in the resulting sequence (specified as an integer denoting milliseconds).\n\t   * @param {Scheduler} [scheduler] Scheduler to run the timer on. If not specified, Rx.Scheduler.timeout is used.\n\t   * @returns {Observable} An observable sequence that produces a value after each period.\n\t   */\n\t  var observableinterval = Observable.interval = function (period, scheduler) {\n\t    return observableTimerTimeSpanAndPeriod(period, period, isScheduler(scheduler) ? scheduler : defaultScheduler);\n\t  };\n\t\n\t  /**\n\t   *  Returns an observable sequence that produces a value after dueTime has elapsed and then after each period.\n\t   * @param {Number} dueTime Absolute (specified as a Date object) or relative time (specified as an integer denoting milliseconds) at which to produce the first value.\n\t   * @param {Mixed} [periodOrScheduler]  Period to produce subsequent values (specified as an integer denoting milliseconds), or the scheduler to run the timer on. If not specified, the resulting timer is not recurring.\n\t   * @param {Scheduler} [scheduler]  Scheduler to run the timer on. If not specified, the timeout scheduler is used.\n\t   * @returns {Observable} An observable sequence that produces a value after due time has elapsed and then each period.\n\t   */\n\t  var observableTimer = Observable.timer = function (dueTime, periodOrScheduler, scheduler) {\n\t    var period;\n\t    isScheduler(scheduler) || (scheduler = defaultScheduler);\n\t    if (periodOrScheduler != null && typeof periodOrScheduler === 'number') {\n\t      period = periodOrScheduler;\n\t    } else if (isScheduler(periodOrScheduler)) {\n\t      scheduler = periodOrScheduler;\n\t    }\n\t    if ((dueTime instanceof Date || typeof dueTime === 'number') && period === undefined) {\n\t      return _observableTimer(dueTime, scheduler);\n\t    }\n\t    if (dueTime instanceof Date && period !== undefined) {\n\t      return observableTimerDateAndPeriod(dueTime.getTime(), periodOrScheduler, scheduler);\n\t    }\n\t    return observableTimerTimeSpanAndPeriod(dueTime, period, scheduler);\n\t  };\n\t\n\t  function observableDelayRelative(source, dueTime, scheduler) {\n\t    return new AnonymousObservable(function (o) {\n\t      var active = false,\n\t        cancelable = new SerialDisposable(),\n\t        exception = null,\n\t        q = [],\n\t        running = false,\n\t        subscription;\n\t      subscription = source.materialize().timestamp(scheduler).subscribe(function (notification) {\n\t        var d, shouldRun;\n\t        if (notification.value.kind === 'E') {\n\t          q = [];\n\t          q.push(notification);\n\t          exception = notification.value.error;\n\t          shouldRun = !running;\n\t        } else {\n\t          q.push({ value: notification.value, timestamp: notification.timestamp + dueTime });\n\t          shouldRun = !active;\n\t          active = true;\n\t        }\n\t        if (shouldRun) {\n\t          if (exception !== null) {\n\t            o.onError(exception);\n\t          } else {\n\t            d = new SingleAssignmentDisposable();\n\t            cancelable.setDisposable(d);\n\t            d.setDisposable(scheduler.scheduleRecursiveFuture(null, dueTime, function (_, self) {\n\t              var e, recurseDueTime, result, shouldRecurse;\n\t              if (exception !== null) {\n\t                return;\n\t              }\n\t              running = true;\n\t              do {\n\t                result = null;\n\t                if (q.length > 0 && q[0].timestamp - scheduler.now() <= 0) {\n\t                  result = q.shift().value;\n\t                }\n\t                if (result !== null) {\n\t                  result.accept(o);\n\t                }\n\t              } while (result !== null);\n\t              shouldRecurse = false;\n\t              recurseDueTime = 0;\n\t              if (q.length > 0) {\n\t                shouldRecurse = true;\n\t                recurseDueTime = Math.max(0, q[0].timestamp - scheduler.now());\n\t              } else {\n\t                active = false;\n\t              }\n\t              e = exception;\n\t              running = false;\n\t              if (e !== null) {\n\t                o.onError(e);\n\t              } else if (shouldRecurse) {\n\t                self(null, recurseDueTime);\n\t              }\n\t            }));\n\t          }\n\t        }\n\t      });\n\t      return new BinaryDisposable(subscription, cancelable);\n\t    }, source);\n\t  }\n\t\n\t  function observableDelayAbsolute(source, dueTime, scheduler) {\n\t    return observableDefer(function () {\n\t      return observableDelayRelative(source, dueTime - scheduler.now(), scheduler);\n\t    });\n\t  }\n\t\n\t  function delayWithSelector(source, subscriptionDelay, delayDurationSelector) {\n\t    var subDelay, selector;\n\t    if (isFunction(subscriptionDelay)) {\n\t      selector = subscriptionDelay;\n\t    } else {\n\t      subDelay = subscriptionDelay;\n\t      selector = delayDurationSelector;\n\t    }\n\t    return new AnonymousObservable(function (o) {\n\t      var delays = new CompositeDisposable(), atEnd = false, subscription = new SerialDisposable();\n\t\n\t      function start() {\n\t        subscription.setDisposable(source.subscribe(\n\t          function (x) {\n\t            var delay = tryCatch(selector)(x);\n\t            if (delay === errorObj) { return o.onError(delay.e); }\n\t            var d = new SingleAssignmentDisposable();\n\t            delays.add(d);\n\t            d.setDisposable(delay.subscribe(\n\t              function () {\n\t                o.onNext(x);\n\t                delays.remove(d);\n\t                done();\n\t              },\n\t              function (e) { o.onError(e); },\n\t              function () {\n\t                o.onNext(x);\n\t                delays.remove(d);\n\t                done();\n\t              }\n\t            ));\n\t          },\n\t          function (e) { o.onError(e); },\n\t          function () {\n\t            atEnd = true;\n\t            subscription.dispose();\n\t            done();\n\t          }\n\t        ));\n\t      }\n\t\n\t      function done () {\n\t        atEnd && delays.length === 0 && o.onCompleted();\n\t      }\n\t\n\t      if (!subDelay) {\n\t        start();\n\t      } else {\n\t        subscription.setDisposable(subDelay.subscribe(start, function (e) { o.onError(e); }, start));\n\t      }\n\t\n\t      return new BinaryDisposable(subscription, delays);\n\t    }, this);\n\t  }\n\t\n\t  /**\n\t   *  Time shifts the observable sequence by dueTime.\n\t   *  The relative time intervals between the values are preserved.\n\t   *\n\t   * @param {Number} dueTime Absolute (specified as a Date object) or relative time (specified as an integer denoting milliseconds) by which to shift the observable sequence.\n\t   * @param {Scheduler} [scheduler] Scheduler to run the delay timers on. If not specified, the timeout scheduler is used.\n\t   * @returns {Observable} Time-shifted sequence.\n\t   */\n\t  observableProto.delay = function () {\n\t    var firstArg = arguments[0];\n\t    if (typeof firstArg === 'number' || firstArg instanceof Date) {\n\t      var dueTime = firstArg, scheduler = arguments[1];\n\t      isScheduler(scheduler) || (scheduler = defaultScheduler);\n\t      return dueTime instanceof Date ?\n\t        observableDelayAbsolute(this, dueTime, scheduler) :\n\t        observableDelayRelative(this, dueTime, scheduler);\n\t    } else if (Observable.isObservable(firstArg) || isFunction(firstArg)) {\n\t      return delayWithSelector(this, firstArg, arguments[1]);\n\t    } else {\n\t      throw new Error('Invalid arguments');\n\t    }\n\t  };\n\t\n\t  var DebounceObservable = (function (__super__) {\n\t    inherits(DebounceObservable, __super__);\n\t    function DebounceObservable(source, dt, s) {\n\t      isScheduler(s) || (s = defaultScheduler);\n\t      this.source = source;\n\t      this._dt = dt;\n\t      this._s = s;\n\t      __super__.call(this);\n\t    }\n\t\n\t    DebounceObservable.prototype.subscribeCore = function (o) {\n\t      var cancelable = new SerialDisposable();\n\t      return new BinaryDisposable(\n\t        this.source.subscribe(new DebounceObserver(o, this.source, this._dt, this._s, cancelable)),\n\t        cancelable);\n\t    };\n\t\n\t    return DebounceObservable;\n\t  }(ObservableBase));\n\t\n\t  var DebounceObserver = (function (__super__) {\n\t    inherits(DebounceObserver, __super__);\n\t    function DebounceObserver(observer, source, dueTime, scheduler, cancelable) {\n\t      this._o = observer;\n\t      this._s = source;\n\t      this._d = dueTime;\n\t      this._scheduler = scheduler;\n\t      this._c = cancelable;\n\t      this._v = null;\n\t      this._hv = false;\n\t      this._id = 0;\n\t      __super__.call(this);\n\t    }\n\t\n\t    DebounceObserver.prototype.next = function (x) {\n\t      this._hv = true;\n\t      this._v = x;\n\t      var currentId = ++this._id, d = new SingleAssignmentDisposable();\n\t      this._c.setDisposable(d);\n\t      d.setDisposable(this._scheduler.scheduleFuture(this, this._d, function (_, self) {\n\t        self._hv && self._id === currentId && self._o.onNext(x);\n\t        self._hv = false;\n\t      }));\n\t    };\n\t\n\t    DebounceObserver.prototype.error = function (e) {\n\t      this._c.dispose();\n\t      this._o.onError(e);\n\t      this._hv = false;\n\t      this._id++;\n\t    };\n\t\n\t    DebounceObserver.prototype.completed = function () {\n\t      this._c.dispose();\n\t      this._hv && this._o.onNext(this._v);\n\t      this._o.onCompleted();\n\t      this._hv = false;\n\t      this._id++;\n\t    };\n\t\n\t    return DebounceObserver;\n\t  }(AbstractObserver));\n\t\n\t  function debounceWithSelector(source, durationSelector) {\n\t    return new AnonymousObservable(function (o) {\n\t      var value, hasValue = false, cancelable = new SerialDisposable(), id = 0;\n\t      var subscription = source.subscribe(\n\t        function (x) {\n\t          var throttle = tryCatch(durationSelector)(x);\n\t          if (throttle === errorObj) { return o.onError(throttle.e); }\n\t\n\t          isPromise(throttle) && (throttle = observableFromPromise(throttle));\n\t\n\t          hasValue = true;\n\t          value = x;\n\t          id++;\n\t          var currentid = id, d = new SingleAssignmentDisposable();\n\t          cancelable.setDisposable(d);\n\t          d.setDisposable(throttle.subscribe(\n\t            function () {\n\t              hasValue && id === currentid && o.onNext(value);\n\t              hasValue = false;\n\t              d.dispose();\n\t            },\n\t            function (e) { o.onError(e); },\n\t            function () {\n\t              hasValue && id === currentid && o.onNext(value);\n\t              hasValue = false;\n\t              d.dispose();\n\t            }\n\t          ));\n\t        },\n\t        function (e) {\n\t          cancelable.dispose();\n\t          o.onError(e);\n\t          hasValue = false;\n\t          id++;\n\t        },\n\t        function () {\n\t          cancelable.dispose();\n\t          hasValue && o.onNext(value);\n\t          o.onCompleted();\n\t          hasValue = false;\n\t          id++;\n\t        }\n\t      );\n\t      return new BinaryDisposable(subscription, cancelable);\n\t    }, source);\n\t  }\n\t\n\t  observableProto.debounce = function () {\n\t    if (isFunction (arguments[0])) {\n\t      return debounceWithSelector(this, arguments[0]);\n\t    } else if (typeof arguments[0] === 'number') {\n\t      return new DebounceObservable(this, arguments[0], arguments[1]);\n\t    } else {\n\t      throw new Error('Invalid arguments');\n\t    }\n\t  };\n\t\n\t  /**\n\t   *  Projects each element of an observable sequence into zero or more windows which are produced based on timing information.\n\t   * @param {Number} timeSpan Length of each window (specified as an integer denoting milliseconds).\n\t   * @param {Mixed} [timeShiftOrScheduler]  Interval between creation of consecutive windows (specified as an integer denoting milliseconds), or an optional scheduler parameter. If not specified, the time shift corresponds to the timeSpan parameter, resulting in non-overlapping adjacent windows.\n\t   * @param {Scheduler} [scheduler]  Scheduler to run windowing timers on. If not specified, the timeout scheduler is used.\n\t   * @returns {Observable} An observable sequence of windows.\n\t   */\n\t  observableProto.windowWithTime = function (timeSpan, timeShiftOrScheduler, scheduler) {\n\t    var source = this, timeShift;\n\t    timeShiftOrScheduler == null && (timeShift = timeSpan);\n\t    isScheduler(scheduler) || (scheduler = defaultScheduler);\n\t    if (typeof timeShiftOrScheduler === 'number') {\n\t      timeShift = timeShiftOrScheduler;\n\t    } else if (isScheduler(timeShiftOrScheduler)) {\n\t      timeShift = timeSpan;\n\t      scheduler = timeShiftOrScheduler;\n\t    }\n\t    return new AnonymousObservable(function (observer) {\n\t      var groupDisposable,\n\t        nextShift = timeShift,\n\t        nextSpan = timeSpan,\n\t        q = [],\n\t        refCountDisposable,\n\t        timerD = new SerialDisposable(),\n\t        totalTime = 0;\n\t        groupDisposable = new CompositeDisposable(timerD),\n\t        refCountDisposable = new RefCountDisposable(groupDisposable);\n\t\n\t       function createTimer () {\n\t        var m = new SingleAssignmentDisposable(),\n\t          isSpan = false,\n\t          isShift = false;\n\t        timerD.setDisposable(m);\n\t        if (nextSpan === nextShift) {\n\t          isSpan = true;\n\t          isShift = true;\n\t        } else if (nextSpan < nextShift) {\n\t            isSpan = true;\n\t        } else {\n\t          isShift = true;\n\t        }\n\t        var newTotalTime = isSpan ? nextSpan : nextShift,\n\t          ts = newTotalTime - totalTime;\n\t        totalTime = newTotalTime;\n\t        if (isSpan) {\n\t          nextSpan += timeShift;\n\t        }\n\t        if (isShift) {\n\t          nextShift += timeShift;\n\t        }\n\t        m.setDisposable(scheduler.scheduleFuture(null, ts, function () {\n\t          if (isShift) {\n\t            var s = new Subject();\n\t            q.push(s);\n\t            observer.onNext(addRef(s, refCountDisposable));\n\t          }\n\t          isSpan && q.shift().onCompleted();\n\t          createTimer();\n\t        }));\n\t      };\n\t      q.push(new Subject());\n\t      observer.onNext(addRef(q[0], refCountDisposable));\n\t      createTimer();\n\t      groupDisposable.add(source.subscribe(\n\t        function (x) {\n\t          for (var i = 0, len = q.length; i < len; i++) { q[i].onNext(x); }\n\t        },\n\t        function (e) {\n\t          for (var i = 0, len = q.length; i < len; i++) { q[i].onError(e); }\n\t          observer.onError(e);\n\t        },\n\t        function () {\n\t          for (var i = 0, len = q.length; i < len; i++) { q[i].onCompleted(); }\n\t          observer.onCompleted();\n\t        }\n\t      ));\n\t      return refCountDisposable;\n\t    }, source);\n\t  };\n\t\n\t  /**\n\t   *  Projects each element of an observable sequence into a window that is completed when either it's full or a given amount of time has elapsed.\n\t   * @param {Number} timeSpan Maximum time length of a window.\n\t   * @param {Number} count Maximum element count of a window.\n\t   * @param {Scheduler} [scheduler]  Scheduler to run windowing timers on. If not specified, the timeout scheduler is used.\n\t   * @returns {Observable} An observable sequence of windows.\n\t   */\n\t  observableProto.windowWithTimeOrCount = function (timeSpan, count, scheduler) {\n\t    var source = this;\n\t    isScheduler(scheduler) || (scheduler = defaultScheduler);\n\t    return new AnonymousObservable(function (observer) {\n\t      var timerD = new SerialDisposable(),\n\t          groupDisposable = new CompositeDisposable(timerD),\n\t          refCountDisposable = new RefCountDisposable(groupDisposable),\n\t          n = 0,\n\t          windowId = 0,\n\t          s = new Subject();\n\t\n\t      function createTimer(id) {\n\t        var m = new SingleAssignmentDisposable();\n\t        timerD.setDisposable(m);\n\t        m.setDisposable(scheduler.scheduleFuture(null, timeSpan, function () {\n\t          if (id !== windowId) { return; }\n\t          n = 0;\n\t          var newId = ++windowId;\n\t          s.onCompleted();\n\t          s = new Subject();\n\t          observer.onNext(addRef(s, refCountDisposable));\n\t          createTimer(newId);\n\t        }));\n\t      }\n\t\n\t      observer.onNext(addRef(s, refCountDisposable));\n\t      createTimer(0);\n\t\n\t      groupDisposable.add(source.subscribe(\n\t        function (x) {\n\t          var newId = 0, newWindow = false;\n\t          s.onNext(x);\n\t          if (++n === count) {\n\t            newWindow = true;\n\t            n = 0;\n\t            newId = ++windowId;\n\t            s.onCompleted();\n\t            s = new Subject();\n\t            observer.onNext(addRef(s, refCountDisposable));\n\t          }\n\t          newWindow && createTimer(newId);\n\t        },\n\t        function (e) {\n\t          s.onError(e);\n\t          observer.onError(e);\n\t        }, function () {\n\t          s.onCompleted();\n\t          observer.onCompleted();\n\t        }\n\t      ));\n\t      return refCountDisposable;\n\t    }, source);\n\t  };\n\t\n\t  function toArray(x) { return x.toArray(); }\n\t\n\t  /**\n\t   *  Projects each element of an observable sequence into zero or more buffers which are produced based on timing information.\n\t   * @param {Number} timeSpan Length of each buffer (specified as an integer denoting milliseconds).\n\t   * @param {Mixed} [timeShiftOrScheduler]  Interval between creation of consecutive buffers (specified as an integer denoting milliseconds), or an optional scheduler parameter. If not specified, the time shift corresponds to the timeSpan parameter, resulting in non-overlapping adjacent buffers.\n\t   * @param {Scheduler} [scheduler]  Scheduler to run buffer timers on. If not specified, the timeout scheduler is used.\n\t   * @returns {Observable} An observable sequence of buffers.\n\t   */\n\t  observableProto.bufferWithTime = function (timeSpan, timeShiftOrScheduler, scheduler) {\n\t    return this.windowWithTime(timeSpan, timeShiftOrScheduler, scheduler).flatMap(toArray);\n\t  };\n\t\n\t  function toArray(x) { return x.toArray(); }\n\t\n\t  /**\n\t   *  Projects each element of an observable sequence into a buffer that is completed when either it's full or a given amount of time has elapsed.\n\t   * @param {Number} timeSpan Maximum time length of a buffer.\n\t   * @param {Number} count Maximum element count of a buffer.\n\t   * @param {Scheduler} [scheduler]  Scheduler to run bufferin timers on. If not specified, the timeout scheduler is used.\n\t   * @returns {Observable} An observable sequence of buffers.\n\t   */\n\t  observableProto.bufferWithTimeOrCount = function (timeSpan, count, scheduler) {\n\t    return this.windowWithTimeOrCount(timeSpan, count, scheduler).flatMap(toArray);\n\t  };\n\t\n\t  var TimeIntervalObservable = (function (__super__) {\n\t    inherits(TimeIntervalObservable, __super__);\n\t    function TimeIntervalObservable(source, s) {\n\t      this.source = source;\n\t      this._s = s;\n\t      __super__.call(this);\n\t    }\n\t\n\t    TimeIntervalObservable.prototype.subscribeCore = function (o) {\n\t      return this.source.subscribe(new TimeIntervalObserver(o, this._s));\n\t    };\n\t\n\t    return TimeIntervalObservable;\n\t  }(ObservableBase));\n\t\n\t  var TimeIntervalObserver = (function (__super__) {\n\t    inherits(TimeIntervalObserver, __super__);\n\t\n\t    function TimeIntervalObserver(o, s) {\n\t      this._o = o;\n\t      this._s = s;\n\t      this._l = s.now();\n\t      __super__.call(this);\n\t    }\n\t\n\t    TimeIntervalObserver.prototype.next = function (x) {\n\t      var now = this._s.now(), span = now - this._l;\n\t      this._l = now;\n\t      this._o.onNext({ value: x, interval: span });\n\t    };\n\t    TimeIntervalObserver.prototype.error = function (e) { this._o.onError(e); };\n\t    TimeIntervalObserver.prototype.completed = function () { this._o.onCompleted(); };\n\t\n\t    return TimeIntervalObserver;\n\t  }(AbstractObserver));\n\t\n\t  /**\n\t   *  Records the time interval between consecutive values in an observable sequence.\n\t   *\n\t   * @example\n\t   *  1 - res = source.timeInterval();\n\t   *  2 - res = source.timeInterval(Rx.Scheduler.timeout);\n\t   *\n\t   * @param [scheduler]  Scheduler used to compute time intervals. If not specified, the timeout scheduler is used.\n\t   * @returns {Observable} An observable sequence with time interval information on values.\n\t   */\n\t  observableProto.timeInterval = function (scheduler) {\n\t    isScheduler(scheduler) || (scheduler = defaultScheduler);\n\t    return new TimeIntervalObservable(this, scheduler);\n\t  };\n\t\n\t  var TimestampObservable = (function (__super__) {\n\t    inherits(TimestampObservable, __super__);\n\t    function TimestampObservable(source, s) {\n\t      this.source = source;\n\t      this._s = s;\n\t      __super__.call(this);\n\t    }\n\t\n\t    TimestampObservable.prototype.subscribeCore = function (o) {\n\t      return this.source.subscribe(new TimestampObserver(o, this._s));\n\t    };\n\t\n\t    return TimestampObservable;\n\t  }(ObservableBase));\n\t\n\t  var TimestampObserver = (function (__super__) {\n\t    inherits(TimestampObserver, __super__);\n\t    function TimestampObserver(o, s) {\n\t      this._o = o;\n\t      this._s = s;\n\t      __super__.call(this);\n\t    }\n\t\n\t    TimestampObserver.prototype.next = function (x) {\n\t      this._o.onNext({ value: x, timestamp: this._s.now() });\n\t    };\n\t\n\t    TimestampObserver.prototype.error = function (e) {\n\t      this._o.onError(e);\n\t    };\n\t\n\t    TimestampObserver.prototype.completed = function () {\n\t      this._o.onCompleted();\n\t    };\n\t\n\t    return TimestampObserver;\n\t  }(AbstractObserver));\n\t\n\t  /**\n\t   *  Records the timestamp for each value in an observable sequence.\n\t   *\n\t   * @example\n\t   *  1 - res = source.timestamp(); // produces { value: x, timestamp: ts }\n\t   *  2 - res = source.timestamp(Rx.Scheduler.default);\n\t   *\n\t   * @param {Scheduler} [scheduler]  Scheduler used to compute timestamps. If not specified, the default scheduler is used.\n\t   * @returns {Observable} An observable sequence with timestamp information on values.\n\t   */\n\t  observableProto.timestamp = function (scheduler) {\n\t    isScheduler(scheduler) || (scheduler = defaultScheduler);\n\t    return new TimestampObservable(this, scheduler);\n\t  };\n\t\n\t  function sampleObservable(source, sampler) {\n\t    return new AnonymousObservable(function (o) {\n\t      var atEnd = false, value, hasValue = false;\n\t\n\t      function sampleSubscribe() {\n\t        if (hasValue) {\n\t          hasValue = false;\n\t          o.onNext(value);\n\t        }\n\t        atEnd && o.onCompleted();\n\t      }\n\t\n\t      var sourceSubscription = new SingleAssignmentDisposable();\n\t      sourceSubscription.setDisposable(source.subscribe(\n\t        function (newValue) {\n\t          hasValue = true;\n\t          value = newValue;\n\t        },\n\t        function (e) { o.onError(e); },\n\t        function () {\n\t          atEnd = true;\n\t          sourceSubscription.dispose();\n\t        }\n\t      ));\n\t\n\t      return new BinaryDisposable(\n\t        sourceSubscription,\n\t        sampler.subscribe(sampleSubscribe, function (e) { o.onError(e); }, sampleSubscribe)\n\t      );\n\t    }, source);\n\t  }\n\t\n\t  /**\n\t   *  Samples the observable sequence at each interval.\n\t   *\n\t   * @example\n\t   *  1 - res = source.sample(sampleObservable); // Sampler tick sequence\n\t   *  2 - res = source.sample(5000); // 5 seconds\n\t   *  2 - res = source.sample(5000, Rx.Scheduler.timeout); // 5 seconds\n\t   *\n\t   * @param {Mixed} intervalOrSampler Interval at which to sample (specified as an integer denoting milliseconds) or Sampler Observable.\n\t   * @param {Scheduler} [scheduler]  Scheduler to run the sampling timer on. If not specified, the timeout scheduler is used.\n\t   * @returns {Observable} Sampled observable sequence.\n\t   */\n\t  observableProto.sample = observableProto.throttleLatest = function (intervalOrSampler, scheduler) {\n\t    isScheduler(scheduler) || (scheduler = defaultScheduler);\n\t    return typeof intervalOrSampler === 'number' ?\n\t      sampleObservable(this, observableinterval(intervalOrSampler, scheduler)) :\n\t      sampleObservable(this, intervalOrSampler);\n\t  };\n\t\n\t  var TimeoutError = Rx.TimeoutError = function(message) {\n\t    this.message = message || 'Timeout has occurred';\n\t    this.name = 'TimeoutError';\n\t    Error.call(this);\n\t  };\n\t  TimeoutError.prototype = Object.create(Error.prototype);\n\t\n\t  function timeoutWithSelector(source, firstTimeout, timeoutDurationSelector, other) {\n\t    if (isFunction(firstTimeout)) {\n\t      other = timeoutDurationSelector;\n\t      timeoutDurationSelector = firstTimeout;\n\t      firstTimeout = observableNever();\n\t    }\n\t    Observable.isObservable(other) || (other = observableThrow(new TimeoutError()));\n\t    return new AnonymousObservable(function (o) {\n\t      var subscription = new SerialDisposable(),\n\t        timer = new SerialDisposable(),\n\t        original = new SingleAssignmentDisposable();\n\t\n\t      subscription.setDisposable(original);\n\t\n\t      var id = 0, switched = false;\n\t\n\t      function setTimer(timeout) {\n\t        var myId = id, d = new SingleAssignmentDisposable();\n\t\n\t        function timerWins() {\n\t          switched = (myId === id);\n\t          return switched;\n\t        }\n\t\n\t        timer.setDisposable(d);\n\t        d.setDisposable(timeout.subscribe(function () {\n\t          timerWins() && subscription.setDisposable(other.subscribe(o));\n\t          d.dispose();\n\t        }, function (e) {\n\t          timerWins() && o.onError(e);\n\t        }, function () {\n\t          timerWins() && subscription.setDisposable(other.subscribe(o));\n\t        }));\n\t      };\n\t\n\t      setTimer(firstTimeout);\n\t\n\t      function oWins() {\n\t        var res = !switched;\n\t        if (res) { id++; }\n\t        return res;\n\t      }\n\t\n\t      original.setDisposable(source.subscribe(function (x) {\n\t        if (oWins()) {\n\t          o.onNext(x);\n\t          var timeout = tryCatch(timeoutDurationSelector)(x);\n\t          if (timeout === errorObj) { return o.onError(timeout.e); }\n\t          setTimer(isPromise(timeout) ? observableFromPromise(timeout) : timeout);\n\t        }\n\t      }, function (e) {\n\t        oWins() && o.onError(e);\n\t      }, function () {\n\t        oWins() && o.onCompleted();\n\t      }));\n\t      return new BinaryDisposable(subscription, timer);\n\t    }, source);\n\t  }\n\t\n\t  function timeout(source, dueTime, other, scheduler) {\n\t    if (isScheduler(other)) {\n\t      scheduler = other;\n\t      other = observableThrow(new TimeoutError());\n\t    }\n\t    if (other instanceof Error) { other = observableThrow(other); }\n\t    isScheduler(scheduler) || (scheduler = defaultScheduler);\n\t    Observable.isObservable(other) || (other = observableThrow(new TimeoutError()));\n\t    return new AnonymousObservable(function (o) {\n\t      var id = 0,\n\t        original = new SingleAssignmentDisposable(),\n\t        subscription = new SerialDisposable(),\n\t        switched = false,\n\t        timer = new SerialDisposable();\n\t\n\t      subscription.setDisposable(original);\n\t\n\t      function createTimer() {\n\t        var myId = id;\n\t        timer.setDisposable(scheduler.scheduleFuture(null, dueTime, function () {\n\t          switched = id === myId;\n\t          if (switched) {\n\t            isPromise(other) && (other = observableFromPromise(other));\n\t            subscription.setDisposable(other.subscribe(o));\n\t          }\n\t        }));\n\t      }\n\t\n\t      createTimer();\n\t\n\t      original.setDisposable(source.subscribe(function (x) {\n\t        if (!switched) {\n\t          id++;\n\t          o.onNext(x);\n\t          createTimer();\n\t        }\n\t      }, function (e) {\n\t        if (!switched) {\n\t          id++;\n\t          o.onError(e);\n\t        }\n\t      }, function () {\n\t        if (!switched) {\n\t          id++;\n\t          o.onCompleted();\n\t        }\n\t      }));\n\t      return new BinaryDisposable(subscription, timer);\n\t    }, source);\n\t  }\n\t\n\t  observableProto.timeout = function () {\n\t    var firstArg = arguments[0];\n\t    if (firstArg instanceof Date || typeof firstArg === 'number') {\n\t      return timeout(this, firstArg, arguments[1], arguments[2]);\n\t    } else if (Observable.isObservable(firstArg) || isFunction(firstArg)) {\n\t      return timeoutWithSelector(this, firstArg, arguments[1], arguments[2]);\n\t    } else {\n\t      throw new Error('Invalid arguments');\n\t    }\n\t  };\n\t\n\t  var GenerateAbsoluteObservable = (function (__super__) {\n\t    inherits(GenerateAbsoluteObservable, __super__);\n\t    function GenerateAbsoluteObservable(state, cndFn, itrFn, resFn, timeFn, s) {\n\t      this._state = state;\n\t      this._cndFn = cndFn;\n\t      this._itrFn = itrFn;\n\t      this._resFn = resFn;\n\t      this._timeFn = timeFn;\n\t      this._s = s;\n\t      this._first = true;\n\t      this._hasResult = false;\n\t      __super__.call(this);\n\t    }\n\t\n\t    function scheduleRecursive(self, recurse) {\n\t      self._hasResult && self._o.onNext(self._state);\n\t\n\t      if (self._first) {\n\t        self._first = false;\n\t      } else {\n\t        self._state = tryCatch(self._itrFn)(self._state);\n\t        if (self._state === errorObj) { return self._o.onError(self._state.e); }\n\t      }\n\t      self._hasResult = tryCatch(self._cndFn)(self._state);\n\t      if (self._hasResult === errorObj) { return self._o.onError(self._hasResult.e); }\n\t      if (self._hasResult) {\n\t        var result = tryCatch(self._resFn)(self._state);\n\t        if (result === errorObj) { return self._o.onError(result.e); }\n\t        var time = tryCatch(self._timeFn)(self._state);\n\t        if (time === errorObj) { return self._o.onError(time.e); }\n\t        recurse(self, time);\n\t      } else {\n\t        self._o.onCompleted();\n\t      }\n\t    }\n\t\n\t    GenerateAbsoluteObservable.prototype.subscribeCore = function (o) {\n\t      this._o = o;\n\t      return this._s.scheduleRecursiveFuture(this, new Date(this._s.now()), scheduleRecursive);\n\t    };\n\t\n\t    return GenerateAbsoluteObservable;\n\t  }(ObservableBase));\n\t\n\t  /**\n\t   *  GenerateAbsolutes an observable sequence by iterating a state from an initial state until the condition fails.\n\t   *\n\t   * @example\n\t   *  res = source.generateWithAbsoluteTime(0,\n\t   *      function (x) { return return true; },\n\t   *      function (x) { return x + 1; },\n\t   *      function (x) { return x; },\n\t   *      function (x) { return new Date(); }\n\t   *  });\n\t   *\n\t   * @param {Mixed} initialState Initial state.\n\t   * @param {Function} condition Condition to terminate generation (upon returning false).\n\t   * @param {Function} iterate Iteration step function.\n\t   * @param {Function} resultSelector Selector function for results produced in the sequence.\n\t   * @param {Function} timeSelector Time selector function to control the speed of values being produced each iteration, returning Date values.\n\t   * @param {Scheduler} [scheduler]  Scheduler on which to run the generator loop. If not specified, the timeout scheduler is used.\n\t   * @returns {Observable} The generated sequence.\n\t   */\n\t  Observable.generateWithAbsoluteTime = function (initialState, condition, iterate, resultSelector, timeSelector, scheduler) {\n\t    isScheduler(scheduler) || (scheduler = defaultScheduler);\n\t    return new GenerateAbsoluteObservable(initialState, condition, iterate, resultSelector, timeSelector, scheduler);\n\t  };\n\t\n\t  var GenerateRelativeObservable = (function (__super__) {\n\t    inherits(GenerateRelativeObservable, __super__);\n\t    function GenerateRelativeObservable(state, cndFn, itrFn, resFn, timeFn, s) {\n\t      this._state = state;\n\t      this._cndFn = cndFn;\n\t      this._itrFn = itrFn;\n\t      this._resFn = resFn;\n\t      this._timeFn = timeFn;\n\t      this._s = s;\n\t      this._first = true;\n\t      this._hasResult = false;\n\t      __super__.call(this);\n\t    }\n\t\n\t    function scheduleRecursive(self, recurse) {\n\t      self._hasResult && self._o.onNext(self._state);\n\t\n\t      if (self._first) {\n\t        self._first = false;\n\t      } else {\n\t        self._state = tryCatch(self._itrFn)(self._state);\n\t        if (self._state === errorObj) { return self._o.onError(self._state.e); }\n\t      }\n\t      self._hasResult = tryCatch(self._cndFn)(self._state);\n\t      if (self._hasResult === errorObj) { return self._o.onError(self._hasResult.e); }\n\t      if (self._hasResult) {\n\t        var result = tryCatch(self._resFn)(self._state);\n\t        if (result === errorObj) { return self._o.onError(result.e); }\n\t        var time = tryCatch(self._timeFn)(self._state);\n\t        if (time === errorObj) { return self._o.onError(time.e); }\n\t        recurse(self, time);\n\t      } else {\n\t        self._o.onCompleted();\n\t      }\n\t    }\n\t\n\t    GenerateRelativeObservable.prototype.subscribeCore = function (o) {\n\t      this._o = o;\n\t      return this._s.scheduleRecursiveFuture(this, 0, scheduleRecursive);\n\t    };\n\t\n\t    return GenerateRelativeObservable;\n\t  }(ObservableBase));\n\t\n\t  /**\n\t   *  Generates an observable sequence by iterating a state from an initial state until the condition fails.\n\t   *\n\t   * @example\n\t   *  res = source.generateWithRelativeTime(0,\n\t   *      function (x) { return return true; },\n\t   *      function (x) { return x + 1; },\n\t   *      function (x) { return x; },\n\t   *      function (x) { return 500; }\n\t   *  );\n\t   *\n\t   * @param {Mixed} initialState Initial state.\n\t   * @param {Function} condition Condition to terminate generation (upon returning false).\n\t   * @param {Function} iterate Iteration step function.\n\t   * @param {Function} resultSelector Selector function for results produced in the sequence.\n\t   * @param {Function} timeSelector Time selector function to control the speed of values being produced each iteration, returning integer values denoting milliseconds.\n\t   * @param {Scheduler} [scheduler]  Scheduler on which to run the generator loop. If not specified, the timeout scheduler is used.\n\t   * @returns {Observable} The generated sequence.\n\t   */\n\t  Observable.generateWithRelativeTime = function (initialState, condition, iterate, resultSelector, timeSelector, scheduler) {\n\t    isScheduler(scheduler) || (scheduler = defaultScheduler);\n\t    return new GenerateRelativeObservable(initialState, condition, iterate, resultSelector, timeSelector, scheduler);\n\t  };\n\t\n\t  var DelaySubscription = (function(__super__) {\n\t    inherits(DelaySubscription, __super__);\n\t    function DelaySubscription(source, dt, s) {\n\t      this.source = source;\n\t      this._dt = dt;\n\t      this._s = s;\n\t      __super__.call(this);\n\t    }\n\t\n\t    DelaySubscription.prototype.subscribeCore = function (o) {\n\t      var d = new SerialDisposable();\n\t\n\t      d.setDisposable(this._s.scheduleFuture([this.source, o, d], this._dt, scheduleMethod));\n\t\n\t      return d;\n\t    };\n\t\n\t    function scheduleMethod(s, state) {\n\t      var source = state[0], o = state[1], d = state[2];\n\t      d.setDisposable(source.subscribe(o));\n\t    }\n\t\n\t    return DelaySubscription;\n\t  }(ObservableBase));\n\t\n\t  /**\n\t   *  Time shifts the observable sequence by delaying the subscription with the specified relative time duration, using the specified scheduler to run timers.\n\t   *\n\t   * @example\n\t   *  1 - res = source.delaySubscription(5000); // 5s\n\t   *  2 - res = source.delaySubscription(5000, Rx.Scheduler.default); // 5 seconds\n\t   *\n\t   * @param {Number} dueTime Relative or absolute time shift of the subscription.\n\t   * @param {Scheduler} [scheduler]  Scheduler to run the subscription delay timer on. If not specified, the timeout scheduler is used.\n\t   * @returns {Observable} Time-shifted sequence.\n\t   */\n\t  observableProto.delaySubscription = function (dueTime, scheduler) {\n\t    isScheduler(scheduler) || (scheduler = defaultScheduler);\n\t    return new DelaySubscription(this, dueTime, scheduler);\n\t  };\n\t\n\t  var SkipLastWithTimeObservable = (function (__super__) {\n\t    inherits(SkipLastWithTimeObservable, __super__);\n\t    function SkipLastWithTimeObservable(source, d, s) {\n\t      this.source = source;\n\t      this._d = d;\n\t      this._s = s;\n\t      __super__.call(this);\n\t    }\n\t\n\t    SkipLastWithTimeObservable.prototype.subscribeCore = function (o) {\n\t      return this.source.subscribe(new SkipLastWithTimeObserver(o, this));\n\t    };\n\t\n\t    return SkipLastWithTimeObservable;\n\t  }(ObservableBase));\n\t\n\t  var SkipLastWithTimeObserver = (function (__super__) {\n\t    inherits(SkipLastWithTimeObserver, __super__);\n\t\n\t    function SkipLastWithTimeObserver(o, p) {\n\t      this._o = o;\n\t      this._s = p._s;\n\t      this._d = p._d;\n\t      this._q = [];\n\t      __super__.call(this);\n\t    }\n\t\n\t    SkipLastWithTimeObserver.prototype.next = function (x) {\n\t      var now = this._s.now();\n\t      this._q.push({ interval: now, value: x });\n\t      while (this._q.length > 0 && now - this._q[0].interval >= this._d) {\n\t        this._o.onNext(this._q.shift().value);\n\t      }\n\t    };\n\t    SkipLastWithTimeObserver.prototype.error = function (e) { this._o.onError(e); };\n\t    SkipLastWithTimeObserver.prototype.completed = function () {\n\t      var now = this._s.now();\n\t      while (this._q.length > 0 && now - this._q[0].interval >= this._d) {\n\t        this._o.onNext(this._q.shift().value);\n\t      }\n\t      this._o.onCompleted();\n\t    };\n\t\n\t    return SkipLastWithTimeObserver;\n\t  }(AbstractObserver));\n\t\n\t  /**\n\t   *  Skips elements for the specified duration from the end of the observable source sequence, using the specified scheduler to run timers.\n\t   * @description\n\t   *  This operator accumulates a queue with a length enough to store elements received during the initial duration window.\n\t   *  As more elements are received, elements older than the specified duration are taken from the queue and produced on the\n\t   *  result sequence. This causes elements to be delayed with duration.\n\t   * @param {Number} duration Duration for skipping elements from the end of the sequence.\n\t   * @param {Scheduler} [scheduler]  Scheduler to run the timer on. If not specified, defaults to Rx.Scheduler.timeout\n\t   * @returns {Observable} An observable sequence with the elements skipped during the specified duration from the end of the source sequence.\n\t   */\n\t  observableProto.skipLastWithTime = function (duration, scheduler) {\n\t    isScheduler(scheduler) || (scheduler = defaultScheduler);\n\t    return new SkipLastWithTimeObservable(this, duration, scheduler);\n\t  };\n\t\n\t  var TakeLastWithTimeObservable = (function (__super__) {\n\t    inherits(TakeLastWithTimeObservable, __super__);\n\t    function TakeLastWithTimeObservable(source, d, s) {\n\t      this.source = source;\n\t      this._d = d;\n\t      this._s = s;\n\t      __super__.call(this);\n\t    }\n\t\n\t    TakeLastWithTimeObservable.prototype.subscribeCore = function (o) {\n\t      return this.source.subscribe(new TakeLastWithTimeObserver(o, this._d, this._s));\n\t    };\n\t\n\t    return TakeLastWithTimeObservable;\n\t  }(ObservableBase));\n\t\n\t  var TakeLastWithTimeObserver = (function (__super__) {\n\t    inherits(TakeLastWithTimeObserver, __super__);\n\t\n\t    function TakeLastWithTimeObserver(o, d, s) {\n\t      this._o = o;\n\t      this._d = d;\n\t      this._s = s;\n\t      this._q = [];\n\t      __super__.call(this);\n\t    }\n\t\n\t    TakeLastWithTimeObserver.prototype.next = function (x) {\n\t      var now = this._s.now();\n\t      this._q.push({ interval: now, value: x });\n\t      while (this._q.length > 0 && now - this._q[0].interval >= this._d) {\n\t        this._q.shift();\n\t      }\n\t    };\n\t    TakeLastWithTimeObserver.prototype.error = function (e) { this._o.onError(e); };\n\t    TakeLastWithTimeObserver.prototype.completed = function () {\n\t      var now = this._s.now();\n\t      while (this._q.length > 0) {\n\t        var next = this._q.shift();\n\t        if (now - next.interval <= this._d) { this._o.onNext(next.value); }\n\t      }\n\t      this._o.onCompleted();\n\t    };\n\t\n\t    return TakeLastWithTimeObserver;\n\t  }(AbstractObserver));\n\t\n\t  /**\n\t   *  Returns elements within the specified duration from the end of the observable source sequence, using the specified schedulers to run timers and to drain the collected elements.\n\t   * @description\n\t   *  This operator accumulates a queue with a length enough to store elements received during the initial duration window.\n\t   *  As more elements are received, elements older than the specified duration are taken from the queue and produced on the\n\t   *  result sequence. This causes elements to be delayed with duration.\n\t   * @param {Number} duration Duration for taking elements from the end of the sequence.\n\t   * @param {Scheduler} [scheduler]  Scheduler to run the timer on. If not specified, defaults to Rx.Scheduler.timeout.\n\t   * @returns {Observable} An observable sequence with the elements taken during the specified duration from the end of the source sequence.\n\t   */\n\t  observableProto.takeLastWithTime = function (duration, scheduler) {\n\t    isScheduler(scheduler) || (scheduler = defaultScheduler);\n\t    return new TakeLastWithTimeObservable(this, duration, scheduler);\n\t  };\n\t\n\t  /**\n\t   *  Returns an array with the elements within the specified duration from the end of the observable source sequence, using the specified scheduler to run timers.\n\t   * @description\n\t   *  This operator accumulates a queue with a length enough to store elements received during the initial duration window.\n\t   *  As more elements are received, elements older than the specified duration are taken from the queue and produced on the\n\t   *  result sequence. This causes elements to be delayed with duration.\n\t   * @param {Number} duration Duration for taking elements from the end of the sequence.\n\t   * @param {Scheduler} scheduler Scheduler to run the timer on. If not specified, defaults to Rx.Scheduler.timeout.\n\t   * @returns {Observable} An observable sequence containing a single array with the elements taken during the specified duration from the end of the source sequence.\n\t   */\n\t  observableProto.takeLastBufferWithTime = function (duration, scheduler) {\n\t    var source = this;\n\t    isScheduler(scheduler) || (scheduler = defaultScheduler);\n\t    return new AnonymousObservable(function (o) {\n\t      var q = [];\n\t      return source.subscribe(function (x) {\n\t        var now = scheduler.now();\n\t        q.push({ interval: now, value: x });\n\t        while (q.length > 0 && now - q[0].interval >= duration) {\n\t          q.shift();\n\t        }\n\t      }, function (e) { o.onError(e); }, function () {\n\t        var now = scheduler.now(), res = [];\n\t        while (q.length > 0) {\n\t          var next = q.shift();\n\t          now - next.interval <= duration && res.push(next.value);\n\t        }\n\t        o.onNext(res);\n\t        o.onCompleted();\n\t      });\n\t    }, source);\n\t  };\n\t\n\t  var TakeWithTimeObservable = (function (__super__) {\n\t    inherits(TakeWithTimeObservable, __super__);\n\t    function TakeWithTimeObservable(source, d, s) {\n\t      this.source = source;\n\t      this._d = d;\n\t      this._s = s;\n\t      __super__.call(this);\n\t    }\n\t\n\t    function scheduleMethod(s, o) {\n\t      o.onCompleted();\n\t    }\n\t\n\t    TakeWithTimeObservable.prototype.subscribeCore = function (o) {\n\t      return new BinaryDisposable(\n\t        this._s.scheduleFuture(o, this._d, scheduleMethod),\n\t        this.source.subscribe(o)\n\t      );\n\t    };\n\t\n\t    return TakeWithTimeObservable;\n\t  }(ObservableBase));\n\t\n\t  /**\n\t   *  Takes elements for the specified duration from the start of the observable source sequence, using the specified scheduler to run timers.\n\t   *\n\t   * @example\n\t   *  1 - res = source.takeWithTime(5000,  [optional scheduler]);\n\t   * @description\n\t   *  This operator accumulates a queue with a length enough to store elements received during the initial duration window.\n\t   *  As more elements are received, elements older than the specified duration are taken from the queue and produced on the\n\t   *  result sequence. This causes elements to be delayed with duration.\n\t   * @param {Number} duration Duration for taking elements from the start of the sequence.\n\t   * @param {Scheduler} scheduler Scheduler to run the timer on. If not specified, defaults to Rx.Scheduler.timeout.\n\t   * @returns {Observable} An observable sequence with the elements taken during the specified duration from the start of the source sequence.\n\t   */\n\t  observableProto.takeWithTime = function (duration, scheduler) {\n\t    isScheduler(scheduler) || (scheduler = defaultScheduler);\n\t    return new TakeWithTimeObservable(this, duration, scheduler);\n\t  };\n\t\n\t  var SkipWithTimeObservable = (function (__super__) {\n\t    inherits(SkipWithTimeObservable, __super__);\n\t    function SkipWithTimeObservable(source, d, s) {\n\t      this.source = source;\n\t      this._d = d;\n\t      this._s = s;\n\t      this._open = false;\n\t      __super__.call(this);\n\t    }\n\t\n\t    function scheduleMethod(s, self) {\n\t      self._open = true;\n\t    }\n\t\n\t    SkipWithTimeObservable.prototype.subscribeCore = function (o) {\n\t      return new BinaryDisposable(\n\t        this._s.scheduleFuture(this, this._d, scheduleMethod),\n\t        this.source.subscribe(new SkipWithTimeObserver(o, this))\n\t      );\n\t    };\n\t\n\t    return SkipWithTimeObservable;\n\t  }(ObservableBase));\n\t\n\t  var SkipWithTimeObserver = (function (__super__) {\n\t    inherits(SkipWithTimeObserver, __super__);\n\t\n\t    function SkipWithTimeObserver(o, p) {\n\t      this._o = o;\n\t      this._p = p;\n\t      __super__.call(this);\n\t    }\n\t\n\t    SkipWithTimeObserver.prototype.next = function (x) { this._p._open && this._o.onNext(x); };\n\t    SkipWithTimeObserver.prototype.error = function (e) { this._o.onError(e); };\n\t    SkipWithTimeObserver.prototype.completed = function () { this._o.onCompleted(); };\n\t\n\t    return SkipWithTimeObserver;\n\t  }(AbstractObserver));\n\t\n\t  /**\n\t   *  Skips elements for the specified duration from the start of the observable source sequence, using the specified scheduler to run timers.\n\t   * @description\n\t   *  Specifying a zero value for duration doesn't guarantee no elements will be dropped from the start of the source sequence.\n\t   *  This is a side-effect of the asynchrony introduced by the scheduler, where the action that causes callbacks from the source sequence to be forwarded\n\t   *  may not execute immediately, despite the zero due time.\n\t   *\n\t   *  Errors produced by the source sequence are always forwarded to the result sequence, even if the error occurs before the duration.\n\t   * @param {Number} duration Duration for skipping elements from the start of the sequence.\n\t   * @param {Scheduler} scheduler Scheduler to run the timer on. If not specified, defaults to Rx.Scheduler.timeout.\n\t   * @returns {Observable} An observable sequence with the elements skipped during the specified duration from the start of the source sequence.\n\t   */\n\t  observableProto.skipWithTime = function (duration, scheduler) {\n\t    isScheduler(scheduler) || (scheduler = defaultScheduler);\n\t    return new SkipWithTimeObservable(this, duration, scheduler);\n\t  };\n\t\n\t  var SkipUntilWithTimeObservable = (function (__super__) {\n\t    inherits(SkipUntilWithTimeObservable, __super__);\n\t    function SkipUntilWithTimeObservable(source, startTime, scheduler) {\n\t      this.source = source;\n\t      this._st = startTime;\n\t      this._s = scheduler;\n\t      __super__.call(this);\n\t    }\n\t\n\t    function scheduleMethod(s, state) {\n\t      state._open = true;\n\t    }\n\t\n\t    SkipUntilWithTimeObservable.prototype.subscribeCore = function (o) {\n\t      this._open = false;\n\t      return new BinaryDisposable(\n\t        this._s.scheduleFuture(this, this._st, scheduleMethod),\n\t        this.source.subscribe(new SkipUntilWithTimeObserver(o, this))\n\t      );\n\t    };\n\t\n\t    return SkipUntilWithTimeObservable;\n\t  }(ObservableBase));\n\t\n\t  var SkipUntilWithTimeObserver = (function (__super__) {\n\t    inherits(SkipUntilWithTimeObserver, __super__);\n\t\n\t    function SkipUntilWithTimeObserver(o, p) {\n\t      this._o = o;\n\t      this._p = p;\n\t      __super__.call(this);\n\t    }\n\t\n\t    SkipUntilWithTimeObserver.prototype.next = function (x) { this._p._open && this._o.onNext(x); };\n\t    SkipUntilWithTimeObserver.prototype.error = function (e) { this._o.onError(e); };\n\t    SkipUntilWithTimeObserver.prototype.completed = function () { this._o.onCompleted(); };\n\t\n\t    return SkipUntilWithTimeObserver;\n\t  }(AbstractObserver));\n\t\n\t\n\t  /**\n\t   *  Skips elements from the observable source sequence until the specified start time, using the specified scheduler to run timers.\n\t   *  Errors produced by the source sequence are always forwarded to the result sequence, even if the error occurs before the start time.\n\t   *\n\t   * @examples\n\t   *  1 - res = source.skipUntilWithTime(new Date(), [scheduler]);\n\t   *  2 - res = source.skipUntilWithTime(5000, [scheduler]);\n\t   * @param {Date|Number} startTime Time to start taking elements from the source sequence. If this value is less than or equal to Date(), no elements will be skipped.\n\t   * @param {Scheduler} [scheduler] Scheduler to run the timer on. If not specified, defaults to Rx.Scheduler.timeout.\n\t   * @returns {Observable} An observable sequence with the elements skipped until the specified start time.\n\t   */\n\t  observableProto.skipUntilWithTime = function (startTime, scheduler) {\n\t    isScheduler(scheduler) || (scheduler = defaultScheduler);\n\t    return new SkipUntilWithTimeObservable(this, startTime, scheduler);\n\t  };\n\t\n\t  /**\n\t   *  Takes elements for the specified duration until the specified end time, using the specified scheduler to run timers.\n\t   * @param {Number | Date} endTime Time to stop taking elements from the source sequence. If this value is less than or equal to new Date(), the result stream will complete immediately.\n\t   * @param {Scheduler} [scheduler] Scheduler to run the timer on.\n\t   * @returns {Observable} An observable sequence with the elements taken until the specified end time.\n\t   */\n\t  observableProto.takeUntilWithTime = function (endTime, scheduler) {\n\t    isScheduler(scheduler) || (scheduler = defaultScheduler);\n\t    var source = this;\n\t    return new AnonymousObservable(function (o) {\n\t      return new BinaryDisposable(\n\t        scheduler.scheduleFuture(o, endTime, function (_, o) { o.onCompleted(); }),\n\t        source.subscribe(o));\n\t    }, source);\n\t  };\n\t\n\t  /**\n\t   * Returns an Observable that emits only the first item emitted by the source Observable during sequential time windows of a specified duration.\n\t   * @param {Number} windowDuration time to wait before emitting another item after emitting the last item\n\t   * @param {Scheduler} [scheduler] the Scheduler to use internally to manage the timers that handle timeout for each item. If not provided, defaults to Scheduler.timeout.\n\t   * @returns {Observable} An Observable that performs the throttle operation.\n\t   */\n\t  observableProto.throttle = function (windowDuration, scheduler) {\n\t    isScheduler(scheduler) || (scheduler = defaultScheduler);\n\t    var duration = +windowDuration || 0;\n\t    if (duration <= 0) { throw new RangeError('windowDuration cannot be less or equal zero.'); }\n\t    var source = this;\n\t    return new AnonymousObservable(function (o) {\n\t      var lastOnNext = 0;\n\t      return source.subscribe(\n\t        function (x) {\n\t          var now = scheduler.now();\n\t          if (lastOnNext === 0 || now - lastOnNext >= duration) {\n\t            lastOnNext = now;\n\t            o.onNext(x);\n\t          }\n\t        },function (e) { o.onError(e); }, function () { o.onCompleted(); }\n\t      );\n\t    }, source);\n\t  };\n\t\n\t  var TransduceObserver = (function (__super__) {\n\t    inherits(TransduceObserver, __super__);\n\t    function TransduceObserver(o, xform) {\n\t      this._o = o;\n\t      this._xform = xform;\n\t      __super__.call(this);\n\t    }\n\t\n\t    TransduceObserver.prototype.next = function (x) {\n\t      var res = tryCatch(this._xform['@@transducer/step']).call(this._xform, this._o, x);\n\t      if (res === errorObj) { this._o.onError(res.e); }\n\t    };\n\t\n\t    TransduceObserver.prototype.error = function (e) { this._o.onError(e); };\n\t\n\t    TransduceObserver.prototype.completed = function () {\n\t      this._xform['@@transducer/result'](this._o);\n\t    };\n\t\n\t    return TransduceObserver;\n\t  }(AbstractObserver));\n\t\n\t  function transformForObserver(o) {\n\t    return {\n\t      '@@transducer/init': function() {\n\t        return o;\n\t      },\n\t      '@@transducer/step': function(obs, input) {\n\t        return obs.onNext(input);\n\t      },\n\t      '@@transducer/result': function(obs) {\n\t        return obs.onCompleted();\n\t      }\n\t    };\n\t  }\n\t\n\t  /**\n\t   * Executes a transducer to transform the observable sequence\n\t   * @param {Transducer} transducer A transducer to execute\n\t   * @returns {Observable} An Observable sequence containing the results from the transducer.\n\t   */\n\t  observableProto.transduce = function(transducer) {\n\t    var source = this;\n\t    return new AnonymousObservable(function(o) {\n\t      var xform = transducer(transformForObserver(o));\n\t      return source.subscribe(new TransduceObserver(o, xform));\n\t    }, source);\n\t  };\n\t\n\t  var SwitchFirstObservable = (function (__super__) {\n\t    inherits(SwitchFirstObservable, __super__);\n\t    function SwitchFirstObservable(source) {\n\t      this.source = source;\n\t      __super__.call(this);\n\t    }\n\t\n\t    SwitchFirstObservable.prototype.subscribeCore = function (o) {\n\t      var m = new SingleAssignmentDisposable(),\n\t        g = new CompositeDisposable(),\n\t        state = {\n\t          hasCurrent: false,\n\t          isStopped: false,\n\t          o: o,\n\t          g: g\n\t        };\n\t\n\t      g.add(m);\n\t      m.setDisposable(this.source.subscribe(new SwitchFirstObserver(state)));\n\t      return g;\n\t    };\n\t\n\t    return SwitchFirstObservable;\n\t  }(ObservableBase));\n\t\n\t  var SwitchFirstObserver = (function(__super__) {\n\t    inherits(SwitchFirstObserver, __super__);\n\t    function SwitchFirstObserver(state) {\n\t      this._s = state;\n\t      __super__.call(this);\n\t    }\n\t\n\t    SwitchFirstObserver.prototype.next = function (x) {\n\t      if (!this._s.hasCurrent) {\n\t        this._s.hasCurrent = true;\n\t        isPromise(x) && (x = observableFromPromise(x));\n\t        var inner = new SingleAssignmentDisposable();\n\t        this._s.g.add(inner);\n\t        inner.setDisposable(x.subscribe(new InnerObserver(this._s, inner)));\n\t      }\n\t    };\n\t\n\t    SwitchFirstObserver.prototype.error = function (e) {\n\t      this._s.o.onError(e);\n\t    };\n\t\n\t    SwitchFirstObserver.prototype.completed = function () {\n\t      this._s.isStopped = true;\n\t      !this._s.hasCurrent && this._s.g.length === 1 && this._s.o.onCompleted();\n\t    };\n\t\n\t    inherits(InnerObserver, __super__);\n\t    function InnerObserver(state, inner) {\n\t      this._s = state;\n\t      this._i = inner;\n\t      __super__.call(this);\n\t    }\n\t\n\t    InnerObserver.prototype.next = function (x) { this._s.o.onNext(x); };\n\t    InnerObserver.prototype.error = function (e) { this._s.o.onError(e); };\n\t    InnerObserver.prototype.completed = function () {\n\t      this._s.g.remove(this._i);\n\t      this._s.hasCurrent = false;\n\t      this._s.isStopped && this._s.g.length === 1 && this._s.o.onCompleted();\n\t    };\n\t\n\t    return SwitchFirstObserver;\n\t  }(AbstractObserver));\n\t\n\t  /**\n\t   * Performs a exclusive waiting for the first to finish before subscribing to another observable.\n\t   * Observables that come in between subscriptions will be dropped on the floor.\n\t   * @returns {Observable} A exclusive observable with only the results that happen when subscribed.\n\t   */\n\t  observableProto.switchFirst = function () {\n\t    return new SwitchFirstObservable(this);\n\t  };\n\t\n\tobservableProto.flatMapFirst = observableProto.selectManyFirst = function(selector, resultSelector, thisArg) {\n\t    return new FlatMapObservable(this, selector, resultSelector, thisArg).switchFirst();\n\t};\n\t\n\tRx.Observable.prototype.flatMapWithMaxConcurrent = function(limit, selector, resultSelector, thisArg) {\n\t    return new FlatMapObservable(this, selector, resultSelector, thisArg).merge(limit);\n\t};\n\t  /** Provides a set of extension methods for virtual time scheduling. */\n\t  var VirtualTimeScheduler = Rx.VirtualTimeScheduler = (function (__super__) {\n\t    inherits(VirtualTimeScheduler, __super__);\n\t\n\t    /**\n\t     * Creates a new virtual time scheduler with the specified initial clock value and absolute time comparer.\n\t     *\n\t     * @constructor\n\t     * @param {Number} initialClock Initial value for the clock.\n\t     * @param {Function} comparer Comparer to determine causality of events based on absolute time.\n\t     */\n\t    function VirtualTimeScheduler(initialClock, comparer) {\n\t      this.clock = initialClock;\n\t      this.comparer = comparer;\n\t      this.isEnabled = false;\n\t      this.queue = new PriorityQueue(1024);\n\t      __super__.call(this);\n\t    }\n\t\n\t    var VirtualTimeSchedulerPrototype = VirtualTimeScheduler.prototype;\n\t\n\t    VirtualTimeSchedulerPrototype.now = function () {\n\t      return this.toAbsoluteTime(this.clock);\n\t    };\n\t\n\t    VirtualTimeSchedulerPrototype.schedule = function (state, action) {\n\t      return this.scheduleAbsolute(state, this.clock, action);\n\t    };\n\t\n\t    VirtualTimeSchedulerPrototype.scheduleFuture = function (state, dueTime, action) {\n\t      var dt = dueTime instanceof Date ?\n\t        this.toRelativeTime(dueTime - this.now()) :\n\t        this.toRelativeTime(dueTime);\n\t\n\t      return this.scheduleRelative(state, dt, action);\n\t    };\n\t\n\t    /**\n\t     * Adds a relative time value to an absolute time value.\n\t     * @param {Number} absolute Absolute virtual time value.\n\t     * @param {Number} relative Relative virtual time value to add.\n\t     * @return {Number} Resulting absolute virtual time sum value.\n\t     */\n\t    VirtualTimeSchedulerPrototype.add = notImplemented;\n\t\n\t    /**\n\t     * Converts an absolute time to a number\n\t     * @param {Any} The absolute time.\n\t     * @returns {Number} The absolute time in ms\n\t     */\n\t    VirtualTimeSchedulerPrototype.toAbsoluteTime = notImplemented;\n\t\n\t    /**\n\t     * Converts the TimeSpan value to a relative virtual time value.\n\t     * @param {Number} timeSpan TimeSpan value to convert.\n\t     * @return {Number} Corresponding relative virtual time value.\n\t     */\n\t    VirtualTimeSchedulerPrototype.toRelativeTime = notImplemented;\n\t\n\t    /**\n\t     * Schedules a periodic piece of work by dynamically discovering the scheduler's capabilities. The periodic task will be emulated using recursive scheduling.\n\t     * @param {Mixed} state Initial state passed to the action upon the first iteration.\n\t     * @param {Number} period Period for running the work periodically.\n\t     * @param {Function} action Action to be executed, potentially updating the state.\n\t     * @returns {Disposable} The disposable object used to cancel the scheduled recurring action (best effort).\n\t     */\n\t    VirtualTimeSchedulerPrototype.schedulePeriodic = function (state, period, action) {\n\t      var s = new SchedulePeriodicRecursive(this, state, period, action);\n\t      return s.start();\n\t    };\n\t\n\t    /**\n\t     * Schedules an action to be executed after dueTime.\n\t     * @param {Mixed} state State passed to the action to be executed.\n\t     * @param {Number} dueTime Relative time after which to execute the action.\n\t     * @param {Function} action Action to be executed.\n\t     * @returns {Disposable} The disposable object used to cancel the scheduled action (best effort).\n\t     */\n\t    VirtualTimeSchedulerPrototype.scheduleRelative = function (state, dueTime, action) {\n\t      var runAt = this.add(this.clock, dueTime);\n\t      return this.scheduleAbsolute(state, runAt, action);\n\t    };\n\t\n\t    /**\n\t     * Starts the virtual time scheduler.\n\t     */\n\t    VirtualTimeSchedulerPrototype.start = function () {\n\t      if (!this.isEnabled) {\n\t        this.isEnabled = true;\n\t        do {\n\t          var next = this.getNext();\n\t          if (next !== null) {\n\t            this.comparer(next.dueTime, this.clock) > 0 && (this.clock = next.dueTime);\n\t            next.invoke();\n\t          } else {\n\t            this.isEnabled = false;\n\t          }\n\t        } while (this.isEnabled);\n\t      }\n\t    };\n\t\n\t    /**\n\t     * Stops the virtual time scheduler.\n\t     */\n\t    VirtualTimeSchedulerPrototype.stop = function () {\n\t      this.isEnabled = false;\n\t    };\n\t\n\t    /**\n\t     * Advances the scheduler's clock to the specified time, running all work till that point.\n\t     * @param {Number} time Absolute time to advance the scheduler's clock to.\n\t     */\n\t    VirtualTimeSchedulerPrototype.advanceTo = function (time) {\n\t      var dueToClock = this.comparer(this.clock, time);\n\t      if (this.comparer(this.clock, time) > 0) { throw new ArgumentOutOfRangeError(); }\n\t      if (dueToClock === 0) { return; }\n\t      if (!this.isEnabled) {\n\t        this.isEnabled = true;\n\t        do {\n\t          var next = this.getNext();\n\t          if (next !== null && this.comparer(next.dueTime, time) <= 0) {\n\t            this.comparer(next.dueTime, this.clock) > 0 && (this.clock = next.dueTime);\n\t            next.invoke();\n\t          } else {\n\t            this.isEnabled = false;\n\t          }\n\t        } while (this.isEnabled);\n\t        this.clock = time;\n\t      }\n\t    };\n\t\n\t    /**\n\t     * Advances the scheduler's clock by the specified relative time, running all work scheduled for that timespan.\n\t     * @param {Number} time Relative time to advance the scheduler's clock by.\n\t     */\n\t    VirtualTimeSchedulerPrototype.advanceBy = function (time) {\n\t      var dt = this.add(this.clock, time),\n\t          dueToClock = this.comparer(this.clock, dt);\n\t      if (dueToClock > 0) { throw new ArgumentOutOfRangeError(); }\n\t      if (dueToClock === 0) {  return; }\n\t\n\t      this.advanceTo(dt);\n\t    };\n\t\n\t    /**\n\t     * Advances the scheduler's clock by the specified relative time.\n\t     * @param {Number} time Relative time to advance the scheduler's clock by.\n\t     */\n\t    VirtualTimeSchedulerPrototype.sleep = function (time) {\n\t      var dt = this.add(this.clock, time);\n\t      if (this.comparer(this.clock, dt) >= 0) { throw new ArgumentOutOfRangeError(); }\n\t\n\t      this.clock = dt;\n\t    };\n\t\n\t    /**\n\t     * Gets the next scheduled item to be executed.\n\t     * @returns {ScheduledItem} The next scheduled item.\n\t     */\n\t    VirtualTimeSchedulerPrototype.getNext = function () {\n\t      while (this.queue.length > 0) {\n\t        var next = this.queue.peek();\n\t        if (next.isCancelled()) {\n\t          this.queue.dequeue();\n\t        } else {\n\t          return next;\n\t        }\n\t      }\n\t      return null;\n\t    };\n\t\n\t    /**\n\t     * Schedules an action to be executed at dueTime.\n\t     * @param {Mixed} state State passed to the action to be executed.\n\t     * @param {Number} dueTime Absolute time at which to execute the action.\n\t     * @param {Function} action Action to be executed.\n\t     * @returns {Disposable} The disposable object used to cancel the scheduled action (best effort).\n\t     */\n\t    VirtualTimeSchedulerPrototype.scheduleAbsolute = function (state, dueTime, action) {\n\t      var self = this;\n\t\n\t      function run(scheduler, state1) {\n\t        self.queue.remove(si);\n\t        return action(scheduler, state1);\n\t      }\n\t\n\t      var si = new ScheduledItem(this, state, run, dueTime, this.comparer);\n\t      this.queue.enqueue(si);\n\t\n\t      return si.disposable;\n\t    };\n\t\n\t    return VirtualTimeScheduler;\n\t  }(Scheduler));\n\t\n\t  /** Provides a virtual time scheduler that uses Date for absolute time and number for relative time. */\n\t  Rx.HistoricalScheduler = (function (__super__) {\n\t    inherits(HistoricalScheduler, __super__);\n\t\n\t    /**\n\t     * Creates a new historical scheduler with the specified initial clock value.\n\t     * @constructor\n\t     * @param {Number} initialClock Initial value for the clock.\n\t     * @param {Function} comparer Comparer to determine causality of events based on absolute time.\n\t     */\n\t    function HistoricalScheduler(initialClock, comparer) {\n\t      var clock = initialClock == null ? 0 : initialClock;\n\t      var cmp = comparer || defaultSubComparer;\n\t      __super__.call(this, clock, cmp);\n\t    }\n\t\n\t    var HistoricalSchedulerProto = HistoricalScheduler.prototype;\n\t\n\t    /**\n\t     * Adds a relative time value to an absolute time value.\n\t     * @param {Number} absolute Absolute virtual time value.\n\t     * @param {Number} relative Relative virtual time value to add.\n\t     * @return {Number} Resulting absolute virtual time sum value.\n\t     */\n\t    HistoricalSchedulerProto.add = function (absolute, relative) {\n\t      return absolute + relative;\n\t    };\n\t\n\t    HistoricalSchedulerProto.toAbsoluteTime = function (absolute) {\n\t      return new Date(absolute).getTime();\n\t    };\n\t\n\t    /**\n\t     * Converts the TimeSpan value to a relative virtual time value.\n\t     * @memberOf HistoricalScheduler\n\t     * @param {Number} timeSpan TimeSpan value to convert.\n\t     * @return {Number} Corresponding relative virtual time value.\n\t     */\n\t    HistoricalSchedulerProto.toRelativeTime = function (timeSpan) {\n\t      return timeSpan;\n\t    };\n\t\n\t    return HistoricalScheduler;\n\t  }(Rx.VirtualTimeScheduler));\n\t\n\tfunction OnNextPredicate(predicate) {\n\t    this.predicate = predicate;\n\t}\n\t\n\tOnNextPredicate.prototype.equals = function (other) {\n\t  if (other === this) { return true; }\n\t  if (other == null) { return false; }\n\t  if (other.kind !== 'N') { return false; }\n\t  return this.predicate(other.value);\n\t};\n\t\n\tfunction OnErrorPredicate(predicate) {\n\t  this.predicate = predicate;\n\t}\n\t\n\tOnErrorPredicate.prototype.equals = function (other) {\n\t  if (other === this) { return true; }\n\t  if (other == null) { return false; }\n\t  if (other.kind !== 'E') { return false; }\n\t  return this.predicate(other.error);\n\t};\n\t\n\tvar ReactiveTest = Rx.ReactiveTest = {\n\t  /** Default virtual time used for creation of observable sequences in unit tests. */\n\t  created: 100,\n\t  /** Default virtual time used to subscribe to observable sequences in unit tests. */\n\t  subscribed: 200,\n\t  /** Default virtual time used to dispose subscriptions in unit tests. */\n\t  disposed: 1000,\n\t\n\t  /**\n\t   * Factory method for an OnNext notification record at a given time with a given value or a predicate function.\n\t   *\n\t   * 1 - ReactiveTest.onNext(200, 42);\n\t   * 2 - ReactiveTest.onNext(200, function (x) { return x.length == 2; });\n\t   *\n\t   * @param ticks Recorded virtual time the OnNext notification occurs.\n\t   * @param value Recorded value stored in the OnNext notification or a predicate.\n\t   * @return Recorded OnNext notification.\n\t   */\n\t  onNext: function (ticks, value) {\n\t    return typeof value === 'function' ?\n\t      new Recorded(ticks, new OnNextPredicate(value)) :\n\t      new Recorded(ticks, Notification.createOnNext(value));\n\t  },\n\t  /**\n\t   * Factory method for an OnError notification record at a given time with a given error.\n\t   *\n\t   * 1 - ReactiveTest.onNext(200, new Error('error'));\n\t   * 2 - ReactiveTest.onNext(200, function (e) { return e.message === 'error'; });\n\t   *\n\t   * @param ticks Recorded virtual time the OnError notification occurs.\n\t   * @param exception Recorded exception stored in the OnError notification.\n\t   * @return Recorded OnError notification.\n\t   */\n\t  onError: function (ticks, error) {\n\t    return typeof error === 'function' ?\n\t      new Recorded(ticks, new OnErrorPredicate(error)) :\n\t      new Recorded(ticks, Notification.createOnError(error));\n\t  },\n\t  /**\n\t   * Factory method for an OnCompleted notification record at a given time.\n\t   *\n\t   * @param ticks Recorded virtual time the OnCompleted notification occurs.\n\t   * @return Recorded OnCompleted notification.\n\t   */\n\t  onCompleted: function (ticks) {\n\t    return new Recorded(ticks, Notification.createOnCompleted());\n\t  },\n\t  /**\n\t   * Factory method for a subscription record based on a given subscription and disposal time.\n\t   *\n\t   * @param start Virtual time indicating when the subscription was created.\n\t   * @param end Virtual time indicating when the subscription was disposed.\n\t   * @return Subscription object.\n\t   */\n\t  subscribe: function (start, end) {\n\t    return new Subscription(start, end);\n\t  }\n\t};\n\t\n\t  /**\n\t   * Creates a new object recording the production of the specified value at the given virtual time.\n\t   *\n\t   * @constructor\n\t   * @param {Number} time Virtual time the value was produced on.\n\t   * @param {Mixed} value Value that was produced.\n\t   * @param {Function} comparer An optional comparer.\n\t   */\n\t  var Recorded = Rx.Recorded = function (time, value, comparer) {\n\t    this.time = time;\n\t    this.value = value;\n\t    this.comparer = comparer || defaultComparer;\n\t  };\n\t\n\t  /**\n\t   * Checks whether the given recorded object is equal to the current instance.\n\t   *\n\t   * @param {Recorded} other Recorded object to check for equality.\n\t   * @returns {Boolean} true if both objects are equal; false otherwise.\n\t   */\n\t  Recorded.prototype.equals = function (other) {\n\t    return this.time === other.time && this.comparer(this.value, other.value);\n\t  };\n\t\n\t  /**\n\t   * Returns a string representation of the current Recorded value.\n\t   *\n\t   * @returns {String} String representation of the current Recorded value.\n\t   */\n\t  Recorded.prototype.toString = function () {\n\t    return this.value.toString() + '@' + this.time;\n\t  };\n\t\n\t  /**\n\t   * Creates a new subscription object with the given virtual subscription and unsubscription time.\n\t   *\n\t   * @constructor\n\t   * @param {Number} subscribe Virtual time at which the subscription occurred.\n\t   * @param {Number} unsubscribe Virtual time at which the unsubscription occurred.\n\t   */\n\t  var Subscription = Rx.Subscription = function (start, end) {\n\t    this.subscribe = start;\n\t    this.unsubscribe = end || Number.MAX_VALUE;\n\t  };\n\t\n\t  /**\n\t   * Checks whether the given subscription is equal to the current instance.\n\t   * @param other Subscription object to check for equality.\n\t   * @returns {Boolean} true if both objects are equal; false otherwise.\n\t   */\n\t  Subscription.prototype.equals = function (other) {\n\t    return this.subscribe === other.subscribe && this.unsubscribe === other.unsubscribe;\n\t  };\n\t\n\t  /**\n\t   * Returns a string representation of the current Subscription value.\n\t   * @returns {String} String representation of the current Subscription value.\n\t   */\n\t  Subscription.prototype.toString = function () {\n\t    return '(' + this.subscribe + ', ' + (this.unsubscribe === Number.MAX_VALUE ? 'Infinite' : this.unsubscribe) + ')';\n\t  };\n\t\n\t  var MockDisposable = Rx.MockDisposable = function (scheduler) {\n\t    this.scheduler = scheduler;\n\t    this.disposes = [];\n\t    this.disposes.push(this.scheduler.clock);\n\t  };\n\t\n\t  MockDisposable.prototype.dispose = function () {\n\t    this.disposes.push(this.scheduler.clock);\n\t  };\n\t\n\t  var MockObserver = (function (__super__) {\n\t    inherits(MockObserver, __super__);\n\t\n\t    function MockObserver(scheduler) {\n\t      __super__.call(this);\n\t      this.scheduler = scheduler;\n\t      this.messages = [];\n\t    }\n\t\n\t    var MockObserverPrototype = MockObserver.prototype;\n\t\n\t    MockObserverPrototype.onNext = function (value) {\n\t      this.messages.push(new Recorded(this.scheduler.clock, Notification.createOnNext(value)));\n\t    };\n\t\n\t    MockObserverPrototype.onError = function (e) {\n\t      this.messages.push(new Recorded(this.scheduler.clock, Notification.createOnError(e)));\n\t    };\n\t\n\t    MockObserverPrototype.onCompleted = function () {\n\t      this.messages.push(new Recorded(this.scheduler.clock, Notification.createOnCompleted()));\n\t    };\n\t\n\t    return MockObserver;\n\t  })(Observer);\n\t\n\t  function MockPromise(scheduler, messages) {\n\t    var self = this;\n\t    this.scheduler = scheduler;\n\t    this.messages = messages;\n\t    this.subscriptions = [];\n\t    this.observers = [];\n\t    for (var i = 0, len = this.messages.length; i < len; i++) {\n\t      var message = this.messages[i],\n\t          notification = message.value;\n\t      (function (innerNotification) {\n\t        scheduler.scheduleAbsolute(null, message.time, function () {\n\t          var obs = self.observers.slice(0);\n\t\n\t          for (var j = 0, jLen = obs.length; j < jLen; j++) {\n\t            innerNotification.accept(obs[j]);\n\t          }\n\t          return disposableEmpty;\n\t        });\n\t      })(notification);\n\t    }\n\t  }\n\t\n\t  MockPromise.prototype.then = function (onResolved, onRejected) {\n\t    var self = this;\n\t\n\t    this.subscriptions.push(new Subscription(this.scheduler.clock));\n\t    var index = this.subscriptions.length - 1;\n\t\n\t    var newPromise;\n\t\n\t    var observer = Rx.Observer.create(\n\t      function (x) {\n\t        var retValue = onResolved(x);\n\t        if (retValue && typeof retValue.then === 'function') {\n\t          newPromise = retValue;\n\t        } else {\n\t          var ticks = self.scheduler.clock;\n\t          newPromise = new MockPromise(self.scheduler, [Rx.ReactiveTest.onNext(ticks, undefined), Rx.ReactiveTest.onCompleted(ticks)]);\n\t        }\n\t        var idx = self.observers.indexOf(observer);\n\t        self.observers.splice(idx, 1);\n\t        self.subscriptions[index] = new Subscription(self.subscriptions[index].subscribe, self.scheduler.clock);\n\t      },\n\t      function (err) {\n\t        onRejected(err);\n\t        var idx = self.observers.indexOf(observer);\n\t        self.observers.splice(idx, 1);\n\t        self.subscriptions[index] = new Subscription(self.subscriptions[index].subscribe, self.scheduler.clock);\n\t      }\n\t    );\n\t    this.observers.push(observer);\n\t\n\t    return newPromise || new MockPromise(this.scheduler, this.messages);\n\t  };\n\t\n\t  var HotObservable = (function (__super__) {\n\t    inherits(HotObservable, __super__);\n\t\n\t    function HotObservable(scheduler, messages) {\n\t      __super__.call(this);\n\t      var message, notification, observable = this;\n\t      this.scheduler = scheduler;\n\t      this.messages = messages;\n\t      this.subscriptions = [];\n\t      this.observers = [];\n\t      for (var i = 0, len = this.messages.length; i < len; i++) {\n\t        message = this.messages[i];\n\t        notification = message.value;\n\t        (function (innerNotification) {\n\t          scheduler.scheduleAbsolute(null, message.time, function () {\n\t            var obs = observable.observers.slice(0);\n\t\n\t            for (var j = 0, jLen = obs.length; j < jLen; j++) {\n\t              innerNotification.accept(obs[j]);\n\t            }\n\t            return disposableEmpty;\n\t          });\n\t        })(notification);\n\t      }\n\t    }\n\t\n\t    HotObservable.prototype._subscribe = function (o) {\n\t      var observable = this;\n\t      this.observers.push(o);\n\t      this.subscriptions.push(new Subscription(this.scheduler.clock));\n\t      var index = this.subscriptions.length - 1;\n\t      return disposableCreate(function () {\n\t        var idx = observable.observers.indexOf(o);\n\t        observable.observers.splice(idx, 1);\n\t        observable.subscriptions[index] = new Subscription(observable.subscriptions[index].subscribe, observable.scheduler.clock);\n\t      });\n\t    };\n\t\n\t    return HotObservable;\n\t  })(Observable);\n\t\n\t  var ColdObservable = (function (__super__) {\n\t    inherits(ColdObservable, __super__);\n\t\n\t    function ColdObservable(scheduler, messages) {\n\t      __super__.call(this);\n\t      this.scheduler = scheduler;\n\t      this.messages = messages;\n\t      this.subscriptions = [];\n\t    }\n\t\n\t    ColdObservable.prototype._subscribe = function (o) {\n\t      var message, notification, observable = this;\n\t      this.subscriptions.push(new Subscription(this.scheduler.clock));\n\t      var index = this.subscriptions.length - 1;\n\t      var d = new CompositeDisposable();\n\t      for (var i = 0, len = this.messages.length; i < len; i++) {\n\t        message = this.messages[i];\n\t        notification = message.value;\n\t        (function (innerNotification) {\n\t          d.add(observable.scheduler.scheduleRelative(null, message.time, function () {\n\t            innerNotification.accept(o);\n\t            return disposableEmpty;\n\t          }));\n\t        })(notification);\n\t      }\n\t      return disposableCreate(function () {\n\t        observable.subscriptions[index] = new Subscription(observable.subscriptions[index].subscribe, observable.scheduler.clock);\n\t        d.dispose();\n\t      });\n\t    };\n\t\n\t    return ColdObservable;\n\t  })(Observable);\n\t\n\t  /** Virtual time scheduler used for testing applications and libraries built using Reactive Extensions. */\n\t  Rx.TestScheduler = (function (__super__) {\n\t    inherits(TestScheduler, __super__);\n\t\n\t    function baseComparer(x, y) {\n\t      return x > y ? 1 : (x < y ? -1 : 0);\n\t    }\n\t\n\t    function TestScheduler() {\n\t      __super__.call(this, 0, baseComparer);\n\t    }\n\t\n\t    /**\n\t     * Schedules an action to be executed at the specified virtual time.\n\t     *\n\t     * @param state State passed to the action to be executed.\n\t     * @param dueTime Absolute virtual time at which to execute the action.\n\t     * @param action Action to be executed.\n\t     * @return Disposable object used to cancel the scheduled action (best effort).\n\t     */\n\t    TestScheduler.prototype.scheduleAbsolute = function (state, dueTime, action) {\n\t      dueTime <= this.clock && (dueTime = this.clock + 1);\n\t      return __super__.prototype.scheduleAbsolute.call(this, state, dueTime, action);\n\t    };\n\t    /**\n\t     * Adds a relative virtual time to an absolute virtual time value.\n\t     *\n\t     * @param absolute Absolute virtual time value.\n\t     * @param relative Relative virtual time value to add.\n\t     * @return Resulting absolute virtual time sum value.\n\t     */\n\t    TestScheduler.prototype.add = function (absolute, relative) {\n\t      return absolute + relative;\n\t    };\n\t    /**\n\t     * Converts the absolute virtual time value to a DateTimeOffset value.\n\t     *\n\t     * @param absolute Absolute virtual time value to convert.\n\t     * @return Corresponding DateTimeOffset value.\n\t     */\n\t    TestScheduler.prototype.toAbsoluteTime = function (absolute) {\n\t      return new Date(absolute).getTime();\n\t    };\n\t    /**\n\t     * Converts the TimeSpan value to a relative virtual time value.\n\t     *\n\t     * @param timeSpan TimeSpan value to convert.\n\t     * @return Corresponding relative virtual time value.\n\t     */\n\t    TestScheduler.prototype.toRelativeTime = function (timeSpan) {\n\t      return timeSpan;\n\t    };\n\t    /**\n\t     * Starts the test scheduler and uses the specified virtual times to invoke the factory function, subscribe to the resulting sequence, and dispose the subscription.\n\t     *\n\t     * @param create Factory method to create an observable sequence.\n\t     * @param created Virtual time at which to invoke the factory to create an observable sequence.\n\t     * @param subscribed Virtual time at which to subscribe to the created observable sequence.\n\t     * @param disposed Virtual time at which to dispose the subscription.\n\t     * @return Observer with timestamped recordings of notification messages that were received during the virtual time window when the subscription to the source sequence was active.\n\t     */\n\t    TestScheduler.prototype.startScheduler = function (createFn, settings) {\n\t      settings || (settings = {});\n\t      settings.created == null && (settings.created = ReactiveTest.created);\n\t      settings.subscribed == null && (settings.subscribed = ReactiveTest.subscribed);\n\t      settings.disposed == null && (settings.disposed = ReactiveTest.disposed);\n\t\n\t      var observer = this.createObserver(), source, subscription;\n\t\n\t      this.scheduleAbsolute(null, settings.created, function () {\n\t        source = createFn();\n\t        return disposableEmpty;\n\t      });\n\t\n\t      this.scheduleAbsolute(null, settings.subscribed, function () {\n\t        subscription = source.subscribe(observer);\n\t        return disposableEmpty;\n\t      });\n\t\n\t      this.scheduleAbsolute(null, settings.disposed, function () {\n\t        subscription.dispose();\n\t        return disposableEmpty;\n\t      });\n\t\n\t      this.start();\n\t\n\t      return observer;\n\t    };\n\t\n\t    /**\n\t     * Creates a hot observable using the specified timestamped notification messages either as an array or arguments.\n\t     * @param messages Notifications to surface through the created sequence at their specified absolute virtual times.\n\t     * @return Hot observable sequence that can be used to assert the timing of subscriptions and notifications.\n\t     */\n\t    TestScheduler.prototype.createHotObservable = function () {\n\t      var len = arguments.length, args;\n\t      if (Array.isArray(arguments[0])) {\n\t        args = arguments[0];\n\t      } else {\n\t        args = new Array(len);\n\t        for (var i = 0; i < len; i++) { args[i] = arguments[i]; }\n\t      }\n\t      return new HotObservable(this, args);\n\t    };\n\t\n\t    /**\n\t     * Creates a cold observable using the specified timestamped notification messages either as an array or arguments.\n\t     * @param messages Notifications to surface through the created sequence at their specified virtual time offsets from the sequence subscription time.\n\t     * @return Cold observable sequence that can be used to assert the timing of subscriptions and notifications.\n\t     */\n\t    TestScheduler.prototype.createColdObservable = function () {\n\t      var len = arguments.length, args;\n\t      if (Array.isArray(arguments[0])) {\n\t        args = arguments[0];\n\t      } else {\n\t        args = new Array(len);\n\t        for (var i = 0; i < len; i++) { args[i] = arguments[i]; }\n\t      }\n\t      return new ColdObservable(this, args);\n\t    };\n\t\n\t    /**\n\t     * Creates a resolved promise with the given value and ticks\n\t     * @param {Number} ticks The absolute time of the resolution.\n\t     * @param {Any} value The value to yield at the given tick.\n\t     * @returns {MockPromise} A mock Promise which fulfills with the given value.\n\t     */\n\t    TestScheduler.prototype.createResolvedPromise = function (ticks, value) {\n\t      return new MockPromise(this, [Rx.ReactiveTest.onNext(ticks, value), Rx.ReactiveTest.onCompleted(ticks)]);\n\t    };\n\t\n\t    /**\n\t     * Creates a rejected promise with the given reason and ticks\n\t     * @param {Number} ticks The absolute time of the resolution.\n\t     * @param {Any} reason The reason for rejection to yield at the given tick.\n\t     * @returns {MockPromise} A mock Promise which rejects with the given reason.\n\t     */\n\t    TestScheduler.prototype.createRejectedPromise = function (ticks, reason) {\n\t      return new MockPromise(this, [Rx.ReactiveTest.onError(ticks, reason)]);\n\t    };\n\t\n\t    /**\n\t     * Creates an observer that records received notification messages and timestamps those.\n\t     * @return Observer that can be used to assert the timing of received notifications.\n\t     */\n\t    TestScheduler.prototype.createObserver = function () {\n\t      return new MockObserver(this);\n\t    };\n\t\n\t    return TestScheduler;\n\t  })(VirtualTimeScheduler);\n\t\n\t  var AnonymousObservable = Rx.AnonymousObservable = (function (__super__) {\n\t    inherits(AnonymousObservable, __super__);\n\t\n\t    // Fix subscriber to check for undefined or function returned to decorate as Disposable\n\t    function fixSubscriber(subscriber) {\n\t      return subscriber && isFunction(subscriber.dispose) ? subscriber :\n\t        isFunction(subscriber) ? disposableCreate(subscriber) : disposableEmpty;\n\t    }\n\t\n\t    function setDisposable(s, state) {\n\t      var ado = state[0], self = state[1];\n\t      var sub = tryCatch(self.__subscribe).call(self, ado);\n\t      if (sub === errorObj && !ado.fail(errorObj.e)) { thrower(errorObj.e); }\n\t      ado.setDisposable(fixSubscriber(sub));\n\t    }\n\t\n\t    function AnonymousObservable(subscribe, parent) {\n\t      this.source = parent;\n\t      this.__subscribe = subscribe;\n\t      __super__.call(this);\n\t    }\n\t\n\t    AnonymousObservable.prototype._subscribe = function (o) {\n\t      var ado = new AutoDetachObserver(o), state = [ado, this];\n\t\n\t      if (currentThreadScheduler.scheduleRequired()) {\n\t        currentThreadScheduler.schedule(state, setDisposable);\n\t      } else {\n\t        setDisposable(null, state);\n\t      }\n\t      return ado;\n\t    };\n\t\n\t    return AnonymousObservable;\n\t\n\t  }(Observable));\n\t\n\t  var AutoDetachObserver = (function (__super__) {\n\t    inherits(AutoDetachObserver, __super__);\n\t\n\t    function AutoDetachObserver(observer) {\n\t      __super__.call(this);\n\t      this.observer = observer;\n\t      this.m = new SingleAssignmentDisposable();\n\t    }\n\t\n\t    var AutoDetachObserverPrototype = AutoDetachObserver.prototype;\n\t\n\t    AutoDetachObserverPrototype.next = function (value) {\n\t      var result = tryCatch(this.observer.onNext).call(this.observer, value);\n\t      if (result === errorObj) {\n\t        this.dispose();\n\t        thrower(result.e);\n\t      }\n\t    };\n\t\n\t    AutoDetachObserverPrototype.error = function (err) {\n\t      var result = tryCatch(this.observer.onError).call(this.observer, err);\n\t      this.dispose();\n\t      result === errorObj && thrower(result.e);\n\t    };\n\t\n\t    AutoDetachObserverPrototype.completed = function () {\n\t      var result = tryCatch(this.observer.onCompleted).call(this.observer);\n\t      this.dispose();\n\t      result === errorObj && thrower(result.e);\n\t    };\n\t\n\t    AutoDetachObserverPrototype.setDisposable = function (value) { this.m.setDisposable(value); };\n\t    AutoDetachObserverPrototype.getDisposable = function () { return this.m.getDisposable(); };\n\t\n\t    AutoDetachObserverPrototype.dispose = function () {\n\t      __super__.prototype.dispose.call(this);\n\t      this.m.dispose();\n\t    };\n\t\n\t    return AutoDetachObserver;\n\t  }(AbstractObserver));\n\t\n\t  var UnderlyingObservable = (function (__super__) {\n\t    inherits(UnderlyingObservable, __super__);\n\t    function UnderlyingObservable(m, u) {\n\t      this._m = m;\n\t      this._u = u;\n\t      __super__.call(this);\n\t    }\n\t\n\t    UnderlyingObservable.prototype.subscribeCore = function (o) {\n\t      return new BinaryDisposable(this._m.getDisposable(), this._u.subscribe(o));\n\t    };\n\t\n\t    return UnderlyingObservable;\n\t  }(ObservableBase));\n\t\n\t  var GroupedObservable = (function (__super__) {\n\t    inherits(GroupedObservable, __super__);\n\t    function GroupedObservable(key, underlyingObservable, mergedDisposable) {\n\t      __super__.call(this);\n\t      this.key = key;\n\t      this.underlyingObservable = !mergedDisposable ?\n\t        underlyingObservable :\n\t        new UnderlyingObservable(mergedDisposable, underlyingObservable);\n\t    }\n\t\n\t    GroupedObservable.prototype._subscribe = function (o) {\n\t      return this.underlyingObservable.subscribe(o);\n\t    };\n\t\n\t    return GroupedObservable;\n\t  }(Observable));\n\t\n\t  /**\n\t   *  Represents an object that is both an observable sequence as well as an observer.\n\t   *  Each notification is broadcasted to all subscribed observers.\n\t   */\n\t  var Subject = Rx.Subject = (function (__super__) {\n\t    inherits(Subject, __super__);\n\t    function Subject() {\n\t      __super__.call(this);\n\t      this.isDisposed = false;\n\t      this.isStopped = false;\n\t      this.observers = [];\n\t      this.hasError = false;\n\t    }\n\t\n\t    addProperties(Subject.prototype, Observer.prototype, {\n\t      _subscribe: function (o) {\n\t        checkDisposed(this);\n\t        if (!this.isStopped) {\n\t          this.observers.push(o);\n\t          return new InnerSubscription(this, o);\n\t        }\n\t        if (this.hasError) {\n\t          o.onError(this.error);\n\t          return disposableEmpty;\n\t        }\n\t        o.onCompleted();\n\t        return disposableEmpty;\n\t      },\n\t      /**\n\t       * Indicates whether the subject has observers subscribed to it.\n\t       * @returns {Boolean} Indicates whether the subject has observers subscribed to it.\n\t       */\n\t      hasObservers: function () { return this.observers.length > 0; },\n\t      /**\n\t       * Notifies all subscribed observers about the end of the sequence.\n\t       */\n\t      onCompleted: function () {\n\t        checkDisposed(this);\n\t        if (!this.isStopped) {\n\t          this.isStopped = true;\n\t          for (var i = 0, os = cloneArray(this.observers), len = os.length; i < len; i++) {\n\t            os[i].onCompleted();\n\t          }\n\t\n\t          this.observers.length = 0;\n\t        }\n\t      },\n\t      /**\n\t       * Notifies all subscribed observers about the exception.\n\t       * @param {Mixed} error The exception to send to all observers.\n\t       */\n\t      onError: function (error) {\n\t        checkDisposed(this);\n\t        if (!this.isStopped) {\n\t          this.isStopped = true;\n\t          this.error = error;\n\t          this.hasError = true;\n\t          for (var i = 0, os = cloneArray(this.observers), len = os.length; i < len; i++) {\n\t            os[i].onError(error);\n\t          }\n\t\n\t          this.observers.length = 0;\n\t        }\n\t      },\n\t      /**\n\t       * Notifies all subscribed observers about the arrival of the specified element in the sequence.\n\t       * @param {Mixed} value The value to send to all observers.\n\t       */\n\t      onNext: function (value) {\n\t        checkDisposed(this);\n\t        if (!this.isStopped) {\n\t          for (var i = 0, os = cloneArray(this.observers), len = os.length; i < len; i++) {\n\t            os[i].onNext(value);\n\t          }\n\t        }\n\t      },\n\t      /**\n\t       * Unsubscribe all observers and release resources.\n\t       */\n\t      dispose: function () {\n\t        this.isDisposed = true;\n\t        this.observers = null;\n\t      }\n\t    });\n\t\n\t    /**\n\t     * Creates a subject from the specified observer and observable.\n\t     * @param {Observer} observer The observer used to send messages to the subject.\n\t     * @param {Observable} observable The observable used to subscribe to messages sent from the subject.\n\t     * @returns {Subject} Subject implemented using the given observer and observable.\n\t     */\n\t    Subject.create = function (observer, observable) {\n\t      return new AnonymousSubject(observer, observable);\n\t    };\n\t\n\t    return Subject;\n\t  }(Observable));\n\t\n\t  /**\n\t   *  Represents the result of an asynchronous operation.\n\t   *  The last value before the OnCompleted notification, or the error received through OnError, is sent to all subscribed observers.\n\t   */\n\t  var AsyncSubject = Rx.AsyncSubject = (function (__super__) {\n\t    inherits(AsyncSubject, __super__);\n\t\n\t    /**\n\t     * Creates a subject that can only receive one value and that value is cached for all future observations.\n\t     * @constructor\n\t     */\n\t    function AsyncSubject() {\n\t      __super__.call(this);\n\t      this.isDisposed = false;\n\t      this.isStopped = false;\n\t      this.hasValue = false;\n\t      this.observers = [];\n\t      this.hasError = false;\n\t    }\n\t\n\t    addProperties(AsyncSubject.prototype, Observer.prototype, {\n\t      _subscribe: function (o) {\n\t        checkDisposed(this);\n\t\n\t        if (!this.isStopped) {\n\t          this.observers.push(o);\n\t          return new InnerSubscription(this, o);\n\t        }\n\t\n\t        if (this.hasError) {\n\t          o.onError(this.error);\n\t        } else if (this.hasValue) {\n\t          o.onNext(this.value);\n\t          o.onCompleted();\n\t        } else {\n\t          o.onCompleted();\n\t        }\n\t\n\t        return disposableEmpty;\n\t      },\n\t      /**\n\t       * Indicates whether the subject has observers subscribed to it.\n\t       * @returns {Boolean} Indicates whether the subject has observers subscribed to it.\n\t       */\n\t      hasObservers: function () {\n\t        checkDisposed(this);\n\t        return this.observers.length > 0;\n\t      },\n\t      /**\n\t       * Notifies all subscribed observers about the end of the sequence, also causing the last received value to be sent out (if any).\n\t       */\n\t      onCompleted: function () {\n\t        var i, len;\n\t        checkDisposed(this);\n\t        if (!this.isStopped) {\n\t          this.isStopped = true;\n\t          var os = cloneArray(this.observers), len = os.length;\n\t\n\t          if (this.hasValue) {\n\t            for (i = 0; i < len; i++) {\n\t              var o = os[i];\n\t              o.onNext(this.value);\n\t              o.onCompleted();\n\t            }\n\t          } else {\n\t            for (i = 0; i < len; i++) {\n\t              os[i].onCompleted();\n\t            }\n\t          }\n\t\n\t          this.observers.length = 0;\n\t        }\n\t      },\n\t      /**\n\t       * Notifies all subscribed observers about the error.\n\t       * @param {Mixed} error The Error to send to all observers.\n\t       */\n\t      onError: function (error) {\n\t        checkDisposed(this);\n\t        if (!this.isStopped) {\n\t          this.isStopped = true;\n\t          this.hasError = true;\n\t          this.error = error;\n\t\n\t          for (var i = 0, os = cloneArray(this.observers), len = os.length; i < len; i++) {\n\t            os[i].onError(error);\n\t          }\n\t\n\t          this.observers.length = 0;\n\t        }\n\t      },\n\t      /**\n\t       * Sends a value to the subject. The last value received before successful termination will be sent to all subscribed and future observers.\n\t       * @param {Mixed} value The value to store in the subject.\n\t       */\n\t      onNext: function (value) {\n\t        checkDisposed(this);\n\t        if (this.isStopped) { return; }\n\t        this.value = value;\n\t        this.hasValue = true;\n\t      },\n\t      /**\n\t       * Unsubscribe all observers and release resources.\n\t       */\n\t      dispose: function () {\n\t        this.isDisposed = true;\n\t        this.observers = null;\n\t        this.error = null;\n\t        this.value = null;\n\t      }\n\t    });\n\t\n\t    return AsyncSubject;\n\t  }(Observable));\n\t\n\t  /**\n\t   *  Represents a value that changes over time.\n\t   *  Observers can subscribe to the subject to receive the last (or initial) value and all subsequent notifications.\n\t   */\n\t  var BehaviorSubject = Rx.BehaviorSubject = (function (__super__) {\n\t    inherits(BehaviorSubject, __super__);\n\t    function BehaviorSubject(value) {\n\t      __super__.call(this);\n\t      this.value = value;\n\t      this.observers = [];\n\t      this.isDisposed = false;\n\t      this.isStopped = false;\n\t      this.hasError = false;\n\t    }\n\t\n\t    addProperties(BehaviorSubject.prototype, Observer.prototype, {\n\t      _subscribe: function (o) {\n\t        checkDisposed(this);\n\t        if (!this.isStopped) {\n\t          this.observers.push(o);\n\t          o.onNext(this.value);\n\t          return new InnerSubscription(this, o);\n\t        }\n\t        if (this.hasError) {\n\t          o.onError(this.error);\n\t        } else {\n\t          o.onCompleted();\n\t        }\n\t        return disposableEmpty;\n\t      },\n\t      /**\n\t       * Gets the current value or throws an exception.\n\t       * Value is frozen after onCompleted is called.\n\t       * After onError is called always throws the specified exception.\n\t       * An exception is always thrown after dispose is called.\n\t       * @returns {Mixed} The initial value passed to the constructor until onNext is called; after which, the last value passed to onNext.\n\t       */\n\t      getValue: function () {\n\t        checkDisposed(this);\n\t        if (this.hasError) { thrower(this.error); }\n\t        return this.value;\n\t      },\n\t      /**\n\t       * Indicates whether the subject has observers subscribed to it.\n\t       * @returns {Boolean} Indicates whether the subject has observers subscribed to it.\n\t       */\n\t      hasObservers: function () { return this.observers.length > 0; },\n\t      /**\n\t       * Notifies all subscribed observers about the end of the sequence.\n\t       */\n\t      onCompleted: function () {\n\t        checkDisposed(this);\n\t        if (this.isStopped) { return; }\n\t        this.isStopped = true;\n\t        for (var i = 0, os = cloneArray(this.observers), len = os.length; i < len; i++) {\n\t          os[i].onCompleted();\n\t        }\n\t\n\t        this.observers.length = 0;\n\t      },\n\t      /**\n\t       * Notifies all subscribed observers about the exception.\n\t       * @param {Mixed} error The exception to send to all observers.\n\t       */\n\t      onError: function (error) {\n\t        checkDisposed(this);\n\t        if (this.isStopped) { return; }\n\t        this.isStopped = true;\n\t        this.hasError = true;\n\t        this.error = error;\n\t\n\t        for (var i = 0, os = cloneArray(this.observers), len = os.length; i < len; i++) {\n\t          os[i].onError(error);\n\t        }\n\t\n\t        this.observers.length = 0;\n\t      },\n\t      /**\n\t       * Notifies all subscribed observers about the arrival of the specified element in the sequence.\n\t       * @param {Mixed} value The value to send to all observers.\n\t       */\n\t      onNext: function (value) {\n\t        checkDisposed(this);\n\t        if (this.isStopped) { return; }\n\t        this.value = value;\n\t        for (var i = 0, os = cloneArray(this.observers), len = os.length; i < len; i++) {\n\t          os[i].onNext(value);\n\t        }\n\t      },\n\t      /**\n\t       * Unsubscribe all observers and release resources.\n\t       */\n\t      dispose: function () {\n\t        this.isDisposed = true;\n\t        this.observers = null;\n\t        this.value = null;\n\t        this.error = null;\n\t      }\n\t    });\n\t\n\t    return BehaviorSubject;\n\t  }(Observable));\n\t\n\t  /**\n\t   * Represents an object that is both an observable sequence as well as an observer.\n\t   * Each notification is broadcasted to all subscribed and future observers, subject to buffer trimming policies.\n\t   */\n\t  var ReplaySubject = Rx.ReplaySubject = (function (__super__) {\n\t\n\t    var maxSafeInteger = Math.pow(2, 53) - 1;\n\t\n\t    function createRemovableDisposable(subject, observer) {\n\t      return disposableCreate(function () {\n\t        observer.dispose();\n\t        !subject.isDisposed && subject.observers.splice(subject.observers.indexOf(observer), 1);\n\t      });\n\t    }\n\t\n\t    inherits(ReplaySubject, __super__);\n\t\n\t    /**\n\t     *  Initializes a new instance of the ReplaySubject class with the specified buffer size, window size and scheduler.\n\t     *  @param {Number} [bufferSize] Maximum element count of the replay buffer.\n\t     *  @param {Number} [windowSize] Maximum time length of the replay buffer.\n\t     *  @param {Scheduler} [scheduler] Scheduler the observers are invoked on.\n\t     */\n\t    function ReplaySubject(bufferSize, windowSize, scheduler) {\n\t      this.bufferSize = bufferSize == null ? maxSafeInteger : bufferSize;\n\t      this.windowSize = windowSize == null ? maxSafeInteger : windowSize;\n\t      this.scheduler = scheduler || currentThreadScheduler;\n\t      this.q = [];\n\t      this.observers = [];\n\t      this.isStopped = false;\n\t      this.isDisposed = false;\n\t      this.hasError = false;\n\t      this.error = null;\n\t      __super__.call(this);\n\t    }\n\t\n\t    addProperties(ReplaySubject.prototype, Observer.prototype, {\n\t      _subscribe: function (o) {\n\t        checkDisposed(this);\n\t        var so = new ScheduledObserver(this.scheduler, o), subscription = createRemovableDisposable(this, so);\n\t\n\t        this._trim(this.scheduler.now());\n\t        this.observers.push(so);\n\t\n\t        for (var i = 0, len = this.q.length; i < len; i++) {\n\t          so.onNext(this.q[i].value);\n\t        }\n\t\n\t        if (this.hasError) {\n\t          so.onError(this.error);\n\t        } else if (this.isStopped) {\n\t          so.onCompleted();\n\t        }\n\t\n\t        so.ensureActive();\n\t        return subscription;\n\t      },\n\t      /**\n\t       * Indicates whether the subject has observers subscribed to it.\n\t       * @returns {Boolean} Indicates whether the subject has observers subscribed to it.\n\t       */\n\t      hasObservers: function () {\n\t        return this.observers.length > 0;\n\t      },\n\t      _trim: function (now) {\n\t        while (this.q.length > this.bufferSize) {\n\t          this.q.shift();\n\t        }\n\t        while (this.q.length > 0 && (now - this.q[0].interval) > this.windowSize) {\n\t          this.q.shift();\n\t        }\n\t      },\n\t      /**\n\t       * Notifies all subscribed observers about the arrival of the specified element in the sequence.\n\t       * @param {Mixed} value The value to send to all observers.\n\t       */\n\t      onNext: function (value) {\n\t        checkDisposed(this);\n\t        if (this.isStopped) { return; }\n\t        var now = this.scheduler.now();\n\t        this.q.push({ interval: now, value: value });\n\t        this._trim(now);\n\t\n\t        for (var i = 0, os = cloneArray(this.observers), len = os.length; i < len; i++) {\n\t          var observer = os[i];\n\t          observer.onNext(value);\n\t          observer.ensureActive();\n\t        }\n\t      },\n\t      /**\n\t       * Notifies all subscribed observers about the exception.\n\t       * @param {Mixed} error The exception to send to all observers.\n\t       */\n\t      onError: function (error) {\n\t        checkDisposed(this);\n\t        if (this.isStopped) { return; }\n\t        this.isStopped = true;\n\t        this.error = error;\n\t        this.hasError = true;\n\t        var now = this.scheduler.now();\n\t        this._trim(now);\n\t        for (var i = 0, os = cloneArray(this.observers), len = os.length; i < len; i++) {\n\t          var observer = os[i];\n\t          observer.onError(error);\n\t          observer.ensureActive();\n\t        }\n\t        this.observers.length = 0;\n\t      },\n\t      /**\n\t       * Notifies all subscribed observers about the end of the sequence.\n\t       */\n\t      onCompleted: function () {\n\t        checkDisposed(this);\n\t        if (this.isStopped) { return; }\n\t        this.isStopped = true;\n\t        var now = this.scheduler.now();\n\t        this._trim(now);\n\t        for (var i = 0, os = cloneArray(this.observers), len = os.length; i < len; i++) {\n\t          var observer = os[i];\n\t          observer.onCompleted();\n\t          observer.ensureActive();\n\t        }\n\t        this.observers.length = 0;\n\t      },\n\t      /**\n\t       * Unsubscribe all observers and release resources.\n\t       */\n\t      dispose: function () {\n\t        this.isDisposed = true;\n\t        this.observers = null;\n\t      }\n\t    });\n\t\n\t    return ReplaySubject;\n\t  }(Observable));\n\t\n\t  var AnonymousSubject = Rx.AnonymousSubject = (function (__super__) {\n\t    inherits(AnonymousSubject, __super__);\n\t    function AnonymousSubject(observer, observable) {\n\t      this.observer = observer;\n\t      this.observable = observable;\n\t      __super__.call(this);\n\t    }\n\t\n\t    addProperties(AnonymousSubject.prototype, Observer.prototype, {\n\t      _subscribe: function (o) {\n\t        return this.observable.subscribe(o);\n\t      },\n\t      onCompleted: function () {\n\t        this.observer.onCompleted();\n\t      },\n\t      onError: function (error) {\n\t        this.observer.onError(error);\n\t      },\n\t      onNext: function (value) {\n\t        this.observer.onNext(value);\n\t      }\n\t    });\n\t\n\t    return AnonymousSubject;\n\t  }(Observable));\n\t\n\t  /**\n\t  * Used to pause and resume streams.\n\t  */\n\t  Rx.Pauser = (function (__super__) {\n\t    inherits(Pauser, __super__);\n\t    function Pauser() {\n\t      __super__.call(this);\n\t    }\n\t\n\t    /**\n\t     * Pauses the underlying sequence.\n\t     */\n\t    Pauser.prototype.pause = function () { this.onNext(false); };\n\t\n\t    /**\n\t    * Resumes the underlying sequence.\n\t    */\n\t    Pauser.prototype.resume = function () { this.onNext(true); };\n\t\n\t    return Pauser;\n\t  }(Subject));\n\t\n\t  if (true) {\n\t    root.Rx = Rx;\n\t\n\t    !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {\n\t      return Rx;\n\t    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t  } else if (freeExports && freeModule) {\n\t    // in Node.js or RingoJS\n\t    if (moduleExports) {\n\t      (freeModule.exports = Rx).Rx = Rx;\n\t    } else {\n\t      freeExports.Rx = Rx;\n\t    }\n\t  } else {\n\t    // in a browser or Rhino\n\t    root.Rx = Rx;\n\t  }\n\t\n\t  // All code before this point will be filtered from stack traces.\n\t  var rEndingLine = captureLine();\n\t\n\t}.call(this));\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(50)(module), (function() { return this; }()), __webpack_require__(51)))\n\n/***/ },\n/* 50 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function(module) {\r\n\t\tif(!module.webpackPolyfill) {\r\n\t\t\tmodule.deprecate = function() {};\r\n\t\t\tmodule.paths = [];\r\n\t\t\t// module.parent = undefined by default\r\n\t\t\tmodule.children = [];\r\n\t\t\tmodule.webpackPolyfill = 1;\r\n\t\t}\r\n\t\treturn module;\r\n\t}\r\n\n\n/***/ },\n/* 51 */\n/***/ function(module, exports) {\n\n\t// shim for using process in browser\n\t\n\tvar process = module.exports = {};\n\tvar queue = [];\n\tvar draining = false;\n\tvar currentQueue;\n\tvar queueIndex = -1;\n\t\n\tfunction cleanUpNextTick() {\n\t    draining = false;\n\t    if (currentQueue.length) {\n\t        queue = currentQueue.concat(queue);\n\t    } else {\n\t        queueIndex = -1;\n\t    }\n\t    if (queue.length) {\n\t        drainQueue();\n\t    }\n\t}\n\t\n\tfunction drainQueue() {\n\t    if (draining) {\n\t        return;\n\t    }\n\t    var timeout = setTimeout(cleanUpNextTick);\n\t    draining = true;\n\t\n\t    var len = queue.length;\n\t    while(len) {\n\t        currentQueue = queue;\n\t        queue = [];\n\t        while (++queueIndex < len) {\n\t            if (currentQueue) {\n\t                currentQueue[queueIndex].run();\n\t            }\n\t        }\n\t        queueIndex = -1;\n\t        len = queue.length;\n\t    }\n\t    currentQueue = null;\n\t    draining = false;\n\t    clearTimeout(timeout);\n\t}\n\t\n\tprocess.nextTick = function (fun) {\n\t    var args = new Array(arguments.length - 1);\n\t    if (arguments.length > 1) {\n\t        for (var i = 1; i < arguments.length; i++) {\n\t            args[i - 1] = arguments[i];\n\t        }\n\t    }\n\t    queue.push(new Item(fun, args));\n\t    if (queue.length === 1 && !draining) {\n\t        setTimeout(drainQueue, 0);\n\t    }\n\t};\n\t\n\t// v8 likes predictible objects\n\tfunction Item(fun, array) {\n\t    this.fun = fun;\n\t    this.array = array;\n\t}\n\tItem.prototype.run = function () {\n\t    this.fun.apply(null, this.array);\n\t};\n\tprocess.title = 'browser';\n\tprocess.browser = true;\n\tprocess.env = {};\n\tprocess.argv = [];\n\tprocess.version = ''; // empty string to avoid regexp issues\n\tprocess.versions = {};\n\t\n\tfunction noop() {}\n\t\n\tprocess.on = noop;\n\tprocess.addListener = noop;\n\tprocess.once = noop;\n\tprocess.off = noop;\n\tprocess.removeListener = noop;\n\tprocess.removeAllListeners = noop;\n\tprocess.emit = noop;\n\t\n\tprocess.binding = function (name) {\n\t    throw new Error('process.binding is not supported');\n\t};\n\t\n\tprocess.cwd = function () { return '/' };\n\tprocess.chdir = function (dir) {\n\t    throw new Error('process.chdir is not supported');\n\t};\n\tprocess.umask = function() { return 0; };\n\n\n/***/ },\n/* 52 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(process) {(function() {\n\t  \"use strict\";\n\t\n\t  function addPropertyTo(target, methodName, value) {\n\t    Object.defineProperty(target, methodName, {\n\t      enumerable: false,\n\t      configurable: false,\n\t      writable: false,\n\t      value: value\n\t    });\n\t  }\n\t\n\t  function banProperty(target, methodName) {\n\t    addPropertyTo(target, methodName, function() {\n\t      throw new ImmutableError(\"The \" + methodName +\n\t        \" method cannot be invoked on an Immutable data structure.\");\n\t    });\n\t  }\n\t\n\t  var immutabilityTag = \"__immutable_invariants_hold\";\n\t\n\t  function addImmutabilityTag(target) {\n\t    addPropertyTo(target, immutabilityTag, true);\n\t  }\n\t\n\t  function isImmutable(target) {\n\t    if (typeof target === \"object\") {\n\t      return target === null || target.hasOwnProperty(immutabilityTag);\n\t    } else {\n\t      // In JavaScript, only objects are even potentially mutable.\n\t      // strings, numbers, null, and undefined are all naturally immutable.\n\t      return true;\n\t    }\n\t  }\n\t\n\t  function isMergableObject(target) {\n\t    return target !== null && typeof target === \"object\" && !(target instanceof Array) && !(target instanceof Date);\n\t  }\n\t\n\t  var mutatingObjectMethods = [\n\t    \"setPrototypeOf\"\n\t  ];\n\t\n\t  var nonMutatingObjectMethods = [\n\t    \"keys\"\n\t  ];\n\t\n\t  var mutatingArrayMethods = mutatingObjectMethods.concat([\n\t    \"push\", \"pop\", \"sort\", \"splice\", \"shift\", \"unshift\", \"reverse\"\n\t  ]);\n\t\n\t  var nonMutatingArrayMethods = nonMutatingObjectMethods.concat([\n\t    \"map\", \"filter\", \"slice\", \"concat\", \"reduce\", \"reduceRight\"\n\t  ]);\n\t\n\t  var mutatingDateMethods = mutatingObjectMethods.concat([\n\t    \"setDate\", \"setFullYear\", \"setHours\", \"setMilliseconds\", \"setMinutes\", \"setMonth\", \"setSeconds\",\n\t    \"setTime\", \"setUTCDate\", \"setUTCFullYear\", \"setUTCHours\", \"setUTCMilliseconds\", \"setUTCMinutes\",\n\t    \"setUTCMonth\", \"setUTCSeconds\", \"setYear\"\n\t  ]);\n\t\n\t  function ImmutableError(message) {\n\t    var err       = new Error(message);\n\t    err.__proto__ = ImmutableError;\n\t\n\t    return err;\n\t  }\n\t  ImmutableError.prototype = Error.prototype;\n\t\n\t  function makeImmutable(obj, bannedMethods) {\n\t    // Tag it so we can quickly tell it's immutable later.\n\t    addImmutabilityTag(obj);\n\t\n\t    if (process.env.NODE_ENV !== \"production\") {\n\t      // Make all mutating methods throw exceptions.\n\t      for (var index in bannedMethods) {\n\t        if (bannedMethods.hasOwnProperty(index)) {\n\t          banProperty(obj, bannedMethods[index]);\n\t        }\n\t      }\n\t\n\t      // Freeze it and return it.\n\t      Object.freeze(obj);\n\t    }\n\t\n\t    return obj;\n\t  }\n\t\n\t  function makeMethodReturnImmutable(obj, methodName) {\n\t    var currentMethod = obj[methodName];\n\t\n\t    addPropertyTo(obj, methodName, function() {\n\t      return Immutable(currentMethod.apply(obj, arguments));\n\t    });\n\t  }\n\t\n\t  function arraySet(idx, value) {\n\t    if (idx in this && this[idx] === value) {\n\t      return this;\n\t    }\n\t\n\t    var mutable = asMutableArray.call(this);\n\t    mutable[idx] = Immutable(value);\n\t    return makeImmutableArray(mutable);\n\t  }\n\t\n\t  var immutableEmptyArray = Immutable([]);\n\t\n\t  function arraySetIn(pth, value) {\n\t    var head = pth[0];\n\t\n\t    if (pth.length === 1) {\n\t      return arraySet.call(this, head, value);\n\t    } else {\n\t      var tail = pth.slice(1);\n\t      var thisHead = this[head];\n\t      var newValue;\n\t\n\t      if (typeof(thisHead) === \"object\" && thisHead !== null && typeof(thisHead.setIn) === \"function\") {\n\t        // Might (validly) be object or array\n\t        newValue = thisHead.setIn(tail, value);\n\t      } else {\n\t        newValue = arraySetIn.call(immutableEmptyArray, tail, value);\n\t      }\n\t\n\t      if (head in this && thisHead === newValue) {\n\t        return this;\n\t      }\n\t\n\t      var mutable = asMutableArray.call(this);\n\t      mutable[head] = newValue;\n\t      return makeImmutableArray(mutable);\n\t    }\n\t  }\n\t\n\t  function makeImmutableArray(array) {\n\t    // Don't change their implementations, but wrap these functions to make sure\n\t    // they always return an immutable value.\n\t    for (var index in nonMutatingArrayMethods) {\n\t      if (nonMutatingArrayMethods.hasOwnProperty(index)) {\n\t        var methodName = nonMutatingArrayMethods[index];\n\t        makeMethodReturnImmutable(array, methodName);\n\t      }\n\t    }\n\t\n\t    addPropertyTo(array, \"flatMap\",  flatMap);\n\t    addPropertyTo(array, \"asObject\", asObject);\n\t    addPropertyTo(array, \"asMutable\", asMutableArray);\n\t    addPropertyTo(array, \"set\", arraySet);\n\t    addPropertyTo(array, \"setIn\", arraySetIn);\n\t\n\t    for(var i = 0, length = array.length; i < length; i++) {\n\t      array[i] = Immutable(array[i]);\n\t    }\n\t\n\t    return makeImmutable(array, mutatingArrayMethods);\n\t  }\n\t\n\t  function makeImmutableDate(date) {\n\t    addPropertyTo(date, \"asMutable\", asMutableDate);\n\t\n\t    return makeImmutable(date, mutatingDateMethods);\n\t  }\n\t\n\t  function asMutableDate() {\n\t    return new Date(this.getTime());\n\t  }\n\t\n\t  /**\n\t   * Effectively performs a map() over the elements in the array, using the\n\t   * provided iterator, except that whenever the iterator returns an array, that\n\t   * array's elements are added to the final result instead of the array itself.\n\t   *\n\t   * @param {function} iterator - The iterator function that will be invoked on each element in the array. It will receive three arguments: the current value, the current index, and the current object.\n\t   */\n\t  function flatMap(iterator) {\n\t    // Calling .flatMap() with no arguments is a no-op. Don't bother cloning.\n\t    if (arguments.length === 0) {\n\t      return this;\n\t    }\n\t\n\t    var result = [],\n\t        length = this.length,\n\t        index;\n\t\n\t    for (index = 0; index < length; index++) {\n\t      var iteratorResult = iterator(this[index], index, this);\n\t\n\t      if (iteratorResult instanceof Array) {\n\t        // Concatenate Array results into the return value we're building up.\n\t        result.push.apply(result, iteratorResult);\n\t      } else {\n\t        // Handle non-Array results the same way map() does.\n\t        result.push(iteratorResult);\n\t      }\n\t    }\n\t\n\t    return makeImmutableArray(result);\n\t  }\n\t\n\t  /**\n\t   * Returns an Immutable copy of the object without the given keys included.\n\t   *\n\t   * @param {array} keysToRemove - A list of strings representing the keys to exclude in the return value. Instead of providing a single array, this method can also be called by passing multiple strings as separate arguments.\n\t   */\n\t  function without(keysToRemove) {\n\t    // Calling .without() with no arguments is a no-op. Don't bother cloning.\n\t    if (arguments.length === 0) {\n\t      return this;\n\t    }\n\t\n\t    // If we weren't given an array, use the arguments list.\n\t    if (!(keysToRemove instanceof Array)) {\n\t      keysToRemove = Array.prototype.slice.call(arguments);\n\t    }\n\t\n\t    var result = this.instantiateEmptyObject();\n\t\n\t    for (var key in this) {\n\t      if (this.hasOwnProperty(key) && (keysToRemove.indexOf(key) === -1)) {\n\t        result[key] = this[key];\n\t      }\n\t    }\n\t\n\t    return makeImmutableObject(result,\n\t      {instantiateEmptyObject: this.instantiateEmptyObject});\n\t  }\n\t\n\t  function asMutableArray(opts) {\n\t    var result = [], i, length;\n\t\n\t    if(opts && opts.deep) {\n\t      for(i = 0, length = this.length; i < length; i++) {\n\t        result.push(asDeepMutable(this[i]));\n\t      }\n\t    } else {\n\t      for(i = 0, length = this.length; i < length; i++) {\n\t        result.push(this[i]);\n\t      }\n\t    }\n\t\n\t    return result;\n\t  }\n\t\n\t  /**\n\t   * Effectively performs a [map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map) over the elements in the array, expecting that the iterator function\n\t   * will return an array of two elements - the first representing a key, the other\n\t   * a value. Then returns an Immutable Object constructed of those keys and values.\n\t   *\n\t   * @param {function} iterator - A function which should return an array of two elements - the first representing the desired key, the other the desired value.\n\t   */\n\t  function asObject(iterator) {\n\t    // If no iterator was provided, assume the identity function\n\t    // (suggesting this array is already a list of key/value pairs.)\n\t    if (typeof iterator !== \"function\") {\n\t      iterator = function(value) { return value; };\n\t    }\n\t\n\t    var result = {},\n\t        length = this.length,\n\t        index;\n\t\n\t    for (index = 0; index < length; index++) {\n\t      var pair  = iterator(this[index], index, this),\n\t          key   = pair[0],\n\t          value = pair[1];\n\t\n\t      result[key] = value;\n\t    }\n\t\n\t    return makeImmutableObject(result);\n\t  }\n\t\n\t  function asDeepMutable(obj) {\n\t    if(!obj || !obj.hasOwnProperty(immutabilityTag) || obj instanceof Date) { return obj; }\n\t    return obj.asMutable({deep: true});\n\t  }\n\t\n\t  function quickCopy(src, dest) {\n\t    for (var key in src) {\n\t      if (src.hasOwnProperty(key)) {\n\t        dest[key] = src[key];\n\t      }\n\t    }\n\t\n\t    return dest;\n\t  }\n\t\n\t  /**\n\t   * Returns an Immutable Object containing the properties and values of both\n\t   * this object and the provided object, prioritizing the provided object's\n\t   * values whenever the same key is present in both objects.\n\t   *\n\t   * @param {object} other - The other object to merge. Multiple objects can be passed as an array. In such a case, the later an object appears in that list, the higher its priority.\n\t   * @param {object} config - Optional config object that contains settings. Supported settings are: {deep: true} for deep merge and {merger: mergerFunc} where mergerFunc is a function\n\t   *                          that takes a property from both objects. If anything is returned it overrides the normal merge behaviour.\n\t   */\n\t  function merge(other, config) {\n\t    // Calling .merge() with no arguments is a no-op. Don't bother cloning.\n\t    if (arguments.length === 0) {\n\t      return this;\n\t    }\n\t\n\t    if (other === null || (typeof other !== \"object\")) {\n\t      throw new TypeError(\"Immutable#merge can only be invoked with objects or arrays, not \" + JSON.stringify(other));\n\t    }\n\t\n\t    var receivedArray = (other instanceof Array),\n\t        deep          = config && config.deep,\n\t        merger        = config && config.merger,\n\t        result;\n\t\n\t    // Use the given key to extract a value from the given object, then place\n\t    // that value in the result object under the same key. If that resulted\n\t    // in a change from this object's value at that key, set anyChanges = true.\n\t    function addToResult(currentObj, otherObj, key) {\n\t      var immutableValue = Immutable(otherObj[key]);\n\t      var mergerResult = merger && merger(currentObj[key], immutableValue, config);\n\t      var currentValue = currentObj[key];\n\t\n\t      if ((result !== undefined) ||\n\t        (mergerResult !== undefined) ||\n\t        (!currentObj.hasOwnProperty(key) ||\n\t        ((immutableValue !== currentValue) &&\n\t          // Avoid false positives due to (NaN !== NaN) evaluating to true\n\t          (immutableValue === immutableValue)))) {\n\t\n\t        var newValue;\n\t\n\t        if (mergerResult) {\n\t          newValue = mergerResult;\n\t        } else if (deep && isMergableObject(currentValue) && isMergableObject(immutableValue)) {\n\t          newValue = currentValue.merge(immutableValue, config);\n\t        } else {\n\t          newValue = immutableValue;\n\t        }\n\t\n\t        // We check (newValue === newValue) because (NaN !== NaN) in JS\n\t        if (((currentValue !== newValue) && (newValue === newValue)) ||\n\t            !currentObj.hasOwnProperty(key)) {\n\t          if (result === undefined) {\n\t            // Make a shallow clone of the current object.\n\t            result = quickCopy(currentObj, currentObj.instantiateEmptyObject());\n\t          }\n\t\n\t          result[key] = newValue;\n\t        }\n\t      }\n\t    }\n\t\n\t    var key;\n\t\n\t    // Achieve prioritization by overriding previous values that get in the way.\n\t    if (!receivedArray) {\n\t      // The most common use case: just merge one object into the existing one.\n\t      for (key in other) {\n\t        if (other.hasOwnProperty(key)) {\n\t          addToResult(this, other, key);\n\t        }\n\t      }\n\t    } else {\n\t      // We also accept an Array\n\t      for (var index=0; index < other.length; index++) {\n\t        var otherFromArray = other[index];\n\t\n\t        for (key in otherFromArray) {\n\t          if (otherFromArray.hasOwnProperty(key)) {\n\t            addToResult(this, otherFromArray, key);\n\t          }\n\t        }\n\t      }\n\t    }\n\t\n\t    if (result === undefined) {\n\t      return this;\n\t    } else {\n\t      return makeImmutableObject(result,\n\t        {instantiateEmptyObject: this.instantiateEmptyObject});\n\t    }\n\t  }\n\t\n\t  var immutableEmptyObject = Immutable({});\n\t\n\t  function objectSetIn(path, value) {\n\t    var head = path[0];\n\t    if (path.length === 1) {\n\t      return objectSet.call(this, head, value);\n\t    }\n\t\n\t    var tail = path.slice(1);\n\t    var newValue;\n\t    var thisHead = this[head];\n\t\n\t    if (this.hasOwnProperty(head) && typeof(thisHead) === \"object\" && thisHead !== null && typeof(thisHead.setIn) === \"function\") {\n\t      // Might (validly) be object or array\n\t      newValue = thisHead.setIn(tail, value);\n\t    } else {\n\t      newValue = objectSetIn.call(immutableEmptyObject, tail, value);\n\t    }\n\t\n\t    if (this.hasOwnProperty(head) && thisHead === newValue) {\n\t      return this;\n\t    }\n\t\n\t    var mutable = quickCopy(this, this.instantiateEmptyObject());\n\t    mutable[head] = newValue;\n\t    return makeImmutableObject(mutable, this);\n\t  }\n\t\n\t  function objectSet(property, value) {\n\t    if (this.hasOwnProperty(property) && this[property] === value) {\n\t      return this;\n\t    }\n\t\n\t    var mutable = quickCopy(this, this.instantiateEmptyObject());\n\t    mutable[property] = Immutable(value);\n\t    return makeImmutableObject(mutable, this);\n\t  }\n\t\n\t  function asMutableObject(opts) {\n\t    var result = this.instantiateEmptyObject(), key;\n\t\n\t    if(opts && opts.deep) {\n\t      for (key in this) {\n\t        if (this.hasOwnProperty(key)) {\n\t          result[key] = asDeepMutable(this[key]);\n\t        }\n\t      }\n\t    } else {\n\t      for (key in this) {\n\t        if (this.hasOwnProperty(key)) {\n\t          result[key] = this[key];\n\t        }\n\t      }\n\t    }\n\t\n\t    return result;\n\t  }\n\t\n\t  // Creates plain object to be used for cloning\n\t  function instantiatePlainObject() {\n\t    return {};\n\t  }\n\t\n\t  // Finalizes an object with immutable methods, freezes it, and returns it.\n\t  function makeImmutableObject(obj, options) {\n\t    var instantiateEmptyObject =\n\t      (options && options.instantiateEmptyObject) ?\n\t        options.instantiateEmptyObject : instantiatePlainObject;\n\t\n\t    addPropertyTo(obj, \"merge\", merge);\n\t    addPropertyTo(obj, \"without\", without);\n\t    addPropertyTo(obj, \"asMutable\", asMutableObject);\n\t    addPropertyTo(obj, \"instantiateEmptyObject\", instantiateEmptyObject);\n\t    addPropertyTo(obj, \"set\", objectSet);\n\t    addPropertyTo(obj, \"setIn\", objectSetIn);\n\t\n\t    return makeImmutable(obj, mutatingObjectMethods);\n\t  }\n\t\n\t  function Immutable(obj, options) {\n\t    if (isImmutable(obj)) {\n\t      return obj;\n\t    } else if (obj instanceof Array) {\n\t      return makeImmutableArray(obj.slice());\n\t    } else if (obj instanceof Date) {\n\t      return makeImmutableDate(new Date(obj.getTime()));\n\t    } else {\n\t      // Don't freeze the object we were given; make a clone and use that.\n\t      var prototype = options && options.prototype;\n\t      var instantiateEmptyObject =\n\t        (!prototype || prototype === Object.prototype) ?\n\t          instantiatePlainObject : (function() { return Object.create(prototype); });\n\t      var clone = instantiateEmptyObject();\n\t\n\t      for (var key in obj) {\n\t        if (obj.hasOwnProperty(key)) {\n\t          clone[key] = Immutable(obj[key]);\n\t        }\n\t      }\n\t\n\t      return makeImmutableObject(clone,\n\t        {instantiateEmptyObject: instantiateEmptyObject});\n\t    }\n\t  }\n\t\n\t  // Export the library\n\t  Immutable.isImmutable    = isImmutable;\n\t  Immutable.ImmutableError = ImmutableError;\n\t\n\t  Object.freeze(Immutable);\n\t\n\t  /* istanbul ignore if */\n\t  if (true) {\n\t    module.exports = Immutable;\n\t  } else if (typeof exports === \"object\") {\n\t    exports.Immutable = Immutable;\n\t  } else if (typeof window === \"object\") {\n\t    window.Immutable = Immutable;\n\t  } else if (typeof global === \"object\") {\n\t    global.Immutable = Immutable;\n\t  }\n\t})();\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(51)))\n\n/***/ },\n/* 53 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar RxWidget, createElement, createPatcher, diff, patch;\n\t\n\tdiff = __webpack_require__(54);\n\t\n\tpatch = __webpack_require__(67);\n\t\n\tcreateElement = __webpack_require__(76);\n\t\n\tcreatePatcher = function(render) {\n\t  var calculatePatches;\n\t  return calculatePatches = function(acc, newState) {\n\t    var newTree;\n\t    newTree = render(newState);\n\t    return {\n\t      state: newState,\n\t      vTree: newTree,\n\t      patches: diff(acc.vTree, newTree)\n\t    };\n\t  };\n\t};\n\t\n\tRxWidget = (function() {\n\t  function RxWidget(source, render, initialState) {\n\t    this.seed = {\n\t      vTree: render(initialState)\n\t    };\n\t    this._patchObs = source.scan(createPatcher(render), this.seed);\n\t  }\n\t\n\t  RxWidget.prototype.init = function() {\n\t    var domNode;\n\t    domNode = createElement(this.seed.vTree);\n\t    this._patcherSubscription = this._patchObs.pluck('patches').subscribe(function(patches) {\n\t      return patch(domNode, patches);\n\t    });\n\t    return domNode;\n\t  };\n\t\n\t  RxWidget.prototype.destroy = function() {\n\t    if (this._patcherSubscription) {\n\t      return this._patcherSubscription.dispose();\n\t    }\n\t  };\n\t\n\t  return RxWidget;\n\t\n\t})();\n\t\n\tmodule.exports = RxWidget;\n\n\n/***/ },\n/* 54 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar diff = __webpack_require__(55)\n\t\n\tmodule.exports = diff\n\n\n/***/ },\n/* 55 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar isArray = __webpack_require__(56)\n\t\n\tvar VPatch = __webpack_require__(57)\n\tvar isVNode = __webpack_require__(59)\n\tvar isVText = __webpack_require__(60)\n\tvar isWidget = __webpack_require__(61)\n\tvar isThunk = __webpack_require__(62)\n\tvar handleThunk = __webpack_require__(63)\n\t\n\tvar diffProps = __webpack_require__(64)\n\t\n\tmodule.exports = diff\n\t\n\tfunction diff(a, b) {\n\t    var patch = { a: a }\n\t    walk(a, b, patch, 0)\n\t    return patch\n\t}\n\t\n\tfunction walk(a, b, patch, index) {\n\t    if (a === b) {\n\t        return\n\t    }\n\t\n\t    var apply = patch[index]\n\t    var applyClear = false\n\t\n\t    if (isThunk(a) || isThunk(b)) {\n\t        thunks(a, b, patch, index)\n\t    } else if (b == null) {\n\t\n\t        // If a is a widget we will add a remove patch for it\n\t        // Otherwise any child widgets/hooks must be destroyed.\n\t        // This prevents adding two remove patches for a widget.\n\t        if (!isWidget(a)) {\n\t            clearState(a, patch, index)\n\t            apply = patch[index]\n\t        }\n\t\n\t        apply = appendPatch(apply, new VPatch(VPatch.REMOVE, a, b))\n\t    } else if (isVNode(b)) {\n\t        if (isVNode(a)) {\n\t            if (a.tagName === b.tagName &&\n\t                a.namespace === b.namespace &&\n\t                a.key === b.key) {\n\t                var propsPatch = diffProps(a.properties, b.properties)\n\t                if (propsPatch) {\n\t                    apply = appendPatch(apply,\n\t                        new VPatch(VPatch.PROPS, a, propsPatch))\n\t                }\n\t                apply = diffChildren(a, b, patch, apply, index)\n\t            } else {\n\t                apply = appendPatch(apply, new VPatch(VPatch.VNODE, a, b))\n\t                applyClear = true\n\t            }\n\t        } else {\n\t            apply = appendPatch(apply, new VPatch(VPatch.VNODE, a, b))\n\t            applyClear = true\n\t        }\n\t    } else if (isVText(b)) {\n\t        if (!isVText(a)) {\n\t            apply = appendPatch(apply, new VPatch(VPatch.VTEXT, a, b))\n\t            applyClear = true\n\t        } else if (a.text !== b.text) {\n\t            apply = appendPatch(apply, new VPatch(VPatch.VTEXT, a, b))\n\t        }\n\t    } else if (isWidget(b)) {\n\t        if (!isWidget(a)) {\n\t            applyClear = true\n\t        }\n\t\n\t        apply = appendPatch(apply, new VPatch(VPatch.WIDGET, a, b))\n\t    }\n\t\n\t    if (apply) {\n\t        patch[index] = apply\n\t    }\n\t\n\t    if (applyClear) {\n\t        clearState(a, patch, index)\n\t    }\n\t}\n\t\n\tfunction diffChildren(a, b, patch, apply, index) {\n\t    var aChildren = a.children\n\t    var orderedSet = reorder(aChildren, b.children)\n\t    var bChildren = orderedSet.children\n\t\n\t    var aLen = aChildren.length\n\t    var bLen = bChildren.length\n\t    var len = aLen > bLen ? aLen : bLen\n\t\n\t    for (var i = 0; i < len; i++) {\n\t        var leftNode = aChildren[i]\n\t        var rightNode = bChildren[i]\n\t        index += 1\n\t\n\t        if (!leftNode) {\n\t            if (rightNode) {\n\t                // Excess nodes in b need to be added\n\t                apply = appendPatch(apply,\n\t                    new VPatch(VPatch.INSERT, null, rightNode))\n\t            }\n\t        } else {\n\t            walk(leftNode, rightNode, patch, index)\n\t        }\n\t\n\t        if (isVNode(leftNode) && leftNode.count) {\n\t            index += leftNode.count\n\t        }\n\t    }\n\t\n\t    if (orderedSet.moves) {\n\t        // Reorder nodes last\n\t        apply = appendPatch(apply, new VPatch(\n\t            VPatch.ORDER,\n\t            a,\n\t            orderedSet.moves\n\t        ))\n\t    }\n\t\n\t    return apply\n\t}\n\t\n\tfunction clearState(vNode, patch, index) {\n\t    // TODO: Make this a single walk, not two\n\t    unhook(vNode, patch, index)\n\t    destroyWidgets(vNode, patch, index)\n\t}\n\t\n\t// Patch records for all destroyed widgets must be added because we need\n\t// a DOM node reference for the destroy function\n\tfunction destroyWidgets(vNode, patch, index) {\n\t    if (isWidget(vNode)) {\n\t        if (typeof vNode.destroy === \"function\") {\n\t            patch[index] = appendPatch(\n\t                patch[index],\n\t                new VPatch(VPatch.REMOVE, vNode, null)\n\t            )\n\t        }\n\t    } else if (isVNode(vNode) && (vNode.hasWidgets || vNode.hasThunks)) {\n\t        var children = vNode.children\n\t        var len = children.length\n\t        for (var i = 0; i < len; i++) {\n\t            var child = children[i]\n\t            index += 1\n\t\n\t            destroyWidgets(child, patch, index)\n\t\n\t            if (isVNode(child) && child.count) {\n\t                index += child.count\n\t            }\n\t        }\n\t    } else if (isThunk(vNode)) {\n\t        thunks(vNode, null, patch, index)\n\t    }\n\t}\n\t\n\t// Create a sub-patch for thunks\n\tfunction thunks(a, b, patch, index) {\n\t    var nodes = handleThunk(a, b)\n\t    var thunkPatch = diff(nodes.a, nodes.b)\n\t    if (hasPatches(thunkPatch)) {\n\t        patch[index] = new VPatch(VPatch.THUNK, null, thunkPatch)\n\t    }\n\t}\n\t\n\tfunction hasPatches(patch) {\n\t    for (var index in patch) {\n\t        if (index !== \"a\") {\n\t            return true\n\t        }\n\t    }\n\t\n\t    return false\n\t}\n\t\n\t// Execute hooks when two nodes are identical\n\tfunction unhook(vNode, patch, index) {\n\t    if (isVNode(vNode)) {\n\t        if (vNode.hooks) {\n\t            patch[index] = appendPatch(\n\t                patch[index],\n\t                new VPatch(\n\t                    VPatch.PROPS,\n\t                    vNode,\n\t                    undefinedKeys(vNode.hooks)\n\t                )\n\t            )\n\t        }\n\t\n\t        if (vNode.descendantHooks || vNode.hasThunks) {\n\t            var children = vNode.children\n\t            var len = children.length\n\t            for (var i = 0; i < len; i++) {\n\t                var child = children[i]\n\t                index += 1\n\t\n\t                unhook(child, patch, index)\n\t\n\t                if (isVNode(child) && child.count) {\n\t                    index += child.count\n\t                }\n\t            }\n\t        }\n\t    } else if (isThunk(vNode)) {\n\t        thunks(vNode, null, patch, index)\n\t    }\n\t}\n\t\n\tfunction undefinedKeys(obj) {\n\t    var result = {}\n\t\n\t    for (var key in obj) {\n\t        result[key] = undefined\n\t    }\n\t\n\t    return result\n\t}\n\t\n\t// List diff, naive left to right reordering\n\tfunction reorder(aChildren, bChildren) {\n\t    // O(M) time, O(M) memory\n\t    var bChildIndex = keyIndex(bChildren)\n\t    var bKeys = bChildIndex.keys\n\t    var bFree = bChildIndex.free\n\t\n\t    if (bFree.length === bChildren.length) {\n\t        return {\n\t            children: bChildren,\n\t            moves: null\n\t        }\n\t    }\n\t\n\t    // O(N) time, O(N) memory\n\t    var aChildIndex = keyIndex(aChildren)\n\t    var aKeys = aChildIndex.keys\n\t    var aFree = aChildIndex.free\n\t\n\t    if (aFree.length === aChildren.length) {\n\t        return {\n\t            children: bChildren,\n\t            moves: null\n\t        }\n\t    }\n\t\n\t    // O(MAX(N, M)) memory\n\t    var newChildren = []\n\t\n\t    var freeIndex = 0\n\t    var freeCount = bFree.length\n\t    var deletedItems = 0\n\t\n\t    // Iterate through a and match a node in b\n\t    // O(N) time,\n\t    for (var i = 0 ; i < aChildren.length; i++) {\n\t        var aItem = aChildren[i]\n\t        var itemIndex\n\t\n\t        if (aItem.key) {\n\t            if (bKeys.hasOwnProperty(aItem.key)) {\n\t                // Match up the old keys\n\t                itemIndex = bKeys[aItem.key]\n\t                newChildren.push(bChildren[itemIndex])\n\t\n\t            } else {\n\t                // Remove old keyed items\n\t                itemIndex = i - deletedItems++\n\t                newChildren.push(null)\n\t            }\n\t        } else {\n\t            // Match the item in a with the next free item in b\n\t            if (freeIndex < freeCount) {\n\t                itemIndex = bFree[freeIndex++]\n\t                newChildren.push(bChildren[itemIndex])\n\t            } else {\n\t                // There are no free items in b to match with\n\t                // the free items in a, so the extra free nodes\n\t                // are deleted.\n\t                itemIndex = i - deletedItems++\n\t                newChildren.push(null)\n\t            }\n\t        }\n\t    }\n\t\n\t    var lastFreeIndex = freeIndex >= bFree.length ?\n\t        bChildren.length :\n\t        bFree[freeIndex]\n\t\n\t    // Iterate through b and append any new keys\n\t    // O(M) time\n\t    for (var j = 0; j < bChildren.length; j++) {\n\t        var newItem = bChildren[j]\n\t\n\t        if (newItem.key) {\n\t            if (!aKeys.hasOwnProperty(newItem.key)) {\n\t                // Add any new keyed items\n\t                // We are adding new items to the end and then sorting them\n\t                // in place. In future we should insert new items in place.\n\t                newChildren.push(newItem)\n\t            }\n\t        } else if (j >= lastFreeIndex) {\n\t            // Add any leftover non-keyed items\n\t            newChildren.push(newItem)\n\t        }\n\t    }\n\t\n\t    var simulate = newChildren.slice()\n\t    var simulateIndex = 0\n\t    var removes = []\n\t    var inserts = []\n\t    var simulateItem\n\t\n\t    for (var k = 0; k < bChildren.length;) {\n\t        var wantedItem = bChildren[k]\n\t        simulateItem = simulate[simulateIndex]\n\t\n\t        // remove items\n\t        while (simulateItem === null && simulate.length) {\n\t            removes.push(remove(simulate, simulateIndex, null))\n\t            simulateItem = simulate[simulateIndex]\n\t        }\n\t\n\t        if (!simulateItem || simulateItem.key !== wantedItem.key) {\n\t            // if we need a key in this position...\n\t            if (wantedItem.key) {\n\t                if (simulateItem && simulateItem.key) {\n\t                    // if an insert doesn't put this key in place, it needs to move\n\t                    if (bKeys[simulateItem.key] !== k + 1) {\n\t                        removes.push(remove(simulate, simulateIndex, simulateItem.key))\n\t                        simulateItem = simulate[simulateIndex]\n\t                        // if the remove didn't put the wanted item in place, we need to insert it\n\t                        if (!simulateItem || simulateItem.key !== wantedItem.key) {\n\t                            inserts.push({key: wantedItem.key, to: k})\n\t                        }\n\t                        // items are matching, so skip ahead\n\t                        else {\n\t                            simulateIndex++\n\t                        }\n\t                    }\n\t                    else {\n\t                        inserts.push({key: wantedItem.key, to: k})\n\t                    }\n\t                }\n\t                else {\n\t                    inserts.push({key: wantedItem.key, to: k})\n\t                }\n\t                k++\n\t            }\n\t            // a key in simulate has no matching wanted key, remove it\n\t            else if (simulateItem && simulateItem.key) {\n\t                removes.push(remove(simulate, simulateIndex, simulateItem.key))\n\t            }\n\t        }\n\t        else {\n\t            simulateIndex++\n\t            k++\n\t        }\n\t    }\n\t\n\t    // remove all the remaining nodes from simulate\n\t    while(simulateIndex < simulate.length) {\n\t        simulateItem = simulate[simulateIndex]\n\t        removes.push(remove(simulate, simulateIndex, simulateItem && simulateItem.key))\n\t    }\n\t\n\t    // If the only moves we have are deletes then we can just\n\t    // let the delete patch remove these items.\n\t    if (removes.length === deletedItems && !inserts.length) {\n\t        return {\n\t            children: newChildren,\n\t            moves: null\n\t        }\n\t    }\n\t\n\t    return {\n\t        children: newChildren,\n\t        moves: {\n\t            removes: removes,\n\t            inserts: inserts\n\t        }\n\t    }\n\t}\n\t\n\tfunction remove(arr, index, key) {\n\t    arr.splice(index, 1)\n\t\n\t    return {\n\t        from: index,\n\t        key: key\n\t    }\n\t}\n\t\n\tfunction keyIndex(children) {\n\t    var keys = {}\n\t    var free = []\n\t    var length = children.length\n\t\n\t    for (var i = 0; i < length; i++) {\n\t        var child = children[i]\n\t\n\t        if (child.key) {\n\t            keys[child.key] = i\n\t        } else {\n\t            free.push(i)\n\t        }\n\t    }\n\t\n\t    return {\n\t        keys: keys,     // A hash of key name to index\n\t        free: free      // An array of unkeyed item indices\n\t    }\n\t}\n\t\n\tfunction appendPatch(apply, patch) {\n\t    if (apply) {\n\t        if (isArray(apply)) {\n\t            apply.push(patch)\n\t        } else {\n\t            apply = [apply, patch]\n\t        }\n\t\n\t        return apply\n\t    } else {\n\t        return patch\n\t    }\n\t}\n\n\n/***/ },\n/* 56 */\n/***/ function(module, exports) {\n\n\tvar nativeIsArray = Array.isArray\n\tvar toString = Object.prototype.toString\n\t\n\tmodule.exports = nativeIsArray || isArray\n\t\n\tfunction isArray(obj) {\n\t    return toString.call(obj) === \"[object Array]\"\n\t}\n\n\n/***/ },\n/* 57 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar version = __webpack_require__(58)\n\t\n\tVirtualPatch.NONE = 0\n\tVirtualPatch.VTEXT = 1\n\tVirtualPatch.VNODE = 2\n\tVirtualPatch.WIDGET = 3\n\tVirtualPatch.PROPS = 4\n\tVirtualPatch.ORDER = 5\n\tVirtualPatch.INSERT = 6\n\tVirtualPatch.REMOVE = 7\n\tVirtualPatch.THUNK = 8\n\t\n\tmodule.exports = VirtualPatch\n\t\n\tfunction VirtualPatch(type, vNode, patch) {\n\t    this.type = Number(type)\n\t    this.vNode = vNode\n\t    this.patch = patch\n\t}\n\t\n\tVirtualPatch.prototype.version = version\n\tVirtualPatch.prototype.type = \"VirtualPatch\"\n\n\n/***/ },\n/* 58 */\n/***/ function(module, exports) {\n\n\tmodule.exports = \"2\"\n\n\n/***/ },\n/* 59 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar version = __webpack_require__(58)\n\t\n\tmodule.exports = isVirtualNode\n\t\n\tfunction isVirtualNode(x) {\n\t    return x && x.type === \"VirtualNode\" && x.version === version\n\t}\n\n\n/***/ },\n/* 60 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar version = __webpack_require__(58)\n\t\n\tmodule.exports = isVirtualText\n\t\n\tfunction isVirtualText(x) {\n\t    return x && x.type === \"VirtualText\" && x.version === version\n\t}\n\n\n/***/ },\n/* 61 */\n/***/ function(module, exports) {\n\n\tmodule.exports = isWidget\n\t\n\tfunction isWidget(w) {\n\t    return w && w.type === \"Widget\"\n\t}\n\n\n/***/ },\n/* 62 */\n/***/ function(module, exports) {\n\n\tmodule.exports = isThunk\r\n\t\r\n\tfunction isThunk(t) {\r\n\t    return t && t.type === \"Thunk\"\r\n\t}\r\n\n\n/***/ },\n/* 63 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar isVNode = __webpack_require__(59)\n\tvar isVText = __webpack_require__(60)\n\tvar isWidget = __webpack_require__(61)\n\tvar isThunk = __webpack_require__(62)\n\t\n\tmodule.exports = handleThunk\n\t\n\tfunction handleThunk(a, b) {\n\t    var renderedA = a\n\t    var renderedB = b\n\t\n\t    if (isThunk(b)) {\n\t        renderedB = renderThunk(b, a)\n\t    }\n\t\n\t    if (isThunk(a)) {\n\t        renderedA = renderThunk(a, null)\n\t    }\n\t\n\t    return {\n\t        a: renderedA,\n\t        b: renderedB\n\t    }\n\t}\n\t\n\tfunction renderThunk(thunk, previous) {\n\t    var renderedThunk = thunk.vnode\n\t\n\t    if (!renderedThunk) {\n\t        renderedThunk = thunk.vnode = thunk.render(previous)\n\t    }\n\t\n\t    if (!(isVNode(renderedThunk) ||\n\t            isVText(renderedThunk) ||\n\t            isWidget(renderedThunk))) {\n\t        throw new Error(\"thunk did not return a valid node\");\n\t    }\n\t\n\t    return renderedThunk\n\t}\n\n\n/***/ },\n/* 64 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar isObject = __webpack_require__(65)\n\tvar isHook = __webpack_require__(66)\n\t\n\tmodule.exports = diffProps\n\t\n\tfunction diffProps(a, b) {\n\t    var diff\n\t\n\t    for (var aKey in a) {\n\t        if (!(aKey in b)) {\n\t            diff = diff || {}\n\t            diff[aKey] = undefined\n\t        }\n\t\n\t        var aValue = a[aKey]\n\t        var bValue = b[aKey]\n\t\n\t        if (aValue === bValue) {\n\t            continue\n\t        } else if (isObject(aValue) && isObject(bValue)) {\n\t            if (getPrototype(bValue) !== getPrototype(aValue)) {\n\t                diff = diff || {}\n\t                diff[aKey] = bValue\n\t            } else if (isHook(bValue)) {\n\t                 diff = diff || {}\n\t                 diff[aKey] = bValue\n\t            } else {\n\t                var objectDiff = diffProps(aValue, bValue)\n\t                if (objectDiff) {\n\t                    diff = diff || {}\n\t                    diff[aKey] = objectDiff\n\t                }\n\t            }\n\t        } else {\n\t            diff = diff || {}\n\t            diff[aKey] = bValue\n\t        }\n\t    }\n\t\n\t    for (var bKey in b) {\n\t        if (!(bKey in a)) {\n\t            diff = diff || {}\n\t            diff[bKey] = b[bKey]\n\t        }\n\t    }\n\t\n\t    return diff\n\t}\n\t\n\tfunction getPrototype(value) {\n\t  if (Object.getPrototypeOf) {\n\t    return Object.getPrototypeOf(value)\n\t  } else if (value.__proto__) {\n\t    return value.__proto__\n\t  } else if (value.constructor) {\n\t    return value.constructor.prototype\n\t  }\n\t}\n\n\n/***/ },\n/* 65 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tmodule.exports = function isObject(x) {\n\t\treturn typeof x === \"object\" && x !== null;\n\t};\n\n\n/***/ },\n/* 66 */\n/***/ function(module, exports) {\n\n\tmodule.exports = isHook\n\t\n\tfunction isHook(hook) {\n\t    return hook &&\n\t      (typeof hook.hook === \"function\" && !hook.hasOwnProperty(\"hook\") ||\n\t       typeof hook.unhook === \"function\" && !hook.hasOwnProperty(\"unhook\"))\n\t}\n\n\n/***/ },\n/* 67 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar patch = __webpack_require__(68)\n\t\n\tmodule.exports = patch\n\n\n/***/ },\n/* 68 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar document = __webpack_require__(69)\n\tvar isArray = __webpack_require__(56)\n\t\n\tvar render = __webpack_require__(71)\n\tvar domIndex = __webpack_require__(73)\n\tvar patchOp = __webpack_require__(74)\n\tmodule.exports = patch\n\t\n\tfunction patch(rootNode, patches, renderOptions) {\n\t    renderOptions = renderOptions || {}\n\t    renderOptions.patch = renderOptions.patch && renderOptions.patch !== patch\n\t        ? renderOptions.patch\n\t        : patchRecursive\n\t    renderOptions.render = renderOptions.render || render\n\t\n\t    return renderOptions.patch(rootNode, patches, renderOptions)\n\t}\n\t\n\tfunction patchRecursive(rootNode, patches, renderOptions) {\n\t    var indices = patchIndices(patches)\n\t\n\t    if (indices.length === 0) {\n\t        return rootNode\n\t    }\n\t\n\t    var index = domIndex(rootNode, patches.a, indices)\n\t    var ownerDocument = rootNode.ownerDocument\n\t\n\t    if (!renderOptions.document && ownerDocument !== document) {\n\t        renderOptions.document = ownerDocument\n\t    }\n\t\n\t    for (var i = 0; i < indices.length; i++) {\n\t        var nodeIndex = indices[i]\n\t        rootNode = applyPatch(rootNode,\n\t            index[nodeIndex],\n\t            patches[nodeIndex],\n\t            renderOptions)\n\t    }\n\t\n\t    return rootNode\n\t}\n\t\n\tfunction applyPatch(rootNode, domNode, patchList, renderOptions) {\n\t    if (!domNode) {\n\t        return rootNode\n\t    }\n\t\n\t    var newNode\n\t\n\t    if (isArray(patchList)) {\n\t        for (var i = 0; i < patchList.length; i++) {\n\t            newNode = patchOp(patchList[i], domNode, renderOptions)\n\t\n\t            if (domNode === rootNode) {\n\t                rootNode = newNode\n\t            }\n\t        }\n\t    } else {\n\t        newNode = patchOp(patchList, domNode, renderOptions)\n\t\n\t        if (domNode === rootNode) {\n\t            rootNode = newNode\n\t        }\n\t    }\n\t\n\t    return rootNode\n\t}\n\t\n\tfunction patchIndices(patches) {\n\t    var indices = []\n\t\n\t    for (var key in patches) {\n\t        if (key !== \"a\") {\n\t            indices.push(Number(key))\n\t        }\n\t    }\n\t\n\t    return indices\n\t}\n\n\n/***/ },\n/* 69 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {var topLevel = typeof global !== 'undefined' ? global :\n\t    typeof window !== 'undefined' ? window : {}\n\tvar minDoc = __webpack_require__(70);\n\t\n\tif (typeof document !== 'undefined') {\n\t    module.exports = document;\n\t} else {\n\t    var doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'];\n\t\n\t    if (!doccy) {\n\t        doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'] = minDoc;\n\t    }\n\t\n\t    module.exports = doccy;\n\t}\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 70 */\n/***/ function(module, exports) {\n\n\t/* (ignored) */\n\n/***/ },\n/* 71 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar document = __webpack_require__(69)\n\t\n\tvar applyProperties = __webpack_require__(72)\n\t\n\tvar isVNode = __webpack_require__(59)\n\tvar isVText = __webpack_require__(60)\n\tvar isWidget = __webpack_require__(61)\n\tvar handleThunk = __webpack_require__(63)\n\t\n\tmodule.exports = createElement\n\t\n\tfunction createElement(vnode, opts) {\n\t    var doc = opts ? opts.document || document : document\n\t    var warn = opts ? opts.warn : null\n\t\n\t    vnode = handleThunk(vnode).a\n\t\n\t    if (isWidget(vnode)) {\n\t        return vnode.init()\n\t    } else if (isVText(vnode)) {\n\t        return doc.createTextNode(vnode.text)\n\t    } else if (!isVNode(vnode)) {\n\t        if (warn) {\n\t            warn(\"Item is not a valid virtual dom node\", vnode)\n\t        }\n\t        return null\n\t    }\n\t\n\t    var node = (vnode.namespace === null) ?\n\t        doc.createElement(vnode.tagName) :\n\t        doc.createElementNS(vnode.namespace, vnode.tagName)\n\t\n\t    var props = vnode.properties\n\t    applyProperties(node, props)\n\t\n\t    var children = vnode.children\n\t\n\t    for (var i = 0; i < children.length; i++) {\n\t        var childNode = createElement(children[i], opts)\n\t        if (childNode) {\n\t            node.appendChild(childNode)\n\t        }\n\t    }\n\t\n\t    return node\n\t}\n\n\n/***/ },\n/* 72 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar isObject = __webpack_require__(65)\n\tvar isHook = __webpack_require__(66)\n\t\n\tmodule.exports = applyProperties\n\t\n\tfunction applyProperties(node, props, previous) {\n\t    for (var propName in props) {\n\t        var propValue = props[propName]\n\t\n\t        if (propValue === undefined) {\n\t            removeProperty(node, propName, propValue, previous);\n\t        } else if (isHook(propValue)) {\n\t            removeProperty(node, propName, propValue, previous)\n\t            if (propValue.hook) {\n\t                propValue.hook(node,\n\t                    propName,\n\t                    previous ? previous[propName] : undefined)\n\t            }\n\t        } else {\n\t            if (isObject(propValue)) {\n\t                patchObject(node, props, previous, propName, propValue);\n\t            } else {\n\t                node[propName] = propValue\n\t            }\n\t        }\n\t    }\n\t}\n\t\n\tfunction removeProperty(node, propName, propValue, previous) {\n\t    if (previous) {\n\t        var previousValue = previous[propName]\n\t\n\t        if (!isHook(previousValue)) {\n\t            if (propName === \"attributes\") {\n\t                for (var attrName in previousValue) {\n\t                    node.removeAttribute(attrName)\n\t                }\n\t            } else if (propName === \"style\") {\n\t                for (var i in previousValue) {\n\t                    node.style[i] = \"\"\n\t                }\n\t            } else if (typeof previousValue === \"string\") {\n\t                node[propName] = \"\"\n\t            } else {\n\t                node[propName] = null\n\t            }\n\t        } else if (previousValue.unhook) {\n\t            previousValue.unhook(node, propName, propValue)\n\t        }\n\t    }\n\t}\n\t\n\tfunction patchObject(node, props, previous, propName, propValue) {\n\t    var previousValue = previous ? previous[propName] : undefined\n\t\n\t    // Set attributes\n\t    if (propName === \"attributes\") {\n\t        for (var attrName in propValue) {\n\t            var attrValue = propValue[attrName]\n\t\n\t            if (attrValue === undefined) {\n\t                node.removeAttribute(attrName)\n\t            } else {\n\t                node.setAttribute(attrName, attrValue)\n\t            }\n\t        }\n\t\n\t        return\n\t    }\n\t\n\t    if(previousValue && isObject(previousValue) &&\n\t        getPrototype(previousValue) !== getPrototype(propValue)) {\n\t        node[propName] = propValue\n\t        return\n\t    }\n\t\n\t    if (!isObject(node[propName])) {\n\t        node[propName] = {}\n\t    }\n\t\n\t    var replacer = propName === \"style\" ? \"\" : undefined\n\t\n\t    for (var k in propValue) {\n\t        var value = propValue[k]\n\t        node[propName][k] = (value === undefined) ? replacer : value\n\t    }\n\t}\n\t\n\tfunction getPrototype(value) {\n\t    if (Object.getPrototypeOf) {\n\t        return Object.getPrototypeOf(value)\n\t    } else if (value.__proto__) {\n\t        return value.__proto__\n\t    } else if (value.constructor) {\n\t        return value.constructor.prototype\n\t    }\n\t}\n\n\n/***/ },\n/* 73 */\n/***/ function(module, exports) {\n\n\t// Maps a virtual DOM tree onto a real DOM tree in an efficient manner.\n\t// We don't want to read all of the DOM nodes in the tree so we use\n\t// the in-order tree indexing to eliminate recursion down certain branches.\n\t// We only recurse into a DOM node if we know that it contains a child of\n\t// interest.\n\t\n\tvar noChild = {}\n\t\n\tmodule.exports = domIndex\n\t\n\tfunction domIndex(rootNode, tree, indices, nodes) {\n\t    if (!indices || indices.length === 0) {\n\t        return {}\n\t    } else {\n\t        indices.sort(ascending)\n\t        return recurse(rootNode, tree, indices, nodes, 0)\n\t    }\n\t}\n\t\n\tfunction recurse(rootNode, tree, indices, nodes, rootIndex) {\n\t    nodes = nodes || {}\n\t\n\t\n\t    if (rootNode) {\n\t        if (indexInRange(indices, rootIndex, rootIndex)) {\n\t            nodes[rootIndex] = rootNode\n\t        }\n\t\n\t        var vChildren = tree.children\n\t\n\t        if (vChildren) {\n\t\n\t            var childNodes = rootNode.childNodes\n\t\n\t            for (var i = 0; i < tree.children.length; i++) {\n\t                rootIndex += 1\n\t\n\t                var vChild = vChildren[i] || noChild\n\t                var nextIndex = rootIndex + (vChild.count || 0)\n\t\n\t                // skip recursion down the tree if there are no nodes down here\n\t                if (indexInRange(indices, rootIndex, nextIndex)) {\n\t                    recurse(childNodes[i], vChild, indices, nodes, rootIndex)\n\t                }\n\t\n\t                rootIndex = nextIndex\n\t            }\n\t        }\n\t    }\n\t\n\t    return nodes\n\t}\n\t\n\t// Binary search for an index in the interval [left, right]\n\tfunction indexInRange(indices, left, right) {\n\t    if (indices.length === 0) {\n\t        return false\n\t    }\n\t\n\t    var minIndex = 0\n\t    var maxIndex = indices.length - 1\n\t    var currentIndex\n\t    var currentItem\n\t\n\t    while (minIndex <= maxIndex) {\n\t        currentIndex = ((maxIndex + minIndex) / 2) >> 0\n\t        currentItem = indices[currentIndex]\n\t\n\t        if (minIndex === maxIndex) {\n\t            return currentItem >= left && currentItem <= right\n\t        } else if (currentItem < left) {\n\t            minIndex = currentIndex + 1\n\t        } else  if (currentItem > right) {\n\t            maxIndex = currentIndex - 1\n\t        } else {\n\t            return true\n\t        }\n\t    }\n\t\n\t    return false;\n\t}\n\t\n\tfunction ascending(a, b) {\n\t    return a > b ? 1 : -1\n\t}\n\n\n/***/ },\n/* 74 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar applyProperties = __webpack_require__(72)\n\t\n\tvar isWidget = __webpack_require__(61)\n\tvar VPatch = __webpack_require__(57)\n\t\n\tvar updateWidget = __webpack_require__(75)\n\t\n\tmodule.exports = applyPatch\n\t\n\tfunction applyPatch(vpatch, domNode, renderOptions) {\n\t    var type = vpatch.type\n\t    var vNode = vpatch.vNode\n\t    var patch = vpatch.patch\n\t\n\t    switch (type) {\n\t        case VPatch.REMOVE:\n\t            return removeNode(domNode, vNode)\n\t        case VPatch.INSERT:\n\t            return insertNode(domNode, patch, renderOptions)\n\t        case VPatch.VTEXT:\n\t            return stringPatch(domNode, vNode, patch, renderOptions)\n\t        case VPatch.WIDGET:\n\t            return widgetPatch(domNode, vNode, patch, renderOptions)\n\t        case VPatch.VNODE:\n\t            return vNodePatch(domNode, vNode, patch, renderOptions)\n\t        case VPatch.ORDER:\n\t            reorderChildren(domNode, patch)\n\t            return domNode\n\t        case VPatch.PROPS:\n\t            applyProperties(domNode, patch, vNode.properties)\n\t            return domNode\n\t        case VPatch.THUNK:\n\t            return replaceRoot(domNode,\n\t                renderOptions.patch(domNode, patch, renderOptions))\n\t        default:\n\t            return domNode\n\t    }\n\t}\n\t\n\tfunction removeNode(domNode, vNode) {\n\t    var parentNode = domNode.parentNode\n\t\n\t    if (parentNode) {\n\t        parentNode.removeChild(domNode)\n\t    }\n\t\n\t    destroyWidget(domNode, vNode);\n\t\n\t    return null\n\t}\n\t\n\tfunction insertNode(parentNode, vNode, renderOptions) {\n\t    var newNode = renderOptions.render(vNode, renderOptions)\n\t\n\t    if (parentNode) {\n\t        parentNode.appendChild(newNode)\n\t    }\n\t\n\t    return parentNode\n\t}\n\t\n\tfunction stringPatch(domNode, leftVNode, vText, renderOptions) {\n\t    var newNode\n\t\n\t    if (domNode.nodeType === 3) {\n\t        domNode.replaceData(0, domNode.length, vText.text)\n\t        newNode = domNode\n\t    } else {\n\t        var parentNode = domNode.parentNode\n\t        newNode = renderOptions.render(vText, renderOptions)\n\t\n\t        if (parentNode && newNode !== domNode) {\n\t            parentNode.replaceChild(newNode, domNode)\n\t        }\n\t    }\n\t\n\t    return newNode\n\t}\n\t\n\tfunction widgetPatch(domNode, leftVNode, widget, renderOptions) {\n\t    var updating = updateWidget(leftVNode, widget)\n\t    var newNode\n\t\n\t    if (updating) {\n\t        newNode = widget.update(leftVNode, domNode) || domNode\n\t    } else {\n\t        newNode = renderOptions.render(widget, renderOptions)\n\t    }\n\t\n\t    var parentNode = domNode.parentNode\n\t\n\t    if (parentNode && newNode !== domNode) {\n\t        parentNode.replaceChild(newNode, domNode)\n\t    }\n\t\n\t    if (!updating) {\n\t        destroyWidget(domNode, leftVNode)\n\t    }\n\t\n\t    return newNode\n\t}\n\t\n\tfunction vNodePatch(domNode, leftVNode, vNode, renderOptions) {\n\t    var parentNode = domNode.parentNode\n\t    var newNode = renderOptions.render(vNode, renderOptions)\n\t\n\t    if (parentNode && newNode !== domNode) {\n\t        parentNode.replaceChild(newNode, domNode)\n\t    }\n\t\n\t    return newNode\n\t}\n\t\n\tfunction destroyWidget(domNode, w) {\n\t    if (typeof w.destroy === \"function\" && isWidget(w)) {\n\t        w.destroy(domNode)\n\t    }\n\t}\n\t\n\tfunction reorderChildren(domNode, moves) {\n\t    var childNodes = domNode.childNodes\n\t    var keyMap = {}\n\t    var node\n\t    var remove\n\t    var insert\n\t\n\t    for (var i = 0; i < moves.removes.length; i++) {\n\t        remove = moves.removes[i]\n\t        node = childNodes[remove.from]\n\t        if (remove.key) {\n\t            keyMap[remove.key] = node\n\t        }\n\t        domNode.removeChild(node)\n\t    }\n\t\n\t    var length = childNodes.length\n\t    for (var j = 0; j < moves.inserts.length; j++) {\n\t        insert = moves.inserts[j]\n\t        node = keyMap[insert.key]\n\t        // this is the weirdest bug i've ever seen in webkit\n\t        domNode.insertBefore(node, insert.to >= length++ ? null : childNodes[insert.to])\n\t    }\n\t}\n\t\n\tfunction replaceRoot(oldRoot, newRoot) {\n\t    if (oldRoot && newRoot && oldRoot !== newRoot && oldRoot.parentNode) {\n\t        oldRoot.parentNode.replaceChild(newRoot, oldRoot)\n\t    }\n\t\n\t    return newRoot;\n\t}\n\n\n/***/ },\n/* 75 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar isWidget = __webpack_require__(61)\n\t\n\tmodule.exports = updateWidget\n\t\n\tfunction updateWidget(a, b) {\n\t    if (isWidget(a) && isWidget(b)) {\n\t        if (\"name\" in a && \"name\" in b) {\n\t            return a.id === b.id\n\t        } else {\n\t            return a.init === b.init\n\t        }\n\t    }\n\t\n\t    return false\n\t}\n\n\n/***/ },\n/* 76 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar createElement = __webpack_require__(71)\n\t\n\tmodule.exports = createElement\n\n\n/***/ },\n/* 77 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _slicedToArray2 = __webpack_require__(3);\n\t\n\tvar _slicedToArray3 = _interopRequireDefault(_slicedToArray2);\n\t\n\tvar _classCallCheck2 = __webpack_require__(45);\n\t\n\tvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\t\n\tvar _createClass2 = __webpack_require__(46);\n\t\n\tvar _createClass3 = _interopRequireDefault(_createClass2);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar h = __webpack_require__(78);\n\tvar _ = __webpack_require__(101),\n\t    Immutable = __webpack_require__(52),\n\t    TodoItem = __webpack_require__(103);\n\t\n\tvar TodoList = function () {\n\t  function TodoList(emit, eventBus) {\n\t    (0, _classCallCheck3.default)(this, TodoList);\n\t\n\t    this.emit = emit;\n\t    this.eventBus = eventBus;\n\t  }\n\t\n\t  (0, _createClass3.default)(TodoList, [{\n\t    key: 'toggelAll',\n\t    value: function toggelAll(completed) {\n\t      this.emit({\n\t        action: 'toggelAll',\n\t        completed: completed\n\t      });\n\t    }\n\t  }, {\n\t    key: 'todoList',\n\t    value: function todoList(show, activeItems, completedItems, allItems) {\n\t      var _this = this;\n\t\n\t      var todos = undefined;\n\t\n\t      switch (show) {\n\t        case 'active':\n\t          todos = activeItems;\n\t          break;\n\t        case 'completed':\n\t          todos = completedItems;\n\t          break;\n\t        case 'all':\n\t        default:\n\t          todos = allItems;\n\t          break;\n\t      }\n\t\n\t      if (todos.length > 0) {\n\t        var todoItems = _.map(todos, function (item) {\n\t          var todoItem = new TodoItem(_this.emit, _this.eventBus);\n\t          return todoItem.render(item);\n\t        });\n\t        return h('section', { class: \"main\" }, [h('input', { class: \"toggle-all\",\n\t          type: \"checkbox\",\n\t          checked: completedItems.length === allItems.length ? true : undefined,\n\t          'ev-click': function evClick(ev) {\n\t            _this.toggelAll(completedItems.length !== allItems.length);\n\t          } }), h('label', { for: \"toggle-all\" }, [\"Mark all as complete\"]), h('ul', { class: \"todo-list\" }, [todoItems])]);\n\t      } else {\n\t        return [];\n\t      }\n\t    }\n\t  }, {\n\t    key: 'create',\n\t    value: function create(ev) {\n\t      if (ev.keyCode == 13) {\n\t        this.emit({\n\t          action: 'create',\n\t          text: ev.target.value\n\t        });\n\t        ev.target.value = '';\n\t      }\n\t    }\n\t  }, {\n\t    key: 'clearButton',\n\t    value: function clearButton() {\n\t      var _this2 = this;\n\t\n\t      return h('button', { class: \"clear-completed\",\n\t        'ev-click': function evClick(ev) {\n\t          _this2.emit({ action: 'clearCompleted' });\n\t        } }, [\"Clear completed\"]);\n\t    }\n\t  }, {\n\t    key: 'render',\n\t    value: function render(opts) {\n\t      var _this3 = this;\n\t\n\t      var activeItems = _.filter(_.toPairs(opts.todos), function (_ref) {\n\t        var _ref2 = (0, _slicedToArray3.default)(_ref, 2);\n\t\n\t        var id = _ref2[0];\n\t        var item = _ref2[1];\n\t        return !item.completed;\n\t      }),\n\t          completedItems = _.filter(_.toPairs(opts.todos), function (_ref3) {\n\t        var _ref4 = (0, _slicedToArray3.default)(_ref3, 2);\n\t\n\t        var id = _ref4[0];\n\t        var item = _ref4[1];\n\t        return item.completed;\n\t      }),\n\t          allItems = _.toPairs(opts.todos);\n\t\n\t      return h('div', null, [h('section', { class: \"todoapp\" }, [h('header', { class: \"header\" }, [h('h1', null, [\"todos\"]), h('input', { class: \"new-todo\",\n\t        'ev-keyup': function evKeyup(ev) {\n\t          return _this3.create(ev);\n\t        },\n\t        placeholder: \"What needs to be completed?\" })]), this.todoList(opts.show, activeItems, completedItems, allItems), h('footer', { class: \"footer\" }, [h('span', { class: \"todo-count\" }, [h('strong', null, [activeItems.length]), \" item\", activeItems.length != 1 ? 's' : '', \" left\"]), h('ul', { class: \"filters\" }, [h('li', null, [h('a', { class: opts.show === 'all' ? 'selected' : '',\n\t        href: \"#/\",\n\t        'ev-click': function evClick(ev) {\n\t          _this3.emit({ action: 'show', show: 'all' });\n\t        } }, [\"All\"])]), h('li', null, [h('a', { class: opts.show === 'active' ? 'selected' : '',\n\t        href: \"#/active\",\n\t        'ev-click': function evClick(ev) {\n\t          _this3.emit({ action: 'show', show: 'active' });\n\t        } }, [\"Active\"])]), h('li', null, [h('a', { class: opts.show === 'completed' ? 'selected' : '',\n\t        href: \"#/completed\",\n\t        'ev-click': function evClick(ev) {\n\t          _this3.emit({ action: 'show', show: 'completed' });\n\t        } }, [\"Completed\"])])]), completedItems.length > 0 ? this.clearButton() : ''])]), h('footer', { class: \"info\" }, [h('p', null, [\"Double-click to edit a todo\"]), h('p', null, [\"Template by \", h('a', { href: \"http://sindresorhus.com\" }, [\"Sindre Sorhus\"])]), h('p', null, [\"Created by \", h('a', { href: \"http://github.com/jpb\" }, [\"you\"])]), h('p', null, [\"Part of \", h('a', { href: \"http://todomvc.com\" }, [\"TodoMVC\"])])])]);\n\t    }\n\t  }]);\n\t  return TodoList;\n\t}();\n\t\n\tmodule.exports = TodoList;\n\n/***/ },\n/* 78 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Delegator, _, h, isVHook, origH, topLevelWhitelistedAttrs,\n\t  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };\n\t\n\t_ = __webpack_require__(79);\n\t\n\torigH = __webpack_require__(80);\n\t\n\tisVHook = __webpack_require__(66);\n\t\n\tDelegator = __webpack_require__(91);\n\t\n\tnew Delegator();\n\t\n\ttopLevelWhitelistedAttrs = ['className', 'style', 'dataset', 'id'];\n\t\n\th = function(first) {\n\t  var args, normalizedAttributes, origAttributes, secondArg;\n\t  args = Array.apply(null, arguments);\n\t  secondArg = args[1];\n\t  if (secondArg && typeof secondArg === 'object') {\n\t    origAttributes = secondArg;\n\t    normalizedAttributes = {\n\t      attributes: origAttributes.attributes || {}\n\t    };\n\t    _.forEach(origAttributes, function(v, k) {\n\t      if (k.indexOf('ev-') === 0 || k.indexOf('on') === 0) {\n\t        return normalizedAttributes[k] = v;\n\t      } else if (indexOf.call(topLevelWhitelistedAttrs, k) >= 0) {\n\t        normalizedAttributes[k] = v;\n\t        return delete normalizedAttributes.attributes[k];\n\t      } else if (k === 'class') {\n\t        if (origAttributes.className || normalizedAttributes.attributes.className) {\n\t          throw new Error('Use either class or className, not both');\n\t        }\n\t        normalizedAttributes['className'] = v;\n\t        return delete normalizedAttributes.attributes[k];\n\t      } else if (isVHook(v)) {\n\t        return normalizedAttributes[k] = v;\n\t      } else if (k === 'attributes') {\n\t        return true;\n\t      } else {\n\t        return normalizedAttributes.attributes[k] = v;\n\t      }\n\t    });\n\t    args[1] = normalizedAttributes;\n\t  }\n\t  return origH.apply(null, args);\n\t};\n\t\n\tmodule.exports = h;\n\n\n/***/ },\n/* 79 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {/**\n\t * @license\n\t * lodash 3.10.1 (Custom Build) <https://lodash.com/>\n\t * Build: `lodash modern -d -o ./index.js`\n\t * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>\n\t * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n\t * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n\t * Available under MIT license <https://lodash.com/license>\n\t */\n\t;(function() {\n\t\n\t  /** Used as a safe reference for `undefined` in pre-ES5 environments. */\n\t  var undefined;\n\t\n\t  /** Used as the semantic version number. */\n\t  var VERSION = '3.10.1';\n\t\n\t  /** Used to compose bitmasks for wrapper metadata. */\n\t  var BIND_FLAG = 1,\n\t      BIND_KEY_FLAG = 2,\n\t      CURRY_BOUND_FLAG = 4,\n\t      CURRY_FLAG = 8,\n\t      CURRY_RIGHT_FLAG = 16,\n\t      PARTIAL_FLAG = 32,\n\t      PARTIAL_RIGHT_FLAG = 64,\n\t      ARY_FLAG = 128,\n\t      REARG_FLAG = 256;\n\t\n\t  /** Used as default options for `_.trunc`. */\n\t  var DEFAULT_TRUNC_LENGTH = 30,\n\t      DEFAULT_TRUNC_OMISSION = '...';\n\t\n\t  /** Used to detect when a function becomes hot. */\n\t  var HOT_COUNT = 150,\n\t      HOT_SPAN = 16;\n\t\n\t  /** Used as the size to enable large array optimizations. */\n\t  var LARGE_ARRAY_SIZE = 200;\n\t\n\t  /** Used to indicate the type of lazy iteratees. */\n\t  var LAZY_FILTER_FLAG = 1,\n\t      LAZY_MAP_FLAG = 2;\n\t\n\t  /** Used as the `TypeError` message for \"Functions\" methods. */\n\t  var FUNC_ERROR_TEXT = 'Expected a function';\n\t\n\t  /** Used as the internal argument placeholder. */\n\t  var PLACEHOLDER = '__lodash_placeholder__';\n\t\n\t  /** `Object#toString` result references. */\n\t  var argsTag = '[object Arguments]',\n\t      arrayTag = '[object Array]',\n\t      boolTag = '[object Boolean]',\n\t      dateTag = '[object Date]',\n\t      errorTag = '[object Error]',\n\t      funcTag = '[object Function]',\n\t      mapTag = '[object Map]',\n\t      numberTag = '[object Number]',\n\t      objectTag = '[object Object]',\n\t      regexpTag = '[object RegExp]',\n\t      setTag = '[object Set]',\n\t      stringTag = '[object String]',\n\t      weakMapTag = '[object WeakMap]';\n\t\n\t  var arrayBufferTag = '[object ArrayBuffer]',\n\t      float32Tag = '[object Float32Array]',\n\t      float64Tag = '[object Float64Array]',\n\t      int8Tag = '[object Int8Array]',\n\t      int16Tag = '[object Int16Array]',\n\t      int32Tag = '[object Int32Array]',\n\t      uint8Tag = '[object Uint8Array]',\n\t      uint8ClampedTag = '[object Uint8ClampedArray]',\n\t      uint16Tag = '[object Uint16Array]',\n\t      uint32Tag = '[object Uint32Array]';\n\t\n\t  /** Used to match empty string literals in compiled template source. */\n\t  var reEmptyStringLeading = /\\b__p \\+= '';/g,\n\t      reEmptyStringMiddle = /\\b(__p \\+=) '' \\+/g,\n\t      reEmptyStringTrailing = /(__e\\(.*?\\)|\\b__t\\)) \\+\\n'';/g;\n\t\n\t  /** Used to match HTML entities and HTML characters. */\n\t  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39|#96);/g,\n\t      reUnescapedHtml = /[&<>\"'`]/g,\n\t      reHasEscapedHtml = RegExp(reEscapedHtml.source),\n\t      reHasUnescapedHtml = RegExp(reUnescapedHtml.source);\n\t\n\t  /** Used to match template delimiters. */\n\t  var reEscape = /<%-([\\s\\S]+?)%>/g,\n\t      reEvaluate = /<%([\\s\\S]+?)%>/g,\n\t      reInterpolate = /<%=([\\s\\S]+?)%>/g;\n\t\n\t  /** Used to match property names within property paths. */\n\t  var reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\n\\\\]|\\\\.)*?\\1)\\]/,\n\t      reIsPlainProp = /^\\w*$/,\n\t      rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\n\\\\]|\\\\.)*?)\\2)\\]/g;\n\t\n\t  /**\n\t   * Used to match `RegExp` [syntax characters](http://ecma-international.org/ecma-262/6.0/#sec-patterns)\n\t   * and those outlined by [`EscapeRegExpPattern`](http://ecma-international.org/ecma-262/6.0/#sec-escaperegexppattern).\n\t   */\n\t  var reRegExpChars = /^[:!,]|[\\\\^$.*+?()[\\]{}|\\/]|(^[0-9a-fA-Fnrtuvx])|([\\n\\r\\u2028\\u2029])/g,\n\t      reHasRegExpChars = RegExp(reRegExpChars.source);\n\t\n\t  /** Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks). */\n\t  var reComboMark = /[\\u0300-\\u036f\\ufe20-\\ufe23]/g;\n\t\n\t  /** Used to match backslashes in property paths. */\n\t  var reEscapeChar = /\\\\(\\\\)?/g;\n\t\n\t  /** Used to match [ES template delimiters](http://ecma-international.org/ecma-262/6.0/#sec-template-literal-lexical-components). */\n\t  var reEsTemplate = /\\$\\{([^\\\\}]*(?:\\\\.[^\\\\}]*)*)\\}/g;\n\t\n\t  /** Used to match `RegExp` flags from their coerced string values. */\n\t  var reFlags = /\\w*$/;\n\t\n\t  /** Used to detect hexadecimal string values. */\n\t  var reHasHexPrefix = /^0[xX]/;\n\t\n\t  /** Used to detect host constructors (Safari > 5). */\n\t  var reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\t\n\t  /** Used to detect unsigned integer values. */\n\t  var reIsUint = /^\\d+$/;\n\t\n\t  /** Used to match latin-1 supplementary letters (excluding mathematical operators). */\n\t  var reLatin1 = /[\\xc0-\\xd6\\xd8-\\xde\\xdf-\\xf6\\xf8-\\xff]/g;\n\t\n\t  /** Used to ensure capturing order of template delimiters. */\n\t  var reNoMatch = /($^)/;\n\t\n\t  /** Used to match unescaped characters in compiled string literals. */\n\t  var reUnescapedString = /['\\n\\r\\u2028\\u2029\\\\]/g;\n\t\n\t  /** Used to match words to create compound words. */\n\t  var reWords = (function() {\n\t    var upper = '[A-Z\\\\xc0-\\\\xd6\\\\xd8-\\\\xde]',\n\t        lower = '[a-z\\\\xdf-\\\\xf6\\\\xf8-\\\\xff]+';\n\t\n\t    return RegExp(upper + '+(?=' + upper + lower + ')|' + upper + '?' + lower + '|' + upper + '+|[0-9]+', 'g');\n\t  }());\n\t\n\t  /** Used to assign default `context` object properties. */\n\t  var contextProps = [\n\t    'Array', 'ArrayBuffer', 'Date', 'Error', 'Float32Array', 'Float64Array',\n\t    'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Math', 'Number',\n\t    'Object', 'RegExp', 'Set', 'String', '_', 'clearTimeout', 'isFinite',\n\t    'parseFloat', 'parseInt', 'setTimeout', 'TypeError', 'Uint8Array',\n\t    'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap'\n\t  ];\n\t\n\t  /** Used to make template sourceURLs easier to identify. */\n\t  var templateCounter = -1;\n\t\n\t  /** Used to identify `toStringTag` values of typed arrays. */\n\t  var typedArrayTags = {};\n\t  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\n\t  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\n\t  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\n\t  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\n\t  typedArrayTags[uint32Tag] = true;\n\t  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =\n\t  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\n\t  typedArrayTags[dateTag] = typedArrayTags[errorTag] =\n\t  typedArrayTags[funcTag] = typedArrayTags[mapTag] =\n\t  typedArrayTags[numberTag] = typedArrayTags[objectTag] =\n\t  typedArrayTags[regexpTag] = typedArrayTags[setTag] =\n\t  typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;\n\t\n\t  /** Used to identify `toStringTag` values supported by `_.clone`. */\n\t  var cloneableTags = {};\n\t  cloneableTags[argsTag] = cloneableTags[arrayTag] =\n\t  cloneableTags[arrayBufferTag] = cloneableTags[boolTag] =\n\t  cloneableTags[dateTag] = cloneableTags[float32Tag] =\n\t  cloneableTags[float64Tag] = cloneableTags[int8Tag] =\n\t  cloneableTags[int16Tag] = cloneableTags[int32Tag] =\n\t  cloneableTags[numberTag] = cloneableTags[objectTag] =\n\t  cloneableTags[regexpTag] = cloneableTags[stringTag] =\n\t  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =\n\t  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;\n\t  cloneableTags[errorTag] = cloneableTags[funcTag] =\n\t  cloneableTags[mapTag] = cloneableTags[setTag] =\n\t  cloneableTags[weakMapTag] = false;\n\t\n\t  /** Used to map latin-1 supplementary letters to basic latin letters. */\n\t  var deburredLetters = {\n\t    '\\xc0': 'A',  '\\xc1': 'A', '\\xc2': 'A', '\\xc3': 'A', '\\xc4': 'A', '\\xc5': 'A',\n\t    '\\xe0': 'a',  '\\xe1': 'a', '\\xe2': 'a', '\\xe3': 'a', '\\xe4': 'a', '\\xe5': 'a',\n\t    '\\xc7': 'C',  '\\xe7': 'c',\n\t    '\\xd0': 'D',  '\\xf0': 'd',\n\t    '\\xc8': 'E',  '\\xc9': 'E', '\\xca': 'E', '\\xcb': 'E',\n\t    '\\xe8': 'e',  '\\xe9': 'e', '\\xea': 'e', '\\xeb': 'e',\n\t    '\\xcC': 'I',  '\\xcd': 'I', '\\xce': 'I', '\\xcf': 'I',\n\t    '\\xeC': 'i',  '\\xed': 'i', '\\xee': 'i', '\\xef': 'i',\n\t    '\\xd1': 'N',  '\\xf1': 'n',\n\t    '\\xd2': 'O',  '\\xd3': 'O', '\\xd4': 'O', '\\xd5': 'O', '\\xd6': 'O', '\\xd8': 'O',\n\t    '\\xf2': 'o',  '\\xf3': 'o', '\\xf4': 'o', '\\xf5': 'o', '\\xf6': 'o', '\\xf8': 'o',\n\t    '\\xd9': 'U',  '\\xda': 'U', '\\xdb': 'U', '\\xdc': 'U',\n\t    '\\xf9': 'u',  '\\xfa': 'u', '\\xfb': 'u', '\\xfc': 'u',\n\t    '\\xdd': 'Y',  '\\xfd': 'y', '\\xff': 'y',\n\t    '\\xc6': 'Ae', '\\xe6': 'ae',\n\t    '\\xde': 'Th', '\\xfe': 'th',\n\t    '\\xdf': 'ss'\n\t  };\n\t\n\t  /** Used to map characters to HTML entities. */\n\t  var htmlEscapes = {\n\t    '&': '&amp;',\n\t    '<': '&lt;',\n\t    '>': '&gt;',\n\t    '\"': '&quot;',\n\t    \"'\": '&#39;',\n\t    '`': '&#96;'\n\t  };\n\t\n\t  /** Used to map HTML entities to characters. */\n\t  var htmlUnescapes = {\n\t    '&amp;': '&',\n\t    '&lt;': '<',\n\t    '&gt;': '>',\n\t    '&quot;': '\"',\n\t    '&#39;': \"'\",\n\t    '&#96;': '`'\n\t  };\n\t\n\t  /** Used to determine if values are of the language type `Object`. */\n\t  var objectTypes = {\n\t    'function': true,\n\t    'object': true\n\t  };\n\t\n\t  /** Used to escape characters for inclusion in compiled regexes. */\n\t  var regexpEscapes = {\n\t    '0': 'x30', '1': 'x31', '2': 'x32', '3': 'x33', '4': 'x34',\n\t    '5': 'x35', '6': 'x36', '7': 'x37', '8': 'x38', '9': 'x39',\n\t    'A': 'x41', 'B': 'x42', 'C': 'x43', 'D': 'x44', 'E': 'x45', 'F': 'x46',\n\t    'a': 'x61', 'b': 'x62', 'c': 'x63', 'd': 'x64', 'e': 'x65', 'f': 'x66',\n\t    'n': 'x6e', 'r': 'x72', 't': 'x74', 'u': 'x75', 'v': 'x76', 'x': 'x78'\n\t  };\n\t\n\t  /** Used to escape characters for inclusion in compiled string literals. */\n\t  var stringEscapes = {\n\t    '\\\\': '\\\\',\n\t    \"'\": \"'\",\n\t    '\\n': 'n',\n\t    '\\r': 'r',\n\t    '\\u2028': 'u2028',\n\t    '\\u2029': 'u2029'\n\t  };\n\t\n\t  /** Detect free variable `exports`. */\n\t  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;\n\t\n\t  /** Detect free variable `module`. */\n\t  var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;\n\t\n\t  /** Detect free variable `global` from Node.js. */\n\t  var freeGlobal = freeExports && freeModule && typeof global == 'object' && global && global.Object && global;\n\t\n\t  /** Detect free variable `self`. */\n\t  var freeSelf = objectTypes[typeof self] && self && self.Object && self;\n\t\n\t  /** Detect free variable `window`. */\n\t  var freeWindow = objectTypes[typeof window] && window && window.Object && window;\n\t\n\t  /** Detect the popular CommonJS extension `module.exports`. */\n\t  var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;\n\t\n\t  /**\n\t   * Used as a reference to the global object.\n\t   *\n\t   * The `this` value is used if it's the global object to avoid Greasemonkey's\n\t   * restricted `window` object, otherwise the `window` object is used.\n\t   */\n\t  var root = freeGlobal || ((freeWindow !== (this && this.window)) && freeWindow) || freeSelf || this;\n\t\n\t  /*--------------------------------------------------------------------------*/\n\t\n\t  /**\n\t   * The base implementation of `compareAscending` which compares values and\n\t   * sorts them in ascending order without guaranteeing a stable sort.\n\t   *\n\t   * @private\n\t   * @param {*} value The value to compare.\n\t   * @param {*} other The other value to compare.\n\t   * @returns {number} Returns the sort order indicator for `value`.\n\t   */\n\t  function baseCompareAscending(value, other) {\n\t    if (value !== other) {\n\t      var valIsNull = value === null,\n\t          valIsUndef = value === undefined,\n\t          valIsReflexive = value === value;\n\t\n\t      var othIsNull = other === null,\n\t          othIsUndef = other === undefined,\n\t          othIsReflexive = other === other;\n\t\n\t      if ((value > other && !othIsNull) || !valIsReflexive ||\n\t          (valIsNull && !othIsUndef && othIsReflexive) ||\n\t          (valIsUndef && othIsReflexive)) {\n\t        return 1;\n\t      }\n\t      if ((value < other && !valIsNull) || !othIsReflexive ||\n\t          (othIsNull && !valIsUndef && valIsReflexive) ||\n\t          (othIsUndef && valIsReflexive)) {\n\t        return -1;\n\t      }\n\t    }\n\t    return 0;\n\t  }\n\t\n\t  /**\n\t   * The base implementation of `_.findIndex` and `_.findLastIndex` without\n\t   * support for callback shorthands and `this` binding.\n\t   *\n\t   * @private\n\t   * @param {Array} array The array to search.\n\t   * @param {Function} predicate The function invoked per iteration.\n\t   * @param {boolean} [fromRight] Specify iterating from right to left.\n\t   * @returns {number} Returns the index of the matched value, else `-1`.\n\t   */\n\t  function baseFindIndex(array, predicate, fromRight) {\n\t    var length = array.length,\n\t        index = fromRight ? length : -1;\n\t\n\t    while ((fromRight ? index-- : ++index < length)) {\n\t      if (predicate(array[index], index, array)) {\n\t        return index;\n\t      }\n\t    }\n\t    return -1;\n\t  }\n\t\n\t  /**\n\t   * The base implementation of `_.indexOf` without support for binary searches.\n\t   *\n\t   * @private\n\t   * @param {Array} array The array to search.\n\t   * @param {*} value The value to search for.\n\t   * @param {number} fromIndex The index to search from.\n\t   * @returns {number} Returns the index of the matched value, else `-1`.\n\t   */\n\t  function baseIndexOf(array, value, fromIndex) {\n\t    if (value !== value) {\n\t      return indexOfNaN(array, fromIndex);\n\t    }\n\t    var index = fromIndex - 1,\n\t        length = array.length;\n\t\n\t    while (++index < length) {\n\t      if (array[index] === value) {\n\t        return index;\n\t      }\n\t    }\n\t    return -1;\n\t  }\n\t\n\t  /**\n\t   * The base implementation of `_.isFunction` without support for environments\n\t   * with incorrect `typeof` results.\n\t   *\n\t   * @private\n\t   * @param {*} value The value to check.\n\t   * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n\t   */\n\t  function baseIsFunction(value) {\n\t    // Avoid a Chakra JIT bug in compatibility modes of IE 11.\n\t    // See https://github.com/jashkenas/underscore/issues/1621 for more details.\n\t    return typeof value == 'function' || false;\n\t  }\n\t\n\t  /**\n\t   * Converts `value` to a string if it's not one. An empty string is returned\n\t   * for `null` or `undefined` values.\n\t   *\n\t   * @private\n\t   * @param {*} value The value to process.\n\t   * @returns {string} Returns the string.\n\t   */\n\t  function baseToString(value) {\n\t    return value == null ? '' : (value + '');\n\t  }\n\t\n\t  /**\n\t   * Used by `_.trim` and `_.trimLeft` to get the index of the first character\n\t   * of `string` that is not found in `chars`.\n\t   *\n\t   * @private\n\t   * @param {string} string The string to inspect.\n\t   * @param {string} chars The characters to find.\n\t   * @returns {number} Returns the index of the first character not found in `chars`.\n\t   */\n\t  function charsLeftIndex(string, chars) {\n\t    var index = -1,\n\t        length = string.length;\n\t\n\t    while (++index < length && chars.indexOf(string.charAt(index)) > -1) {}\n\t    return index;\n\t  }\n\t\n\t  /**\n\t   * Used by `_.trim` and `_.trimRight` to get the index of the last character\n\t   * of `string` that is not found in `chars`.\n\t   *\n\t   * @private\n\t   * @param {string} string The string to inspect.\n\t   * @param {string} chars The characters to find.\n\t   * @returns {number} Returns the index of the last character not found in `chars`.\n\t   */\n\t  function charsRightIndex(string, chars) {\n\t    var index = string.length;\n\t\n\t    while (index-- && chars.indexOf(string.charAt(index)) > -1) {}\n\t    return index;\n\t  }\n\t\n\t  /**\n\t   * Used by `_.sortBy` to compare transformed elements of a collection and stable\n\t   * sort them in ascending order.\n\t   *\n\t   * @private\n\t   * @param {Object} object The object to compare.\n\t   * @param {Object} other The other object to compare.\n\t   * @returns {number} Returns the sort order indicator for `object`.\n\t   */\n\t  function compareAscending(object, other) {\n\t    return baseCompareAscending(object.criteria, other.criteria) || (object.index - other.index);\n\t  }\n\t\n\t  /**\n\t   * Used by `_.sortByOrder` to compare multiple properties of a value to another\n\t   * and stable sort them.\n\t   *\n\t   * If `orders` is unspecified, all valuess are sorted in ascending order. Otherwise,\n\t   * a value is sorted in ascending order if its corresponding order is \"asc\", and\n\t   * descending if \"desc\".\n\t   *\n\t   * @private\n\t   * @param {Object} object The object to compare.\n\t   * @param {Object} other The other object to compare.\n\t   * @param {boolean[]} orders The order to sort by for each property.\n\t   * @returns {number} Returns the sort order indicator for `object`.\n\t   */\n\t  function compareMultiple(object, other, orders) {\n\t    var index = -1,\n\t        objCriteria = object.criteria,\n\t        othCriteria = other.criteria,\n\t        length = objCriteria.length,\n\t        ordersLength = orders.length;\n\t\n\t    while (++index < length) {\n\t      var result = baseCompareAscending(objCriteria[index], othCriteria[index]);\n\t      if (result) {\n\t        if (index >= ordersLength) {\n\t          return result;\n\t        }\n\t        var order = orders[index];\n\t        return result * ((order === 'asc' || order === true) ? 1 : -1);\n\t      }\n\t    }\n\t    // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications\n\t    // that causes it, under certain circumstances, to provide the same value for\n\t    // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247\n\t    // for more details.\n\t    //\n\t    // This also ensures a stable sort in V8 and other engines.\n\t    // See https://code.google.com/p/v8/issues/detail?id=90 for more details.\n\t    return object.index - other.index;\n\t  }\n\t\n\t  /**\n\t   * Used by `_.deburr` to convert latin-1 supplementary letters to basic latin letters.\n\t   *\n\t   * @private\n\t   * @param {string} letter The matched letter to deburr.\n\t   * @returns {string} Returns the deburred letter.\n\t   */\n\t  function deburrLetter(letter) {\n\t    return deburredLetters[letter];\n\t  }\n\t\n\t  /**\n\t   * Used by `_.escape` to convert characters to HTML entities.\n\t   *\n\t   * @private\n\t   * @param {string} chr The matched character to escape.\n\t   * @returns {string} Returns the escaped character.\n\t   */\n\t  function escapeHtmlChar(chr) {\n\t    return htmlEscapes[chr];\n\t  }\n\t\n\t  /**\n\t   * Used by `_.escapeRegExp` to escape characters for inclusion in compiled regexes.\n\t   *\n\t   * @private\n\t   * @param {string} chr The matched character to escape.\n\t   * @param {string} leadingChar The capture group for a leading character.\n\t   * @param {string} whitespaceChar The capture group for a whitespace character.\n\t   * @returns {string} Returns the escaped character.\n\t   */\n\t  function escapeRegExpChar(chr, leadingChar, whitespaceChar) {\n\t    if (leadingChar) {\n\t      chr = regexpEscapes[chr];\n\t    } else if (whitespaceChar) {\n\t      chr = stringEscapes[chr];\n\t    }\n\t    return '\\\\' + chr;\n\t  }\n\t\n\t  /**\n\t   * Used by `_.template` to escape characters for inclusion in compiled string literals.\n\t   *\n\t   * @private\n\t   * @param {string} chr The matched character to escape.\n\t   * @returns {string} Returns the escaped character.\n\t   */\n\t  function escapeStringChar(chr) {\n\t    return '\\\\' + stringEscapes[chr];\n\t  }\n\t\n\t  /**\n\t   * Gets the index at which the first occurrence of `NaN` is found in `array`.\n\t   *\n\t   * @private\n\t   * @param {Array} array The array to search.\n\t   * @param {number} fromIndex The index to search from.\n\t   * @param {boolean} [fromRight] Specify iterating from right to left.\n\t   * @returns {number} Returns the index of the matched `NaN`, else `-1`.\n\t   */\n\t  function indexOfNaN(array, fromIndex, fromRight) {\n\t    var length = array.length,\n\t        index = fromIndex + (fromRight ? 0 : -1);\n\t\n\t    while ((fromRight ? index-- : ++index < length)) {\n\t      var other = array[index];\n\t      if (other !== other) {\n\t        return index;\n\t      }\n\t    }\n\t    return -1;\n\t  }\n\t\n\t  /**\n\t   * Checks if `value` is object-like.\n\t   *\n\t   * @private\n\t   * @param {*} value The value to check.\n\t   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n\t   */\n\t  function isObjectLike(value) {\n\t    return !!value && typeof value == 'object';\n\t  }\n\t\n\t  /**\n\t   * Used by `trimmedLeftIndex` and `trimmedRightIndex` to determine if a\n\t   * character code is whitespace.\n\t   *\n\t   * @private\n\t   * @param {number} charCode The character code to inspect.\n\t   * @returns {boolean} Returns `true` if `charCode` is whitespace, else `false`.\n\t   */\n\t  function isSpace(charCode) {\n\t    return ((charCode <= 160 && (charCode >= 9 && charCode <= 13) || charCode == 32 || charCode == 160) || charCode == 5760 || charCode == 6158 ||\n\t      (charCode >= 8192 && (charCode <= 8202 || charCode == 8232 || charCode == 8233 || charCode == 8239 || charCode == 8287 || charCode == 12288 || charCode == 65279)));\n\t  }\n\t\n\t  /**\n\t   * Replaces all `placeholder` elements in `array` with an internal placeholder\n\t   * and returns an array of their indexes.\n\t   *\n\t   * @private\n\t   * @param {Array} array The array to modify.\n\t   * @param {*} placeholder The placeholder to replace.\n\t   * @returns {Array} Returns the new array of placeholder indexes.\n\t   */\n\t  function replaceHolders(array, placeholder) {\n\t    var index = -1,\n\t        length = array.length,\n\t        resIndex = -1,\n\t        result = [];\n\t\n\t    while (++index < length) {\n\t      if (array[index] === placeholder) {\n\t        array[index] = PLACEHOLDER;\n\t        result[++resIndex] = index;\n\t      }\n\t    }\n\t    return result;\n\t  }\n\t\n\t  /**\n\t   * An implementation of `_.uniq` optimized for sorted arrays without support\n\t   * for callback shorthands and `this` binding.\n\t   *\n\t   * @private\n\t   * @param {Array} array The array to inspect.\n\t   * @param {Function} [iteratee] The function invoked per iteration.\n\t   * @returns {Array} Returns the new duplicate-value-free array.\n\t   */\n\t  function sortedUniq(array, iteratee) {\n\t    var seen,\n\t        index = -1,\n\t        length = array.length,\n\t        resIndex = -1,\n\t        result = [];\n\t\n\t    while (++index < length) {\n\t      var value = array[index],\n\t          computed = iteratee ? iteratee(value, index, array) : value;\n\t\n\t      if (!index || seen !== computed) {\n\t        seen = computed;\n\t        result[++resIndex] = value;\n\t      }\n\t    }\n\t    return result;\n\t  }\n\t\n\t  /**\n\t   * Used by `_.trim` and `_.trimLeft` to get the index of the first non-whitespace\n\t   * character of `string`.\n\t   *\n\t   * @private\n\t   * @param {string} string The string to inspect.\n\t   * @returns {number} Returns the index of the first non-whitespace character.\n\t   */\n\t  function trimmedLeftIndex(string) {\n\t    var index = -1,\n\t        length = string.length;\n\t\n\t    while (++index < length && isSpace(string.charCodeAt(index))) {}\n\t    return index;\n\t  }\n\t\n\t  /**\n\t   * Used by `_.trim` and `_.trimRight` to get the index of the last non-whitespace\n\t   * character of `string`.\n\t   *\n\t   * @private\n\t   * @param {string} string The string to inspect.\n\t   * @returns {number} Returns the index of the last non-whitespace character.\n\t   */\n\t  function trimmedRightIndex(string) {\n\t    var index = string.length;\n\t\n\t    while (index-- && isSpace(string.charCodeAt(index))) {}\n\t    return index;\n\t  }\n\t\n\t  /**\n\t   * Used by `_.unescape` to convert HTML entities to characters.\n\t   *\n\t   * @private\n\t   * @param {string} chr The matched character to unescape.\n\t   * @returns {string} Returns the unescaped character.\n\t   */\n\t  function unescapeHtmlChar(chr) {\n\t    return htmlUnescapes[chr];\n\t  }\n\t\n\t  /*--------------------------------------------------------------------------*/\n\t\n\t  /**\n\t   * Create a new pristine `lodash` function using the given `context` object.\n\t   *\n\t   * @static\n\t   * @memberOf _\n\t   * @category Utility\n\t   * @param {Object} [context=root] The context object.\n\t   * @returns {Function} Returns a new `lodash` function.\n\t   * @example\n\t   *\n\t   * _.mixin({ 'foo': _.constant('foo') });\n\t   *\n\t   * var lodash = _.runInContext();\n\t   * lodash.mixin({ 'bar': lodash.constant('bar') });\n\t   *\n\t   * _.isFunction(_.foo);\n\t   * // => true\n\t   * _.isFunction(_.bar);\n\t   * // => false\n\t   *\n\t   * lodash.isFunction(lodash.foo);\n\t   * // => false\n\t   * lodash.isFunction(lodash.bar);\n\t   * // => true\n\t   *\n\t   * // using `context` to mock `Date#getTime` use in `_.now`\n\t   * var mock = _.runInContext({\n\t   *   'Date': function() {\n\t   *     return { 'getTime': getTimeMock };\n\t   *   }\n\t   * });\n\t   *\n\t   * // or creating a suped-up `defer` in Node.js\n\t   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;\n\t   */\n\t  function runInContext(context) {\n\t    // Avoid issues with some ES3 environments that attempt to use values, named\n\t    // after built-in constructors like `Object`, for the creation of literals.\n\t    // ES5 clears this up by stating that literals must use built-in constructors.\n\t    // See https://es5.github.io/#x11.1.5 for more details.\n\t    context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;\n\t\n\t    /** Native constructor references. */\n\t    var Array = context.Array,\n\t        Date = context.Date,\n\t        Error = context.Error,\n\t        Function = context.Function,\n\t        Math = context.Math,\n\t        Number = context.Number,\n\t        Object = context.Object,\n\t        RegExp = context.RegExp,\n\t        String = context.String,\n\t        TypeError = context.TypeError;\n\t\n\t    /** Used for native method references. */\n\t    var arrayProto = Array.prototype,\n\t        objectProto = Object.prototype,\n\t        stringProto = String.prototype;\n\t\n\t    /** Used to resolve the decompiled source of functions. */\n\t    var fnToString = Function.prototype.toString;\n\t\n\t    /** Used to check objects for own properties. */\n\t    var hasOwnProperty = objectProto.hasOwnProperty;\n\t\n\t    /** Used to generate unique IDs. */\n\t    var idCounter = 0;\n\t\n\t    /**\n\t     * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\n\t     * of values.\n\t     */\n\t    var objToString = objectProto.toString;\n\t\n\t    /** Used to restore the original `_` reference in `_.noConflict`. */\n\t    var oldDash = root._;\n\t\n\t    /** Used to detect if a method is native. */\n\t    var reIsNative = RegExp('^' +\n\t      fnToString.call(hasOwnProperty).replace(/[\\\\^$.*+?()[\\]{}|]/g, '\\\\$&')\n\t      .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n\t    );\n\t\n\t    /** Native method references. */\n\t    var ArrayBuffer = context.ArrayBuffer,\n\t        clearTimeout = context.clearTimeout,\n\t        parseFloat = context.parseFloat,\n\t        pow = Math.pow,\n\t        propertyIsEnumerable = objectProto.propertyIsEnumerable,\n\t        Set = getNative(context, 'Set'),\n\t        setTimeout = context.setTimeout,\n\t        splice = arrayProto.splice,\n\t        Uint8Array = context.Uint8Array,\n\t        WeakMap = getNative(context, 'WeakMap');\n\t\n\t    /* Native method references for those with the same name as other `lodash` methods. */\n\t    var nativeCeil = Math.ceil,\n\t        nativeCreate = getNative(Object, 'create'),\n\t        nativeFloor = Math.floor,\n\t        nativeIsArray = getNative(Array, 'isArray'),\n\t        nativeIsFinite = context.isFinite,\n\t        nativeKeys = getNative(Object, 'keys'),\n\t        nativeMax = Math.max,\n\t        nativeMin = Math.min,\n\t        nativeNow = getNative(Date, 'now'),\n\t        nativeParseInt = context.parseInt,\n\t        nativeRandom = Math.random;\n\t\n\t    /** Used as references for `-Infinity` and `Infinity`. */\n\t    var NEGATIVE_INFINITY = Number.NEGATIVE_INFINITY,\n\t        POSITIVE_INFINITY = Number.POSITIVE_INFINITY;\n\t\n\t    /** Used as references for the maximum length and index of an array. */\n\t    var MAX_ARRAY_LENGTH = 4294967295,\n\t        MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,\n\t        HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;\n\t\n\t    /**\n\t     * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)\n\t     * of an array-like value.\n\t     */\n\t    var MAX_SAFE_INTEGER = 9007199254740991;\n\t\n\t    /** Used to store function metadata. */\n\t    var metaMap = WeakMap && new WeakMap;\n\t\n\t    /** Used to lookup unminified function names. */\n\t    var realNames = {};\n\t\n\t    /*------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * Creates a `lodash` object which wraps `value` to enable implicit chaining.\n\t     * Methods that operate on and return arrays, collections, and functions can\n\t     * be chained together. Methods that retrieve a single value or may return a\n\t     * primitive value will automatically end the chain returning the unwrapped\n\t     * value. Explicit chaining may be enabled using `_.chain`. The execution of\n\t     * chained methods is lazy, that is, execution is deferred until `_#value`\n\t     * is implicitly or explicitly called.\n\t     *\n\t     * Lazy evaluation allows several methods to support shortcut fusion. Shortcut\n\t     * fusion is an optimization strategy which merge iteratee calls; this can help\n\t     * to avoid the creation of intermediate data structures and greatly reduce the\n\t     * number of iteratee executions.\n\t     *\n\t     * Chaining is supported in custom builds as long as the `_#value` method is\n\t     * directly or indirectly included in the build.\n\t     *\n\t     * In addition to lodash methods, wrappers have `Array` and `String` methods.\n\t     *\n\t     * The wrapper `Array` methods are:\n\t     * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`,\n\t     * `splice`, and `unshift`\n\t     *\n\t     * The wrapper `String` methods are:\n\t     * `replace` and `split`\n\t     *\n\t     * The wrapper methods that support shortcut fusion are:\n\t     * `compact`, `drop`, `dropRight`, `dropRightWhile`, `dropWhile`, `filter`,\n\t     * `first`, `initial`, `last`, `map`, `pluck`, `reject`, `rest`, `reverse`,\n\t     * `slice`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, `toArray`,\n\t     * and `where`\n\t     *\n\t     * The chainable wrapper methods are:\n\t     * `after`, `ary`, `assign`, `at`, `before`, `bind`, `bindAll`, `bindKey`,\n\t     * `callback`, `chain`, `chunk`, `commit`, `compact`, `concat`, `constant`,\n\t     * `countBy`, `create`, `curry`, `debounce`, `defaults`, `defaultsDeep`,\n\t     * `defer`, `delay`, `difference`, `drop`, `dropRight`, `dropRightWhile`,\n\t     * `dropWhile`, `fill`, `filter`, `flatten`, `flattenDeep`, `flow`, `flowRight`,\n\t     * `forEach`, `forEachRight`, `forIn`, `forInRight`, `forOwn`, `forOwnRight`,\n\t     * `functions`, `groupBy`, `indexBy`, `initial`, `intersection`, `invert`,\n\t     * `invoke`, `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`,\n\t     * `matchesProperty`, `memoize`, `merge`, `method`, `methodOf`, `mixin`,\n\t     * `modArgs`, `negate`, `omit`, `once`, `pairs`, `partial`, `partialRight`,\n\t     * `partition`, `pick`, `plant`, `pluck`, `property`, `propertyOf`, `pull`,\n\t     * `pullAt`, `push`, `range`, `rearg`, `reject`, `remove`, `rest`, `restParam`,\n\t     * `reverse`, `set`, `shuffle`, `slice`, `sort`, `sortBy`, `sortByAll`,\n\t     * `sortByOrder`, `splice`, `spread`, `take`, `takeRight`, `takeRightWhile`,\n\t     * `takeWhile`, `tap`, `throttle`, `thru`, `times`, `toArray`, `toPlainObject`,\n\t     * `transform`, `union`, `uniq`, `unshift`, `unzip`, `unzipWith`, `values`,\n\t     * `valuesIn`, `where`, `without`, `wrap`, `xor`, `zip`, `zipObject`, `zipWith`\n\t     *\n\t     * The wrapper methods that are **not** chainable by default are:\n\t     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clone`, `cloneDeep`,\n\t     * `deburr`, `endsWith`, `escape`, `escapeRegExp`, `every`, `find`, `findIndex`,\n\t     * `findKey`, `findLast`, `findLastIndex`, `findLastKey`, `findWhere`, `first`,\n\t     * `floor`, `get`, `gt`, `gte`, `has`, `identity`, `includes`, `indexOf`,\n\t     * `inRange`, `isArguments`, `isArray`, `isBoolean`, `isDate`, `isElement`,\n\t     * `isEmpty`, `isEqual`, `isError`, `isFinite` `isFunction`, `isMatch`,\n\t     * `isNative`, `isNaN`, `isNull`, `isNumber`, `isObject`, `isPlainObject`,\n\t     * `isRegExp`, `isString`, `isUndefined`, `isTypedArray`, `join`, `kebabCase`,\n\t     * `last`, `lastIndexOf`, `lt`, `lte`, `max`, `min`, `noConflict`, `noop`,\n\t     * `now`, `pad`, `padLeft`, `padRight`, `parseInt`, `pop`, `random`, `reduce`,\n\t     * `reduceRight`, `repeat`, `result`, `round`, `runInContext`, `shift`, `size`,\n\t     * `snakeCase`, `some`, `sortedIndex`, `sortedLastIndex`, `startCase`,\n\t     * `startsWith`, `sum`, `template`, `trim`, `trimLeft`, `trimRight`, `trunc`,\n\t     * `unescape`, `uniqueId`, `value`, and `words`\n\t     *\n\t     * The wrapper method `sample` will return a wrapped value when `n` is provided,\n\t     * otherwise an unwrapped value is returned.\n\t     *\n\t     * @name _\n\t     * @constructor\n\t     * @category Chain\n\t     * @param {*} value The value to wrap in a `lodash` instance.\n\t     * @returns {Object} Returns the new `lodash` wrapper instance.\n\t     * @example\n\t     *\n\t     * var wrapped = _([1, 2, 3]);\n\t     *\n\t     * // returns an unwrapped value\n\t     * wrapped.reduce(function(total, n) {\n\t     *   return total + n;\n\t     * });\n\t     * // => 6\n\t     *\n\t     * // returns a wrapped value\n\t     * var squares = wrapped.map(function(n) {\n\t     *   return n * n;\n\t     * });\n\t     *\n\t     * _.isArray(squares);\n\t     * // => false\n\t     *\n\t     * _.isArray(squares.value());\n\t     * // => true\n\t     */\n\t    function lodash(value) {\n\t      if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {\n\t        if (value instanceof LodashWrapper) {\n\t          return value;\n\t        }\n\t        if (hasOwnProperty.call(value, '__chain__') && hasOwnProperty.call(value, '__wrapped__')) {\n\t          return wrapperClone(value);\n\t        }\n\t      }\n\t      return new LodashWrapper(value);\n\t    }\n\t\n\t    /**\n\t     * The function whose prototype all chaining wrappers inherit from.\n\t     *\n\t     * @private\n\t     */\n\t    function baseLodash() {\n\t      // No operation performed.\n\t    }\n\t\n\t    /**\n\t     * The base constructor for creating `lodash` wrapper objects.\n\t     *\n\t     * @private\n\t     * @param {*} value The value to wrap.\n\t     * @param {boolean} [chainAll] Enable chaining for all wrapper methods.\n\t     * @param {Array} [actions=[]] Actions to peform to resolve the unwrapped value.\n\t     */\n\t    function LodashWrapper(value, chainAll, actions) {\n\t      this.__wrapped__ = value;\n\t      this.__actions__ = actions || [];\n\t      this.__chain__ = !!chainAll;\n\t    }\n\t\n\t    /**\n\t     * An object environment feature flags.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @type Object\n\t     */\n\t    var support = lodash.support = {};\n\t\n\t    /**\n\t     * By default, the template delimiters used by lodash are like those in\n\t     * embedded Ruby (ERB). Change the following template settings to use\n\t     * alternative delimiters.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @type Object\n\t     */\n\t    lodash.templateSettings = {\n\t\n\t      /**\n\t       * Used to detect `data` property values to be HTML-escaped.\n\t       *\n\t       * @memberOf _.templateSettings\n\t       * @type RegExp\n\t       */\n\t      'escape': reEscape,\n\t\n\t      /**\n\t       * Used to detect code to be evaluated.\n\t       *\n\t       * @memberOf _.templateSettings\n\t       * @type RegExp\n\t       */\n\t      'evaluate': reEvaluate,\n\t\n\t      /**\n\t       * Used to detect `data` property values to inject.\n\t       *\n\t       * @memberOf _.templateSettings\n\t       * @type RegExp\n\t       */\n\t      'interpolate': reInterpolate,\n\t\n\t      /**\n\t       * Used to reference the data object in the template text.\n\t       *\n\t       * @memberOf _.templateSettings\n\t       * @type string\n\t       */\n\t      'variable': '',\n\t\n\t      /**\n\t       * Used to import variables into the compiled template.\n\t       *\n\t       * @memberOf _.templateSettings\n\t       * @type Object\n\t       */\n\t      'imports': {\n\t\n\t        /**\n\t         * A reference to the `lodash` function.\n\t         *\n\t         * @memberOf _.templateSettings.imports\n\t         * @type Function\n\t         */\n\t        '_': lodash\n\t      }\n\t    };\n\t\n\t    /*------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.\n\t     *\n\t     * @private\n\t     * @param {*} value The value to wrap.\n\t     */\n\t    function LazyWrapper(value) {\n\t      this.__wrapped__ = value;\n\t      this.__actions__ = [];\n\t      this.__dir__ = 1;\n\t      this.__filtered__ = false;\n\t      this.__iteratees__ = [];\n\t      this.__takeCount__ = POSITIVE_INFINITY;\n\t      this.__views__ = [];\n\t    }\n\t\n\t    /**\n\t     * Creates a clone of the lazy wrapper object.\n\t     *\n\t     * @private\n\t     * @name clone\n\t     * @memberOf LazyWrapper\n\t     * @returns {Object} Returns the cloned `LazyWrapper` object.\n\t     */\n\t    function lazyClone() {\n\t      var result = new LazyWrapper(this.__wrapped__);\n\t      result.__actions__ = arrayCopy(this.__actions__);\n\t      result.__dir__ = this.__dir__;\n\t      result.__filtered__ = this.__filtered__;\n\t      result.__iteratees__ = arrayCopy(this.__iteratees__);\n\t      result.__takeCount__ = this.__takeCount__;\n\t      result.__views__ = arrayCopy(this.__views__);\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * Reverses the direction of lazy iteration.\n\t     *\n\t     * @private\n\t     * @name reverse\n\t     * @memberOf LazyWrapper\n\t     * @returns {Object} Returns the new reversed `LazyWrapper` object.\n\t     */\n\t    function lazyReverse() {\n\t      if (this.__filtered__) {\n\t        var result = new LazyWrapper(this);\n\t        result.__dir__ = -1;\n\t        result.__filtered__ = true;\n\t      } else {\n\t        result = this.clone();\n\t        result.__dir__ *= -1;\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * Extracts the unwrapped value from its lazy wrapper.\n\t     *\n\t     * @private\n\t     * @name value\n\t     * @memberOf LazyWrapper\n\t     * @returns {*} Returns the unwrapped value.\n\t     */\n\t    function lazyValue() {\n\t      var array = this.__wrapped__.value(),\n\t          dir = this.__dir__,\n\t          isArr = isArray(array),\n\t          isRight = dir < 0,\n\t          arrLength = isArr ? array.length : 0,\n\t          view = getView(0, arrLength, this.__views__),\n\t          start = view.start,\n\t          end = view.end,\n\t          length = end - start,\n\t          index = isRight ? end : (start - 1),\n\t          iteratees = this.__iteratees__,\n\t          iterLength = iteratees.length,\n\t          resIndex = 0,\n\t          takeCount = nativeMin(length, this.__takeCount__);\n\t\n\t      if (!isArr || arrLength < LARGE_ARRAY_SIZE || (arrLength == length && takeCount == length)) {\n\t        return baseWrapperValue((isRight && isArr) ? array.reverse() : array, this.__actions__);\n\t      }\n\t      var result = [];\n\t\n\t      outer:\n\t      while (length-- && resIndex < takeCount) {\n\t        index += dir;\n\t\n\t        var iterIndex = -1,\n\t            value = array[index];\n\t\n\t        while (++iterIndex < iterLength) {\n\t          var data = iteratees[iterIndex],\n\t              iteratee = data.iteratee,\n\t              type = data.type,\n\t              computed = iteratee(value);\n\t\n\t          if (type == LAZY_MAP_FLAG) {\n\t            value = computed;\n\t          } else if (!computed) {\n\t            if (type == LAZY_FILTER_FLAG) {\n\t              continue outer;\n\t            } else {\n\t              break outer;\n\t            }\n\t          }\n\t        }\n\t        result[resIndex++] = value;\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /*------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * Creates a cache object to store key/value pairs.\n\t     *\n\t     * @private\n\t     * @static\n\t     * @name Cache\n\t     * @memberOf _.memoize\n\t     */\n\t    function MapCache() {\n\t      this.__data__ = {};\n\t    }\n\t\n\t    /**\n\t     * Removes `key` and its value from the cache.\n\t     *\n\t     * @private\n\t     * @name delete\n\t     * @memberOf _.memoize.Cache\n\t     * @param {string} key The key of the value to remove.\n\t     * @returns {boolean} Returns `true` if the entry was removed successfully, else `false`.\n\t     */\n\t    function mapDelete(key) {\n\t      return this.has(key) && delete this.__data__[key];\n\t    }\n\t\n\t    /**\n\t     * Gets the cached value for `key`.\n\t     *\n\t     * @private\n\t     * @name get\n\t     * @memberOf _.memoize.Cache\n\t     * @param {string} key The key of the value to get.\n\t     * @returns {*} Returns the cached value.\n\t     */\n\t    function mapGet(key) {\n\t      return key == '__proto__' ? undefined : this.__data__[key];\n\t    }\n\t\n\t    /**\n\t     * Checks if a cached value for `key` exists.\n\t     *\n\t     * @private\n\t     * @name has\n\t     * @memberOf _.memoize.Cache\n\t     * @param {string} key The key of the entry to check.\n\t     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n\t     */\n\t    function mapHas(key) {\n\t      return key != '__proto__' && hasOwnProperty.call(this.__data__, key);\n\t    }\n\t\n\t    /**\n\t     * Sets `value` to `key` of the cache.\n\t     *\n\t     * @private\n\t     * @name set\n\t     * @memberOf _.memoize.Cache\n\t     * @param {string} key The key of the value to cache.\n\t     * @param {*} value The value to cache.\n\t     * @returns {Object} Returns the cache object.\n\t     */\n\t    function mapSet(key, value) {\n\t      if (key != '__proto__') {\n\t        this.__data__[key] = value;\n\t      }\n\t      return this;\n\t    }\n\t\n\t    /*------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     *\n\t     * Creates a cache object to store unique values.\n\t     *\n\t     * @private\n\t     * @param {Array} [values] The values to cache.\n\t     */\n\t    function SetCache(values) {\n\t      var length = values ? values.length : 0;\n\t\n\t      this.data = { 'hash': nativeCreate(null), 'set': new Set };\n\t      while (length--) {\n\t        this.push(values[length]);\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is in `cache` mimicking the return signature of\n\t     * `_.indexOf` by returning `0` if the value is found, else `-1`.\n\t     *\n\t     * @private\n\t     * @param {Object} cache The cache to search.\n\t     * @param {*} value The value to search for.\n\t     * @returns {number} Returns `0` if `value` is found, else `-1`.\n\t     */\n\t    function cacheIndexOf(cache, value) {\n\t      var data = cache.data,\n\t          result = (typeof value == 'string' || isObject(value)) ? data.set.has(value) : data.hash[value];\n\t\n\t      return result ? 0 : -1;\n\t    }\n\t\n\t    /**\n\t     * Adds `value` to the cache.\n\t     *\n\t     * @private\n\t     * @name push\n\t     * @memberOf SetCache\n\t     * @param {*} value The value to cache.\n\t     */\n\t    function cachePush(value) {\n\t      var data = this.data;\n\t      if (typeof value == 'string' || isObject(value)) {\n\t        data.set.add(value);\n\t      } else {\n\t        data.hash[value] = true;\n\t      }\n\t    }\n\t\n\t    /*------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * Creates a new array joining `array` with `other`.\n\t     *\n\t     * @private\n\t     * @param {Array} array The array to join.\n\t     * @param {Array} other The other array to join.\n\t     * @returns {Array} Returns the new concatenated array.\n\t     */\n\t    function arrayConcat(array, other) {\n\t      var index = -1,\n\t          length = array.length,\n\t          othIndex = -1,\n\t          othLength = other.length,\n\t          result = Array(length + othLength);\n\t\n\t      while (++index < length) {\n\t        result[index] = array[index];\n\t      }\n\t      while (++othIndex < othLength) {\n\t        result[index++] = other[othIndex];\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * Copies the values of `source` to `array`.\n\t     *\n\t     * @private\n\t     * @param {Array} source The array to copy values from.\n\t     * @param {Array} [array=[]] The array to copy values to.\n\t     * @returns {Array} Returns `array`.\n\t     */\n\t    function arrayCopy(source, array) {\n\t      var index = -1,\n\t          length = source.length;\n\t\n\t      array || (array = Array(length));\n\t      while (++index < length) {\n\t        array[index] = source[index];\n\t      }\n\t      return array;\n\t    }\n\t\n\t    /**\n\t     * A specialized version of `_.forEach` for arrays without support for callback\n\t     * shorthands and `this` binding.\n\t     *\n\t     * @private\n\t     * @param {Array} array The array to iterate over.\n\t     * @param {Function} iteratee The function invoked per iteration.\n\t     * @returns {Array} Returns `array`.\n\t     */\n\t    function arrayEach(array, iteratee) {\n\t      var index = -1,\n\t          length = array.length;\n\t\n\t      while (++index < length) {\n\t        if (iteratee(array[index], index, array) === false) {\n\t          break;\n\t        }\n\t      }\n\t      return array;\n\t    }\n\t\n\t    /**\n\t     * A specialized version of `_.forEachRight` for arrays without support for\n\t     * callback shorthands and `this` binding.\n\t     *\n\t     * @private\n\t     * @param {Array} array The array to iterate over.\n\t     * @param {Function} iteratee The function invoked per iteration.\n\t     * @returns {Array} Returns `array`.\n\t     */\n\t    function arrayEachRight(array, iteratee) {\n\t      var length = array.length;\n\t\n\t      while (length--) {\n\t        if (iteratee(array[length], length, array) === false) {\n\t          break;\n\t        }\n\t      }\n\t      return array;\n\t    }\n\t\n\t    /**\n\t     * A specialized version of `_.every` for arrays without support for callback\n\t     * shorthands and `this` binding.\n\t     *\n\t     * @private\n\t     * @param {Array} array The array to iterate over.\n\t     * @param {Function} predicate The function invoked per iteration.\n\t     * @returns {boolean} Returns `true` if all elements pass the predicate check,\n\t     *  else `false`.\n\t     */\n\t    function arrayEvery(array, predicate) {\n\t      var index = -1,\n\t          length = array.length;\n\t\n\t      while (++index < length) {\n\t        if (!predicate(array[index], index, array)) {\n\t          return false;\n\t        }\n\t      }\n\t      return true;\n\t    }\n\t\n\t    /**\n\t     * A specialized version of `baseExtremum` for arrays which invokes `iteratee`\n\t     * with one argument: (value).\n\t     *\n\t     * @private\n\t     * @param {Array} array The array to iterate over.\n\t     * @param {Function} iteratee The function invoked per iteration.\n\t     * @param {Function} comparator The function used to compare values.\n\t     * @param {*} exValue The initial extremum value.\n\t     * @returns {*} Returns the extremum value.\n\t     */\n\t    function arrayExtremum(array, iteratee, comparator, exValue) {\n\t      var index = -1,\n\t          length = array.length,\n\t          computed = exValue,\n\t          result = computed;\n\t\n\t      while (++index < length) {\n\t        var value = array[index],\n\t            current = +iteratee(value);\n\t\n\t        if (comparator(current, computed)) {\n\t          computed = current;\n\t          result = value;\n\t        }\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * A specialized version of `_.filter` for arrays without support for callback\n\t     * shorthands and `this` binding.\n\t     *\n\t     * @private\n\t     * @param {Array} array The array to iterate over.\n\t     * @param {Function} predicate The function invoked per iteration.\n\t     * @returns {Array} Returns the new filtered array.\n\t     */\n\t    function arrayFilter(array, predicate) {\n\t      var index = -1,\n\t          length = array.length,\n\t          resIndex = -1,\n\t          result = [];\n\t\n\t      while (++index < length) {\n\t        var value = array[index];\n\t        if (predicate(value, index, array)) {\n\t          result[++resIndex] = value;\n\t        }\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * A specialized version of `_.map` for arrays without support for callback\n\t     * shorthands and `this` binding.\n\t     *\n\t     * @private\n\t     * @param {Array} array The array to iterate over.\n\t     * @param {Function} iteratee The function invoked per iteration.\n\t     * @returns {Array} Returns the new mapped array.\n\t     */\n\t    function arrayMap(array, iteratee) {\n\t      var index = -1,\n\t          length = array.length,\n\t          result = Array(length);\n\t\n\t      while (++index < length) {\n\t        result[index] = iteratee(array[index], index, array);\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * Appends the elements of `values` to `array`.\n\t     *\n\t     * @private\n\t     * @param {Array} array The array to modify.\n\t     * @param {Array} values The values to append.\n\t     * @returns {Array} Returns `array`.\n\t     */\n\t    function arrayPush(array, values) {\n\t      var index = -1,\n\t          length = values.length,\n\t          offset = array.length;\n\t\n\t      while (++index < length) {\n\t        array[offset + index] = values[index];\n\t      }\n\t      return array;\n\t    }\n\t\n\t    /**\n\t     * A specialized version of `_.reduce` for arrays without support for callback\n\t     * shorthands and `this` binding.\n\t     *\n\t     * @private\n\t     * @param {Array} array The array to iterate over.\n\t     * @param {Function} iteratee The function invoked per iteration.\n\t     * @param {*} [accumulator] The initial value.\n\t     * @param {boolean} [initFromArray] Specify using the first element of `array`\n\t     *  as the initial value.\n\t     * @returns {*} Returns the accumulated value.\n\t     */\n\t    function arrayReduce(array, iteratee, accumulator, initFromArray) {\n\t      var index = -1,\n\t          length = array.length;\n\t\n\t      if (initFromArray && length) {\n\t        accumulator = array[++index];\n\t      }\n\t      while (++index < length) {\n\t        accumulator = iteratee(accumulator, array[index], index, array);\n\t      }\n\t      return accumulator;\n\t    }\n\t\n\t    /**\n\t     * A specialized version of `_.reduceRight` for arrays without support for\n\t     * callback shorthands and `this` binding.\n\t     *\n\t     * @private\n\t     * @param {Array} array The array to iterate over.\n\t     * @param {Function} iteratee The function invoked per iteration.\n\t     * @param {*} [accumulator] The initial value.\n\t     * @param {boolean} [initFromArray] Specify using the last element of `array`\n\t     *  as the initial value.\n\t     * @returns {*} Returns the accumulated value.\n\t     */\n\t    function arrayReduceRight(array, iteratee, accumulator, initFromArray) {\n\t      var length = array.length;\n\t      if (initFromArray && length) {\n\t        accumulator = array[--length];\n\t      }\n\t      while (length--) {\n\t        accumulator = iteratee(accumulator, array[length], length, array);\n\t      }\n\t      return accumulator;\n\t    }\n\t\n\t    /**\n\t     * A specialized version of `_.some` for arrays without support for callback\n\t     * shorthands and `this` binding.\n\t     *\n\t     * @private\n\t     * @param {Array} array The array to iterate over.\n\t     * @param {Function} predicate The function invoked per iteration.\n\t     * @returns {boolean} Returns `true` if any element passes the predicate check,\n\t     *  else `false`.\n\t     */\n\t    function arraySome(array, predicate) {\n\t      var index = -1,\n\t          length = array.length;\n\t\n\t      while (++index < length) {\n\t        if (predicate(array[index], index, array)) {\n\t          return true;\n\t        }\n\t      }\n\t      return false;\n\t    }\n\t\n\t    /**\n\t     * A specialized version of `_.sum` for arrays without support for callback\n\t     * shorthands and `this` binding..\n\t     *\n\t     * @private\n\t     * @param {Array} array The array to iterate over.\n\t     * @param {Function} iteratee The function invoked per iteration.\n\t     * @returns {number} Returns the sum.\n\t     */\n\t    function arraySum(array, iteratee) {\n\t      var length = array.length,\n\t          result = 0;\n\t\n\t      while (length--) {\n\t        result += +iteratee(array[length]) || 0;\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * Used by `_.defaults` to customize its `_.assign` use.\n\t     *\n\t     * @private\n\t     * @param {*} objectValue The destination object property value.\n\t     * @param {*} sourceValue The source object property value.\n\t     * @returns {*} Returns the value to assign to the destination object.\n\t     */\n\t    function assignDefaults(objectValue, sourceValue) {\n\t      return objectValue === undefined ? sourceValue : objectValue;\n\t    }\n\t\n\t    /**\n\t     * Used by `_.template` to customize its `_.assign` use.\n\t     *\n\t     * **Note:** This function is like `assignDefaults` except that it ignores\n\t     * inherited property values when checking if a property is `undefined`.\n\t     *\n\t     * @private\n\t     * @param {*} objectValue The destination object property value.\n\t     * @param {*} sourceValue The source object property value.\n\t     * @param {string} key The key associated with the object and source values.\n\t     * @param {Object} object The destination object.\n\t     * @returns {*} Returns the value to assign to the destination object.\n\t     */\n\t    function assignOwnDefaults(objectValue, sourceValue, key, object) {\n\t      return (objectValue === undefined || !hasOwnProperty.call(object, key))\n\t        ? sourceValue\n\t        : objectValue;\n\t    }\n\t\n\t    /**\n\t     * A specialized version of `_.assign` for customizing assigned values without\n\t     * support for argument juggling, multiple sources, and `this` binding `customizer`\n\t     * functions.\n\t     *\n\t     * @private\n\t     * @param {Object} object The destination object.\n\t     * @param {Object} source The source object.\n\t     * @param {Function} customizer The function to customize assigned values.\n\t     * @returns {Object} Returns `object`.\n\t     */\n\t    function assignWith(object, source, customizer) {\n\t      var index = -1,\n\t          props = keys(source),\n\t          length = props.length;\n\t\n\t      while (++index < length) {\n\t        var key = props[index],\n\t            value = object[key],\n\t            result = customizer(value, source[key], key, object, source);\n\t\n\t        if ((result === result ? (result !== value) : (value === value)) ||\n\t            (value === undefined && !(key in object))) {\n\t          object[key] = result;\n\t        }\n\t      }\n\t      return object;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.assign` without support for argument juggling,\n\t     * multiple sources, and `customizer` functions.\n\t     *\n\t     * @private\n\t     * @param {Object} object The destination object.\n\t     * @param {Object} source The source object.\n\t     * @returns {Object} Returns `object`.\n\t     */\n\t    function baseAssign(object, source) {\n\t      return source == null\n\t        ? object\n\t        : baseCopy(source, keys(source), object);\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.at` without support for string collections\n\t     * and individual key arguments.\n\t     *\n\t     * @private\n\t     * @param {Array|Object} collection The collection to iterate over.\n\t     * @param {number[]|string[]} props The property names or indexes of elements to pick.\n\t     * @returns {Array} Returns the new array of picked elements.\n\t     */\n\t    function baseAt(collection, props) {\n\t      var index = -1,\n\t          isNil = collection == null,\n\t          isArr = !isNil && isArrayLike(collection),\n\t          length = isArr ? collection.length : 0,\n\t          propsLength = props.length,\n\t          result = Array(propsLength);\n\t\n\t      while(++index < propsLength) {\n\t        var key = props[index];\n\t        if (isArr) {\n\t          result[index] = isIndex(key, length) ? collection[key] : undefined;\n\t        } else {\n\t          result[index] = isNil ? undefined : collection[key];\n\t        }\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * Copies properties of `source` to `object`.\n\t     *\n\t     * @private\n\t     * @param {Object} source The object to copy properties from.\n\t     * @param {Array} props The property names to copy.\n\t     * @param {Object} [object={}] The object to copy properties to.\n\t     * @returns {Object} Returns `object`.\n\t     */\n\t    function baseCopy(source, props, object) {\n\t      object || (object = {});\n\t\n\t      var index = -1,\n\t          length = props.length;\n\t\n\t      while (++index < length) {\n\t        var key = props[index];\n\t        object[key] = source[key];\n\t      }\n\t      return object;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.callback` which supports specifying the\n\t     * number of arguments to provide to `func`.\n\t     *\n\t     * @private\n\t     * @param {*} [func=_.identity] The value to convert to a callback.\n\t     * @param {*} [thisArg] The `this` binding of `func`.\n\t     * @param {number} [argCount] The number of arguments to provide to `func`.\n\t     * @returns {Function} Returns the callback.\n\t     */\n\t    function baseCallback(func, thisArg, argCount) {\n\t      var type = typeof func;\n\t      if (type == 'function') {\n\t        return thisArg === undefined\n\t          ? func\n\t          : bindCallback(func, thisArg, argCount);\n\t      }\n\t      if (func == null) {\n\t        return identity;\n\t      }\n\t      if (type == 'object') {\n\t        return baseMatches(func);\n\t      }\n\t      return thisArg === undefined\n\t        ? property(func)\n\t        : baseMatchesProperty(func, thisArg);\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.clone` without support for argument juggling\n\t     * and `this` binding `customizer` functions.\n\t     *\n\t     * @private\n\t     * @param {*} value The value to clone.\n\t     * @param {boolean} [isDeep] Specify a deep clone.\n\t     * @param {Function} [customizer] The function to customize cloning values.\n\t     * @param {string} [key] The key of `value`.\n\t     * @param {Object} [object] The object `value` belongs to.\n\t     * @param {Array} [stackA=[]] Tracks traversed source objects.\n\t     * @param {Array} [stackB=[]] Associates clones with source counterparts.\n\t     * @returns {*} Returns the cloned value.\n\t     */\n\t    function baseClone(value, isDeep, customizer, key, object, stackA, stackB) {\n\t      var result;\n\t      if (customizer) {\n\t        result = object ? customizer(value, key, object) : customizer(value);\n\t      }\n\t      if (result !== undefined) {\n\t        return result;\n\t      }\n\t      if (!isObject(value)) {\n\t        return value;\n\t      }\n\t      var isArr = isArray(value);\n\t      if (isArr) {\n\t        result = initCloneArray(value);\n\t        if (!isDeep) {\n\t          return arrayCopy(value, result);\n\t        }\n\t      } else {\n\t        var tag = objToString.call(value),\n\t            isFunc = tag == funcTag;\n\t\n\t        if (tag == objectTag || tag == argsTag || (isFunc && !object)) {\n\t          result = initCloneObject(isFunc ? {} : value);\n\t          if (!isDeep) {\n\t            return baseAssign(result, value);\n\t          }\n\t        } else {\n\t          return cloneableTags[tag]\n\t            ? initCloneByTag(value, tag, isDeep)\n\t            : (object ? value : {});\n\t        }\n\t      }\n\t      // Check for circular references and return its corresponding clone.\n\t      stackA || (stackA = []);\n\t      stackB || (stackB = []);\n\t\n\t      var length = stackA.length;\n\t      while (length--) {\n\t        if (stackA[length] == value) {\n\t          return stackB[length];\n\t        }\n\t      }\n\t      // Add the source value to the stack of traversed objects and associate it with its clone.\n\t      stackA.push(value);\n\t      stackB.push(result);\n\t\n\t      // Recursively populate clone (susceptible to call stack limits).\n\t      (isArr ? arrayEach : baseForOwn)(value, function(subValue, key) {\n\t        result[key] = baseClone(subValue, isDeep, customizer, key, value, stackA, stackB);\n\t      });\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.create` without support for assigning\n\t     * properties to the created object.\n\t     *\n\t     * @private\n\t     * @param {Object} prototype The object to inherit from.\n\t     * @returns {Object} Returns the new object.\n\t     */\n\t    var baseCreate = (function() {\n\t      function object() {}\n\t      return function(prototype) {\n\t        if (isObject(prototype)) {\n\t          object.prototype = prototype;\n\t          var result = new object;\n\t          object.prototype = undefined;\n\t        }\n\t        return result || {};\n\t      };\n\t    }());\n\t\n\t    /**\n\t     * The base implementation of `_.delay` and `_.defer` which accepts an index\n\t     * of where to slice the arguments to provide to `func`.\n\t     *\n\t     * @private\n\t     * @param {Function} func The function to delay.\n\t     * @param {number} wait The number of milliseconds to delay invocation.\n\t     * @param {Object} args The arguments provide to `func`.\n\t     * @returns {number} Returns the timer id.\n\t     */\n\t    function baseDelay(func, wait, args) {\n\t      if (typeof func != 'function') {\n\t        throw new TypeError(FUNC_ERROR_TEXT);\n\t      }\n\t      return setTimeout(function() { func.apply(undefined, args); }, wait);\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.difference` which accepts a single array\n\t     * of values to exclude.\n\t     *\n\t     * @private\n\t     * @param {Array} array The array to inspect.\n\t     * @param {Array} values The values to exclude.\n\t     * @returns {Array} Returns the new array of filtered values.\n\t     */\n\t    function baseDifference(array, values) {\n\t      var length = array ? array.length : 0,\n\t          result = [];\n\t\n\t      if (!length) {\n\t        return result;\n\t      }\n\t      var index = -1,\n\t          indexOf = getIndexOf(),\n\t          isCommon = indexOf == baseIndexOf,\n\t          cache = (isCommon && values.length >= LARGE_ARRAY_SIZE) ? createCache(values) : null,\n\t          valuesLength = values.length;\n\t\n\t      if (cache) {\n\t        indexOf = cacheIndexOf;\n\t        isCommon = false;\n\t        values = cache;\n\t      }\n\t      outer:\n\t      while (++index < length) {\n\t        var value = array[index];\n\t\n\t        if (isCommon && value === value) {\n\t          var valuesIndex = valuesLength;\n\t          while (valuesIndex--) {\n\t            if (values[valuesIndex] === value) {\n\t              continue outer;\n\t            }\n\t          }\n\t          result.push(value);\n\t        }\n\t        else if (indexOf(values, value, 0) < 0) {\n\t          result.push(value);\n\t        }\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.forEach` without support for callback\n\t     * shorthands and `this` binding.\n\t     *\n\t     * @private\n\t     * @param {Array|Object|string} collection The collection to iterate over.\n\t     * @param {Function} iteratee The function invoked per iteration.\n\t     * @returns {Array|Object|string} Returns `collection`.\n\t     */\n\t    var baseEach = createBaseEach(baseForOwn);\n\t\n\t    /**\n\t     * The base implementation of `_.forEachRight` without support for callback\n\t     * shorthands and `this` binding.\n\t     *\n\t     * @private\n\t     * @param {Array|Object|string} collection The collection to iterate over.\n\t     * @param {Function} iteratee The function invoked per iteration.\n\t     * @returns {Array|Object|string} Returns `collection`.\n\t     */\n\t    var baseEachRight = createBaseEach(baseForOwnRight, true);\n\t\n\t    /**\n\t     * The base implementation of `_.every` without support for callback\n\t     * shorthands and `this` binding.\n\t     *\n\t     * @private\n\t     * @param {Array|Object|string} collection The collection to iterate over.\n\t     * @param {Function} predicate The function invoked per iteration.\n\t     * @returns {boolean} Returns `true` if all elements pass the predicate check,\n\t     *  else `false`\n\t     */\n\t    function baseEvery(collection, predicate) {\n\t      var result = true;\n\t      baseEach(collection, function(value, index, collection) {\n\t        result = !!predicate(value, index, collection);\n\t        return result;\n\t      });\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * Gets the extremum value of `collection` invoking `iteratee` for each value\n\t     * in `collection` to generate the criterion by which the value is ranked.\n\t     * The `iteratee` is invoked with three arguments: (value, index|key, collection).\n\t     *\n\t     * @private\n\t     * @param {Array|Object|string} collection The collection to iterate over.\n\t     * @param {Function} iteratee The function invoked per iteration.\n\t     * @param {Function} comparator The function used to compare values.\n\t     * @param {*} exValue The initial extremum value.\n\t     * @returns {*} Returns the extremum value.\n\t     */\n\t    function baseExtremum(collection, iteratee, comparator, exValue) {\n\t      var computed = exValue,\n\t          result = computed;\n\t\n\t      baseEach(collection, function(value, index, collection) {\n\t        var current = +iteratee(value, index, collection);\n\t        if (comparator(current, computed) || (current === exValue && current === result)) {\n\t          computed = current;\n\t          result = value;\n\t        }\n\t      });\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.fill` without an iteratee call guard.\n\t     *\n\t     * @private\n\t     * @param {Array} array The array to fill.\n\t     * @param {*} value The value to fill `array` with.\n\t     * @param {number} [start=0] The start position.\n\t     * @param {number} [end=array.length] The end position.\n\t     * @returns {Array} Returns `array`.\n\t     */\n\t    function baseFill(array, value, start, end) {\n\t      var length = array.length;\n\t\n\t      start = start == null ? 0 : (+start || 0);\n\t      if (start < 0) {\n\t        start = -start > length ? 0 : (length + start);\n\t      }\n\t      end = (end === undefined || end > length) ? length : (+end || 0);\n\t      if (end < 0) {\n\t        end += length;\n\t      }\n\t      length = start > end ? 0 : (end >>> 0);\n\t      start >>>= 0;\n\t\n\t      while (start < length) {\n\t        array[start++] = value;\n\t      }\n\t      return array;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.filter` without support for callback\n\t     * shorthands and `this` binding.\n\t     *\n\t     * @private\n\t     * @param {Array|Object|string} collection The collection to iterate over.\n\t     * @param {Function} predicate The function invoked per iteration.\n\t     * @returns {Array} Returns the new filtered array.\n\t     */\n\t    function baseFilter(collection, predicate) {\n\t      var result = [];\n\t      baseEach(collection, function(value, index, collection) {\n\t        if (predicate(value, index, collection)) {\n\t          result.push(value);\n\t        }\n\t      });\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.find`, `_.findLast`, `_.findKey`, and `_.findLastKey`,\n\t     * without support for callback shorthands and `this` binding, which iterates\n\t     * over `collection` using the provided `eachFunc`.\n\t     *\n\t     * @private\n\t     * @param {Array|Object|string} collection The collection to search.\n\t     * @param {Function} predicate The function invoked per iteration.\n\t     * @param {Function} eachFunc The function to iterate over `collection`.\n\t     * @param {boolean} [retKey] Specify returning the key of the found element\n\t     *  instead of the element itself.\n\t     * @returns {*} Returns the found element or its key, else `undefined`.\n\t     */\n\t    function baseFind(collection, predicate, eachFunc, retKey) {\n\t      var result;\n\t      eachFunc(collection, function(value, key, collection) {\n\t        if (predicate(value, key, collection)) {\n\t          result = retKey ? key : value;\n\t          return false;\n\t        }\n\t      });\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.flatten` with added support for restricting\n\t     * flattening and specifying the start index.\n\t     *\n\t     * @private\n\t     * @param {Array} array The array to flatten.\n\t     * @param {boolean} [isDeep] Specify a deep flatten.\n\t     * @param {boolean} [isStrict] Restrict flattening to arrays-like objects.\n\t     * @param {Array} [result=[]] The initial result value.\n\t     * @returns {Array} Returns the new flattened array.\n\t     */\n\t    function baseFlatten(array, isDeep, isStrict, result) {\n\t      result || (result = []);\n\t\n\t      var index = -1,\n\t          length = array.length;\n\t\n\t      while (++index < length) {\n\t        var value = array[index];\n\t        if (isObjectLike(value) && isArrayLike(value) &&\n\t            (isStrict || isArray(value) || isArguments(value))) {\n\t          if (isDeep) {\n\t            // Recursively flatten arrays (susceptible to call stack limits).\n\t            baseFlatten(value, isDeep, isStrict, result);\n\t          } else {\n\t            arrayPush(result, value);\n\t          }\n\t        } else if (!isStrict) {\n\t          result[result.length] = value;\n\t        }\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `baseForIn` and `baseForOwn` which iterates\n\t     * over `object` properties returned by `keysFunc` invoking `iteratee` for\n\t     * each property. Iteratee functions may exit iteration early by explicitly\n\t     * returning `false`.\n\t     *\n\t     * @private\n\t     * @param {Object} object The object to iterate over.\n\t     * @param {Function} iteratee The function invoked per iteration.\n\t     * @param {Function} keysFunc The function to get the keys of `object`.\n\t     * @returns {Object} Returns `object`.\n\t     */\n\t    var baseFor = createBaseFor();\n\t\n\t    /**\n\t     * This function is like `baseFor` except that it iterates over properties\n\t     * in the opposite order.\n\t     *\n\t     * @private\n\t     * @param {Object} object The object to iterate over.\n\t     * @param {Function} iteratee The function invoked per iteration.\n\t     * @param {Function} keysFunc The function to get the keys of `object`.\n\t     * @returns {Object} Returns `object`.\n\t     */\n\t    var baseForRight = createBaseFor(true);\n\t\n\t    /**\n\t     * The base implementation of `_.forIn` without support for callback\n\t     * shorthands and `this` binding.\n\t     *\n\t     * @private\n\t     * @param {Object} object The object to iterate over.\n\t     * @param {Function} iteratee The function invoked per iteration.\n\t     * @returns {Object} Returns `object`.\n\t     */\n\t    function baseForIn(object, iteratee) {\n\t      return baseFor(object, iteratee, keysIn);\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.forOwn` without support for callback\n\t     * shorthands and `this` binding.\n\t     *\n\t     * @private\n\t     * @param {Object} object The object to iterate over.\n\t     * @param {Function} iteratee The function invoked per iteration.\n\t     * @returns {Object} Returns `object`.\n\t     */\n\t    function baseForOwn(object, iteratee) {\n\t      return baseFor(object, iteratee, keys);\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.forOwnRight` without support for callback\n\t     * shorthands and `this` binding.\n\t     *\n\t     * @private\n\t     * @param {Object} object The object to iterate over.\n\t     * @param {Function} iteratee The function invoked per iteration.\n\t     * @returns {Object} Returns `object`.\n\t     */\n\t    function baseForOwnRight(object, iteratee) {\n\t      return baseForRight(object, iteratee, keys);\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.functions` which creates an array of\n\t     * `object` function property names filtered from those provided.\n\t     *\n\t     * @private\n\t     * @param {Object} object The object to inspect.\n\t     * @param {Array} props The property names to filter.\n\t     * @returns {Array} Returns the new array of filtered property names.\n\t     */\n\t    function baseFunctions(object, props) {\n\t      var index = -1,\n\t          length = props.length,\n\t          resIndex = -1,\n\t          result = [];\n\t\n\t      while (++index < length) {\n\t        var key = props[index];\n\t        if (isFunction(object[key])) {\n\t          result[++resIndex] = key;\n\t        }\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `get` without support for string paths\n\t     * and default values.\n\t     *\n\t     * @private\n\t     * @param {Object} object The object to query.\n\t     * @param {Array} path The path of the property to get.\n\t     * @param {string} [pathKey] The key representation of path.\n\t     * @returns {*} Returns the resolved value.\n\t     */\n\t    function baseGet(object, path, pathKey) {\n\t      if (object == null) {\n\t        return;\n\t      }\n\t      if (pathKey !== undefined && pathKey in toObject(object)) {\n\t        path = [pathKey];\n\t      }\n\t      var index = 0,\n\t          length = path.length;\n\t\n\t      while (object != null && index < length) {\n\t        object = object[path[index++]];\n\t      }\n\t      return (index && index == length) ? object : undefined;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.isEqual` without support for `this` binding\n\t     * `customizer` functions.\n\t     *\n\t     * @private\n\t     * @param {*} value The value to compare.\n\t     * @param {*} other The other value to compare.\n\t     * @param {Function} [customizer] The function to customize comparing values.\n\t     * @param {boolean} [isLoose] Specify performing partial comparisons.\n\t     * @param {Array} [stackA] Tracks traversed `value` objects.\n\t     * @param {Array} [stackB] Tracks traversed `other` objects.\n\t     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n\t     */\n\t    function baseIsEqual(value, other, customizer, isLoose, stackA, stackB) {\n\t      if (value === other) {\n\t        return true;\n\t      }\n\t      if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {\n\t        return value !== value && other !== other;\n\t      }\n\t      return baseIsEqualDeep(value, other, baseIsEqual, customizer, isLoose, stackA, stackB);\n\t    }\n\t\n\t    /**\n\t     * A specialized version of `baseIsEqual` for arrays and objects which performs\n\t     * deep comparisons and tracks traversed objects enabling objects with circular\n\t     * references to be compared.\n\t     *\n\t     * @private\n\t     * @param {Object} object The object to compare.\n\t     * @param {Object} other The other object to compare.\n\t     * @param {Function} equalFunc The function to determine equivalents of values.\n\t     * @param {Function} [customizer] The function to customize comparing objects.\n\t     * @param {boolean} [isLoose] Specify performing partial comparisons.\n\t     * @param {Array} [stackA=[]] Tracks traversed `value` objects.\n\t     * @param {Array} [stackB=[]] Tracks traversed `other` objects.\n\t     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n\t     */\n\t    function baseIsEqualDeep(object, other, equalFunc, customizer, isLoose, stackA, stackB) {\n\t      var objIsArr = isArray(object),\n\t          othIsArr = isArray(other),\n\t          objTag = arrayTag,\n\t          othTag = arrayTag;\n\t\n\t      if (!objIsArr) {\n\t        objTag = objToString.call(object);\n\t        if (objTag == argsTag) {\n\t          objTag = objectTag;\n\t        } else if (objTag != objectTag) {\n\t          objIsArr = isTypedArray(object);\n\t        }\n\t      }\n\t      if (!othIsArr) {\n\t        othTag = objToString.call(other);\n\t        if (othTag == argsTag) {\n\t          othTag = objectTag;\n\t        } else if (othTag != objectTag) {\n\t          othIsArr = isTypedArray(other);\n\t        }\n\t      }\n\t      var objIsObj = objTag == objectTag,\n\t          othIsObj = othTag == objectTag,\n\t          isSameTag = objTag == othTag;\n\t\n\t      if (isSameTag && !(objIsArr || objIsObj)) {\n\t        return equalByTag(object, other, objTag);\n\t      }\n\t      if (!isLoose) {\n\t        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\n\t            othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\t\n\t        if (objIsWrapped || othIsWrapped) {\n\t          return equalFunc(objIsWrapped ? object.value() : object, othIsWrapped ? other.value() : other, customizer, isLoose, stackA, stackB);\n\t        }\n\t      }\n\t      if (!isSameTag) {\n\t        return false;\n\t      }\n\t      // Assume cyclic values are equal.\n\t      // For more information on detecting circular references see https://es5.github.io/#JO.\n\t      stackA || (stackA = []);\n\t      stackB || (stackB = []);\n\t\n\t      var length = stackA.length;\n\t      while (length--) {\n\t        if (stackA[length] == object) {\n\t          return stackB[length] == other;\n\t        }\n\t      }\n\t      // Add `object` and `other` to the stack of traversed objects.\n\t      stackA.push(object);\n\t      stackB.push(other);\n\t\n\t      var result = (objIsArr ? equalArrays : equalObjects)(object, other, equalFunc, customizer, isLoose, stackA, stackB);\n\t\n\t      stackA.pop();\n\t      stackB.pop();\n\t\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.isMatch` without support for callback\n\t     * shorthands and `this` binding.\n\t     *\n\t     * @private\n\t     * @param {Object} object The object to inspect.\n\t     * @param {Array} matchData The propery names, values, and compare flags to match.\n\t     * @param {Function} [customizer] The function to customize comparing objects.\n\t     * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n\t     */\n\t    function baseIsMatch(object, matchData, customizer) {\n\t      var index = matchData.length,\n\t          length = index,\n\t          noCustomizer = !customizer;\n\t\n\t      if (object == null) {\n\t        return !length;\n\t      }\n\t      object = toObject(object);\n\t      while (index--) {\n\t        var data = matchData[index];\n\t        if ((noCustomizer && data[2])\n\t              ? data[1] !== object[data[0]]\n\t              : !(data[0] in object)\n\t            ) {\n\t          return false;\n\t        }\n\t      }\n\t      while (++index < length) {\n\t        data = matchData[index];\n\t        var key = data[0],\n\t            objValue = object[key],\n\t            srcValue = data[1];\n\t\n\t        if (noCustomizer && data[2]) {\n\t          if (objValue === undefined && !(key in object)) {\n\t            return false;\n\t          }\n\t        } else {\n\t          var result = customizer ? customizer(objValue, srcValue, key) : undefined;\n\t          if (!(result === undefined ? baseIsEqual(srcValue, objValue, customizer, true) : result)) {\n\t            return false;\n\t          }\n\t        }\n\t      }\n\t      return true;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.map` without support for callback shorthands\n\t     * and `this` binding.\n\t     *\n\t     * @private\n\t     * @param {Array|Object|string} collection The collection to iterate over.\n\t     * @param {Function} iteratee The function invoked per iteration.\n\t     * @returns {Array} Returns the new mapped array.\n\t     */\n\t    function baseMap(collection, iteratee) {\n\t      var index = -1,\n\t          result = isArrayLike(collection) ? Array(collection.length) : [];\n\t\n\t      baseEach(collection, function(value, key, collection) {\n\t        result[++index] = iteratee(value, key, collection);\n\t      });\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.matches` which does not clone `source`.\n\t     *\n\t     * @private\n\t     * @param {Object} source The object of property values to match.\n\t     * @returns {Function} Returns the new function.\n\t     */\n\t    function baseMatches(source) {\n\t      var matchData = getMatchData(source);\n\t      if (matchData.length == 1 && matchData[0][2]) {\n\t        var key = matchData[0][0],\n\t            value = matchData[0][1];\n\t\n\t        return function(object) {\n\t          if (object == null) {\n\t            return false;\n\t          }\n\t          return object[key] === value && (value !== undefined || (key in toObject(object)));\n\t        };\n\t      }\n\t      return function(object) {\n\t        return baseIsMatch(object, matchData);\n\t      };\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.matchesProperty` which does not clone `srcValue`.\n\t     *\n\t     * @private\n\t     * @param {string} path The path of the property to get.\n\t     * @param {*} srcValue The value to compare.\n\t     * @returns {Function} Returns the new function.\n\t     */\n\t    function baseMatchesProperty(path, srcValue) {\n\t      var isArr = isArray(path),\n\t          isCommon = isKey(path) && isStrictComparable(srcValue),\n\t          pathKey = (path + '');\n\t\n\t      path = toPath(path);\n\t      return function(object) {\n\t        if (object == null) {\n\t          return false;\n\t        }\n\t        var key = pathKey;\n\t        object = toObject(object);\n\t        if ((isArr || !isCommon) && !(key in object)) {\n\t          object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));\n\t          if (object == null) {\n\t            return false;\n\t          }\n\t          key = last(path);\n\t          object = toObject(object);\n\t        }\n\t        return object[key] === srcValue\n\t          ? (srcValue !== undefined || (key in object))\n\t          : baseIsEqual(srcValue, object[key], undefined, true);\n\t      };\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.merge` without support for argument juggling,\n\t     * multiple sources, and `this` binding `customizer` functions.\n\t     *\n\t     * @private\n\t     * @param {Object} object The destination object.\n\t     * @param {Object} source The source object.\n\t     * @param {Function} [customizer] The function to customize merged values.\n\t     * @param {Array} [stackA=[]] Tracks traversed source objects.\n\t     * @param {Array} [stackB=[]] Associates values with source counterparts.\n\t     * @returns {Object} Returns `object`.\n\t     */\n\t    function baseMerge(object, source, customizer, stackA, stackB) {\n\t      if (!isObject(object)) {\n\t        return object;\n\t      }\n\t      var isSrcArr = isArrayLike(source) && (isArray(source) || isTypedArray(source)),\n\t          props = isSrcArr ? undefined : keys(source);\n\t\n\t      arrayEach(props || source, function(srcValue, key) {\n\t        if (props) {\n\t          key = srcValue;\n\t          srcValue = source[key];\n\t        }\n\t        if (isObjectLike(srcValue)) {\n\t          stackA || (stackA = []);\n\t          stackB || (stackB = []);\n\t          baseMergeDeep(object, source, key, baseMerge, customizer, stackA, stackB);\n\t        }\n\t        else {\n\t          var value = object[key],\n\t              result = customizer ? customizer(value, srcValue, key, object, source) : undefined,\n\t              isCommon = result === undefined;\n\t\n\t          if (isCommon) {\n\t            result = srcValue;\n\t          }\n\t          if ((result !== undefined || (isSrcArr && !(key in object))) &&\n\t              (isCommon || (result === result ? (result !== value) : (value === value)))) {\n\t            object[key] = result;\n\t          }\n\t        }\n\t      });\n\t      return object;\n\t    }\n\t\n\t    /**\n\t     * A specialized version of `baseMerge` for arrays and objects which performs\n\t     * deep merges and tracks traversed objects enabling objects with circular\n\t     * references to be merged.\n\t     *\n\t     * @private\n\t     * @param {Object} object The destination object.\n\t     * @param {Object} source The source object.\n\t     * @param {string} key The key of the value to merge.\n\t     * @param {Function} mergeFunc The function to merge values.\n\t     * @param {Function} [customizer] The function to customize merged values.\n\t     * @param {Array} [stackA=[]] Tracks traversed source objects.\n\t     * @param {Array} [stackB=[]] Associates values with source counterparts.\n\t     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n\t     */\n\t    function baseMergeDeep(object, source, key, mergeFunc, customizer, stackA, stackB) {\n\t      var length = stackA.length,\n\t          srcValue = source[key];\n\t\n\t      while (length--) {\n\t        if (stackA[length] == srcValue) {\n\t          object[key] = stackB[length];\n\t          return;\n\t        }\n\t      }\n\t      var value = object[key],\n\t          result = customizer ? customizer(value, srcValue, key, object, source) : undefined,\n\t          isCommon = result === undefined;\n\t\n\t      if (isCommon) {\n\t        result = srcValue;\n\t        if (isArrayLike(srcValue) && (isArray(srcValue) || isTypedArray(srcValue))) {\n\t          result = isArray(value)\n\t            ? value\n\t            : (isArrayLike(value) ? arrayCopy(value) : []);\n\t        }\n\t        else if (isPlainObject(srcValue) || isArguments(srcValue)) {\n\t          result = isArguments(value)\n\t            ? toPlainObject(value)\n\t            : (isPlainObject(value) ? value : {});\n\t        }\n\t        else {\n\t          isCommon = false;\n\t        }\n\t      }\n\t      // Add the source value to the stack of traversed objects and associate\n\t      // it with its merged value.\n\t      stackA.push(srcValue);\n\t      stackB.push(result);\n\t\n\t      if (isCommon) {\n\t        // Recursively merge objects and arrays (susceptible to call stack limits).\n\t        object[key] = mergeFunc(result, srcValue, customizer, stackA, stackB);\n\t      } else if (result === result ? (result !== value) : (value === value)) {\n\t        object[key] = result;\n\t      }\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.property` without support for deep paths.\n\t     *\n\t     * @private\n\t     * @param {string} key The key of the property to get.\n\t     * @returns {Function} Returns the new function.\n\t     */\n\t    function baseProperty(key) {\n\t      return function(object) {\n\t        return object == null ? undefined : object[key];\n\t      };\n\t    }\n\t\n\t    /**\n\t     * A specialized version of `baseProperty` which supports deep paths.\n\t     *\n\t     * @private\n\t     * @param {Array|string} path The path of the property to get.\n\t     * @returns {Function} Returns the new function.\n\t     */\n\t    function basePropertyDeep(path) {\n\t      var pathKey = (path + '');\n\t      path = toPath(path);\n\t      return function(object) {\n\t        return baseGet(object, path, pathKey);\n\t      };\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.pullAt` without support for individual\n\t     * index arguments and capturing the removed elements.\n\t     *\n\t     * @private\n\t     * @param {Array} array The array to modify.\n\t     * @param {number[]} indexes The indexes of elements to remove.\n\t     * @returns {Array} Returns `array`.\n\t     */\n\t    function basePullAt(array, indexes) {\n\t      var length = array ? indexes.length : 0;\n\t      while (length--) {\n\t        var index = indexes[length];\n\t        if (index != previous && isIndex(index)) {\n\t          var previous = index;\n\t          splice.call(array, index, 1);\n\t        }\n\t      }\n\t      return array;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.random` without support for argument juggling\n\t     * and returning floating-point numbers.\n\t     *\n\t     * @private\n\t     * @param {number} min The minimum possible value.\n\t     * @param {number} max The maximum possible value.\n\t     * @returns {number} Returns the random number.\n\t     */\n\t    function baseRandom(min, max) {\n\t      return min + nativeFloor(nativeRandom() * (max - min + 1));\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.reduce` and `_.reduceRight` without support\n\t     * for callback shorthands and `this` binding, which iterates over `collection`\n\t     * using the provided `eachFunc`.\n\t     *\n\t     * @private\n\t     * @param {Array|Object|string} collection The collection to iterate over.\n\t     * @param {Function} iteratee The function invoked per iteration.\n\t     * @param {*} accumulator The initial value.\n\t     * @param {boolean} initFromCollection Specify using the first or last element\n\t     *  of `collection` as the initial value.\n\t     * @param {Function} eachFunc The function to iterate over `collection`.\n\t     * @returns {*} Returns the accumulated value.\n\t     */\n\t    function baseReduce(collection, iteratee, accumulator, initFromCollection, eachFunc) {\n\t      eachFunc(collection, function(value, index, collection) {\n\t        accumulator = initFromCollection\n\t          ? (initFromCollection = false, value)\n\t          : iteratee(accumulator, value, index, collection);\n\t      });\n\t      return accumulator;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `setData` without support for hot loop detection.\n\t     *\n\t     * @private\n\t     * @param {Function} func The function to associate metadata with.\n\t     * @param {*} data The metadata.\n\t     * @returns {Function} Returns `func`.\n\t     */\n\t    var baseSetData = !metaMap ? identity : function(func, data) {\n\t      metaMap.set(func, data);\n\t      return func;\n\t    };\n\t\n\t    /**\n\t     * The base implementation of `_.slice` without an iteratee call guard.\n\t     *\n\t     * @private\n\t     * @param {Array} array The array to slice.\n\t     * @param {number} [start=0] The start position.\n\t     * @param {number} [end=array.length] The end position.\n\t     * @returns {Array} Returns the slice of `array`.\n\t     */\n\t    function baseSlice(array, start, end) {\n\t      var index = -1,\n\t          length = array.length;\n\t\n\t      start = start == null ? 0 : (+start || 0);\n\t      if (start < 0) {\n\t        start = -start > length ? 0 : (length + start);\n\t      }\n\t      end = (end === undefined || end > length) ? length : (+end || 0);\n\t      if (end < 0) {\n\t        end += length;\n\t      }\n\t      length = start > end ? 0 : ((end - start) >>> 0);\n\t      start >>>= 0;\n\t\n\t      var result = Array(length);\n\t      while (++index < length) {\n\t        result[index] = array[index + start];\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.some` without support for callback shorthands\n\t     * and `this` binding.\n\t     *\n\t     * @private\n\t     * @param {Array|Object|string} collection The collection to iterate over.\n\t     * @param {Function} predicate The function invoked per iteration.\n\t     * @returns {boolean} Returns `true` if any element passes the predicate check,\n\t     *  else `false`.\n\t     */\n\t    function baseSome(collection, predicate) {\n\t      var result;\n\t\n\t      baseEach(collection, function(value, index, collection) {\n\t        result = predicate(value, index, collection);\n\t        return !result;\n\t      });\n\t      return !!result;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.sortBy` which uses `comparer` to define\n\t     * the sort order of `array` and replaces criteria objects with their\n\t     * corresponding values.\n\t     *\n\t     * @private\n\t     * @param {Array} array The array to sort.\n\t     * @param {Function} comparer The function to define sort order.\n\t     * @returns {Array} Returns `array`.\n\t     */\n\t    function baseSortBy(array, comparer) {\n\t      var length = array.length;\n\t\n\t      array.sort(comparer);\n\t      while (length--) {\n\t        array[length] = array[length].value;\n\t      }\n\t      return array;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.sortByOrder` without param guards.\n\t     *\n\t     * @private\n\t     * @param {Array|Object|string} collection The collection to iterate over.\n\t     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.\n\t     * @param {boolean[]} orders The sort orders of `iteratees`.\n\t     * @returns {Array} Returns the new sorted array.\n\t     */\n\t    function baseSortByOrder(collection, iteratees, orders) {\n\t      var callback = getCallback(),\n\t          index = -1;\n\t\n\t      iteratees = arrayMap(iteratees, function(iteratee) { return callback(iteratee); });\n\t\n\t      var result = baseMap(collection, function(value) {\n\t        var criteria = arrayMap(iteratees, function(iteratee) { return iteratee(value); });\n\t        return { 'criteria': criteria, 'index': ++index, 'value': value };\n\t      });\n\t\n\t      return baseSortBy(result, function(object, other) {\n\t        return compareMultiple(object, other, orders);\n\t      });\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.sum` without support for callback shorthands\n\t     * and `this` binding.\n\t     *\n\t     * @private\n\t     * @param {Array|Object|string} collection The collection to iterate over.\n\t     * @param {Function} iteratee The function invoked per iteration.\n\t     * @returns {number} Returns the sum.\n\t     */\n\t    function baseSum(collection, iteratee) {\n\t      var result = 0;\n\t      baseEach(collection, function(value, index, collection) {\n\t        result += +iteratee(value, index, collection) || 0;\n\t      });\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.uniq` without support for callback shorthands\n\t     * and `this` binding.\n\t     *\n\t     * @private\n\t     * @param {Array} array The array to inspect.\n\t     * @param {Function} [iteratee] The function invoked per iteration.\n\t     * @returns {Array} Returns the new duplicate-value-free array.\n\t     */\n\t    function baseUniq(array, iteratee) {\n\t      var index = -1,\n\t          indexOf = getIndexOf(),\n\t          length = array.length,\n\t          isCommon = indexOf == baseIndexOf,\n\t          isLarge = isCommon && length >= LARGE_ARRAY_SIZE,\n\t          seen = isLarge ? createCache() : null,\n\t          result = [];\n\t\n\t      if (seen) {\n\t        indexOf = cacheIndexOf;\n\t        isCommon = false;\n\t      } else {\n\t        isLarge = false;\n\t        seen = iteratee ? [] : result;\n\t      }\n\t      outer:\n\t      while (++index < length) {\n\t        var value = array[index],\n\t            computed = iteratee ? iteratee(value, index, array) : value;\n\t\n\t        if (isCommon && value === value) {\n\t          var seenIndex = seen.length;\n\t          while (seenIndex--) {\n\t            if (seen[seenIndex] === computed) {\n\t              continue outer;\n\t            }\n\t          }\n\t          if (iteratee) {\n\t            seen.push(computed);\n\t          }\n\t          result.push(value);\n\t        }\n\t        else if (indexOf(seen, computed, 0) < 0) {\n\t          if (iteratee || isLarge) {\n\t            seen.push(computed);\n\t          }\n\t          result.push(value);\n\t        }\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.values` and `_.valuesIn` which creates an\n\t     * array of `object` property values corresponding to the property names\n\t     * of `props`.\n\t     *\n\t     * @private\n\t     * @param {Object} object The object to query.\n\t     * @param {Array} props The property names to get values for.\n\t     * @returns {Object} Returns the array of property values.\n\t     */\n\t    function baseValues(object, props) {\n\t      var index = -1,\n\t          length = props.length,\n\t          result = Array(length);\n\t\n\t      while (++index < length) {\n\t        result[index] = object[props[index]];\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.dropRightWhile`, `_.dropWhile`, `_.takeRightWhile`,\n\t     * and `_.takeWhile` without support for callback shorthands and `this` binding.\n\t     *\n\t     * @private\n\t     * @param {Array} array The array to query.\n\t     * @param {Function} predicate The function invoked per iteration.\n\t     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.\n\t     * @param {boolean} [fromRight] Specify iterating from right to left.\n\t     * @returns {Array} Returns the slice of `array`.\n\t     */\n\t    function baseWhile(array, predicate, isDrop, fromRight) {\n\t      var length = array.length,\n\t          index = fromRight ? length : -1;\n\t\n\t      while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {}\n\t      return isDrop\n\t        ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))\n\t        : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `wrapperValue` which returns the result of\n\t     * performing a sequence of actions on the unwrapped `value`, where each\n\t     * successive action is supplied the return value of the previous.\n\t     *\n\t     * @private\n\t     * @param {*} value The unwrapped value.\n\t     * @param {Array} actions Actions to peform to resolve the unwrapped value.\n\t     * @returns {*} Returns the resolved value.\n\t     */\n\t    function baseWrapperValue(value, actions) {\n\t      var result = value;\n\t      if (result instanceof LazyWrapper) {\n\t        result = result.value();\n\t      }\n\t      var index = -1,\n\t          length = actions.length;\n\t\n\t      while (++index < length) {\n\t        var action = actions[index];\n\t        result = action.func.apply(action.thisArg, arrayPush([result], action.args));\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * Performs a binary search of `array` to determine the index at which `value`\n\t     * should be inserted into `array` in order to maintain its sort order.\n\t     *\n\t     * @private\n\t     * @param {Array} array The sorted array to inspect.\n\t     * @param {*} value The value to evaluate.\n\t     * @param {boolean} [retHighest] Specify returning the highest qualified index.\n\t     * @returns {number} Returns the index at which `value` should be inserted\n\t     *  into `array`.\n\t     */\n\t    function binaryIndex(array, value, retHighest) {\n\t      var low = 0,\n\t          high = array ? array.length : low;\n\t\n\t      if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {\n\t        while (low < high) {\n\t          var mid = (low + high) >>> 1,\n\t              computed = array[mid];\n\t\n\t          if ((retHighest ? (computed <= value) : (computed < value)) && computed !== null) {\n\t            low = mid + 1;\n\t          } else {\n\t            high = mid;\n\t          }\n\t        }\n\t        return high;\n\t      }\n\t      return binaryIndexBy(array, value, identity, retHighest);\n\t    }\n\t\n\t    /**\n\t     * This function is like `binaryIndex` except that it invokes `iteratee` for\n\t     * `value` and each element of `array` to compute their sort ranking. The\n\t     * iteratee is invoked with one argument; (value).\n\t     *\n\t     * @private\n\t     * @param {Array} array The sorted array to inspect.\n\t     * @param {*} value The value to evaluate.\n\t     * @param {Function} iteratee The function invoked per iteration.\n\t     * @param {boolean} [retHighest] Specify returning the highest qualified index.\n\t     * @returns {number} Returns the index at which `value` should be inserted\n\t     *  into `array`.\n\t     */\n\t    function binaryIndexBy(array, value, iteratee, retHighest) {\n\t      value = iteratee(value);\n\t\n\t      var low = 0,\n\t          high = array ? array.length : 0,\n\t          valIsNaN = value !== value,\n\t          valIsNull = value === null,\n\t          valIsUndef = value === undefined;\n\t\n\t      while (low < high) {\n\t        var mid = nativeFloor((low + high) / 2),\n\t            computed = iteratee(array[mid]),\n\t            isDef = computed !== undefined,\n\t            isReflexive = computed === computed;\n\t\n\t        if (valIsNaN) {\n\t          var setLow = isReflexive || retHighest;\n\t        } else if (valIsNull) {\n\t          setLow = isReflexive && isDef && (retHighest || computed != null);\n\t        } else if (valIsUndef) {\n\t          setLow = isReflexive && (retHighest || isDef);\n\t        } else if (computed == null) {\n\t          setLow = false;\n\t        } else {\n\t          setLow = retHighest ? (computed <= value) : (computed < value);\n\t        }\n\t        if (setLow) {\n\t          low = mid + 1;\n\t        } else {\n\t          high = mid;\n\t        }\n\t      }\n\t      return nativeMin(high, MAX_ARRAY_INDEX);\n\t    }\n\t\n\t    /**\n\t     * A specialized version of `baseCallback` which only supports `this` binding\n\t     * and specifying the number of arguments to provide to `func`.\n\t     *\n\t     * @private\n\t     * @param {Function} func The function to bind.\n\t     * @param {*} thisArg The `this` binding of `func`.\n\t     * @param {number} [argCount] The number of arguments to provide to `func`.\n\t     * @returns {Function} Returns the callback.\n\t     */\n\t    function bindCallback(func, thisArg, argCount) {\n\t      if (typeof func != 'function') {\n\t        return identity;\n\t      }\n\t      if (thisArg === undefined) {\n\t        return func;\n\t      }\n\t      switch (argCount) {\n\t        case 1: return function(value) {\n\t          return func.call(thisArg, value);\n\t        };\n\t        case 3: return function(value, index, collection) {\n\t          return func.call(thisArg, value, index, collection);\n\t        };\n\t        case 4: return function(accumulator, value, index, collection) {\n\t          return func.call(thisArg, accumulator, value, index, collection);\n\t        };\n\t        case 5: return function(value, other, key, object, source) {\n\t          return func.call(thisArg, value, other, key, object, source);\n\t        };\n\t      }\n\t      return function() {\n\t        return func.apply(thisArg, arguments);\n\t      };\n\t    }\n\t\n\t    /**\n\t     * Creates a clone of the given array buffer.\n\t     *\n\t     * @private\n\t     * @param {ArrayBuffer} buffer The array buffer to clone.\n\t     * @returns {ArrayBuffer} Returns the cloned array buffer.\n\t     */\n\t    function bufferClone(buffer) {\n\t      var result = new ArrayBuffer(buffer.byteLength),\n\t          view = new Uint8Array(result);\n\t\n\t      view.set(new Uint8Array(buffer));\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * Creates an array that is the composition of partially applied arguments,\n\t     * placeholders, and provided arguments into a single array of arguments.\n\t     *\n\t     * @private\n\t     * @param {Array|Object} args The provided arguments.\n\t     * @param {Array} partials The arguments to prepend to those provided.\n\t     * @param {Array} holders The `partials` placeholder indexes.\n\t     * @returns {Array} Returns the new array of composed arguments.\n\t     */\n\t    function composeArgs(args, partials, holders) {\n\t      var holdersLength = holders.length,\n\t          argsIndex = -1,\n\t          argsLength = nativeMax(args.length - holdersLength, 0),\n\t          leftIndex = -1,\n\t          leftLength = partials.length,\n\t          result = Array(leftLength + argsLength);\n\t\n\t      while (++leftIndex < leftLength) {\n\t        result[leftIndex] = partials[leftIndex];\n\t      }\n\t      while (++argsIndex < holdersLength) {\n\t        result[holders[argsIndex]] = args[argsIndex];\n\t      }\n\t      while (argsLength--) {\n\t        result[leftIndex++] = args[argsIndex++];\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * This function is like `composeArgs` except that the arguments composition\n\t     * is tailored for `_.partialRight`.\n\t     *\n\t     * @private\n\t     * @param {Array|Object} args The provided arguments.\n\t     * @param {Array} partials The arguments to append to those provided.\n\t     * @param {Array} holders The `partials` placeholder indexes.\n\t     * @returns {Array} Returns the new array of composed arguments.\n\t     */\n\t    function composeArgsRight(args, partials, holders) {\n\t      var holdersIndex = -1,\n\t          holdersLength = holders.length,\n\t          argsIndex = -1,\n\t          argsLength = nativeMax(args.length - holdersLength, 0),\n\t          rightIndex = -1,\n\t          rightLength = partials.length,\n\t          result = Array(argsLength + rightLength);\n\t\n\t      while (++argsIndex < argsLength) {\n\t        result[argsIndex] = args[argsIndex];\n\t      }\n\t      var offset = argsIndex;\n\t      while (++rightIndex < rightLength) {\n\t        result[offset + rightIndex] = partials[rightIndex];\n\t      }\n\t      while (++holdersIndex < holdersLength) {\n\t        result[offset + holders[holdersIndex]] = args[argsIndex++];\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * Creates a `_.countBy`, `_.groupBy`, `_.indexBy`, or `_.partition` function.\n\t     *\n\t     * @private\n\t     * @param {Function} setter The function to set keys and values of the accumulator object.\n\t     * @param {Function} [initializer] The function to initialize the accumulator object.\n\t     * @returns {Function} Returns the new aggregator function.\n\t     */\n\t    function createAggregator(setter, initializer) {\n\t      return function(collection, iteratee, thisArg) {\n\t        var result = initializer ? initializer() : {};\n\t        iteratee = getCallback(iteratee, thisArg, 3);\n\t\n\t        if (isArray(collection)) {\n\t          var index = -1,\n\t              length = collection.length;\n\t\n\t          while (++index < length) {\n\t            var value = collection[index];\n\t            setter(result, value, iteratee(value, index, collection), collection);\n\t          }\n\t        } else {\n\t          baseEach(collection, function(value, key, collection) {\n\t            setter(result, value, iteratee(value, key, collection), collection);\n\t          });\n\t        }\n\t        return result;\n\t      };\n\t    }\n\t\n\t    /**\n\t     * Creates a `_.assign`, `_.defaults`, or `_.merge` function.\n\t     *\n\t     * @private\n\t     * @param {Function} assigner The function to assign values.\n\t     * @returns {Function} Returns the new assigner function.\n\t     */\n\t    function createAssigner(assigner) {\n\t      return restParam(function(object, sources) {\n\t        var index = -1,\n\t            length = object == null ? 0 : sources.length,\n\t            customizer = length > 2 ? sources[length - 2] : undefined,\n\t            guard = length > 2 ? sources[2] : undefined,\n\t            thisArg = length > 1 ? sources[length - 1] : undefined;\n\t\n\t        if (typeof customizer == 'function') {\n\t          customizer = bindCallback(customizer, thisArg, 5);\n\t          length -= 2;\n\t        } else {\n\t          customizer = typeof thisArg == 'function' ? thisArg : undefined;\n\t          length -= (customizer ? 1 : 0);\n\t        }\n\t        if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n\t          customizer = length < 3 ? undefined : customizer;\n\t          length = 1;\n\t        }\n\t        while (++index < length) {\n\t          var source = sources[index];\n\t          if (source) {\n\t            assigner(object, source, customizer);\n\t          }\n\t        }\n\t        return object;\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Creates a `baseEach` or `baseEachRight` function.\n\t     *\n\t     * @private\n\t     * @param {Function} eachFunc The function to iterate over a collection.\n\t     * @param {boolean} [fromRight] Specify iterating from right to left.\n\t     * @returns {Function} Returns the new base function.\n\t     */\n\t    function createBaseEach(eachFunc, fromRight) {\n\t      return function(collection, iteratee) {\n\t        var length = collection ? getLength(collection) : 0;\n\t        if (!isLength(length)) {\n\t          return eachFunc(collection, iteratee);\n\t        }\n\t        var index = fromRight ? length : -1,\n\t            iterable = toObject(collection);\n\t\n\t        while ((fromRight ? index-- : ++index < length)) {\n\t          if (iteratee(iterable[index], index, iterable) === false) {\n\t            break;\n\t          }\n\t        }\n\t        return collection;\n\t      };\n\t    }\n\t\n\t    /**\n\t     * Creates a base function for `_.forIn` or `_.forInRight`.\n\t     *\n\t     * @private\n\t     * @param {boolean} [fromRight] Specify iterating from right to left.\n\t     * @returns {Function} Returns the new base function.\n\t     */\n\t    function createBaseFor(fromRight) {\n\t      return function(object, iteratee, keysFunc) {\n\t        var iterable = toObject(object),\n\t            props = keysFunc(object),\n\t            length = props.length,\n\t            index = fromRight ? length : -1;\n\t\n\t        while ((fromRight ? index-- : ++index < length)) {\n\t          var key = props[index];\n\t          if (iteratee(iterable[key], key, iterable) === false) {\n\t            break;\n\t          }\n\t        }\n\t        return object;\n\t      };\n\t    }\n\t\n\t    /**\n\t     * Creates a function that wraps `func` and invokes it with the `this`\n\t     * binding of `thisArg`.\n\t     *\n\t     * @private\n\t     * @param {Function} func The function to bind.\n\t     * @param {*} [thisArg] The `this` binding of `func`.\n\t     * @returns {Function} Returns the new bound function.\n\t     */\n\t    function createBindWrapper(func, thisArg) {\n\t      var Ctor = createCtorWrapper(func);\n\t\n\t      function wrapper() {\n\t        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;\n\t        return fn.apply(thisArg, arguments);\n\t      }\n\t      return wrapper;\n\t    }\n\t\n\t    /**\n\t     * Creates a `Set` cache object to optimize linear searches of large arrays.\n\t     *\n\t     * @private\n\t     * @param {Array} [values] The values to cache.\n\t     * @returns {null|Object} Returns the new cache object if `Set` is supported, else `null`.\n\t     */\n\t    function createCache(values) {\n\t      return (nativeCreate && Set) ? new SetCache(values) : null;\n\t    }\n\t\n\t    /**\n\t     * Creates a function that produces compound words out of the words in a\n\t     * given string.\n\t     *\n\t     * @private\n\t     * @param {Function} callback The function to combine each word.\n\t     * @returns {Function} Returns the new compounder function.\n\t     */\n\t    function createCompounder(callback) {\n\t      return function(string) {\n\t        var index = -1,\n\t            array = words(deburr(string)),\n\t            length = array.length,\n\t            result = '';\n\t\n\t        while (++index < length) {\n\t          result = callback(result, array[index], index);\n\t        }\n\t        return result;\n\t      };\n\t    }\n\t\n\t    /**\n\t     * Creates a function that produces an instance of `Ctor` regardless of\n\t     * whether it was invoked as part of a `new` expression or by `call` or `apply`.\n\t     *\n\t     * @private\n\t     * @param {Function} Ctor The constructor to wrap.\n\t     * @returns {Function} Returns the new wrapped function.\n\t     */\n\t    function createCtorWrapper(Ctor) {\n\t      return function() {\n\t        // Use a `switch` statement to work with class constructors.\n\t        // See http://ecma-international.org/ecma-262/6.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist\n\t        // for more details.\n\t        var args = arguments;\n\t        switch (args.length) {\n\t          case 0: return new Ctor;\n\t          case 1: return new Ctor(args[0]);\n\t          case 2: return new Ctor(args[0], args[1]);\n\t          case 3: return new Ctor(args[0], args[1], args[2]);\n\t          case 4: return new Ctor(args[0], args[1], args[2], args[3]);\n\t          case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);\n\t          case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);\n\t          case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);\n\t        }\n\t        var thisBinding = baseCreate(Ctor.prototype),\n\t            result = Ctor.apply(thisBinding, args);\n\t\n\t        // Mimic the constructor's `return` behavior.\n\t        // See https://es5.github.io/#x13.2.2 for more details.\n\t        return isObject(result) ? result : thisBinding;\n\t      };\n\t    }\n\t\n\t    /**\n\t     * Creates a `_.curry` or `_.curryRight` function.\n\t     *\n\t     * @private\n\t     * @param {boolean} flag The curry bit flag.\n\t     * @returns {Function} Returns the new curry function.\n\t     */\n\t    function createCurry(flag) {\n\t      function curryFunc(func, arity, guard) {\n\t        if (guard && isIterateeCall(func, arity, guard)) {\n\t          arity = undefined;\n\t        }\n\t        var result = createWrapper(func, flag, undefined, undefined, undefined, undefined, undefined, arity);\n\t        result.placeholder = curryFunc.placeholder;\n\t        return result;\n\t      }\n\t      return curryFunc;\n\t    }\n\t\n\t    /**\n\t     * Creates a `_.defaults` or `_.defaultsDeep` function.\n\t     *\n\t     * @private\n\t     * @param {Function} assigner The function to assign values.\n\t     * @param {Function} customizer The function to customize assigned values.\n\t     * @returns {Function} Returns the new defaults function.\n\t     */\n\t    function createDefaults(assigner, customizer) {\n\t      return restParam(function(args) {\n\t        var object = args[0];\n\t        if (object == null) {\n\t          return object;\n\t        }\n\t        args.push(customizer);\n\t        return assigner.apply(undefined, args);\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Creates a `_.max` or `_.min` function.\n\t     *\n\t     * @private\n\t     * @param {Function} comparator The function used to compare values.\n\t     * @param {*} exValue The initial extremum value.\n\t     * @returns {Function} Returns the new extremum function.\n\t     */\n\t    function createExtremum(comparator, exValue) {\n\t      return function(collection, iteratee, thisArg) {\n\t        if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {\n\t          iteratee = undefined;\n\t        }\n\t        iteratee = getCallback(iteratee, thisArg, 3);\n\t        if (iteratee.length == 1) {\n\t          collection = isArray(collection) ? collection : toIterable(collection);\n\t          var result = arrayExtremum(collection, iteratee, comparator, exValue);\n\t          if (!(collection.length && result === exValue)) {\n\t            return result;\n\t          }\n\t        }\n\t        return baseExtremum(collection, iteratee, comparator, exValue);\n\t      };\n\t    }\n\t\n\t    /**\n\t     * Creates a `_.find` or `_.findLast` function.\n\t     *\n\t     * @private\n\t     * @param {Function} eachFunc The function to iterate over a collection.\n\t     * @param {boolean} [fromRight] Specify iterating from right to left.\n\t     * @returns {Function} Returns the new find function.\n\t     */\n\t    function createFind(eachFunc, fromRight) {\n\t      return function(collection, predicate, thisArg) {\n\t        predicate = getCallback(predicate, thisArg, 3);\n\t        if (isArray(collection)) {\n\t          var index = baseFindIndex(collection, predicate, fromRight);\n\t          return index > -1 ? collection[index] : undefined;\n\t        }\n\t        return baseFind(collection, predicate, eachFunc);\n\t      };\n\t    }\n\t\n\t    /**\n\t     * Creates a `_.findIndex` or `_.findLastIndex` function.\n\t     *\n\t     * @private\n\t     * @param {boolean} [fromRight] Specify iterating from right to left.\n\t     * @returns {Function} Returns the new find function.\n\t     */\n\t    function createFindIndex(fromRight) {\n\t      return function(array, predicate, thisArg) {\n\t        if (!(array && array.length)) {\n\t          return -1;\n\t        }\n\t        predicate = getCallback(predicate, thisArg, 3);\n\t        return baseFindIndex(array, predicate, fromRight);\n\t      };\n\t    }\n\t\n\t    /**\n\t     * Creates a `_.findKey` or `_.findLastKey` function.\n\t     *\n\t     * @private\n\t     * @param {Function} objectFunc The function to iterate over an object.\n\t     * @returns {Function} Returns the new find function.\n\t     */\n\t    function createFindKey(objectFunc) {\n\t      return function(object, predicate, thisArg) {\n\t        predicate = getCallback(predicate, thisArg, 3);\n\t        return baseFind(object, predicate, objectFunc, true);\n\t      };\n\t    }\n\t\n\t    /**\n\t     * Creates a `_.flow` or `_.flowRight` function.\n\t     *\n\t     * @private\n\t     * @param {boolean} [fromRight] Specify iterating from right to left.\n\t     * @returns {Function} Returns the new flow function.\n\t     */\n\t    function createFlow(fromRight) {\n\t      return function() {\n\t        var wrapper,\n\t            length = arguments.length,\n\t            index = fromRight ? length : -1,\n\t            leftIndex = 0,\n\t            funcs = Array(length);\n\t\n\t        while ((fromRight ? index-- : ++index < length)) {\n\t          var func = funcs[leftIndex++] = arguments[index];\n\t          if (typeof func != 'function') {\n\t            throw new TypeError(FUNC_ERROR_TEXT);\n\t          }\n\t          if (!wrapper && LodashWrapper.prototype.thru && getFuncName(func) == 'wrapper') {\n\t            wrapper = new LodashWrapper([], true);\n\t          }\n\t        }\n\t        index = wrapper ? -1 : length;\n\t        while (++index < length) {\n\t          func = funcs[index];\n\t\n\t          var funcName = getFuncName(func),\n\t              data = funcName == 'wrapper' ? getData(func) : undefined;\n\t\n\t          if (data && isLaziable(data[0]) && data[1] == (ARY_FLAG | CURRY_FLAG | PARTIAL_FLAG | REARG_FLAG) && !data[4].length && data[9] == 1) {\n\t            wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);\n\t          } else {\n\t            wrapper = (func.length == 1 && isLaziable(func)) ? wrapper[funcName]() : wrapper.thru(func);\n\t          }\n\t        }\n\t        return function() {\n\t          var args = arguments,\n\t              value = args[0];\n\t\n\t          if (wrapper && args.length == 1 && isArray(value) && value.length >= LARGE_ARRAY_SIZE) {\n\t            return wrapper.plant(value).value();\n\t          }\n\t          var index = 0,\n\t              result = length ? funcs[index].apply(this, args) : value;\n\t\n\t          while (++index < length) {\n\t            result = funcs[index].call(this, result);\n\t          }\n\t          return result;\n\t        };\n\t      };\n\t    }\n\t\n\t    /**\n\t     * Creates a function for `_.forEach` or `_.forEachRight`.\n\t     *\n\t     * @private\n\t     * @param {Function} arrayFunc The function to iterate over an array.\n\t     * @param {Function} eachFunc The function to iterate over a collection.\n\t     * @returns {Function} Returns the new each function.\n\t     */\n\t    function createForEach(arrayFunc, eachFunc) {\n\t      return function(collection, iteratee, thisArg) {\n\t        return (typeof iteratee == 'function' && thisArg === undefined && isArray(collection))\n\t          ? arrayFunc(collection, iteratee)\n\t          : eachFunc(collection, bindCallback(iteratee, thisArg, 3));\n\t      };\n\t    }\n\t\n\t    /**\n\t     * Creates a function for `_.forIn` or `_.forInRight`.\n\t     *\n\t     * @private\n\t     * @param {Function} objectFunc The function to iterate over an object.\n\t     * @returns {Function} Returns the new each function.\n\t     */\n\t    function createForIn(objectFunc) {\n\t      return function(object, iteratee, thisArg) {\n\t        if (typeof iteratee != 'function' || thisArg !== undefined) {\n\t          iteratee = bindCallback(iteratee, thisArg, 3);\n\t        }\n\t        return objectFunc(object, iteratee, keysIn);\n\t      };\n\t    }\n\t\n\t    /**\n\t     * Creates a function for `_.forOwn` or `_.forOwnRight`.\n\t     *\n\t     * @private\n\t     * @param {Function} objectFunc The function to iterate over an object.\n\t     * @returns {Function} Returns the new each function.\n\t     */\n\t    function createForOwn(objectFunc) {\n\t      return function(object, iteratee, thisArg) {\n\t        if (typeof iteratee != 'function' || thisArg !== undefined) {\n\t          iteratee = bindCallback(iteratee, thisArg, 3);\n\t        }\n\t        return objectFunc(object, iteratee);\n\t      };\n\t    }\n\t\n\t    /**\n\t     * Creates a function for `_.mapKeys` or `_.mapValues`.\n\t     *\n\t     * @private\n\t     * @param {boolean} [isMapKeys] Specify mapping keys instead of values.\n\t     * @returns {Function} Returns the new map function.\n\t     */\n\t    function createObjectMapper(isMapKeys) {\n\t      return function(object, iteratee, thisArg) {\n\t        var result = {};\n\t        iteratee = getCallback(iteratee, thisArg, 3);\n\t\n\t        baseForOwn(object, function(value, key, object) {\n\t          var mapped = iteratee(value, key, object);\n\t          key = isMapKeys ? mapped : key;\n\t          value = isMapKeys ? value : mapped;\n\t          result[key] = value;\n\t        });\n\t        return result;\n\t      };\n\t    }\n\t\n\t    /**\n\t     * Creates a function for `_.padLeft` or `_.padRight`.\n\t     *\n\t     * @private\n\t     * @param {boolean} [fromRight] Specify padding from the right.\n\t     * @returns {Function} Returns the new pad function.\n\t     */\n\t    function createPadDir(fromRight) {\n\t      return function(string, length, chars) {\n\t        string = baseToString(string);\n\t        return (fromRight ? string : '') + createPadding(string, length, chars) + (fromRight ? '' : string);\n\t      };\n\t    }\n\t\n\t    /**\n\t     * Creates a `_.partial` or `_.partialRight` function.\n\t     *\n\t     * @private\n\t     * @param {boolean} flag The partial bit flag.\n\t     * @returns {Function} Returns the new partial function.\n\t     */\n\t    function createPartial(flag) {\n\t      var partialFunc = restParam(function(func, partials) {\n\t        var holders = replaceHolders(partials, partialFunc.placeholder);\n\t        return createWrapper(func, flag, undefined, partials, holders);\n\t      });\n\t      return partialFunc;\n\t    }\n\t\n\t    /**\n\t     * Creates a function for `_.reduce` or `_.reduceRight`.\n\t     *\n\t     * @private\n\t     * @param {Function} arrayFunc The function to iterate over an array.\n\t     * @param {Function} eachFunc The function to iterate over a collection.\n\t     * @returns {Function} Returns the new each function.\n\t     */\n\t    function createReduce(arrayFunc, eachFunc) {\n\t      return function(collection, iteratee, accumulator, thisArg) {\n\t        var initFromArray = arguments.length < 3;\n\t        return (typeof iteratee == 'function' && thisArg === undefined && isArray(collection))\n\t          ? arrayFunc(collection, iteratee, accumulator, initFromArray)\n\t          : baseReduce(collection, getCallback(iteratee, thisArg, 4), accumulator, initFromArray, eachFunc);\n\t      };\n\t    }\n\t\n\t    /**\n\t     * Creates a function that wraps `func` and invokes it with optional `this`\n\t     * binding of, partial application, and currying.\n\t     *\n\t     * @private\n\t     * @param {Function|string} func The function or method name to reference.\n\t     * @param {number} bitmask The bitmask of flags. See `createWrapper` for more details.\n\t     * @param {*} [thisArg] The `this` binding of `func`.\n\t     * @param {Array} [partials] The arguments to prepend to those provided to the new function.\n\t     * @param {Array} [holders] The `partials` placeholder indexes.\n\t     * @param {Array} [partialsRight] The arguments to append to those provided to the new function.\n\t     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.\n\t     * @param {Array} [argPos] The argument positions of the new function.\n\t     * @param {number} [ary] The arity cap of `func`.\n\t     * @param {number} [arity] The arity of `func`.\n\t     * @returns {Function} Returns the new wrapped function.\n\t     */\n\t    function createHybridWrapper(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {\n\t      var isAry = bitmask & ARY_FLAG,\n\t          isBind = bitmask & BIND_FLAG,\n\t          isBindKey = bitmask & BIND_KEY_FLAG,\n\t          isCurry = bitmask & CURRY_FLAG,\n\t          isCurryBound = bitmask & CURRY_BOUND_FLAG,\n\t          isCurryRight = bitmask & CURRY_RIGHT_FLAG,\n\t          Ctor = isBindKey ? undefined : createCtorWrapper(func);\n\t\n\t      function wrapper() {\n\t        // Avoid `arguments` object use disqualifying optimizations by\n\t        // converting it to an array before providing it to other functions.\n\t        var length = arguments.length,\n\t            index = length,\n\t            args = Array(length);\n\t\n\t        while (index--) {\n\t          args[index] = arguments[index];\n\t        }\n\t        if (partials) {\n\t          args = composeArgs(args, partials, holders);\n\t        }\n\t        if (partialsRight) {\n\t          args = composeArgsRight(args, partialsRight, holdersRight);\n\t        }\n\t        if (isCurry || isCurryRight) {\n\t          var placeholder = wrapper.placeholder,\n\t              argsHolders = replaceHolders(args, placeholder);\n\t\n\t          length -= argsHolders.length;\n\t          if (length < arity) {\n\t            var newArgPos = argPos ? arrayCopy(argPos) : undefined,\n\t                newArity = nativeMax(arity - length, 0),\n\t                newsHolders = isCurry ? argsHolders : undefined,\n\t                newHoldersRight = isCurry ? undefined : argsHolders,\n\t                newPartials = isCurry ? args : undefined,\n\t                newPartialsRight = isCurry ? undefined : args;\n\t\n\t            bitmask |= (isCurry ? PARTIAL_FLAG : PARTIAL_RIGHT_FLAG);\n\t            bitmask &= ~(isCurry ? PARTIAL_RIGHT_FLAG : PARTIAL_FLAG);\n\t\n\t            if (!isCurryBound) {\n\t              bitmask &= ~(BIND_FLAG | BIND_KEY_FLAG);\n\t            }\n\t            var newData = [func, bitmask, thisArg, newPartials, newsHolders, newPartialsRight, newHoldersRight, newArgPos, ary, newArity],\n\t                result = createHybridWrapper.apply(undefined, newData);\n\t\n\t            if (isLaziable(func)) {\n\t              setData(result, newData);\n\t            }\n\t            result.placeholder = placeholder;\n\t            return result;\n\t          }\n\t        }\n\t        var thisBinding = isBind ? thisArg : this,\n\t            fn = isBindKey ? thisBinding[func] : func;\n\t\n\t        if (argPos) {\n\t          args = reorder(args, argPos);\n\t        }\n\t        if (isAry && ary < args.length) {\n\t          args.length = ary;\n\t        }\n\t        if (this && this !== root && this instanceof wrapper) {\n\t          fn = Ctor || createCtorWrapper(func);\n\t        }\n\t        return fn.apply(thisBinding, args);\n\t      }\n\t      return wrapper;\n\t    }\n\t\n\t    /**\n\t     * Creates the padding required for `string` based on the given `length`.\n\t     * The `chars` string is truncated if the number of characters exceeds `length`.\n\t     *\n\t     * @private\n\t     * @param {string} string The string to create padding for.\n\t     * @param {number} [length=0] The padding length.\n\t     * @param {string} [chars=' '] The string used as padding.\n\t     * @returns {string} Returns the pad for `string`.\n\t     */\n\t    function createPadding(string, length, chars) {\n\t      var strLength = string.length;\n\t      length = +length;\n\t\n\t      if (strLength >= length || !nativeIsFinite(length)) {\n\t        return '';\n\t      }\n\t      var padLength = length - strLength;\n\t      chars = chars == null ? ' ' : (chars + '');\n\t      return repeat(chars, nativeCeil(padLength / chars.length)).slice(0, padLength);\n\t    }\n\t\n\t    /**\n\t     * Creates a function that wraps `func` and invokes it with the optional `this`\n\t     * binding of `thisArg` and the `partials` prepended to those provided to\n\t     * the wrapper.\n\t     *\n\t     * @private\n\t     * @param {Function} func The function to partially apply arguments to.\n\t     * @param {number} bitmask The bitmask of flags. See `createWrapper` for more details.\n\t     * @param {*} thisArg The `this` binding of `func`.\n\t     * @param {Array} partials The arguments to prepend to those provided to the new function.\n\t     * @returns {Function} Returns the new bound function.\n\t     */\n\t    function createPartialWrapper(func, bitmask, thisArg, partials) {\n\t      var isBind = bitmask & BIND_FLAG,\n\t          Ctor = createCtorWrapper(func);\n\t\n\t      function wrapper() {\n\t        // Avoid `arguments` object use disqualifying optimizations by\n\t        // converting it to an array before providing it `func`.\n\t        var argsIndex = -1,\n\t            argsLength = arguments.length,\n\t            leftIndex = -1,\n\t            leftLength = partials.length,\n\t            args = Array(leftLength + argsLength);\n\t\n\t        while (++leftIndex < leftLength) {\n\t          args[leftIndex] = partials[leftIndex];\n\t        }\n\t        while (argsLength--) {\n\t          args[leftIndex++] = arguments[++argsIndex];\n\t        }\n\t        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;\n\t        return fn.apply(isBind ? thisArg : this, args);\n\t      }\n\t      return wrapper;\n\t    }\n\t\n\t    /**\n\t     * Creates a `_.ceil`, `_.floor`, or `_.round` function.\n\t     *\n\t     * @private\n\t     * @param {string} methodName The name of the `Math` method to use when rounding.\n\t     * @returns {Function} Returns the new round function.\n\t     */\n\t    function createRound(methodName) {\n\t      var func = Math[methodName];\n\t      return function(number, precision) {\n\t        precision = precision === undefined ? 0 : (+precision || 0);\n\t        if (precision) {\n\t          precision = pow(10, precision);\n\t          return func(number * precision) / precision;\n\t        }\n\t        return func(number);\n\t      };\n\t    }\n\t\n\t    /**\n\t     * Creates a `_.sortedIndex` or `_.sortedLastIndex` function.\n\t     *\n\t     * @private\n\t     * @param {boolean} [retHighest] Specify returning the highest qualified index.\n\t     * @returns {Function} Returns the new index function.\n\t     */\n\t    function createSortedIndex(retHighest) {\n\t      return function(array, value, iteratee, thisArg) {\n\t        var callback = getCallback(iteratee);\n\t        return (iteratee == null && callback === baseCallback)\n\t          ? binaryIndex(array, value, retHighest)\n\t          : binaryIndexBy(array, value, callback(iteratee, thisArg, 1), retHighest);\n\t      };\n\t    }\n\t\n\t    /**\n\t     * Creates a function that either curries or invokes `func` with optional\n\t     * `this` binding and partially applied arguments.\n\t     *\n\t     * @private\n\t     * @param {Function|string} func The function or method name to reference.\n\t     * @param {number} bitmask The bitmask of flags.\n\t     *  The bitmask may be composed of the following flags:\n\t     *     1 - `_.bind`\n\t     *     2 - `_.bindKey`\n\t     *     4 - `_.curry` or `_.curryRight` of a bound function\n\t     *     8 - `_.curry`\n\t     *    16 - `_.curryRight`\n\t     *    32 - `_.partial`\n\t     *    64 - `_.partialRight`\n\t     *   128 - `_.rearg`\n\t     *   256 - `_.ary`\n\t     * @param {*} [thisArg] The `this` binding of `func`.\n\t     * @param {Array} [partials] The arguments to be partially applied.\n\t     * @param {Array} [holders] The `partials` placeholder indexes.\n\t     * @param {Array} [argPos] The argument positions of the new function.\n\t     * @param {number} [ary] The arity cap of `func`.\n\t     * @param {number} [arity] The arity of `func`.\n\t     * @returns {Function} Returns the new wrapped function.\n\t     */\n\t    function createWrapper(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {\n\t      var isBindKey = bitmask & BIND_KEY_FLAG;\n\t      if (!isBindKey && typeof func != 'function') {\n\t        throw new TypeError(FUNC_ERROR_TEXT);\n\t      }\n\t      var length = partials ? partials.length : 0;\n\t      if (!length) {\n\t        bitmask &= ~(PARTIAL_FLAG | PARTIAL_RIGHT_FLAG);\n\t        partials = holders = undefined;\n\t      }\n\t      length -= (holders ? holders.length : 0);\n\t      if (bitmask & PARTIAL_RIGHT_FLAG) {\n\t        var partialsRight = partials,\n\t            holdersRight = holders;\n\t\n\t        partials = holders = undefined;\n\t      }\n\t      var data = isBindKey ? undefined : getData(func),\n\t          newData = [func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity];\n\t\n\t      if (data) {\n\t        mergeData(newData, data);\n\t        bitmask = newData[1];\n\t        arity = newData[9];\n\t      }\n\t      newData[9] = arity == null\n\t        ? (isBindKey ? 0 : func.length)\n\t        : (nativeMax(arity - length, 0) || 0);\n\t\n\t      if (bitmask == BIND_FLAG) {\n\t        var result = createBindWrapper(newData[0], newData[2]);\n\t      } else if ((bitmask == PARTIAL_FLAG || bitmask == (BIND_FLAG | PARTIAL_FLAG)) && !newData[4].length) {\n\t        result = createPartialWrapper.apply(undefined, newData);\n\t      } else {\n\t        result = createHybridWrapper.apply(undefined, newData);\n\t      }\n\t      var setter = data ? baseSetData : setData;\n\t      return setter(result, newData);\n\t    }\n\t\n\t    /**\n\t     * A specialized version of `baseIsEqualDeep` for arrays with support for\n\t     * partial deep comparisons.\n\t     *\n\t     * @private\n\t     * @param {Array} array The array to compare.\n\t     * @param {Array} other The other array to compare.\n\t     * @param {Function} equalFunc The function to determine equivalents of values.\n\t     * @param {Function} [customizer] The function to customize comparing arrays.\n\t     * @param {boolean} [isLoose] Specify performing partial comparisons.\n\t     * @param {Array} [stackA] Tracks traversed `value` objects.\n\t     * @param {Array} [stackB] Tracks traversed `other` objects.\n\t     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n\t     */\n\t    function equalArrays(array, other, equalFunc, customizer, isLoose, stackA, stackB) {\n\t      var index = -1,\n\t          arrLength = array.length,\n\t          othLength = other.length;\n\t\n\t      if (arrLength != othLength && !(isLoose && othLength > arrLength)) {\n\t        return false;\n\t      }\n\t      // Ignore non-index properties.\n\t      while (++index < arrLength) {\n\t        var arrValue = array[index],\n\t            othValue = other[index],\n\t            result = customizer ? customizer(isLoose ? othValue : arrValue, isLoose ? arrValue : othValue, index) : undefined;\n\t\n\t        if (result !== undefined) {\n\t          if (result) {\n\t            continue;\n\t          }\n\t          return false;\n\t        }\n\t        // Recursively compare arrays (susceptible to call stack limits).\n\t        if (isLoose) {\n\t          if (!arraySome(other, function(othValue) {\n\t                return arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB);\n\t              })) {\n\t            return false;\n\t          }\n\t        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB))) {\n\t          return false;\n\t        }\n\t      }\n\t      return true;\n\t    }\n\t\n\t    /**\n\t     * A specialized version of `baseIsEqualDeep` for comparing objects of\n\t     * the same `toStringTag`.\n\t     *\n\t     * **Note:** This function only supports comparing values with tags of\n\t     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n\t     *\n\t     * @private\n\t     * @param {Object} object The object to compare.\n\t     * @param {Object} other The other object to compare.\n\t     * @param {string} tag The `toStringTag` of the objects to compare.\n\t     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n\t     */\n\t    function equalByTag(object, other, tag) {\n\t      switch (tag) {\n\t        case boolTag:\n\t        case dateTag:\n\t          // Coerce dates and booleans to numbers, dates to milliseconds and booleans\n\t          // to `1` or `0` treating invalid dates coerced to `NaN` as not equal.\n\t          return +object == +other;\n\t\n\t        case errorTag:\n\t          return object.name == other.name && object.message == other.message;\n\t\n\t        case numberTag:\n\t          // Treat `NaN` vs. `NaN` as equal.\n\t          return (object != +object)\n\t            ? other != +other\n\t            : object == +other;\n\t\n\t        case regexpTag:\n\t        case stringTag:\n\t          // Coerce regexes to strings and treat strings primitives and string\n\t          // objects as equal. See https://es5.github.io/#x15.10.6.4 for more details.\n\t          return object == (other + '');\n\t      }\n\t      return false;\n\t    }\n\t\n\t    /**\n\t     * A specialized version of `baseIsEqualDeep` for objects with support for\n\t     * partial deep comparisons.\n\t     *\n\t     * @private\n\t     * @param {Object} object The object to compare.\n\t     * @param {Object} other The other object to compare.\n\t     * @param {Function} equalFunc The function to determine equivalents of values.\n\t     * @param {Function} [customizer] The function to customize comparing values.\n\t     * @param {boolean} [isLoose] Specify performing partial comparisons.\n\t     * @param {Array} [stackA] Tracks traversed `value` objects.\n\t     * @param {Array} [stackB] Tracks traversed `other` objects.\n\t     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n\t     */\n\t    function equalObjects(object, other, equalFunc, customizer, isLoose, stackA, stackB) {\n\t      var objProps = keys(object),\n\t          objLength = objProps.length,\n\t          othProps = keys(other),\n\t          othLength = othProps.length;\n\t\n\t      if (objLength != othLength && !isLoose) {\n\t        return false;\n\t      }\n\t      var index = objLength;\n\t      while (index--) {\n\t        var key = objProps[index];\n\t        if (!(isLoose ? key in other : hasOwnProperty.call(other, key))) {\n\t          return false;\n\t        }\n\t      }\n\t      var skipCtor = isLoose;\n\t      while (++index < objLength) {\n\t        key = objProps[index];\n\t        var objValue = object[key],\n\t            othValue = other[key],\n\t            result = customizer ? customizer(isLoose ? othValue : objValue, isLoose? objValue : othValue, key) : undefined;\n\t\n\t        // Recursively compare objects (susceptible to call stack limits).\n\t        if (!(result === undefined ? equalFunc(objValue, othValue, customizer, isLoose, stackA, stackB) : result)) {\n\t          return false;\n\t        }\n\t        skipCtor || (skipCtor = key == 'constructor');\n\t      }\n\t      if (!skipCtor) {\n\t        var objCtor = object.constructor,\n\t            othCtor = other.constructor;\n\t\n\t        // Non `Object` object instances with different constructors are not equal.\n\t        if (objCtor != othCtor &&\n\t            ('constructor' in object && 'constructor' in other) &&\n\t            !(typeof objCtor == 'function' && objCtor instanceof objCtor &&\n\t              typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n\t          return false;\n\t        }\n\t      }\n\t      return true;\n\t    }\n\t\n\t    /**\n\t     * Gets the appropriate \"callback\" function. If the `_.callback` method is\n\t     * customized this function returns the custom method, otherwise it returns\n\t     * the `baseCallback` function. If arguments are provided the chosen function\n\t     * is invoked with them and its result is returned.\n\t     *\n\t     * @private\n\t     * @returns {Function} Returns the chosen function or its result.\n\t     */\n\t    function getCallback(func, thisArg, argCount) {\n\t      var result = lodash.callback || callback;\n\t      result = result === callback ? baseCallback : result;\n\t      return argCount ? result(func, thisArg, argCount) : result;\n\t    }\n\t\n\t    /**\n\t     * Gets metadata for `func`.\n\t     *\n\t     * @private\n\t     * @param {Function} func The function to query.\n\t     * @returns {*} Returns the metadata for `func`.\n\t     */\n\t    var getData = !metaMap ? noop : function(func) {\n\t      return metaMap.get(func);\n\t    };\n\t\n\t    /**\n\t     * Gets the name of `func`.\n\t     *\n\t     * @private\n\t     * @param {Function} func The function to query.\n\t     * @returns {string} Returns the function name.\n\t     */\n\t    function getFuncName(func) {\n\t      var result = func.name,\n\t          array = realNames[result],\n\t          length = array ? array.length : 0;\n\t\n\t      while (length--) {\n\t        var data = array[length],\n\t            otherFunc = data.func;\n\t        if (otherFunc == null || otherFunc == func) {\n\t          return data.name;\n\t        }\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * Gets the appropriate \"indexOf\" function. If the `_.indexOf` method is\n\t     * customized this function returns the custom method, otherwise it returns\n\t     * the `baseIndexOf` function. If arguments are provided the chosen function\n\t     * is invoked with them and its result is returned.\n\t     *\n\t     * @private\n\t     * @returns {Function|number} Returns the chosen function or its result.\n\t     */\n\t    function getIndexOf(collection, target, fromIndex) {\n\t      var result = lodash.indexOf || indexOf;\n\t      result = result === indexOf ? baseIndexOf : result;\n\t      return collection ? result(collection, target, fromIndex) : result;\n\t    }\n\t\n\t    /**\n\t     * Gets the \"length\" property value of `object`.\n\t     *\n\t     * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)\n\t     * that affects Safari on at least iOS 8.1-8.3 ARM64.\n\t     *\n\t     * @private\n\t     * @param {Object} object The object to query.\n\t     * @returns {*} Returns the \"length\" value.\n\t     */\n\t    var getLength = baseProperty('length');\n\t\n\t    /**\n\t     * Gets the propery names, values, and compare flags of `object`.\n\t     *\n\t     * @private\n\t     * @param {Object} object The object to query.\n\t     * @returns {Array} Returns the match data of `object`.\n\t     */\n\t    function getMatchData(object) {\n\t      var result = pairs(object),\n\t          length = result.length;\n\t\n\t      while (length--) {\n\t        result[length][2] = isStrictComparable(result[length][1]);\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * Gets the native function at `key` of `object`.\n\t     *\n\t     * @private\n\t     * @param {Object} object The object to query.\n\t     * @param {string} key The key of the method to get.\n\t     * @returns {*} Returns the function if it's native, else `undefined`.\n\t     */\n\t    function getNative(object, key) {\n\t      var value = object == null ? undefined : object[key];\n\t      return isNative(value) ? value : undefined;\n\t    }\n\t\n\t    /**\n\t     * Gets the view, applying any `transforms` to the `start` and `end` positions.\n\t     *\n\t     * @private\n\t     * @param {number} start The start of the view.\n\t     * @param {number} end The end of the view.\n\t     * @param {Array} transforms The transformations to apply to the view.\n\t     * @returns {Object} Returns an object containing the `start` and `end`\n\t     *  positions of the view.\n\t     */\n\t    function getView(start, end, transforms) {\n\t      var index = -1,\n\t          length = transforms.length;\n\t\n\t      while (++index < length) {\n\t        var data = transforms[index],\n\t            size = data.size;\n\t\n\t        switch (data.type) {\n\t          case 'drop':      start += size; break;\n\t          case 'dropRight': end -= size; break;\n\t          case 'take':      end = nativeMin(end, start + size); break;\n\t          case 'takeRight': start = nativeMax(start, end - size); break;\n\t        }\n\t      }\n\t      return { 'start': start, 'end': end };\n\t    }\n\t\n\t    /**\n\t     * Initializes an array clone.\n\t     *\n\t     * @private\n\t     * @param {Array} array The array to clone.\n\t     * @returns {Array} Returns the initialized clone.\n\t     */\n\t    function initCloneArray(array) {\n\t      var length = array.length,\n\t          result = new array.constructor(length);\n\t\n\t      // Add array properties assigned by `RegExp#exec`.\n\t      if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {\n\t        result.index = array.index;\n\t        result.input = array.input;\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * Initializes an object clone.\n\t     *\n\t     * @private\n\t     * @param {Object} object The object to clone.\n\t     * @returns {Object} Returns the initialized clone.\n\t     */\n\t    function initCloneObject(object) {\n\t      var Ctor = object.constructor;\n\t      if (!(typeof Ctor == 'function' && Ctor instanceof Ctor)) {\n\t        Ctor = Object;\n\t      }\n\t      return new Ctor;\n\t    }\n\t\n\t    /**\n\t     * Initializes an object clone based on its `toStringTag`.\n\t     *\n\t     * **Note:** This function only supports cloning values with tags of\n\t     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n\t     *\n\t     * @private\n\t     * @param {Object} object The object to clone.\n\t     * @param {string} tag The `toStringTag` of the object to clone.\n\t     * @param {boolean} [isDeep] Specify a deep clone.\n\t     * @returns {Object} Returns the initialized clone.\n\t     */\n\t    function initCloneByTag(object, tag, isDeep) {\n\t      var Ctor = object.constructor;\n\t      switch (tag) {\n\t        case arrayBufferTag:\n\t          return bufferClone(object);\n\t\n\t        case boolTag:\n\t        case dateTag:\n\t          return new Ctor(+object);\n\t\n\t        case float32Tag: case float64Tag:\n\t        case int8Tag: case int16Tag: case int32Tag:\n\t        case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:\n\t          var buffer = object.buffer;\n\t          return new Ctor(isDeep ? bufferClone(buffer) : buffer, object.byteOffset, object.length);\n\t\n\t        case numberTag:\n\t        case stringTag:\n\t          return new Ctor(object);\n\t\n\t        case regexpTag:\n\t          var result = new Ctor(object.source, reFlags.exec(object));\n\t          result.lastIndex = object.lastIndex;\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * Invokes the method at `path` on `object`.\n\t     *\n\t     * @private\n\t     * @param {Object} object The object to query.\n\t     * @param {Array|string} path The path of the method to invoke.\n\t     * @param {Array} args The arguments to invoke the method with.\n\t     * @returns {*} Returns the result of the invoked method.\n\t     */\n\t    function invokePath(object, path, args) {\n\t      if (object != null && !isKey(path, object)) {\n\t        path = toPath(path);\n\t        object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));\n\t        path = last(path);\n\t      }\n\t      var func = object == null ? object : object[path];\n\t      return func == null ? undefined : func.apply(object, args);\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is array-like.\n\t     *\n\t     * @private\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n\t     */\n\t    function isArrayLike(value) {\n\t      return value != null && isLength(getLength(value));\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is a valid array-like index.\n\t     *\n\t     * @private\n\t     * @param {*} value The value to check.\n\t     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n\t     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n\t     */\n\t    function isIndex(value, length) {\n\t      value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;\n\t      length = length == null ? MAX_SAFE_INTEGER : length;\n\t      return value > -1 && value % 1 == 0 && value < length;\n\t    }\n\t\n\t    /**\n\t     * Checks if the provided arguments are from an iteratee call.\n\t     *\n\t     * @private\n\t     * @param {*} value The potential iteratee value argument.\n\t     * @param {*} index The potential iteratee index or key argument.\n\t     * @param {*} object The potential iteratee object argument.\n\t     * @returns {boolean} Returns `true` if the arguments are from an iteratee call, else `false`.\n\t     */\n\t    function isIterateeCall(value, index, object) {\n\t      if (!isObject(object)) {\n\t        return false;\n\t      }\n\t      var type = typeof index;\n\t      if (type == 'number'\n\t          ? (isArrayLike(object) && isIndex(index, object.length))\n\t          : (type == 'string' && index in object)) {\n\t        var other = object[index];\n\t        return value === value ? (value === other) : (other !== other);\n\t      }\n\t      return false;\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is a property name and not a property path.\n\t     *\n\t     * @private\n\t     * @param {*} value The value to check.\n\t     * @param {Object} [object] The object to query keys on.\n\t     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n\t     */\n\t    function isKey(value, object) {\n\t      var type = typeof value;\n\t      if ((type == 'string' && reIsPlainProp.test(value)) || type == 'number') {\n\t        return true;\n\t      }\n\t      if (isArray(value)) {\n\t        return false;\n\t      }\n\t      var result = !reIsDeepProp.test(value);\n\t      return result || (object != null && value in toObject(object));\n\t    }\n\t\n\t    /**\n\t     * Checks if `func` has a lazy counterpart.\n\t     *\n\t     * @private\n\t     * @param {Function} func The function to check.\n\t     * @returns {boolean} Returns `true` if `func` has a lazy counterpart, else `false`.\n\t     */\n\t    function isLaziable(func) {\n\t      var funcName = getFuncName(func);\n\t      if (!(funcName in LazyWrapper.prototype)) {\n\t        return false;\n\t      }\n\t      var other = lodash[funcName];\n\t      if (func === other) {\n\t        return true;\n\t      }\n\t      var data = getData(other);\n\t      return !!data && func === data[0];\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is a valid array-like length.\n\t     *\n\t     * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).\n\t     *\n\t     * @private\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n\t     */\n\t    function isLength(value) {\n\t      return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.\n\t     *\n\t     * @private\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` if suitable for strict\n\t     *  equality comparisons, else `false`.\n\t     */\n\t    function isStrictComparable(value) {\n\t      return value === value && !isObject(value);\n\t    }\n\t\n\t    /**\n\t     * Merges the function metadata of `source` into `data`.\n\t     *\n\t     * Merging metadata reduces the number of wrappers required to invoke a function.\n\t     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`\n\t     * may be applied regardless of execution order. Methods like `_.ary` and `_.rearg`\n\t     * augment function arguments, making the order in which they are executed important,\n\t     * preventing the merging of metadata. However, we make an exception for a safe\n\t     * common case where curried functions have `_.ary` and or `_.rearg` applied.\n\t     *\n\t     * @private\n\t     * @param {Array} data The destination metadata.\n\t     * @param {Array} source The source metadata.\n\t     * @returns {Array} Returns `data`.\n\t     */\n\t    function mergeData(data, source) {\n\t      var bitmask = data[1],\n\t          srcBitmask = source[1],\n\t          newBitmask = bitmask | srcBitmask,\n\t          isCommon = newBitmask < ARY_FLAG;\n\t\n\t      var isCombo =\n\t        (srcBitmask == ARY_FLAG && bitmask == CURRY_FLAG) ||\n\t        (srcBitmask == ARY_FLAG && bitmask == REARG_FLAG && data[7].length <= source[8]) ||\n\t        (srcBitmask == (ARY_FLAG | REARG_FLAG) && bitmask == CURRY_FLAG);\n\t\n\t      // Exit early if metadata can't be merged.\n\t      if (!(isCommon || isCombo)) {\n\t        return data;\n\t      }\n\t      // Use source `thisArg` if available.\n\t      if (srcBitmask & BIND_FLAG) {\n\t        data[2] = source[2];\n\t        // Set when currying a bound function.\n\t        newBitmask |= (bitmask & BIND_FLAG) ? 0 : CURRY_BOUND_FLAG;\n\t      }\n\t      // Compose partial arguments.\n\t      var value = source[3];\n\t      if (value) {\n\t        var partials = data[3];\n\t        data[3] = partials ? composeArgs(partials, value, source[4]) : arrayCopy(value);\n\t        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : arrayCopy(source[4]);\n\t      }\n\t      // Compose partial right arguments.\n\t      value = source[5];\n\t      if (value) {\n\t        partials = data[5];\n\t        data[5] = partials ? composeArgsRight(partials, value, source[6]) : arrayCopy(value);\n\t        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : arrayCopy(source[6]);\n\t      }\n\t      // Use source `argPos` if available.\n\t      value = source[7];\n\t      if (value) {\n\t        data[7] = arrayCopy(value);\n\t      }\n\t      // Use source `ary` if it's smaller.\n\t      if (srcBitmask & ARY_FLAG) {\n\t        data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);\n\t      }\n\t      // Use source `arity` if one is not provided.\n\t      if (data[9] == null) {\n\t        data[9] = source[9];\n\t      }\n\t      // Use source `func` and merge bitmasks.\n\t      data[0] = source[0];\n\t      data[1] = newBitmask;\n\t\n\t      return data;\n\t    }\n\t\n\t    /**\n\t     * Used by `_.defaultsDeep` to customize its `_.merge` use.\n\t     *\n\t     * @private\n\t     * @param {*} objectValue The destination object property value.\n\t     * @param {*} sourceValue The source object property value.\n\t     * @returns {*} Returns the value to assign to the destination object.\n\t     */\n\t    function mergeDefaults(objectValue, sourceValue) {\n\t      return objectValue === undefined ? sourceValue : merge(objectValue, sourceValue, mergeDefaults);\n\t    }\n\t\n\t    /**\n\t     * A specialized version of `_.pick` which picks `object` properties specified\n\t     * by `props`.\n\t     *\n\t     * @private\n\t     * @param {Object} object The source object.\n\t     * @param {string[]} props The property names to pick.\n\t     * @returns {Object} Returns the new object.\n\t     */\n\t    function pickByArray(object, props) {\n\t      object = toObject(object);\n\t\n\t      var index = -1,\n\t          length = props.length,\n\t          result = {};\n\t\n\t      while (++index < length) {\n\t        var key = props[index];\n\t        if (key in object) {\n\t          result[key] = object[key];\n\t        }\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * A specialized version of `_.pick` which picks `object` properties `predicate`\n\t     * returns truthy for.\n\t     *\n\t     * @private\n\t     * @param {Object} object The source object.\n\t     * @param {Function} predicate The function invoked per iteration.\n\t     * @returns {Object} Returns the new object.\n\t     */\n\t    function pickByCallback(object, predicate) {\n\t      var result = {};\n\t      baseForIn(object, function(value, key, object) {\n\t        if (predicate(value, key, object)) {\n\t          result[key] = value;\n\t        }\n\t      });\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * Reorder `array` according to the specified indexes where the element at\n\t     * the first index is assigned as the first element, the element at\n\t     * the second index is assigned as the second element, and so on.\n\t     *\n\t     * @private\n\t     * @param {Array} array The array to reorder.\n\t     * @param {Array} indexes The arranged array indexes.\n\t     * @returns {Array} Returns `array`.\n\t     */\n\t    function reorder(array, indexes) {\n\t      var arrLength = array.length,\n\t          length = nativeMin(indexes.length, arrLength),\n\t          oldArray = arrayCopy(array);\n\t\n\t      while (length--) {\n\t        var index = indexes[length];\n\t        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;\n\t      }\n\t      return array;\n\t    }\n\t\n\t    /**\n\t     * Sets metadata for `func`.\n\t     *\n\t     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short\n\t     * period of time, it will trip its breaker and transition to an identity function\n\t     * to avoid garbage collection pauses in V8. See [V8 issue 2070](https://code.google.com/p/v8/issues/detail?id=2070)\n\t     * for more details.\n\t     *\n\t     * @private\n\t     * @param {Function} func The function to associate metadata with.\n\t     * @param {*} data The metadata.\n\t     * @returns {Function} Returns `func`.\n\t     */\n\t    var setData = (function() {\n\t      var count = 0,\n\t          lastCalled = 0;\n\t\n\t      return function(key, value) {\n\t        var stamp = now(),\n\t            remaining = HOT_SPAN - (stamp - lastCalled);\n\t\n\t        lastCalled = stamp;\n\t        if (remaining > 0) {\n\t          if (++count >= HOT_COUNT) {\n\t            return key;\n\t          }\n\t        } else {\n\t          count = 0;\n\t        }\n\t        return baseSetData(key, value);\n\t      };\n\t    }());\n\t\n\t    /**\n\t     * A fallback implementation of `Object.keys` which creates an array of the\n\t     * own enumerable property names of `object`.\n\t     *\n\t     * @private\n\t     * @param {Object} object The object to query.\n\t     * @returns {Array} Returns the array of property names.\n\t     */\n\t    function shimKeys(object) {\n\t      var props = keysIn(object),\n\t          propsLength = props.length,\n\t          length = propsLength && object.length;\n\t\n\t      var allowIndexes = !!length && isLength(length) &&\n\t        (isArray(object) || isArguments(object));\n\t\n\t      var index = -1,\n\t          result = [];\n\t\n\t      while (++index < propsLength) {\n\t        var key = props[index];\n\t        if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {\n\t          result.push(key);\n\t        }\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * Converts `value` to an array-like object if it's not one.\n\t     *\n\t     * @private\n\t     * @param {*} value The value to process.\n\t     * @returns {Array|Object} Returns the array-like object.\n\t     */\n\t    function toIterable(value) {\n\t      if (value == null) {\n\t        return [];\n\t      }\n\t      if (!isArrayLike(value)) {\n\t        return values(value);\n\t      }\n\t      return isObject(value) ? value : Object(value);\n\t    }\n\t\n\t    /**\n\t     * Converts `value` to an object if it's not one.\n\t     *\n\t     * @private\n\t     * @param {*} value The value to process.\n\t     * @returns {Object} Returns the object.\n\t     */\n\t    function toObject(value) {\n\t      return isObject(value) ? value : Object(value);\n\t    }\n\t\n\t    /**\n\t     * Converts `value` to property path array if it's not one.\n\t     *\n\t     * @private\n\t     * @param {*} value The value to process.\n\t     * @returns {Array} Returns the property path array.\n\t     */\n\t    function toPath(value) {\n\t      if (isArray(value)) {\n\t        return value;\n\t      }\n\t      var result = [];\n\t      baseToString(value).replace(rePropName, function(match, number, quote, string) {\n\t        result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));\n\t      });\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * Creates a clone of `wrapper`.\n\t     *\n\t     * @private\n\t     * @param {Object} wrapper The wrapper to clone.\n\t     * @returns {Object} Returns the cloned wrapper.\n\t     */\n\t    function wrapperClone(wrapper) {\n\t      return wrapper instanceof LazyWrapper\n\t        ? wrapper.clone()\n\t        : new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__, arrayCopy(wrapper.__actions__));\n\t    }\n\t\n\t    /*------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * Creates an array of elements split into groups the length of `size`.\n\t     * If `collection` can't be split evenly, the final chunk will be the remaining\n\t     * elements.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {Array} array The array to process.\n\t     * @param {number} [size=1] The length of each chunk.\n\t     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n\t     * @returns {Array} Returns the new array containing chunks.\n\t     * @example\n\t     *\n\t     * _.chunk(['a', 'b', 'c', 'd'], 2);\n\t     * // => [['a', 'b'], ['c', 'd']]\n\t     *\n\t     * _.chunk(['a', 'b', 'c', 'd'], 3);\n\t     * // => [['a', 'b', 'c'], ['d']]\n\t     */\n\t    function chunk(array, size, guard) {\n\t      if (guard ? isIterateeCall(array, size, guard) : size == null) {\n\t        size = 1;\n\t      } else {\n\t        size = nativeMax(nativeFloor(size) || 1, 1);\n\t      }\n\t      var index = 0,\n\t          length = array ? array.length : 0,\n\t          resIndex = -1,\n\t          result = Array(nativeCeil(length / size));\n\t\n\t      while (index < length) {\n\t        result[++resIndex] = baseSlice(array, index, (index += size));\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * Creates an array with all falsey values removed. The values `false`, `null`,\n\t     * `0`, `\"\"`, `undefined`, and `NaN` are falsey.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {Array} array The array to compact.\n\t     * @returns {Array} Returns the new array of filtered values.\n\t     * @example\n\t     *\n\t     * _.compact([0, 1, false, 2, '', 3]);\n\t     * // => [1, 2, 3]\n\t     */\n\t    function compact(array) {\n\t      var index = -1,\n\t          length = array ? array.length : 0,\n\t          resIndex = -1,\n\t          result = [];\n\t\n\t      while (++index < length) {\n\t        var value = array[index];\n\t        if (value) {\n\t          result[++resIndex] = value;\n\t        }\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * Creates an array of unique `array` values not included in the other\n\t     * provided arrays using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)\n\t     * for equality comparisons.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {Array} array The array to inspect.\n\t     * @param {...Array} [values] The arrays of values to exclude.\n\t     * @returns {Array} Returns the new array of filtered values.\n\t     * @example\n\t     *\n\t     * _.difference([1, 2, 3], [4, 2]);\n\t     * // => [1, 3]\n\t     */\n\t    var difference = restParam(function(array, values) {\n\t      return (isObjectLike(array) && isArrayLike(array))\n\t        ? baseDifference(array, baseFlatten(values, false, true))\n\t        : [];\n\t    });\n\t\n\t    /**\n\t     * Creates a slice of `array` with `n` elements dropped from the beginning.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {Array} array The array to query.\n\t     * @param {number} [n=1] The number of elements to drop.\n\t     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n\t     * @returns {Array} Returns the slice of `array`.\n\t     * @example\n\t     *\n\t     * _.drop([1, 2, 3]);\n\t     * // => [2, 3]\n\t     *\n\t     * _.drop([1, 2, 3], 2);\n\t     * // => [3]\n\t     *\n\t     * _.drop([1, 2, 3], 5);\n\t     * // => []\n\t     *\n\t     * _.drop([1, 2, 3], 0);\n\t     * // => [1, 2, 3]\n\t     */\n\t    function drop(array, n, guard) {\n\t      var length = array ? array.length : 0;\n\t      if (!length) {\n\t        return [];\n\t      }\n\t      if (guard ? isIterateeCall(array, n, guard) : n == null) {\n\t        n = 1;\n\t      }\n\t      return baseSlice(array, n < 0 ? 0 : n);\n\t    }\n\t\n\t    /**\n\t     * Creates a slice of `array` with `n` elements dropped from the end.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {Array} array The array to query.\n\t     * @param {number} [n=1] The number of elements to drop.\n\t     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n\t     * @returns {Array} Returns the slice of `array`.\n\t     * @example\n\t     *\n\t     * _.dropRight([1, 2, 3]);\n\t     * // => [1, 2]\n\t     *\n\t     * _.dropRight([1, 2, 3], 2);\n\t     * // => [1]\n\t     *\n\t     * _.dropRight([1, 2, 3], 5);\n\t     * // => []\n\t     *\n\t     * _.dropRight([1, 2, 3], 0);\n\t     * // => [1, 2, 3]\n\t     */\n\t    function dropRight(array, n, guard) {\n\t      var length = array ? array.length : 0;\n\t      if (!length) {\n\t        return [];\n\t      }\n\t      if (guard ? isIterateeCall(array, n, guard) : n == null) {\n\t        n = 1;\n\t      }\n\t      n = length - (+n || 0);\n\t      return baseSlice(array, 0, n < 0 ? 0 : n);\n\t    }\n\t\n\t    /**\n\t     * Creates a slice of `array` excluding elements dropped from the end.\n\t     * Elements are dropped until `predicate` returns falsey. The predicate is\n\t     * bound to `thisArg` and invoked with three arguments: (value, index, array).\n\t     *\n\t     * If a property name is provided for `predicate` the created `_.property`\n\t     * style callback returns the property value of the given element.\n\t     *\n\t     * If a value is also provided for `thisArg` the created `_.matchesProperty`\n\t     * style callback returns `true` for elements that have a matching property\n\t     * value, else `false`.\n\t     *\n\t     * If an object is provided for `predicate` the created `_.matches` style\n\t     * callback returns `true` for elements that match the properties of the given\n\t     * object, else `false`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {Array} array The array to query.\n\t     * @param {Function|Object|string} [predicate=_.identity] The function invoked\n\t     *  per iteration.\n\t     * @param {*} [thisArg] The `this` binding of `predicate`.\n\t     * @returns {Array} Returns the slice of `array`.\n\t     * @example\n\t     *\n\t     * _.dropRightWhile([1, 2, 3], function(n) {\n\t     *   return n > 1;\n\t     * });\n\t     * // => [1]\n\t     *\n\t     * var users = [\n\t     *   { 'user': 'barney',  'active': true },\n\t     *   { 'user': 'fred',    'active': false },\n\t     *   { 'user': 'pebbles', 'active': false }\n\t     * ];\n\t     *\n\t     * // using the `_.matches` callback shorthand\n\t     * _.pluck(_.dropRightWhile(users, { 'user': 'pebbles', 'active': false }), 'user');\n\t     * // => ['barney', 'fred']\n\t     *\n\t     * // using the `_.matchesProperty` callback shorthand\n\t     * _.pluck(_.dropRightWhile(users, 'active', false), 'user');\n\t     * // => ['barney']\n\t     *\n\t     * // using the `_.property` callback shorthand\n\t     * _.pluck(_.dropRightWhile(users, 'active'), 'user');\n\t     * // => ['barney', 'fred', 'pebbles']\n\t     */\n\t    function dropRightWhile(array, predicate, thisArg) {\n\t      return (array && array.length)\n\t        ? baseWhile(array, getCallback(predicate, thisArg, 3), true, true)\n\t        : [];\n\t    }\n\t\n\t    /**\n\t     * Creates a slice of `array` excluding elements dropped from the beginning.\n\t     * Elements are dropped until `predicate` returns falsey. The predicate is\n\t     * bound to `thisArg` and invoked with three arguments: (value, index, array).\n\t     *\n\t     * If a property name is provided for `predicate` the created `_.property`\n\t     * style callback returns the property value of the given element.\n\t     *\n\t     * If a value is also provided for `thisArg` the created `_.matchesProperty`\n\t     * style callback returns `true` for elements that have a matching property\n\t     * value, else `false`.\n\t     *\n\t     * If an object is provided for `predicate` the created `_.matches` style\n\t     * callback returns `true` for elements that have the properties of the given\n\t     * object, else `false`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {Array} array The array to query.\n\t     * @param {Function|Object|string} [predicate=_.identity] The function invoked\n\t     *  per iteration.\n\t     * @param {*} [thisArg] The `this` binding of `predicate`.\n\t     * @returns {Array} Returns the slice of `array`.\n\t     * @example\n\t     *\n\t     * _.dropWhile([1, 2, 3], function(n) {\n\t     *   return n < 3;\n\t     * });\n\t     * // => [3]\n\t     *\n\t     * var users = [\n\t     *   { 'user': 'barney',  'active': false },\n\t     *   { 'user': 'fred',    'active': false },\n\t     *   { 'user': 'pebbles', 'active': true }\n\t     * ];\n\t     *\n\t     * // using the `_.matches` callback shorthand\n\t     * _.pluck(_.dropWhile(users, { 'user': 'barney', 'active': false }), 'user');\n\t     * // => ['fred', 'pebbles']\n\t     *\n\t     * // using the `_.matchesProperty` callback shorthand\n\t     * _.pluck(_.dropWhile(users, 'active', false), 'user');\n\t     * // => ['pebbles']\n\t     *\n\t     * // using the `_.property` callback shorthand\n\t     * _.pluck(_.dropWhile(users, 'active'), 'user');\n\t     * // => ['barney', 'fred', 'pebbles']\n\t     */\n\t    function dropWhile(array, predicate, thisArg) {\n\t      return (array && array.length)\n\t        ? baseWhile(array, getCallback(predicate, thisArg, 3), true)\n\t        : [];\n\t    }\n\t\n\t    /**\n\t     * Fills elements of `array` with `value` from `start` up to, but not\n\t     * including, `end`.\n\t     *\n\t     * **Note:** This method mutates `array`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {Array} array The array to fill.\n\t     * @param {*} value The value to fill `array` with.\n\t     * @param {number} [start=0] The start position.\n\t     * @param {number} [end=array.length] The end position.\n\t     * @returns {Array} Returns `array`.\n\t     * @example\n\t     *\n\t     * var array = [1, 2, 3];\n\t     *\n\t     * _.fill(array, 'a');\n\t     * console.log(array);\n\t     * // => ['a', 'a', 'a']\n\t     *\n\t     * _.fill(Array(3), 2);\n\t     * // => [2, 2, 2]\n\t     *\n\t     * _.fill([4, 6, 8], '*', 1, 2);\n\t     * // => [4, '*', 8]\n\t     */\n\t    function fill(array, value, start, end) {\n\t      var length = array ? array.length : 0;\n\t      if (!length) {\n\t        return [];\n\t      }\n\t      if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {\n\t        start = 0;\n\t        end = length;\n\t      }\n\t      return baseFill(array, value, start, end);\n\t    }\n\t\n\t    /**\n\t     * This method is like `_.find` except that it returns the index of the first\n\t     * element `predicate` returns truthy for instead of the element itself.\n\t     *\n\t     * If a property name is provided for `predicate` the created `_.property`\n\t     * style callback returns the property value of the given element.\n\t     *\n\t     * If a value is also provided for `thisArg` the created `_.matchesProperty`\n\t     * style callback returns `true` for elements that have a matching property\n\t     * value, else `false`.\n\t     *\n\t     * If an object is provided for `predicate` the created `_.matches` style\n\t     * callback returns `true` for elements that have the properties of the given\n\t     * object, else `false`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {Array} array The array to search.\n\t     * @param {Function|Object|string} [predicate=_.identity] The function invoked\n\t     *  per iteration.\n\t     * @param {*} [thisArg] The `this` binding of `predicate`.\n\t     * @returns {number} Returns the index of the found element, else `-1`.\n\t     * @example\n\t     *\n\t     * var users = [\n\t     *   { 'user': 'barney',  'active': false },\n\t     *   { 'user': 'fred',    'active': false },\n\t     *   { 'user': 'pebbles', 'active': true }\n\t     * ];\n\t     *\n\t     * _.findIndex(users, function(chr) {\n\t     *   return chr.user == 'barney';\n\t     * });\n\t     * // => 0\n\t     *\n\t     * // using the `_.matches` callback shorthand\n\t     * _.findIndex(users, { 'user': 'fred', 'active': false });\n\t     * // => 1\n\t     *\n\t     * // using the `_.matchesProperty` callback shorthand\n\t     * _.findIndex(users, 'active', false);\n\t     * // => 0\n\t     *\n\t     * // using the `_.property` callback shorthand\n\t     * _.findIndex(users, 'active');\n\t     * // => 2\n\t     */\n\t    var findIndex = createFindIndex();\n\t\n\t    /**\n\t     * This method is like `_.findIndex` except that it iterates over elements\n\t     * of `collection` from right to left.\n\t     *\n\t     * If a property name is provided for `predicate` the created `_.property`\n\t     * style callback returns the property value of the given element.\n\t     *\n\t     * If a value is also provided for `thisArg` the created `_.matchesProperty`\n\t     * style callback returns `true` for elements that have a matching property\n\t     * value, else `false`.\n\t     *\n\t     * If an object is provided for `predicate` the created `_.matches` style\n\t     * callback returns `true` for elements that have the properties of the given\n\t     * object, else `false`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {Array} array The array to search.\n\t     * @param {Function|Object|string} [predicate=_.identity] The function invoked\n\t     *  per iteration.\n\t     * @param {*} [thisArg] The `this` binding of `predicate`.\n\t     * @returns {number} Returns the index of the found element, else `-1`.\n\t     * @example\n\t     *\n\t     * var users = [\n\t     *   { 'user': 'barney',  'active': true },\n\t     *   { 'user': 'fred',    'active': false },\n\t     *   { 'user': 'pebbles', 'active': false }\n\t     * ];\n\t     *\n\t     * _.findLastIndex(users, function(chr) {\n\t     *   return chr.user == 'pebbles';\n\t     * });\n\t     * // => 2\n\t     *\n\t     * // using the `_.matches` callback shorthand\n\t     * _.findLastIndex(users, { 'user': 'barney', 'active': true });\n\t     * // => 0\n\t     *\n\t     * // using the `_.matchesProperty` callback shorthand\n\t     * _.findLastIndex(users, 'active', false);\n\t     * // => 2\n\t     *\n\t     * // using the `_.property` callback shorthand\n\t     * _.findLastIndex(users, 'active');\n\t     * // => 0\n\t     */\n\t    var findLastIndex = createFindIndex(true);\n\t\n\t    /**\n\t     * Gets the first element of `array`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @alias head\n\t     * @category Array\n\t     * @param {Array} array The array to query.\n\t     * @returns {*} Returns the first element of `array`.\n\t     * @example\n\t     *\n\t     * _.first([1, 2, 3]);\n\t     * // => 1\n\t     *\n\t     * _.first([]);\n\t     * // => undefined\n\t     */\n\t    function first(array) {\n\t      return array ? array[0] : undefined;\n\t    }\n\t\n\t    /**\n\t     * Flattens a nested array. If `isDeep` is `true` the array is recursively\n\t     * flattened, otherwise it is only flattened a single level.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {Array} array The array to flatten.\n\t     * @param {boolean} [isDeep] Specify a deep flatten.\n\t     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n\t     * @returns {Array} Returns the new flattened array.\n\t     * @example\n\t     *\n\t     * _.flatten([1, [2, 3, [4]]]);\n\t     * // => [1, 2, 3, [4]]\n\t     *\n\t     * // using `isDeep`\n\t     * _.flatten([1, [2, 3, [4]]], true);\n\t     * // => [1, 2, 3, 4]\n\t     */\n\t    function flatten(array, isDeep, guard) {\n\t      var length = array ? array.length : 0;\n\t      if (guard && isIterateeCall(array, isDeep, guard)) {\n\t        isDeep = false;\n\t      }\n\t      return length ? baseFlatten(array, isDeep) : [];\n\t    }\n\t\n\t    /**\n\t     * Recursively flattens a nested array.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {Array} array The array to recursively flatten.\n\t     * @returns {Array} Returns the new flattened array.\n\t     * @example\n\t     *\n\t     * _.flattenDeep([1, [2, 3, [4]]]);\n\t     * // => [1, 2, 3, 4]\n\t     */\n\t    function flattenDeep(array) {\n\t      var length = array ? array.length : 0;\n\t      return length ? baseFlatten(array, true) : [];\n\t    }\n\t\n\t    /**\n\t     * Gets the index at which the first occurrence of `value` is found in `array`\n\t     * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)\n\t     * for equality comparisons. If `fromIndex` is negative, it is used as the offset\n\t     * from the end of `array`. If `array` is sorted providing `true` for `fromIndex`\n\t     * performs a faster binary search.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {Array} array The array to search.\n\t     * @param {*} value The value to search for.\n\t     * @param {boolean|number} [fromIndex=0] The index to search from or `true`\n\t     *  to perform a binary search on a sorted array.\n\t     * @returns {number} Returns the index of the matched value, else `-1`.\n\t     * @example\n\t     *\n\t     * _.indexOf([1, 2, 1, 2], 2);\n\t     * // => 1\n\t     *\n\t     * // using `fromIndex`\n\t     * _.indexOf([1, 2, 1, 2], 2, 2);\n\t     * // => 3\n\t     *\n\t     * // performing a binary search\n\t     * _.indexOf([1, 1, 2, 2], 2, true);\n\t     * // => 2\n\t     */\n\t    function indexOf(array, value, fromIndex) {\n\t      var length = array ? array.length : 0;\n\t      if (!length) {\n\t        return -1;\n\t      }\n\t      if (typeof fromIndex == 'number') {\n\t        fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : fromIndex;\n\t      } else if (fromIndex) {\n\t        var index = binaryIndex(array, value);\n\t        if (index < length &&\n\t            (value === value ? (value === array[index]) : (array[index] !== array[index]))) {\n\t          return index;\n\t        }\n\t        return -1;\n\t      }\n\t      return baseIndexOf(array, value, fromIndex || 0);\n\t    }\n\t\n\t    /**\n\t     * Gets all but the last element of `array`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {Array} array The array to query.\n\t     * @returns {Array} Returns the slice of `array`.\n\t     * @example\n\t     *\n\t     * _.initial([1, 2, 3]);\n\t     * // => [1, 2]\n\t     */\n\t    function initial(array) {\n\t      return dropRight(array, 1);\n\t    }\n\t\n\t    /**\n\t     * Creates an array of unique values that are included in all of the provided\n\t     * arrays using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)\n\t     * for equality comparisons.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {...Array} [arrays] The arrays to inspect.\n\t     * @returns {Array} Returns the new array of shared values.\n\t     * @example\n\t     * _.intersection([1, 2], [4, 2], [2, 1]);\n\t     * // => [2]\n\t     */\n\t    var intersection = restParam(function(arrays) {\n\t      var othLength = arrays.length,\n\t          othIndex = othLength,\n\t          caches = Array(length),\n\t          indexOf = getIndexOf(),\n\t          isCommon = indexOf == baseIndexOf,\n\t          result = [];\n\t\n\t      while (othIndex--) {\n\t        var value = arrays[othIndex] = isArrayLike(value = arrays[othIndex]) ? value : [];\n\t        caches[othIndex] = (isCommon && value.length >= 120) ? createCache(othIndex && value) : null;\n\t      }\n\t      var array = arrays[0],\n\t          index = -1,\n\t          length = array ? array.length : 0,\n\t          seen = caches[0];\n\t\n\t      outer:\n\t      while (++index < length) {\n\t        value = array[index];\n\t        if ((seen ? cacheIndexOf(seen, value) : indexOf(result, value, 0)) < 0) {\n\t          var othIndex = othLength;\n\t          while (--othIndex) {\n\t            var cache = caches[othIndex];\n\t            if ((cache ? cacheIndexOf(cache, value) : indexOf(arrays[othIndex], value, 0)) < 0) {\n\t              continue outer;\n\t            }\n\t          }\n\t          if (seen) {\n\t            seen.push(value);\n\t          }\n\t          result.push(value);\n\t        }\n\t      }\n\t      return result;\n\t    });\n\t\n\t    /**\n\t     * Gets the last element of `array`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {Array} array The array to query.\n\t     * @returns {*} Returns the last element of `array`.\n\t     * @example\n\t     *\n\t     * _.last([1, 2, 3]);\n\t     * // => 3\n\t     */\n\t    function last(array) {\n\t      var length = array ? array.length : 0;\n\t      return length ? array[length - 1] : undefined;\n\t    }\n\t\n\t    /**\n\t     * This method is like `_.indexOf` except that it iterates over elements of\n\t     * `array` from right to left.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {Array} array The array to search.\n\t     * @param {*} value The value to search for.\n\t     * @param {boolean|number} [fromIndex=array.length-1] The index to search from\n\t     *  or `true` to perform a binary search on a sorted array.\n\t     * @returns {number} Returns the index of the matched value, else `-1`.\n\t     * @example\n\t     *\n\t     * _.lastIndexOf([1, 2, 1, 2], 2);\n\t     * // => 3\n\t     *\n\t     * // using `fromIndex`\n\t     * _.lastIndexOf([1, 2, 1, 2], 2, 2);\n\t     * // => 1\n\t     *\n\t     * // performing a binary search\n\t     * _.lastIndexOf([1, 1, 2, 2], 2, true);\n\t     * // => 3\n\t     */\n\t    function lastIndexOf(array, value, fromIndex) {\n\t      var length = array ? array.length : 0;\n\t      if (!length) {\n\t        return -1;\n\t      }\n\t      var index = length;\n\t      if (typeof fromIndex == 'number') {\n\t        index = (fromIndex < 0 ? nativeMax(length + fromIndex, 0) : nativeMin(fromIndex || 0, length - 1)) + 1;\n\t      } else if (fromIndex) {\n\t        index = binaryIndex(array, value, true) - 1;\n\t        var other = array[index];\n\t        if (value === value ? (value === other) : (other !== other)) {\n\t          return index;\n\t        }\n\t        return -1;\n\t      }\n\t      if (value !== value) {\n\t        return indexOfNaN(array, index, true);\n\t      }\n\t      while (index--) {\n\t        if (array[index] === value) {\n\t          return index;\n\t        }\n\t      }\n\t      return -1;\n\t    }\n\t\n\t    /**\n\t     * Removes all provided values from `array` using\n\t     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)\n\t     * for equality comparisons.\n\t     *\n\t     * **Note:** Unlike `_.without`, this method mutates `array`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {Array} array The array to modify.\n\t     * @param {...*} [values] The values to remove.\n\t     * @returns {Array} Returns `array`.\n\t     * @example\n\t     *\n\t     * var array = [1, 2, 3, 1, 2, 3];\n\t     *\n\t     * _.pull(array, 2, 3);\n\t     * console.log(array);\n\t     * // => [1, 1]\n\t     */\n\t    function pull() {\n\t      var args = arguments,\n\t          array = args[0];\n\t\n\t      if (!(array && array.length)) {\n\t        return array;\n\t      }\n\t      var index = 0,\n\t          indexOf = getIndexOf(),\n\t          length = args.length;\n\t\n\t      while (++index < length) {\n\t        var fromIndex = 0,\n\t            value = args[index];\n\t\n\t        while ((fromIndex = indexOf(array, value, fromIndex)) > -1) {\n\t          splice.call(array, fromIndex, 1);\n\t        }\n\t      }\n\t      return array;\n\t    }\n\t\n\t    /**\n\t     * Removes elements from `array` corresponding to the given indexes and returns\n\t     * an array of the removed elements. Indexes may be specified as an array of\n\t     * indexes or as individual arguments.\n\t     *\n\t     * **Note:** Unlike `_.at`, this method mutates `array`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {Array} array The array to modify.\n\t     * @param {...(number|number[])} [indexes] The indexes of elements to remove,\n\t     *  specified as individual indexes or arrays of indexes.\n\t     * @returns {Array} Returns the new array of removed elements.\n\t     * @example\n\t     *\n\t     * var array = [5, 10, 15, 20];\n\t     * var evens = _.pullAt(array, 1, 3);\n\t     *\n\t     * console.log(array);\n\t     * // => [5, 15]\n\t     *\n\t     * console.log(evens);\n\t     * // => [10, 20]\n\t     */\n\t    var pullAt = restParam(function(array, indexes) {\n\t      indexes = baseFlatten(indexes);\n\t\n\t      var result = baseAt(array, indexes);\n\t      basePullAt(array, indexes.sort(baseCompareAscending));\n\t      return result;\n\t    });\n\t\n\t    /**\n\t     * Removes all elements from `array` that `predicate` returns truthy for\n\t     * and returns an array of the removed elements. The predicate is bound to\n\t     * `thisArg` and invoked with three arguments: (value, index, array).\n\t     *\n\t     * If a property name is provided for `predicate` the created `_.property`\n\t     * style callback returns the property value of the given element.\n\t     *\n\t     * If a value is also provided for `thisArg` the created `_.matchesProperty`\n\t     * style callback returns `true` for elements that have a matching property\n\t     * value, else `false`.\n\t     *\n\t     * If an object is provided for `predicate` the created `_.matches` style\n\t     * callback returns `true` for elements that have the properties of the given\n\t     * object, else `false`.\n\t     *\n\t     * **Note:** Unlike `_.filter`, this method mutates `array`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {Array} array The array to modify.\n\t     * @param {Function|Object|string} [predicate=_.identity] The function invoked\n\t     *  per iteration.\n\t     * @param {*} [thisArg] The `this` binding of `predicate`.\n\t     * @returns {Array} Returns the new array of removed elements.\n\t     * @example\n\t     *\n\t     * var array = [1, 2, 3, 4];\n\t     * var evens = _.remove(array, function(n) {\n\t     *   return n % 2 == 0;\n\t     * });\n\t     *\n\t     * console.log(array);\n\t     * // => [1, 3]\n\t     *\n\t     * console.log(evens);\n\t     * // => [2, 4]\n\t     */\n\t    function remove(array, predicate, thisArg) {\n\t      var result = [];\n\t      if (!(array && array.length)) {\n\t        return result;\n\t      }\n\t      var index = -1,\n\t          indexes = [],\n\t          length = array.length;\n\t\n\t      predicate = getCallback(predicate, thisArg, 3);\n\t      while (++index < length) {\n\t        var value = array[index];\n\t        if (predicate(value, index, array)) {\n\t          result.push(value);\n\t          indexes.push(index);\n\t        }\n\t      }\n\t      basePullAt(array, indexes);\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * Gets all but the first element of `array`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @alias tail\n\t     * @category Array\n\t     * @param {Array} array The array to query.\n\t     * @returns {Array} Returns the slice of `array`.\n\t     * @example\n\t     *\n\t     * _.rest([1, 2, 3]);\n\t     * // => [2, 3]\n\t     */\n\t    function rest(array) {\n\t      return drop(array, 1);\n\t    }\n\t\n\t    /**\n\t     * Creates a slice of `array` from `start` up to, but not including, `end`.\n\t     *\n\t     * **Note:** This method is used instead of `Array#slice` to support node\n\t     * lists in IE < 9 and to ensure dense arrays are returned.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {Array} array The array to slice.\n\t     * @param {number} [start=0] The start position.\n\t     * @param {number} [end=array.length] The end position.\n\t     * @returns {Array} Returns the slice of `array`.\n\t     */\n\t    function slice(array, start, end) {\n\t      var length = array ? array.length : 0;\n\t      if (!length) {\n\t        return [];\n\t      }\n\t      if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {\n\t        start = 0;\n\t        end = length;\n\t      }\n\t      return baseSlice(array, start, end);\n\t    }\n\t\n\t    /**\n\t     * Uses a binary search to determine the lowest index at which `value` should\n\t     * be inserted into `array` in order to maintain its sort order. If an iteratee\n\t     * function is provided it is invoked for `value` and each element of `array`\n\t     * to compute their sort ranking. The iteratee is bound to `thisArg` and\n\t     * invoked with one argument; (value).\n\t     *\n\t     * If a property name is provided for `iteratee` the created `_.property`\n\t     * style callback returns the property value of the given element.\n\t     *\n\t     * If a value is also provided for `thisArg` the created `_.matchesProperty`\n\t     * style callback returns `true` for elements that have a matching property\n\t     * value, else `false`.\n\t     *\n\t     * If an object is provided for `iteratee` the created `_.matches` style\n\t     * callback returns `true` for elements that have the properties of the given\n\t     * object, else `false`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {Array} array The sorted array to inspect.\n\t     * @param {*} value The value to evaluate.\n\t     * @param {Function|Object|string} [iteratee=_.identity] The function invoked\n\t     *  per iteration.\n\t     * @param {*} [thisArg] The `this` binding of `iteratee`.\n\t     * @returns {number} Returns the index at which `value` should be inserted\n\t     *  into `array`.\n\t     * @example\n\t     *\n\t     * _.sortedIndex([30, 50], 40);\n\t     * // => 1\n\t     *\n\t     * _.sortedIndex([4, 4, 5, 5], 5);\n\t     * // => 2\n\t     *\n\t     * var dict = { 'data': { 'thirty': 30, 'forty': 40, 'fifty': 50 } };\n\t     *\n\t     * // using an iteratee function\n\t     * _.sortedIndex(['thirty', 'fifty'], 'forty', function(word) {\n\t     *   return this.data[word];\n\t     * }, dict);\n\t     * // => 1\n\t     *\n\t     * // using the `_.property` callback shorthand\n\t     * _.sortedIndex([{ 'x': 30 }, { 'x': 50 }], { 'x': 40 }, 'x');\n\t     * // => 1\n\t     */\n\t    var sortedIndex = createSortedIndex();\n\t\n\t    /**\n\t     * This method is like `_.sortedIndex` except that it returns the highest\n\t     * index at which `value` should be inserted into `array` in order to\n\t     * maintain its sort order.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {Array} array The sorted array to inspect.\n\t     * @param {*} value The value to evaluate.\n\t     * @param {Function|Object|string} [iteratee=_.identity] The function invoked\n\t     *  per iteration.\n\t     * @param {*} [thisArg] The `this` binding of `iteratee`.\n\t     * @returns {number} Returns the index at which `value` should be inserted\n\t     *  into `array`.\n\t     * @example\n\t     *\n\t     * _.sortedLastIndex([4, 4, 5, 5], 5);\n\t     * // => 4\n\t     */\n\t    var sortedLastIndex = createSortedIndex(true);\n\t\n\t    /**\n\t     * Creates a slice of `array` with `n` elements taken from the beginning.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {Array} array The array to query.\n\t     * @param {number} [n=1] The number of elements to take.\n\t     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n\t     * @returns {Array} Returns the slice of `array`.\n\t     * @example\n\t     *\n\t     * _.take([1, 2, 3]);\n\t     * // => [1]\n\t     *\n\t     * _.take([1, 2, 3], 2);\n\t     * // => [1, 2]\n\t     *\n\t     * _.take([1, 2, 3], 5);\n\t     * // => [1, 2, 3]\n\t     *\n\t     * _.take([1, 2, 3], 0);\n\t     * // => []\n\t     */\n\t    function take(array, n, guard) {\n\t      var length = array ? array.length : 0;\n\t      if (!length) {\n\t        return [];\n\t      }\n\t      if (guard ? isIterateeCall(array, n, guard) : n == null) {\n\t        n = 1;\n\t      }\n\t      return baseSlice(array, 0, n < 0 ? 0 : n);\n\t    }\n\t\n\t    /**\n\t     * Creates a slice of `array` with `n` elements taken from the end.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {Array} array The array to query.\n\t     * @param {number} [n=1] The number of elements to take.\n\t     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n\t     * @returns {Array} Returns the slice of `array`.\n\t     * @example\n\t     *\n\t     * _.takeRight([1, 2, 3]);\n\t     * // => [3]\n\t     *\n\t     * _.takeRight([1, 2, 3], 2);\n\t     * // => [2, 3]\n\t     *\n\t     * _.takeRight([1, 2, 3], 5);\n\t     * // => [1, 2, 3]\n\t     *\n\t     * _.takeRight([1, 2, 3], 0);\n\t     * // => []\n\t     */\n\t    function takeRight(array, n, guard) {\n\t      var length = array ? array.length : 0;\n\t      if (!length) {\n\t        return [];\n\t      }\n\t      if (guard ? isIterateeCall(array, n, guard) : n == null) {\n\t        n = 1;\n\t      }\n\t      n = length - (+n || 0);\n\t      return baseSlice(array, n < 0 ? 0 : n);\n\t    }\n\t\n\t    /**\n\t     * Creates a slice of `array` with elements taken from the end. Elements are\n\t     * taken until `predicate` returns falsey. The predicate is bound to `thisArg`\n\t     * and invoked with three arguments: (value, index, array).\n\t     *\n\t     * If a property name is provided for `predicate` the created `_.property`\n\t     * style callback returns the property value of the given element.\n\t     *\n\t     * If a value is also provided for `thisArg` the created `_.matchesProperty`\n\t     * style callback returns `true` for elements that have a matching property\n\t     * value, else `false`.\n\t     *\n\t     * If an object is provided for `predicate` the created `_.matches` style\n\t     * callback returns `true` for elements that have the properties of the given\n\t     * object, else `false`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {Array} array The array to query.\n\t     * @param {Function|Object|string} [predicate=_.identity] The function invoked\n\t     *  per iteration.\n\t     * @param {*} [thisArg] The `this` binding of `predicate`.\n\t     * @returns {Array} Returns the slice of `array`.\n\t     * @example\n\t     *\n\t     * _.takeRightWhile([1, 2, 3], function(n) {\n\t     *   return n > 1;\n\t     * });\n\t     * // => [2, 3]\n\t     *\n\t     * var users = [\n\t     *   { 'user': 'barney',  'active': true },\n\t     *   { 'user': 'fred',    'active': false },\n\t     *   { 'user': 'pebbles', 'active': false }\n\t     * ];\n\t     *\n\t     * // using the `_.matches` callback shorthand\n\t     * _.pluck(_.takeRightWhile(users, { 'user': 'pebbles', 'active': false }), 'user');\n\t     * // => ['pebbles']\n\t     *\n\t     * // using the `_.matchesProperty` callback shorthand\n\t     * _.pluck(_.takeRightWhile(users, 'active', false), 'user');\n\t     * // => ['fred', 'pebbles']\n\t     *\n\t     * // using the `_.property` callback shorthand\n\t     * _.pluck(_.takeRightWhile(users, 'active'), 'user');\n\t     * // => []\n\t     */\n\t    function takeRightWhile(array, predicate, thisArg) {\n\t      return (array && array.length)\n\t        ? baseWhile(array, getCallback(predicate, thisArg, 3), false, true)\n\t        : [];\n\t    }\n\t\n\t    /**\n\t     * Creates a slice of `array` with elements taken from the beginning. Elements\n\t     * are taken until `predicate` returns falsey. The predicate is bound to\n\t     * `thisArg` and invoked with three arguments: (value, index, array).\n\t     *\n\t     * If a property name is provided for `predicate` the created `_.property`\n\t     * style callback returns the property value of the given element.\n\t     *\n\t     * If a value is also provided for `thisArg` the created `_.matchesProperty`\n\t     * style callback returns `true` for elements that have a matching property\n\t     * value, else `false`.\n\t     *\n\t     * If an object is provided for `predicate` the created `_.matches` style\n\t     * callback returns `true` for elements that have the properties of the given\n\t     * object, else `false`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {Array} array The array to query.\n\t     * @param {Function|Object|string} [predicate=_.identity] The function invoked\n\t     *  per iteration.\n\t     * @param {*} [thisArg] The `this` binding of `predicate`.\n\t     * @returns {Array} Returns the slice of `array`.\n\t     * @example\n\t     *\n\t     * _.takeWhile([1, 2, 3], function(n) {\n\t     *   return n < 3;\n\t     * });\n\t     * // => [1, 2]\n\t     *\n\t     * var users = [\n\t     *   { 'user': 'barney',  'active': false },\n\t     *   { 'user': 'fred',    'active': false},\n\t     *   { 'user': 'pebbles', 'active': true }\n\t     * ];\n\t     *\n\t     * // using the `_.matches` callback shorthand\n\t     * _.pluck(_.takeWhile(users, { 'user': 'barney', 'active': false }), 'user');\n\t     * // => ['barney']\n\t     *\n\t     * // using the `_.matchesProperty` callback shorthand\n\t     * _.pluck(_.takeWhile(users, 'active', false), 'user');\n\t     * // => ['barney', 'fred']\n\t     *\n\t     * // using the `_.property` callback shorthand\n\t     * _.pluck(_.takeWhile(users, 'active'), 'user');\n\t     * // => []\n\t     */\n\t    function takeWhile(array, predicate, thisArg) {\n\t      return (array && array.length)\n\t        ? baseWhile(array, getCallback(predicate, thisArg, 3))\n\t        : [];\n\t    }\n\t\n\t    /**\n\t     * Creates an array of unique values, in order, from all of the provided arrays\n\t     * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)\n\t     * for equality comparisons.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {...Array} [arrays] The arrays to inspect.\n\t     * @returns {Array} Returns the new array of combined values.\n\t     * @example\n\t     *\n\t     * _.union([1, 2], [4, 2], [2, 1]);\n\t     * // => [1, 2, 4]\n\t     */\n\t    var union = restParam(function(arrays) {\n\t      return baseUniq(baseFlatten(arrays, false, true));\n\t    });\n\t\n\t    /**\n\t     * Creates a duplicate-free version of an array, using\n\t     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)\n\t     * for equality comparisons, in which only the first occurence of each element\n\t     * is kept. Providing `true` for `isSorted` performs a faster search algorithm\n\t     * for sorted arrays. If an iteratee function is provided it is invoked for\n\t     * each element in the array to generate the criterion by which uniqueness\n\t     * is computed. The `iteratee` is bound to `thisArg` and invoked with three\n\t     * arguments: (value, index, array).\n\t     *\n\t     * If a property name is provided for `iteratee` the created `_.property`\n\t     * style callback returns the property value of the given element.\n\t     *\n\t     * If a value is also provided for `thisArg` the created `_.matchesProperty`\n\t     * style callback returns `true` for elements that have a matching property\n\t     * value, else `false`.\n\t     *\n\t     * If an object is provided for `iteratee` the created `_.matches` style\n\t     * callback returns `true` for elements that have the properties of the given\n\t     * object, else `false`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @alias unique\n\t     * @category Array\n\t     * @param {Array} array The array to inspect.\n\t     * @param {boolean} [isSorted] Specify the array is sorted.\n\t     * @param {Function|Object|string} [iteratee] The function invoked per iteration.\n\t     * @param {*} [thisArg] The `this` binding of `iteratee`.\n\t     * @returns {Array} Returns the new duplicate-value-free array.\n\t     * @example\n\t     *\n\t     * _.uniq([2, 1, 2]);\n\t     * // => [2, 1]\n\t     *\n\t     * // using `isSorted`\n\t     * _.uniq([1, 1, 2], true);\n\t     * // => [1, 2]\n\t     *\n\t     * // using an iteratee function\n\t     * _.uniq([1, 2.5, 1.5, 2], function(n) {\n\t     *   return this.floor(n);\n\t     * }, Math);\n\t     * // => [1, 2.5]\n\t     *\n\t     * // using the `_.property` callback shorthand\n\t     * _.uniq([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');\n\t     * // => [{ 'x': 1 }, { 'x': 2 }]\n\t     */\n\t    function uniq(array, isSorted, iteratee, thisArg) {\n\t      var length = array ? array.length : 0;\n\t      if (!length) {\n\t        return [];\n\t      }\n\t      if (isSorted != null && typeof isSorted != 'boolean') {\n\t        thisArg = iteratee;\n\t        iteratee = isIterateeCall(array, isSorted, thisArg) ? undefined : isSorted;\n\t        isSorted = false;\n\t      }\n\t      var callback = getCallback();\n\t      if (!(iteratee == null && callback === baseCallback)) {\n\t        iteratee = callback(iteratee, thisArg, 3);\n\t      }\n\t      return (isSorted && getIndexOf() == baseIndexOf)\n\t        ? sortedUniq(array, iteratee)\n\t        : baseUniq(array, iteratee);\n\t    }\n\t\n\t    /**\n\t     * This method is like `_.zip` except that it accepts an array of grouped\n\t     * elements and creates an array regrouping the elements to their pre-zip\n\t     * configuration.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {Array} array The array of grouped elements to process.\n\t     * @returns {Array} Returns the new array of regrouped elements.\n\t     * @example\n\t     *\n\t     * var zipped = _.zip(['fred', 'barney'], [30, 40], [true, false]);\n\t     * // => [['fred', 30, true], ['barney', 40, false]]\n\t     *\n\t     * _.unzip(zipped);\n\t     * // => [['fred', 'barney'], [30, 40], [true, false]]\n\t     */\n\t    function unzip(array) {\n\t      if (!(array && array.length)) {\n\t        return [];\n\t      }\n\t      var index = -1,\n\t          length = 0;\n\t\n\t      array = arrayFilter(array, function(group) {\n\t        if (isArrayLike(group)) {\n\t          length = nativeMax(group.length, length);\n\t          return true;\n\t        }\n\t      });\n\t      var result = Array(length);\n\t      while (++index < length) {\n\t        result[index] = arrayMap(array, baseProperty(index));\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * This method is like `_.unzip` except that it accepts an iteratee to specify\n\t     * how regrouped values should be combined. The `iteratee` is bound to `thisArg`\n\t     * and invoked with four arguments: (accumulator, value, index, group).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {Array} array The array of grouped elements to process.\n\t     * @param {Function} [iteratee] The function to combine regrouped values.\n\t     * @param {*} [thisArg] The `this` binding of `iteratee`.\n\t     * @returns {Array} Returns the new array of regrouped elements.\n\t     * @example\n\t     *\n\t     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);\n\t     * // => [[1, 10, 100], [2, 20, 200]]\n\t     *\n\t     * _.unzipWith(zipped, _.add);\n\t     * // => [3, 30, 300]\n\t     */\n\t    function unzipWith(array, iteratee, thisArg) {\n\t      var length = array ? array.length : 0;\n\t      if (!length) {\n\t        return [];\n\t      }\n\t      var result = unzip(array);\n\t      if (iteratee == null) {\n\t        return result;\n\t      }\n\t      iteratee = bindCallback(iteratee, thisArg, 4);\n\t      return arrayMap(result, function(group) {\n\t        return arrayReduce(group, iteratee, undefined, true);\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Creates an array excluding all provided values using\n\t     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)\n\t     * for equality comparisons.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {Array} array The array to filter.\n\t     * @param {...*} [values] The values to exclude.\n\t     * @returns {Array} Returns the new array of filtered values.\n\t     * @example\n\t     *\n\t     * _.without([1, 2, 1, 3], 1, 2);\n\t     * // => [3]\n\t     */\n\t    var without = restParam(function(array, values) {\n\t      return isArrayLike(array)\n\t        ? baseDifference(array, values)\n\t        : [];\n\t    });\n\t\n\t    /**\n\t     * Creates an array of unique values that is the [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)\n\t     * of the provided arrays.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {...Array} [arrays] The arrays to inspect.\n\t     * @returns {Array} Returns the new array of values.\n\t     * @example\n\t     *\n\t     * _.xor([1, 2], [4, 2]);\n\t     * // => [1, 4]\n\t     */\n\t    function xor() {\n\t      var index = -1,\n\t          length = arguments.length;\n\t\n\t      while (++index < length) {\n\t        var array = arguments[index];\n\t        if (isArrayLike(array)) {\n\t          var result = result\n\t            ? arrayPush(baseDifference(result, array), baseDifference(array, result))\n\t            : array;\n\t        }\n\t      }\n\t      return result ? baseUniq(result) : [];\n\t    }\n\t\n\t    /**\n\t     * Creates an array of grouped elements, the first of which contains the first\n\t     * elements of the given arrays, the second of which contains the second elements\n\t     * of the given arrays, and so on.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {...Array} [arrays] The arrays to process.\n\t     * @returns {Array} Returns the new array of grouped elements.\n\t     * @example\n\t     *\n\t     * _.zip(['fred', 'barney'], [30, 40], [true, false]);\n\t     * // => [['fred', 30, true], ['barney', 40, false]]\n\t     */\n\t    var zip = restParam(unzip);\n\t\n\t    /**\n\t     * The inverse of `_.pairs`; this method returns an object composed from arrays\n\t     * of property names and values. Provide either a single two dimensional array,\n\t     * e.g. `[[key1, value1], [key2, value2]]` or two arrays, one of property names\n\t     * and one of corresponding values.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @alias object\n\t     * @category Array\n\t     * @param {Array} props The property names.\n\t     * @param {Array} [values=[]] The property values.\n\t     * @returns {Object} Returns the new object.\n\t     * @example\n\t     *\n\t     * _.zipObject([['fred', 30], ['barney', 40]]);\n\t     * // => { 'fred': 30, 'barney': 40 }\n\t     *\n\t     * _.zipObject(['fred', 'barney'], [30, 40]);\n\t     * // => { 'fred': 30, 'barney': 40 }\n\t     */\n\t    function zipObject(props, values) {\n\t      var index = -1,\n\t          length = props ? props.length : 0,\n\t          result = {};\n\t\n\t      if (length && !values && !isArray(props[0])) {\n\t        values = [];\n\t      }\n\t      while (++index < length) {\n\t        var key = props[index];\n\t        if (values) {\n\t          result[key] = values[index];\n\t        } else if (key) {\n\t          result[key[0]] = key[1];\n\t        }\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * This method is like `_.zip` except that it accepts an iteratee to specify\n\t     * how grouped values should be combined. The `iteratee` is bound to `thisArg`\n\t     * and invoked with four arguments: (accumulator, value, index, group).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {...Array} [arrays] The arrays to process.\n\t     * @param {Function} [iteratee] The function to combine grouped values.\n\t     * @param {*} [thisArg] The `this` binding of `iteratee`.\n\t     * @returns {Array} Returns the new array of grouped elements.\n\t     * @example\n\t     *\n\t     * _.zipWith([1, 2], [10, 20], [100, 200], _.add);\n\t     * // => [111, 222]\n\t     */\n\t    var zipWith = restParam(function(arrays) {\n\t      var length = arrays.length,\n\t          iteratee = length > 2 ? arrays[length - 2] : undefined,\n\t          thisArg = length > 1 ? arrays[length - 1] : undefined;\n\t\n\t      if (length > 2 && typeof iteratee == 'function') {\n\t        length -= 2;\n\t      } else {\n\t        iteratee = (length > 1 && typeof thisArg == 'function') ? (--length, thisArg) : undefined;\n\t        thisArg = undefined;\n\t      }\n\t      arrays.length = length;\n\t      return unzipWith(arrays, iteratee, thisArg);\n\t    });\n\t\n\t    /*------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * Creates a `lodash` object that wraps `value` with explicit method\n\t     * chaining enabled.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Chain\n\t     * @param {*} value The value to wrap.\n\t     * @returns {Object} Returns the new `lodash` wrapper instance.\n\t     * @example\n\t     *\n\t     * var users = [\n\t     *   { 'user': 'barney',  'age': 36 },\n\t     *   { 'user': 'fred',    'age': 40 },\n\t     *   { 'user': 'pebbles', 'age': 1 }\n\t     * ];\n\t     *\n\t     * var youngest = _.chain(users)\n\t     *   .sortBy('age')\n\t     *   .map(function(chr) {\n\t     *     return chr.user + ' is ' + chr.age;\n\t     *   })\n\t     *   .first()\n\t     *   .value();\n\t     * // => 'pebbles is 1'\n\t     */\n\t    function chain(value) {\n\t      var result = lodash(value);\n\t      result.__chain__ = true;\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * This method invokes `interceptor` and returns `value`. The interceptor is\n\t     * bound to `thisArg` and invoked with one argument; (value). The purpose of\n\t     * this method is to \"tap into\" a method chain in order to perform operations\n\t     * on intermediate results within the chain.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Chain\n\t     * @param {*} value The value to provide to `interceptor`.\n\t     * @param {Function} interceptor The function to invoke.\n\t     * @param {*} [thisArg] The `this` binding of `interceptor`.\n\t     * @returns {*} Returns `value`.\n\t     * @example\n\t     *\n\t     * _([1, 2, 3])\n\t     *  .tap(function(array) {\n\t     *    array.pop();\n\t     *  })\n\t     *  .reverse()\n\t     *  .value();\n\t     * // => [2, 1]\n\t     */\n\t    function tap(value, interceptor, thisArg) {\n\t      interceptor.call(thisArg, value);\n\t      return value;\n\t    }\n\t\n\t    /**\n\t     * This method is like `_.tap` except that it returns the result of `interceptor`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Chain\n\t     * @param {*} value The value to provide to `interceptor`.\n\t     * @param {Function} interceptor The function to invoke.\n\t     * @param {*} [thisArg] The `this` binding of `interceptor`.\n\t     * @returns {*} Returns the result of `interceptor`.\n\t     * @example\n\t     *\n\t     * _('  abc  ')\n\t     *  .chain()\n\t     *  .trim()\n\t     *  .thru(function(value) {\n\t     *    return [value];\n\t     *  })\n\t     *  .value();\n\t     * // => ['abc']\n\t     */\n\t    function thru(value, interceptor, thisArg) {\n\t      return interceptor.call(thisArg, value);\n\t    }\n\t\n\t    /**\n\t     * Enables explicit method chaining on the wrapper object.\n\t     *\n\t     * @name chain\n\t     * @memberOf _\n\t     * @category Chain\n\t     * @returns {Object} Returns the new `lodash` wrapper instance.\n\t     * @example\n\t     *\n\t     * var users = [\n\t     *   { 'user': 'barney', 'age': 36 },\n\t     *   { 'user': 'fred',   'age': 40 }\n\t     * ];\n\t     *\n\t     * // without explicit chaining\n\t     * _(users).first();\n\t     * // => { 'user': 'barney', 'age': 36 }\n\t     *\n\t     * // with explicit chaining\n\t     * _(users).chain()\n\t     *   .first()\n\t     *   .pick('user')\n\t     *   .value();\n\t     * // => { 'user': 'barney' }\n\t     */\n\t    function wrapperChain() {\n\t      return chain(this);\n\t    }\n\t\n\t    /**\n\t     * Executes the chained sequence and returns the wrapped result.\n\t     *\n\t     * @name commit\n\t     * @memberOf _\n\t     * @category Chain\n\t     * @returns {Object} Returns the new `lodash` wrapper instance.\n\t     * @example\n\t     *\n\t     * var array = [1, 2];\n\t     * var wrapped = _(array).push(3);\n\t     *\n\t     * console.log(array);\n\t     * // => [1, 2]\n\t     *\n\t     * wrapped = wrapped.commit();\n\t     * console.log(array);\n\t     * // => [1, 2, 3]\n\t     *\n\t     * wrapped.last();\n\t     * // => 3\n\t     *\n\t     * console.log(array);\n\t     * // => [1, 2, 3]\n\t     */\n\t    function wrapperCommit() {\n\t      return new LodashWrapper(this.value(), this.__chain__);\n\t    }\n\t\n\t    /**\n\t     * Creates a new array joining a wrapped array with any additional arrays\n\t     * and/or values.\n\t     *\n\t     * @name concat\n\t     * @memberOf _\n\t     * @category Chain\n\t     * @param {...*} [values] The values to concatenate.\n\t     * @returns {Array} Returns the new concatenated array.\n\t     * @example\n\t     *\n\t     * var array = [1];\n\t     * var wrapped = _(array).concat(2, [3], [[4]]);\n\t     *\n\t     * console.log(wrapped.value());\n\t     * // => [1, 2, 3, [4]]\n\t     *\n\t     * console.log(array);\n\t     * // => [1]\n\t     */\n\t    var wrapperConcat = restParam(function(values) {\n\t      values = baseFlatten(values);\n\t      return this.thru(function(array) {\n\t        return arrayConcat(isArray(array) ? array : [toObject(array)], values);\n\t      });\n\t    });\n\t\n\t    /**\n\t     * Creates a clone of the chained sequence planting `value` as the wrapped value.\n\t     *\n\t     * @name plant\n\t     * @memberOf _\n\t     * @category Chain\n\t     * @returns {Object} Returns the new `lodash` wrapper instance.\n\t     * @example\n\t     *\n\t     * var array = [1, 2];\n\t     * var wrapped = _(array).map(function(value) {\n\t     *   return Math.pow(value, 2);\n\t     * });\n\t     *\n\t     * var other = [3, 4];\n\t     * var otherWrapped = wrapped.plant(other);\n\t     *\n\t     * otherWrapped.value();\n\t     * // => [9, 16]\n\t     *\n\t     * wrapped.value();\n\t     * // => [1, 4]\n\t     */\n\t    function wrapperPlant(value) {\n\t      var result,\n\t          parent = this;\n\t\n\t      while (parent instanceof baseLodash) {\n\t        var clone = wrapperClone(parent);\n\t        if (result) {\n\t          previous.__wrapped__ = clone;\n\t        } else {\n\t          result = clone;\n\t        }\n\t        var previous = clone;\n\t        parent = parent.__wrapped__;\n\t      }\n\t      previous.__wrapped__ = value;\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * Reverses the wrapped array so the first element becomes the last, the\n\t     * second element becomes the second to last, and so on.\n\t     *\n\t     * **Note:** This method mutates the wrapped array.\n\t     *\n\t     * @name reverse\n\t     * @memberOf _\n\t     * @category Chain\n\t     * @returns {Object} Returns the new reversed `lodash` wrapper instance.\n\t     * @example\n\t     *\n\t     * var array = [1, 2, 3];\n\t     *\n\t     * _(array).reverse().value()\n\t     * // => [3, 2, 1]\n\t     *\n\t     * console.log(array);\n\t     * // => [3, 2, 1]\n\t     */\n\t    function wrapperReverse() {\n\t      var value = this.__wrapped__;\n\t\n\t      var interceptor = function(value) {\n\t        return (wrapped && wrapped.__dir__ < 0) ? value : value.reverse();\n\t      };\n\t      if (value instanceof LazyWrapper) {\n\t        var wrapped = value;\n\t        if (this.__actions__.length) {\n\t          wrapped = new LazyWrapper(this);\n\t        }\n\t        wrapped = wrapped.reverse();\n\t        wrapped.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined });\n\t        return new LodashWrapper(wrapped, this.__chain__);\n\t      }\n\t      return this.thru(interceptor);\n\t    }\n\t\n\t    /**\n\t     * Produces the result of coercing the unwrapped value to a string.\n\t     *\n\t     * @name toString\n\t     * @memberOf _\n\t     * @category Chain\n\t     * @returns {string} Returns the coerced string value.\n\t     * @example\n\t     *\n\t     * _([1, 2, 3]).toString();\n\t     * // => '1,2,3'\n\t     */\n\t    function wrapperToString() {\n\t      return (this.value() + '');\n\t    }\n\t\n\t    /**\n\t     * Executes the chained sequence to extract the unwrapped value.\n\t     *\n\t     * @name value\n\t     * @memberOf _\n\t     * @alias run, toJSON, valueOf\n\t     * @category Chain\n\t     * @returns {*} Returns the resolved unwrapped value.\n\t     * @example\n\t     *\n\t     * _([1, 2, 3]).value();\n\t     * // => [1, 2, 3]\n\t     */\n\t    function wrapperValue() {\n\t      return baseWrapperValue(this.__wrapped__, this.__actions__);\n\t    }\n\t\n\t    /*------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * Creates an array of elements corresponding to the given keys, or indexes,\n\t     * of `collection`. Keys may be specified as individual arguments or as arrays\n\t     * of keys.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Collection\n\t     * @param {Array|Object|string} collection The collection to iterate over.\n\t     * @param {...(number|number[]|string|string[])} [props] The property names\n\t     *  or indexes of elements to pick, specified individually or in arrays.\n\t     * @returns {Array} Returns the new array of picked elements.\n\t     * @example\n\t     *\n\t     * _.at(['a', 'b', 'c'], [0, 2]);\n\t     * // => ['a', 'c']\n\t     *\n\t     * _.at(['barney', 'fred', 'pebbles'], 0, 2);\n\t     * // => ['barney', 'pebbles']\n\t     */\n\t    var at = restParam(function(collection, props) {\n\t      return baseAt(collection, baseFlatten(props));\n\t    });\n\t\n\t    /**\n\t     * Creates an object composed of keys generated from the results of running\n\t     * each element of `collection` through `iteratee`. The corresponding value\n\t     * of each key is the number of times the key was returned by `iteratee`.\n\t     * The `iteratee` is bound to `thisArg` and invoked with three arguments:\n\t     * (value, index|key, collection).\n\t     *\n\t     * If a property name is provided for `iteratee` the created `_.property`\n\t     * style callback returns the property value of the given element.\n\t     *\n\t     * If a value is also provided for `thisArg` the created `_.matchesProperty`\n\t     * style callback returns `true` for elements that have a matching property\n\t     * value, else `false`.\n\t     *\n\t     * If an object is provided for `iteratee` the created `_.matches` style\n\t     * callback returns `true` for elements that have the properties of the given\n\t     * object, else `false`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Collection\n\t     * @param {Array|Object|string} collection The collection to iterate over.\n\t     * @param {Function|Object|string} [iteratee=_.identity] The function invoked\n\t     *  per iteration.\n\t     * @param {*} [thisArg] The `this` binding of `iteratee`.\n\t     * @returns {Object} Returns the composed aggregate object.\n\t     * @example\n\t     *\n\t     * _.countBy([4.3, 6.1, 6.4], function(n) {\n\t     *   return Math.floor(n);\n\t     * });\n\t     * // => { '4': 1, '6': 2 }\n\t     *\n\t     * _.countBy([4.3, 6.1, 6.4], function(n) {\n\t     *   return this.floor(n);\n\t     * }, Math);\n\t     * // => { '4': 1, '6': 2 }\n\t     *\n\t     * _.countBy(['one', 'two', 'three'], 'length');\n\t     * // => { '3': 2, '5': 1 }\n\t     */\n\t    var countBy = createAggregator(function(result, value, key) {\n\t      hasOwnProperty.call(result, key) ? ++result[key] : (result[key] = 1);\n\t    });\n\t\n\t    /**\n\t     * Checks if `predicate` returns truthy for **all** elements of `collection`.\n\t     * The predicate is bound to `thisArg` and invoked with three arguments:\n\t     * (value, index|key, collection).\n\t     *\n\t     * If a property name is provided for `predicate` the created `_.property`\n\t     * style callback returns the property value of the given element.\n\t     *\n\t     * If a value is also provided for `thisArg` the created `_.matchesProperty`\n\t     * style callback returns `true` for elements that have a matching property\n\t     * value, else `false`.\n\t     *\n\t     * If an object is provided for `predicate` the created `_.matches` style\n\t     * callback returns `true` for elements that have the properties of the given\n\t     * object, else `false`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @alias all\n\t     * @category Collection\n\t     * @param {Array|Object|string} collection The collection to iterate over.\n\t     * @param {Function|Object|string} [predicate=_.identity] The function invoked\n\t     *  per iteration.\n\t     * @param {*} [thisArg] The `this` binding of `predicate`.\n\t     * @returns {boolean} Returns `true` if all elements pass the predicate check,\n\t     *  else `false`.\n\t     * @example\n\t     *\n\t     * _.every([true, 1, null, 'yes'], Boolean);\n\t     * // => false\n\t     *\n\t     * var users = [\n\t     *   { 'user': 'barney', 'active': false },\n\t     *   { 'user': 'fred',   'active': false }\n\t     * ];\n\t     *\n\t     * // using the `_.matches` callback shorthand\n\t     * _.every(users, { 'user': 'barney', 'active': false });\n\t     * // => false\n\t     *\n\t     * // using the `_.matchesProperty` callback shorthand\n\t     * _.every(users, 'active', false);\n\t     * // => true\n\t     *\n\t     * // using the `_.property` callback shorthand\n\t     * _.every(users, 'active');\n\t     * // => false\n\t     */\n\t    function every(collection, predicate, thisArg) {\n\t      var func = isArray(collection) ? arrayEvery : baseEvery;\n\t      if (thisArg && isIterateeCall(collection, predicate, thisArg)) {\n\t        predicate = undefined;\n\t      }\n\t      if (typeof predicate != 'function' || thisArg !== undefined) {\n\t        predicate = getCallback(predicate, thisArg, 3);\n\t      }\n\t      return func(collection, predicate);\n\t    }\n\t\n\t    /**\n\t     * Iterates over elements of `collection`, returning an array of all elements\n\t     * `predicate` returns truthy for. The predicate is bound to `thisArg` and\n\t     * invoked with three arguments: (value, index|key, collection).\n\t     *\n\t     * If a property name is provided for `predicate` the created `_.property`\n\t     * style callback returns the property value of the given element.\n\t     *\n\t     * If a value is also provided for `thisArg` the created `_.matchesProperty`\n\t     * style callback returns `true` for elements that have a matching property\n\t     * value, else `false`.\n\t     *\n\t     * If an object is provided for `predicate` the created `_.matches` style\n\t     * callback returns `true` for elements that have the properties of the given\n\t     * object, else `false`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @alias select\n\t     * @category Collection\n\t     * @param {Array|Object|string} collection The collection to iterate over.\n\t     * @param {Function|Object|string} [predicate=_.identity] The function invoked\n\t     *  per iteration.\n\t     * @param {*} [thisArg] The `this` binding of `predicate`.\n\t     * @returns {Array} Returns the new filtered array.\n\t     * @example\n\t     *\n\t     * _.filter([4, 5, 6], function(n) {\n\t     *   return n % 2 == 0;\n\t     * });\n\t     * // => [4, 6]\n\t     *\n\t     * var users = [\n\t     *   { 'user': 'barney', 'age': 36, 'active': true },\n\t     *   { 'user': 'fred',   'age': 40, 'active': false }\n\t     * ];\n\t     *\n\t     * // using the `_.matches` callback shorthand\n\t     * _.pluck(_.filter(users, { 'age': 36, 'active': true }), 'user');\n\t     * // => ['barney']\n\t     *\n\t     * // using the `_.matchesProperty` callback shorthand\n\t     * _.pluck(_.filter(users, 'active', false), 'user');\n\t     * // => ['fred']\n\t     *\n\t     * // using the `_.property` callback shorthand\n\t     * _.pluck(_.filter(users, 'active'), 'user');\n\t     * // => ['barney']\n\t     */\n\t    function filter(collection, predicate, thisArg) {\n\t      var func = isArray(collection) ? arrayFilter : baseFilter;\n\t      predicate = getCallback(predicate, thisArg, 3);\n\t      return func(collection, predicate);\n\t    }\n\t\n\t    /**\n\t     * Iterates over elements of `collection`, returning the first element\n\t     * `predicate` returns truthy for. The predicate is bound to `thisArg` and\n\t     * invoked with three arguments: (value, index|key, collection).\n\t     *\n\t     * If a property name is provided for `predicate` the created `_.property`\n\t     * style callback returns the property value of the given element.\n\t     *\n\t     * If a value is also provided for `thisArg` the created `_.matchesProperty`\n\t     * style callback returns `true` for elements that have a matching property\n\t     * value, else `false`.\n\t     *\n\t     * If an object is provided for `predicate` the created `_.matches` style\n\t     * callback returns `true` for elements that have the properties of the given\n\t     * object, else `false`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @alias detect\n\t     * @category Collection\n\t     * @param {Array|Object|string} collection The collection to search.\n\t     * @param {Function|Object|string} [predicate=_.identity] The function invoked\n\t     *  per iteration.\n\t     * @param {*} [thisArg] The `this` binding of `predicate`.\n\t     * @returns {*} Returns the matched element, else `undefined`.\n\t     * @example\n\t     *\n\t     * var users = [\n\t     *   { 'user': 'barney',  'age': 36, 'active': true },\n\t     *   { 'user': 'fred',    'age': 40, 'active': false },\n\t     *   { 'user': 'pebbles', 'age': 1,  'active': true }\n\t     * ];\n\t     *\n\t     * _.result(_.find(users, function(chr) {\n\t     *   return chr.age < 40;\n\t     * }), 'user');\n\t     * // => 'barney'\n\t     *\n\t     * // using the `_.matches` callback shorthand\n\t     * _.result(_.find(users, { 'age': 1, 'active': true }), 'user');\n\t     * // => 'pebbles'\n\t     *\n\t     * // using the `_.matchesProperty` callback shorthand\n\t     * _.result(_.find(users, 'active', false), 'user');\n\t     * // => 'fred'\n\t     *\n\t     * // using the `_.property` callback shorthand\n\t     * _.result(_.find(users, 'active'), 'user');\n\t     * // => 'barney'\n\t     */\n\t    var find = createFind(baseEach);\n\t\n\t    /**\n\t     * This method is like `_.find` except that it iterates over elements of\n\t     * `collection` from right to left.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Collection\n\t     * @param {Array|Object|string} collection The collection to search.\n\t     * @param {Function|Object|string} [predicate=_.identity] The function invoked\n\t     *  per iteration.\n\t     * @param {*} [thisArg] The `this` binding of `predicate`.\n\t     * @returns {*} Returns the matched element, else `undefined`.\n\t     * @example\n\t     *\n\t     * _.findLast([1, 2, 3, 4], function(n) {\n\t     *   return n % 2 == 1;\n\t     * });\n\t     * // => 3\n\t     */\n\t    var findLast = createFind(baseEachRight, true);\n\t\n\t    /**\n\t     * Performs a deep comparison between each element in `collection` and the\n\t     * source object, returning the first element that has equivalent property\n\t     * values.\n\t     *\n\t     * **Note:** This method supports comparing arrays, booleans, `Date` objects,\n\t     * numbers, `Object` objects, regexes, and strings. Objects are compared by\n\t     * their own, not inherited, enumerable properties. For comparing a single\n\t     * own or inherited property value see `_.matchesProperty`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Collection\n\t     * @param {Array|Object|string} collection The collection to search.\n\t     * @param {Object} source The object of property values to match.\n\t     * @returns {*} Returns the matched element, else `undefined`.\n\t     * @example\n\t     *\n\t     * var users = [\n\t     *   { 'user': 'barney', 'age': 36, 'active': true },\n\t     *   { 'user': 'fred',   'age': 40, 'active': false }\n\t     * ];\n\t     *\n\t     * _.result(_.findWhere(users, { 'age': 36, 'active': true }), 'user');\n\t     * // => 'barney'\n\t     *\n\t     * _.result(_.findWhere(users, { 'age': 40, 'active': false }), 'user');\n\t     * // => 'fred'\n\t     */\n\t    function findWhere(collection, source) {\n\t      return find(collection, baseMatches(source));\n\t    }\n\t\n\t    /**\n\t     * Iterates over elements of `collection` invoking `iteratee` for each element.\n\t     * The `iteratee` is bound to `thisArg` and invoked with three arguments:\n\t     * (value, index|key, collection). Iteratee functions may exit iteration early\n\t     * by explicitly returning `false`.\n\t     *\n\t     * **Note:** As with other \"Collections\" methods, objects with a \"length\" property\n\t     * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`\n\t     * may be used for object iteration.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @alias each\n\t     * @category Collection\n\t     * @param {Array|Object|string} collection The collection to iterate over.\n\t     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n\t     * @param {*} [thisArg] The `this` binding of `iteratee`.\n\t     * @returns {Array|Object|string} Returns `collection`.\n\t     * @example\n\t     *\n\t     * _([1, 2]).forEach(function(n) {\n\t     *   console.log(n);\n\t     * }).value();\n\t     * // => logs each value from left to right and returns the array\n\t     *\n\t     * _.forEach({ 'a': 1, 'b': 2 }, function(n, key) {\n\t     *   console.log(n, key);\n\t     * });\n\t     * // => logs each value-key pair and returns the object (iteration order is not guaranteed)\n\t     */\n\t    var forEach = createForEach(arrayEach, baseEach);\n\t\n\t    /**\n\t     * This method is like `_.forEach` except that it iterates over elements of\n\t     * `collection` from right to left.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @alias eachRight\n\t     * @category Collection\n\t     * @param {Array|Object|string} collection The collection to iterate over.\n\t     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n\t     * @param {*} [thisArg] The `this` binding of `iteratee`.\n\t     * @returns {Array|Object|string} Returns `collection`.\n\t     * @example\n\t     *\n\t     * _([1, 2]).forEachRight(function(n) {\n\t     *   console.log(n);\n\t     * }).value();\n\t     * // => logs each value from right to left and returns the array\n\t     */\n\t    var forEachRight = createForEach(arrayEachRight, baseEachRight);\n\t\n\t    /**\n\t     * Creates an object composed of keys generated from the results of running\n\t     * each element of `collection` through `iteratee`. The corresponding value\n\t     * of each key is an array of the elements responsible for generating the key.\n\t     * The `iteratee` is bound to `thisArg` and invoked with three arguments:\n\t     * (value, index|key, collection).\n\t     *\n\t     * If a property name is provided for `iteratee` the created `_.property`\n\t     * style callback returns the property value of the given element.\n\t     *\n\t     * If a value is also provided for `thisArg` the created `_.matchesProperty`\n\t     * style callback returns `true` for elements that have a matching property\n\t     * value, else `false`.\n\t     *\n\t     * If an object is provided for `iteratee` the created `_.matches` style\n\t     * callback returns `true` for elements that have the properties of the given\n\t     * object, else `false`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Collection\n\t     * @param {Array|Object|string} collection The collection to iterate over.\n\t     * @param {Function|Object|string} [iteratee=_.identity] The function invoked\n\t     *  per iteration.\n\t     * @param {*} [thisArg] The `this` binding of `iteratee`.\n\t     * @returns {Object} Returns the composed aggregate object.\n\t     * @example\n\t     *\n\t     * _.groupBy([4.2, 6.1, 6.4], function(n) {\n\t     *   return Math.floor(n);\n\t     * });\n\t     * // => { '4': [4.2], '6': [6.1, 6.4] }\n\t     *\n\t     * _.groupBy([4.2, 6.1, 6.4], function(n) {\n\t     *   return this.floor(n);\n\t     * }, Math);\n\t     * // => { '4': [4.2], '6': [6.1, 6.4] }\n\t     *\n\t     * // using the `_.property` callback shorthand\n\t     * _.groupBy(['one', 'two', 'three'], 'length');\n\t     * // => { '3': ['one', 'two'], '5': ['three'] }\n\t     */\n\t    var groupBy = createAggregator(function(result, value, key) {\n\t      if (hasOwnProperty.call(result, key)) {\n\t        result[key].push(value);\n\t      } else {\n\t        result[key] = [value];\n\t      }\n\t    });\n\t\n\t    /**\n\t     * Checks if `value` is in `collection` using\n\t     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)\n\t     * for equality comparisons. If `fromIndex` is negative, it is used as the offset\n\t     * from the end of `collection`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @alias contains, include\n\t     * @category Collection\n\t     * @param {Array|Object|string} collection The collection to search.\n\t     * @param {*} target The value to search for.\n\t     * @param {number} [fromIndex=0] The index to search from.\n\t     * @param- {Object} [guard] Enables use as a callback for functions like `_.reduce`.\n\t     * @returns {boolean} Returns `true` if a matching element is found, else `false`.\n\t     * @example\n\t     *\n\t     * _.includes([1, 2, 3], 1);\n\t     * // => true\n\t     *\n\t     * _.includes([1, 2, 3], 1, 2);\n\t     * // => false\n\t     *\n\t     * _.includes({ 'user': 'fred', 'age': 40 }, 'fred');\n\t     * // => true\n\t     *\n\t     * _.includes('pebbles', 'eb');\n\t     * // => true\n\t     */\n\t    function includes(collection, target, fromIndex, guard) {\n\t      var length = collection ? getLength(collection) : 0;\n\t      if (!isLength(length)) {\n\t        collection = values(collection);\n\t        length = collection.length;\n\t      }\n\t      if (typeof fromIndex != 'number' || (guard && isIterateeCall(target, fromIndex, guard))) {\n\t        fromIndex = 0;\n\t      } else {\n\t        fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : (fromIndex || 0);\n\t      }\n\t      return (typeof collection == 'string' || !isArray(collection) && isString(collection))\n\t        ? (fromIndex <= length && collection.indexOf(target, fromIndex) > -1)\n\t        : (!!length && getIndexOf(collection, target, fromIndex) > -1);\n\t    }\n\t\n\t    /**\n\t     * Creates an object composed of keys generated from the results of running\n\t     * each element of `collection` through `iteratee`. The corresponding value\n\t     * of each key is the last element responsible for generating the key. The\n\t     * iteratee function is bound to `thisArg` and invoked with three arguments:\n\t     * (value, index|key, collection).\n\t     *\n\t     * If a property name is provided for `iteratee` the created `_.property`\n\t     * style callback returns the property value of the given element.\n\t     *\n\t     * If a value is also provided for `thisArg` the created `_.matchesProperty`\n\t     * style callback returns `true` for elements that have a matching property\n\t     * value, else `false`.\n\t     *\n\t     * If an object is provided for `iteratee` the created `_.matches` style\n\t     * callback returns `true` for elements that have the properties of the given\n\t     * object, else `false`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Collection\n\t     * @param {Array|Object|string} collection The collection to iterate over.\n\t     * @param {Function|Object|string} [iteratee=_.identity] The function invoked\n\t     *  per iteration.\n\t     * @param {*} [thisArg] The `this` binding of `iteratee`.\n\t     * @returns {Object} Returns the composed aggregate object.\n\t     * @example\n\t     *\n\t     * var keyData = [\n\t     *   { 'dir': 'left', 'code': 97 },\n\t     *   { 'dir': 'right', 'code': 100 }\n\t     * ];\n\t     *\n\t     * _.indexBy(keyData, 'dir');\n\t     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }\n\t     *\n\t     * _.indexBy(keyData, function(object) {\n\t     *   return String.fromCharCode(object.code);\n\t     * });\n\t     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }\n\t     *\n\t     * _.indexBy(keyData, function(object) {\n\t     *   return this.fromCharCode(object.code);\n\t     * }, String);\n\t     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }\n\t     */\n\t    var indexBy = createAggregator(function(result, value, key) {\n\t      result[key] = value;\n\t    });\n\t\n\t    /**\n\t     * Invokes the method at `path` of each element in `collection`, returning\n\t     * an array of the results of each invoked method. Any additional arguments\n\t     * are provided to each invoked method. If `methodName` is a function it is\n\t     * invoked for, and `this` bound to, each element in `collection`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Collection\n\t     * @param {Array|Object|string} collection The collection to iterate over.\n\t     * @param {Array|Function|string} path The path of the method to invoke or\n\t     *  the function invoked per iteration.\n\t     * @param {...*} [args] The arguments to invoke the method with.\n\t     * @returns {Array} Returns the array of results.\n\t     * @example\n\t     *\n\t     * _.invoke([[5, 1, 7], [3, 2, 1]], 'sort');\n\t     * // => [[1, 5, 7], [1, 2, 3]]\n\t     *\n\t     * _.invoke([123, 456], String.prototype.split, '');\n\t     * // => [['1', '2', '3'], ['4', '5', '6']]\n\t     */\n\t    var invoke = restParam(function(collection, path, args) {\n\t      var index = -1,\n\t          isFunc = typeof path == 'function',\n\t          isProp = isKey(path),\n\t          result = isArrayLike(collection) ? Array(collection.length) : [];\n\t\n\t      baseEach(collection, function(value) {\n\t        var func = isFunc ? path : ((isProp && value != null) ? value[path] : undefined);\n\t        result[++index] = func ? func.apply(value, args) : invokePath(value, path, args);\n\t      });\n\t      return result;\n\t    });\n\t\n\t    /**\n\t     * Creates an array of values by running each element in `collection` through\n\t     * `iteratee`. The `iteratee` is bound to `thisArg` and invoked with three\n\t     * arguments: (value, index|key, collection).\n\t     *\n\t     * If a property name is provided for `iteratee` the created `_.property`\n\t     * style callback returns the property value of the given element.\n\t     *\n\t     * If a value is also provided for `thisArg` the created `_.matchesProperty`\n\t     * style callback returns `true` for elements that have a matching property\n\t     * value, else `false`.\n\t     *\n\t     * If an object is provided for `iteratee` the created `_.matches` style\n\t     * callback returns `true` for elements that have the properties of the given\n\t     * object, else `false`.\n\t     *\n\t     * Many lodash methods are guarded to work as iteratees for methods like\n\t     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.\n\t     *\n\t     * The guarded methods are:\n\t     * `ary`, `callback`, `chunk`, `clone`, `create`, `curry`, `curryRight`,\n\t     * `drop`, `dropRight`, `every`, `fill`, `flatten`, `invert`, `max`, `min`,\n\t     * `parseInt`, `slice`, `sortBy`, `take`, `takeRight`, `template`, `trim`,\n\t     * `trimLeft`, `trimRight`, `trunc`, `random`, `range`, `sample`, `some`,\n\t     * `sum`, `uniq`, and `words`\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @alias collect\n\t     * @category Collection\n\t     * @param {Array|Object|string} collection The collection to iterate over.\n\t     * @param {Function|Object|string} [iteratee=_.identity] The function invoked\n\t     *  per iteration.\n\t     * @param {*} [thisArg] The `this` binding of `iteratee`.\n\t     * @returns {Array} Returns the new mapped array.\n\t     * @example\n\t     *\n\t     * function timesThree(n) {\n\t     *   return n * 3;\n\t     * }\n\t     *\n\t     * _.map([1, 2], timesThree);\n\t     * // => [3, 6]\n\t     *\n\t     * _.map({ 'a': 1, 'b': 2 }, timesThree);\n\t     * // => [3, 6] (iteration order is not guaranteed)\n\t     *\n\t     * var users = [\n\t     *   { 'user': 'barney' },\n\t     *   { 'user': 'fred' }\n\t     * ];\n\t     *\n\t     * // using the `_.property` callback shorthand\n\t     * _.map(users, 'user');\n\t     * // => ['barney', 'fred']\n\t     */\n\t    function map(collection, iteratee, thisArg) {\n\t      var func = isArray(collection) ? arrayMap : baseMap;\n\t      iteratee = getCallback(iteratee, thisArg, 3);\n\t      return func(collection, iteratee);\n\t    }\n\t\n\t    /**\n\t     * Creates an array of elements split into two groups, the first of which\n\t     * contains elements `predicate` returns truthy for, while the second of which\n\t     * contains elements `predicate` returns falsey for. The predicate is bound\n\t     * to `thisArg` and invoked with three arguments: (value, index|key, collection).\n\t     *\n\t     * If a property name is provided for `predicate` the created `_.property`\n\t     * style callback returns the property value of the given element.\n\t     *\n\t     * If a value is also provided for `thisArg` the created `_.matchesProperty`\n\t     * style callback returns `true` for elements that have a matching property\n\t     * value, else `false`.\n\t     *\n\t     * If an object is provided for `predicate` the created `_.matches` style\n\t     * callback returns `true` for elements that have the properties of the given\n\t     * object, else `false`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Collection\n\t     * @param {Array|Object|string} collection The collection to iterate over.\n\t     * @param {Function|Object|string} [predicate=_.identity] The function invoked\n\t     *  per iteration.\n\t     * @param {*} [thisArg] The `this` binding of `predicate`.\n\t     * @returns {Array} Returns the array of grouped elements.\n\t     * @example\n\t     *\n\t     * _.partition([1, 2, 3], function(n) {\n\t     *   return n % 2;\n\t     * });\n\t     * // => [[1, 3], [2]]\n\t     *\n\t     * _.partition([1.2, 2.3, 3.4], function(n) {\n\t     *   return this.floor(n) % 2;\n\t     * }, Math);\n\t     * // => [[1.2, 3.4], [2.3]]\n\t     *\n\t     * var users = [\n\t     *   { 'user': 'barney',  'age': 36, 'active': false },\n\t     *   { 'user': 'fred',    'age': 40, 'active': true },\n\t     *   { 'user': 'pebbles', 'age': 1,  'active': false }\n\t     * ];\n\t     *\n\t     * var mapper = function(array) {\n\t     *   return _.pluck(array, 'user');\n\t     * };\n\t     *\n\t     * // using the `_.matches` callback shorthand\n\t     * _.map(_.partition(users, { 'age': 1, 'active': false }), mapper);\n\t     * // => [['pebbles'], ['barney', 'fred']]\n\t     *\n\t     * // using the `_.matchesProperty` callback shorthand\n\t     * _.map(_.partition(users, 'active', false), mapper);\n\t     * // => [['barney', 'pebbles'], ['fred']]\n\t     *\n\t     * // using the `_.property` callback shorthand\n\t     * _.map(_.partition(users, 'active'), mapper);\n\t     * // => [['fred'], ['barney', 'pebbles']]\n\t     */\n\t    var partition = createAggregator(function(result, value, key) {\n\t      result[key ? 0 : 1].push(value);\n\t    }, function() { return [[], []]; });\n\t\n\t    /**\n\t     * Gets the property value of `path` from all elements in `collection`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Collection\n\t     * @param {Array|Object|string} collection The collection to iterate over.\n\t     * @param {Array|string} path The path of the property to pluck.\n\t     * @returns {Array} Returns the property values.\n\t     * @example\n\t     *\n\t     * var users = [\n\t     *   { 'user': 'barney', 'age': 36 },\n\t     *   { 'user': 'fred',   'age': 40 }\n\t     * ];\n\t     *\n\t     * _.pluck(users, 'user');\n\t     * // => ['barney', 'fred']\n\t     *\n\t     * var userIndex = _.indexBy(users, 'user');\n\t     * _.pluck(userIndex, 'age');\n\t     * // => [36, 40] (iteration order is not guaranteed)\n\t     */\n\t    function pluck(collection, path) {\n\t      return map(collection, property(path));\n\t    }\n\t\n\t    /**\n\t     * Reduces `collection` to a value which is the accumulated result of running\n\t     * each element in `collection` through `iteratee`, where each successive\n\t     * invocation is supplied the return value of the previous. If `accumulator`\n\t     * is not provided the first element of `collection` is used as the initial\n\t     * value. The `iteratee` is bound to `thisArg` and invoked with four arguments:\n\t     * (accumulator, value, index|key, collection).\n\t     *\n\t     * Many lodash methods are guarded to work as iteratees for methods like\n\t     * `_.reduce`, `_.reduceRight`, and `_.transform`.\n\t     *\n\t     * The guarded methods are:\n\t     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `sortByAll`,\n\t     * and `sortByOrder`\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @alias foldl, inject\n\t     * @category Collection\n\t     * @param {Array|Object|string} collection The collection to iterate over.\n\t     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n\t     * @param {*} [accumulator] The initial value.\n\t     * @param {*} [thisArg] The `this` binding of `iteratee`.\n\t     * @returns {*} Returns the accumulated value.\n\t     * @example\n\t     *\n\t     * _.reduce([1, 2], function(total, n) {\n\t     *   return total + n;\n\t     * });\n\t     * // => 3\n\t     *\n\t     * _.reduce({ 'a': 1, 'b': 2 }, function(result, n, key) {\n\t     *   result[key] = n * 3;\n\t     *   return result;\n\t     * }, {});\n\t     * // => { 'a': 3, 'b': 6 } (iteration order is not guaranteed)\n\t     */\n\t    var reduce = createReduce(arrayReduce, baseEach);\n\t\n\t    /**\n\t     * This method is like `_.reduce` except that it iterates over elements of\n\t     * `collection` from right to left.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @alias foldr\n\t     * @category Collection\n\t     * @param {Array|Object|string} collection The collection to iterate over.\n\t     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n\t     * @param {*} [accumulator] The initial value.\n\t     * @param {*} [thisArg] The `this` binding of `iteratee`.\n\t     * @returns {*} Returns the accumulated value.\n\t     * @example\n\t     *\n\t     * var array = [[0, 1], [2, 3], [4, 5]];\n\t     *\n\t     * _.reduceRight(array, function(flattened, other) {\n\t     *   return flattened.concat(other);\n\t     * }, []);\n\t     * // => [4, 5, 2, 3, 0, 1]\n\t     */\n\t    var reduceRight = createReduce(arrayReduceRight, baseEachRight);\n\t\n\t    /**\n\t     * The opposite of `_.filter`; this method returns the elements of `collection`\n\t     * that `predicate` does **not** return truthy for.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Collection\n\t     * @param {Array|Object|string} collection The collection to iterate over.\n\t     * @param {Function|Object|string} [predicate=_.identity] The function invoked\n\t     *  per iteration.\n\t     * @param {*} [thisArg] The `this` binding of `predicate`.\n\t     * @returns {Array} Returns the new filtered array.\n\t     * @example\n\t     *\n\t     * _.reject([1, 2, 3, 4], function(n) {\n\t     *   return n % 2 == 0;\n\t     * });\n\t     * // => [1, 3]\n\t     *\n\t     * var users = [\n\t     *   { 'user': 'barney', 'age': 36, 'active': false },\n\t     *   { 'user': 'fred',   'age': 40, 'active': true }\n\t     * ];\n\t     *\n\t     * // using the `_.matches` callback shorthand\n\t     * _.pluck(_.reject(users, { 'age': 40, 'active': true }), 'user');\n\t     * // => ['barney']\n\t     *\n\t     * // using the `_.matchesProperty` callback shorthand\n\t     * _.pluck(_.reject(users, 'active', false), 'user');\n\t     * // => ['fred']\n\t     *\n\t     * // using the `_.property` callback shorthand\n\t     * _.pluck(_.reject(users, 'active'), 'user');\n\t     * // => ['barney']\n\t     */\n\t    function reject(collection, predicate, thisArg) {\n\t      var func = isArray(collection) ? arrayFilter : baseFilter;\n\t      predicate = getCallback(predicate, thisArg, 3);\n\t      return func(collection, function(value, index, collection) {\n\t        return !predicate(value, index, collection);\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Gets a random element or `n` random elements from a collection.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Collection\n\t     * @param {Array|Object|string} collection The collection to sample.\n\t     * @param {number} [n] The number of elements to sample.\n\t     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n\t     * @returns {*} Returns the random sample(s).\n\t     * @example\n\t     *\n\t     * _.sample([1, 2, 3, 4]);\n\t     * // => 2\n\t     *\n\t     * _.sample([1, 2, 3, 4], 2);\n\t     * // => [3, 1]\n\t     */\n\t    function sample(collection, n, guard) {\n\t      if (guard ? isIterateeCall(collection, n, guard) : n == null) {\n\t        collection = toIterable(collection);\n\t        var length = collection.length;\n\t        return length > 0 ? collection[baseRandom(0, length - 1)] : undefined;\n\t      }\n\t      var index = -1,\n\t          result = toArray(collection),\n\t          length = result.length,\n\t          lastIndex = length - 1;\n\t\n\t      n = nativeMin(n < 0 ? 0 : (+n || 0), length);\n\t      while (++index < n) {\n\t        var rand = baseRandom(index, lastIndex),\n\t            value = result[rand];\n\t\n\t        result[rand] = result[index];\n\t        result[index] = value;\n\t      }\n\t      result.length = n;\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * Creates an array of shuffled values, using a version of the\n\t     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Collection\n\t     * @param {Array|Object|string} collection The collection to shuffle.\n\t     * @returns {Array} Returns the new shuffled array.\n\t     * @example\n\t     *\n\t     * _.shuffle([1, 2, 3, 4]);\n\t     * // => [4, 1, 3, 2]\n\t     */\n\t    function shuffle(collection) {\n\t      return sample(collection, POSITIVE_INFINITY);\n\t    }\n\t\n\t    /**\n\t     * Gets the size of `collection` by returning its length for array-like\n\t     * values or the number of own enumerable properties for objects.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Collection\n\t     * @param {Array|Object|string} collection The collection to inspect.\n\t     * @returns {number} Returns the size of `collection`.\n\t     * @example\n\t     *\n\t     * _.size([1, 2, 3]);\n\t     * // => 3\n\t     *\n\t     * _.size({ 'a': 1, 'b': 2 });\n\t     * // => 2\n\t     *\n\t     * _.size('pebbles');\n\t     * // => 7\n\t     */\n\t    function size(collection) {\n\t      var length = collection ? getLength(collection) : 0;\n\t      return isLength(length) ? length : keys(collection).length;\n\t    }\n\t\n\t    /**\n\t     * Checks if `predicate` returns truthy for **any** element of `collection`.\n\t     * The function returns as soon as it finds a passing value and does not iterate\n\t     * over the entire collection. The predicate is bound to `thisArg` and invoked\n\t     * with three arguments: (value, index|key, collection).\n\t     *\n\t     * If a property name is provided for `predicate` the created `_.property`\n\t     * style callback returns the property value of the given element.\n\t     *\n\t     * If a value is also provided for `thisArg` the created `_.matchesProperty`\n\t     * style callback returns `true` for elements that have a matching property\n\t     * value, else `false`.\n\t     *\n\t     * If an object is provided for `predicate` the created `_.matches` style\n\t     * callback returns `true` for elements that have the properties of the given\n\t     * object, else `false`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @alias any\n\t     * @category Collection\n\t     * @param {Array|Object|string} collection The collection to iterate over.\n\t     * @param {Function|Object|string} [predicate=_.identity] The function invoked\n\t     *  per iteration.\n\t     * @param {*} [thisArg] The `this` binding of `predicate`.\n\t     * @returns {boolean} Returns `true` if any element passes the predicate check,\n\t     *  else `false`.\n\t     * @example\n\t     *\n\t     * _.some([null, 0, 'yes', false], Boolean);\n\t     * // => true\n\t     *\n\t     * var users = [\n\t     *   { 'user': 'barney', 'active': true },\n\t     *   { 'user': 'fred',   'active': false }\n\t     * ];\n\t     *\n\t     * // using the `_.matches` callback shorthand\n\t     * _.some(users, { 'user': 'barney', 'active': false });\n\t     * // => false\n\t     *\n\t     * // using the `_.matchesProperty` callback shorthand\n\t     * _.some(users, 'active', false);\n\t     * // => true\n\t     *\n\t     * // using the `_.property` callback shorthand\n\t     * _.some(users, 'active');\n\t     * // => true\n\t     */\n\t    function some(collection, predicate, thisArg) {\n\t      var func = isArray(collection) ? arraySome : baseSome;\n\t      if (thisArg && isIterateeCall(collection, predicate, thisArg)) {\n\t        predicate = undefined;\n\t      }\n\t      if (typeof predicate != 'function' || thisArg !== undefined) {\n\t        predicate = getCallback(predicate, thisArg, 3);\n\t      }\n\t      return func(collection, predicate);\n\t    }\n\t\n\t    /**\n\t     * Creates an array of elements, sorted in ascending order by the results of\n\t     * running each element in a collection through `iteratee`. This method performs\n\t     * a stable sort, that is, it preserves the original sort order of equal elements.\n\t     * The `iteratee` is bound to `thisArg` and invoked with three arguments:\n\t     * (value, index|key, collection).\n\t     *\n\t     * If a property name is provided for `iteratee` the created `_.property`\n\t     * style callback returns the property value of the given element.\n\t     *\n\t     * If a value is also provided for `thisArg` the created `_.matchesProperty`\n\t     * style callback returns `true` for elements that have a matching property\n\t     * value, else `false`.\n\t     *\n\t     * If an object is provided for `iteratee` the created `_.matches` style\n\t     * callback returns `true` for elements that have the properties of the given\n\t     * object, else `false`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Collection\n\t     * @param {Array|Object|string} collection The collection to iterate over.\n\t     * @param {Function|Object|string} [iteratee=_.identity] The function invoked\n\t     *  per iteration.\n\t     * @param {*} [thisArg] The `this` binding of `iteratee`.\n\t     * @returns {Array} Returns the new sorted array.\n\t     * @example\n\t     *\n\t     * _.sortBy([1, 2, 3], function(n) {\n\t     *   return Math.sin(n);\n\t     * });\n\t     * // => [3, 1, 2]\n\t     *\n\t     * _.sortBy([1, 2, 3], function(n) {\n\t     *   return this.sin(n);\n\t     * }, Math);\n\t     * // => [3, 1, 2]\n\t     *\n\t     * var users = [\n\t     *   { 'user': 'fred' },\n\t     *   { 'user': 'pebbles' },\n\t     *   { 'user': 'barney' }\n\t     * ];\n\t     *\n\t     * // using the `_.property` callback shorthand\n\t     * _.pluck(_.sortBy(users, 'user'), 'user');\n\t     * // => ['barney', 'fred', 'pebbles']\n\t     */\n\t    function sortBy(collection, iteratee, thisArg) {\n\t      if (collection == null) {\n\t        return [];\n\t      }\n\t      if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {\n\t        iteratee = undefined;\n\t      }\n\t      var index = -1;\n\t      iteratee = getCallback(iteratee, thisArg, 3);\n\t\n\t      var result = baseMap(collection, function(value, key, collection) {\n\t        return { 'criteria': iteratee(value, key, collection), 'index': ++index, 'value': value };\n\t      });\n\t      return baseSortBy(result, compareAscending);\n\t    }\n\t\n\t    /**\n\t     * This method is like `_.sortBy` except that it can sort by multiple iteratees\n\t     * or property names.\n\t     *\n\t     * If a property name is provided for an iteratee the created `_.property`\n\t     * style callback returns the property value of the given element.\n\t     *\n\t     * If an object is provided for an iteratee the created `_.matches` style\n\t     * callback returns `true` for elements that have the properties of the given\n\t     * object, else `false`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Collection\n\t     * @param {Array|Object|string} collection The collection to iterate over.\n\t     * @param {...(Function|Function[]|Object|Object[]|string|string[])} iteratees\n\t     *  The iteratees to sort by, specified as individual values or arrays of values.\n\t     * @returns {Array} Returns the new sorted array.\n\t     * @example\n\t     *\n\t     * var users = [\n\t     *   { 'user': 'fred',   'age': 48 },\n\t     *   { 'user': 'barney', 'age': 36 },\n\t     *   { 'user': 'fred',   'age': 42 },\n\t     *   { 'user': 'barney', 'age': 34 }\n\t     * ];\n\t     *\n\t     * _.map(_.sortByAll(users, ['user', 'age']), _.values);\n\t     * // => [['barney', 34], ['barney', 36], ['fred', 42], ['fred', 48]]\n\t     *\n\t     * _.map(_.sortByAll(users, 'user', function(chr) {\n\t     *   return Math.floor(chr.age / 10);\n\t     * }), _.values);\n\t     * // => [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 42]]\n\t     */\n\t    var sortByAll = restParam(function(collection, iteratees) {\n\t      if (collection == null) {\n\t        return [];\n\t      }\n\t      var guard = iteratees[2];\n\t      if (guard && isIterateeCall(iteratees[0], iteratees[1], guard)) {\n\t        iteratees.length = 1;\n\t      }\n\t      return baseSortByOrder(collection, baseFlatten(iteratees), []);\n\t    });\n\t\n\t    /**\n\t     * This method is like `_.sortByAll` except that it allows specifying the\n\t     * sort orders of the iteratees to sort by. If `orders` is unspecified, all\n\t     * values are sorted in ascending order. Otherwise, a value is sorted in\n\t     * ascending order if its corresponding order is \"asc\", and descending if \"desc\".\n\t     *\n\t     * If a property name is provided for an iteratee the created `_.property`\n\t     * style callback returns the property value of the given element.\n\t     *\n\t     * If an object is provided for an iteratee the created `_.matches` style\n\t     * callback returns `true` for elements that have the properties of the given\n\t     * object, else `false`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Collection\n\t     * @param {Array|Object|string} collection The collection to iterate over.\n\t     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.\n\t     * @param {boolean[]} [orders] The sort orders of `iteratees`.\n\t     * @param- {Object} [guard] Enables use as a callback for functions like `_.reduce`.\n\t     * @returns {Array} Returns the new sorted array.\n\t     * @example\n\t     *\n\t     * var users = [\n\t     *   { 'user': 'fred',   'age': 48 },\n\t     *   { 'user': 'barney', 'age': 34 },\n\t     *   { 'user': 'fred',   'age': 42 },\n\t     *   { 'user': 'barney', 'age': 36 }\n\t     * ];\n\t     *\n\t     * // sort by `user` in ascending order and by `age` in descending order\n\t     * _.map(_.sortByOrder(users, ['user', 'age'], ['asc', 'desc']), _.values);\n\t     * // => [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 42]]\n\t     */\n\t    function sortByOrder(collection, iteratees, orders, guard) {\n\t      if (collection == null) {\n\t        return [];\n\t      }\n\t      if (guard && isIterateeCall(iteratees, orders, guard)) {\n\t        orders = undefined;\n\t      }\n\t      if (!isArray(iteratees)) {\n\t        iteratees = iteratees == null ? [] : [iteratees];\n\t      }\n\t      if (!isArray(orders)) {\n\t        orders = orders == null ? [] : [orders];\n\t      }\n\t      return baseSortByOrder(collection, iteratees, orders);\n\t    }\n\t\n\t    /**\n\t     * Performs a deep comparison between each element in `collection` and the\n\t     * source object, returning an array of all elements that have equivalent\n\t     * property values.\n\t     *\n\t     * **Note:** This method supports comparing arrays, booleans, `Date` objects,\n\t     * numbers, `Object` objects, regexes, and strings. Objects are compared by\n\t     * their own, not inherited, enumerable properties. For comparing a single\n\t     * own or inherited property value see `_.matchesProperty`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Collection\n\t     * @param {Array|Object|string} collection The collection to search.\n\t     * @param {Object} source The object of property values to match.\n\t     * @returns {Array} Returns the new filtered array.\n\t     * @example\n\t     *\n\t     * var users = [\n\t     *   { 'user': 'barney', 'age': 36, 'active': false, 'pets': ['hoppy'] },\n\t     *   { 'user': 'fred',   'age': 40, 'active': true, 'pets': ['baby puss', 'dino'] }\n\t     * ];\n\t     *\n\t     * _.pluck(_.where(users, { 'age': 36, 'active': false }), 'user');\n\t     * // => ['barney']\n\t     *\n\t     * _.pluck(_.where(users, { 'pets': ['dino'] }), 'user');\n\t     * // => ['fred']\n\t     */\n\t    function where(collection, source) {\n\t      return filter(collection, baseMatches(source));\n\t    }\n\t\n\t    /*------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * Gets the number of milliseconds that have elapsed since the Unix epoch\n\t     * (1 January 1970 00:00:00 UTC).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Date\n\t     * @example\n\t     *\n\t     * _.defer(function(stamp) {\n\t     *   console.log(_.now() - stamp);\n\t     * }, _.now());\n\t     * // => logs the number of milliseconds it took for the deferred function to be invoked\n\t     */\n\t    var now = nativeNow || function() {\n\t      return new Date().getTime();\n\t    };\n\t\n\t    /*------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * The opposite of `_.before`; this method creates a function that invokes\n\t     * `func` once it is called `n` or more times.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Function\n\t     * @param {number} n The number of calls before `func` is invoked.\n\t     * @param {Function} func The function to restrict.\n\t     * @returns {Function} Returns the new restricted function.\n\t     * @example\n\t     *\n\t     * var saves = ['profile', 'settings'];\n\t     *\n\t     * var done = _.after(saves.length, function() {\n\t     *   console.log('done saving!');\n\t     * });\n\t     *\n\t     * _.forEach(saves, function(type) {\n\t     *   asyncSave({ 'type': type, 'complete': done });\n\t     * });\n\t     * // => logs 'done saving!' after the two async saves have completed\n\t     */\n\t    function after(n, func) {\n\t      if (typeof func != 'function') {\n\t        if (typeof n == 'function') {\n\t          var temp = n;\n\t          n = func;\n\t          func = temp;\n\t        } else {\n\t          throw new TypeError(FUNC_ERROR_TEXT);\n\t        }\n\t      }\n\t      n = nativeIsFinite(n = +n) ? n : 0;\n\t      return function() {\n\t        if (--n < 1) {\n\t          return func.apply(this, arguments);\n\t        }\n\t      };\n\t    }\n\t\n\t    /**\n\t     * Creates a function that accepts up to `n` arguments ignoring any\n\t     * additional arguments.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Function\n\t     * @param {Function} func The function to cap arguments for.\n\t     * @param {number} [n=func.length] The arity cap.\n\t     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n\t     * @returns {Function} Returns the new function.\n\t     * @example\n\t     *\n\t     * _.map(['6', '8', '10'], _.ary(parseInt, 1));\n\t     * // => [6, 8, 10]\n\t     */\n\t    function ary(func, n, guard) {\n\t      if (guard && isIterateeCall(func, n, guard)) {\n\t        n = undefined;\n\t      }\n\t      n = (func && n == null) ? func.length : nativeMax(+n || 0, 0);\n\t      return createWrapper(func, ARY_FLAG, undefined, undefined, undefined, undefined, n);\n\t    }\n\t\n\t    /**\n\t     * Creates a function that invokes `func`, with the `this` binding and arguments\n\t     * of the created function, while it is called less than `n` times. Subsequent\n\t     * calls to the created function return the result of the last `func` invocation.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Function\n\t     * @param {number} n The number of calls at which `func` is no longer invoked.\n\t     * @param {Function} func The function to restrict.\n\t     * @returns {Function} Returns the new restricted function.\n\t     * @example\n\t     *\n\t     * jQuery('#add').on('click', _.before(5, addContactToList));\n\t     * // => allows adding up to 4 contacts to the list\n\t     */\n\t    function before(n, func) {\n\t      var result;\n\t      if (typeof func != 'function') {\n\t        if (typeof n == 'function') {\n\t          var temp = n;\n\t          n = func;\n\t          func = temp;\n\t        } else {\n\t          throw new TypeError(FUNC_ERROR_TEXT);\n\t        }\n\t      }\n\t      return function() {\n\t        if (--n > 0) {\n\t          result = func.apply(this, arguments);\n\t        }\n\t        if (n <= 1) {\n\t          func = undefined;\n\t        }\n\t        return result;\n\t      };\n\t    }\n\t\n\t    /**\n\t     * Creates a function that invokes `func` with the `this` binding of `thisArg`\n\t     * and prepends any additional `_.bind` arguments to those provided to the\n\t     * bound function.\n\t     *\n\t     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,\n\t     * may be used as a placeholder for partially applied arguments.\n\t     *\n\t     * **Note:** Unlike native `Function#bind` this method does not set the \"length\"\n\t     * property of bound functions.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Function\n\t     * @param {Function} func The function to bind.\n\t     * @param {*} thisArg The `this` binding of `func`.\n\t     * @param {...*} [partials] The arguments to be partially applied.\n\t     * @returns {Function} Returns the new bound function.\n\t     * @example\n\t     *\n\t     * var greet = function(greeting, punctuation) {\n\t     *   return greeting + ' ' + this.user + punctuation;\n\t     * };\n\t     *\n\t     * var object = { 'user': 'fred' };\n\t     *\n\t     * var bound = _.bind(greet, object, 'hi');\n\t     * bound('!');\n\t     * // => 'hi fred!'\n\t     *\n\t     * // using placeholders\n\t     * var bound = _.bind(greet, object, _, '!');\n\t     * bound('hi');\n\t     * // => 'hi fred!'\n\t     */\n\t    var bind = restParam(function(func, thisArg, partials) {\n\t      var bitmask = BIND_FLAG;\n\t      if (partials.length) {\n\t        var holders = replaceHolders(partials, bind.placeholder);\n\t        bitmask |= PARTIAL_FLAG;\n\t      }\n\t      return createWrapper(func, bitmask, thisArg, partials, holders);\n\t    });\n\t\n\t    /**\n\t     * Binds methods of an object to the object itself, overwriting the existing\n\t     * method. Method names may be specified as individual arguments or as arrays\n\t     * of method names. If no method names are provided all enumerable function\n\t     * properties, own and inherited, of `object` are bound.\n\t     *\n\t     * **Note:** This method does not set the \"length\" property of bound functions.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Function\n\t     * @param {Object} object The object to bind and assign the bound methods to.\n\t     * @param {...(string|string[])} [methodNames] The object method names to bind,\n\t     *  specified as individual method names or arrays of method names.\n\t     * @returns {Object} Returns `object`.\n\t     * @example\n\t     *\n\t     * var view = {\n\t     *   'label': 'docs',\n\t     *   'onClick': function() {\n\t     *     console.log('clicked ' + this.label);\n\t     *   }\n\t     * };\n\t     *\n\t     * _.bindAll(view);\n\t     * jQuery('#docs').on('click', view.onClick);\n\t     * // => logs 'clicked docs' when the element is clicked\n\t     */\n\t    var bindAll = restParam(function(object, methodNames) {\n\t      methodNames = methodNames.length ? baseFlatten(methodNames) : functions(object);\n\t\n\t      var index = -1,\n\t          length = methodNames.length;\n\t\n\t      while (++index < length) {\n\t        var key = methodNames[index];\n\t        object[key] = createWrapper(object[key], BIND_FLAG, object);\n\t      }\n\t      return object;\n\t    });\n\t\n\t    /**\n\t     * Creates a function that invokes the method at `object[key]` and prepends\n\t     * any additional `_.bindKey` arguments to those provided to the bound function.\n\t     *\n\t     * This method differs from `_.bind` by allowing bound functions to reference\n\t     * methods that may be redefined or don't yet exist.\n\t     * See [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)\n\t     * for more details.\n\t     *\n\t     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic\n\t     * builds, may be used as a placeholder for partially applied arguments.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Function\n\t     * @param {Object} object The object the method belongs to.\n\t     * @param {string} key The key of the method.\n\t     * @param {...*} [partials] The arguments to be partially applied.\n\t     * @returns {Function} Returns the new bound function.\n\t     * @example\n\t     *\n\t     * var object = {\n\t     *   'user': 'fred',\n\t     *   'greet': function(greeting, punctuation) {\n\t     *     return greeting + ' ' + this.user + punctuation;\n\t     *   }\n\t     * };\n\t     *\n\t     * var bound = _.bindKey(object, 'greet', 'hi');\n\t     * bound('!');\n\t     * // => 'hi fred!'\n\t     *\n\t     * object.greet = function(greeting, punctuation) {\n\t     *   return greeting + 'ya ' + this.user + punctuation;\n\t     * };\n\t     *\n\t     * bound('!');\n\t     * // => 'hiya fred!'\n\t     *\n\t     * // using placeholders\n\t     * var bound = _.bindKey(object, 'greet', _, '!');\n\t     * bound('hi');\n\t     * // => 'hiya fred!'\n\t     */\n\t    var bindKey = restParam(function(object, key, partials) {\n\t      var bitmask = BIND_FLAG | BIND_KEY_FLAG;\n\t      if (partials.length) {\n\t        var holders = replaceHolders(partials, bindKey.placeholder);\n\t        bitmask |= PARTIAL_FLAG;\n\t      }\n\t      return createWrapper(key, bitmask, object, partials, holders);\n\t    });\n\t\n\t    /**\n\t     * Creates a function that accepts one or more arguments of `func` that when\n\t     * called either invokes `func` returning its result, if all `func` arguments\n\t     * have been provided, or returns a function that accepts one or more of the\n\t     * remaining `func` arguments, and so on. The arity of `func` may be specified\n\t     * if `func.length` is not sufficient.\n\t     *\n\t     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,\n\t     * may be used as a placeholder for provided arguments.\n\t     *\n\t     * **Note:** This method does not set the \"length\" property of curried functions.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Function\n\t     * @param {Function} func The function to curry.\n\t     * @param {number} [arity=func.length] The arity of `func`.\n\t     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n\t     * @returns {Function} Returns the new curried function.\n\t     * @example\n\t     *\n\t     * var abc = function(a, b, c) {\n\t     *   return [a, b, c];\n\t     * };\n\t     *\n\t     * var curried = _.curry(abc);\n\t     *\n\t     * curried(1)(2)(3);\n\t     * // => [1, 2, 3]\n\t     *\n\t     * curried(1, 2)(3);\n\t     * // => [1, 2, 3]\n\t     *\n\t     * curried(1, 2, 3);\n\t     * // => [1, 2, 3]\n\t     *\n\t     * // using placeholders\n\t     * curried(1)(_, 3)(2);\n\t     * // => [1, 2, 3]\n\t     */\n\t    var curry = createCurry(CURRY_FLAG);\n\t\n\t    /**\n\t     * This method is like `_.curry` except that arguments are applied to `func`\n\t     * in the manner of `_.partialRight` instead of `_.partial`.\n\t     *\n\t     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic\n\t     * builds, may be used as a placeholder for provided arguments.\n\t     *\n\t     * **Note:** This method does not set the \"length\" property of curried functions.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Function\n\t     * @param {Function} func The function to curry.\n\t     * @param {number} [arity=func.length] The arity of `func`.\n\t     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n\t     * @returns {Function} Returns the new curried function.\n\t     * @example\n\t     *\n\t     * var abc = function(a, b, c) {\n\t     *   return [a, b, c];\n\t     * };\n\t     *\n\t     * var curried = _.curryRight(abc);\n\t     *\n\t     * curried(3)(2)(1);\n\t     * // => [1, 2, 3]\n\t     *\n\t     * curried(2, 3)(1);\n\t     * // => [1, 2, 3]\n\t     *\n\t     * curried(1, 2, 3);\n\t     * // => [1, 2, 3]\n\t     *\n\t     * // using placeholders\n\t     * curried(3)(1, _)(2);\n\t     * // => [1, 2, 3]\n\t     */\n\t    var curryRight = createCurry(CURRY_RIGHT_FLAG);\n\t\n\t    /**\n\t     * Creates a debounced function that delays invoking `func` until after `wait`\n\t     * milliseconds have elapsed since the last time the debounced function was\n\t     * invoked. The debounced function comes with a `cancel` method to cancel\n\t     * delayed invocations. Provide an options object to indicate that `func`\n\t     * should be invoked on the leading and/or trailing edge of the `wait` timeout.\n\t     * Subsequent calls to the debounced function return the result of the last\n\t     * `func` invocation.\n\t     *\n\t     * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked\n\t     * on the trailing edge of the timeout only if the the debounced function is\n\t     * invoked more than once during the `wait` timeout.\n\t     *\n\t     * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)\n\t     * for details over the differences between `_.debounce` and `_.throttle`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Function\n\t     * @param {Function} func The function to debounce.\n\t     * @param {number} [wait=0] The number of milliseconds to delay.\n\t     * @param {Object} [options] The options object.\n\t     * @param {boolean} [options.leading=false] Specify invoking on the leading\n\t     *  edge of the timeout.\n\t     * @param {number} [options.maxWait] The maximum time `func` is allowed to be\n\t     *  delayed before it is invoked.\n\t     * @param {boolean} [options.trailing=true] Specify invoking on the trailing\n\t     *  edge of the timeout.\n\t     * @returns {Function} Returns the new debounced function.\n\t     * @example\n\t     *\n\t     * // avoid costly calculations while the window size is in flux\n\t     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n\t     *\n\t     * // invoke `sendMail` when the click event is fired, debouncing subsequent calls\n\t     * jQuery('#postbox').on('click', _.debounce(sendMail, 300, {\n\t     *   'leading': true,\n\t     *   'trailing': false\n\t     * }));\n\t     *\n\t     * // ensure `batchLog` is invoked once after 1 second of debounced calls\n\t     * var source = new EventSource('/stream');\n\t     * jQuery(source).on('message', _.debounce(batchLog, 250, {\n\t     *   'maxWait': 1000\n\t     * }));\n\t     *\n\t     * // cancel a debounced call\n\t     * var todoChanges = _.debounce(batchLog, 1000);\n\t     * Object.observe(models.todo, todoChanges);\n\t     *\n\t     * Object.observe(models, function(changes) {\n\t     *   if (_.find(changes, { 'user': 'todo', 'type': 'delete'})) {\n\t     *     todoChanges.cancel();\n\t     *   }\n\t     * }, ['delete']);\n\t     *\n\t     * // ...at some point `models.todo` is changed\n\t     * models.todo.completed = true;\n\t     *\n\t     * // ...before 1 second has passed `models.todo` is deleted\n\t     * // which cancels the debounced `todoChanges` call\n\t     * delete models.todo;\n\t     */\n\t    function debounce(func, wait, options) {\n\t      var args,\n\t          maxTimeoutId,\n\t          result,\n\t          stamp,\n\t          thisArg,\n\t          timeoutId,\n\t          trailingCall,\n\t          lastCalled = 0,\n\t          maxWait = false,\n\t          trailing = true;\n\t\n\t      if (typeof func != 'function') {\n\t        throw new TypeError(FUNC_ERROR_TEXT);\n\t      }\n\t      wait = wait < 0 ? 0 : (+wait || 0);\n\t      if (options === true) {\n\t        var leading = true;\n\t        trailing = false;\n\t      } else if (isObject(options)) {\n\t        leading = !!options.leading;\n\t        maxWait = 'maxWait' in options && nativeMax(+options.maxWait || 0, wait);\n\t        trailing = 'trailing' in options ? !!options.trailing : trailing;\n\t      }\n\t\n\t      function cancel() {\n\t        if (timeoutId) {\n\t          clearTimeout(timeoutId);\n\t        }\n\t        if (maxTimeoutId) {\n\t          clearTimeout(maxTimeoutId);\n\t        }\n\t        lastCalled = 0;\n\t        maxTimeoutId = timeoutId = trailingCall = undefined;\n\t      }\n\t\n\t      function complete(isCalled, id) {\n\t        if (id) {\n\t          clearTimeout(id);\n\t        }\n\t        maxTimeoutId = timeoutId = trailingCall = undefined;\n\t        if (isCalled) {\n\t          lastCalled = now();\n\t          result = func.apply(thisArg, args);\n\t          if (!timeoutId && !maxTimeoutId) {\n\t            args = thisArg = undefined;\n\t          }\n\t        }\n\t      }\n\t\n\t      function delayed() {\n\t        var remaining = wait - (now() - stamp);\n\t        if (remaining <= 0 || remaining > wait) {\n\t          complete(trailingCall, maxTimeoutId);\n\t        } else {\n\t          timeoutId = setTimeout(delayed, remaining);\n\t        }\n\t      }\n\t\n\t      function maxDelayed() {\n\t        complete(trailing, timeoutId);\n\t      }\n\t\n\t      function debounced() {\n\t        args = arguments;\n\t        stamp = now();\n\t        thisArg = this;\n\t        trailingCall = trailing && (timeoutId || !leading);\n\t\n\t        if (maxWait === false) {\n\t          var leadingCall = leading && !timeoutId;\n\t        } else {\n\t          if (!maxTimeoutId && !leading) {\n\t            lastCalled = stamp;\n\t          }\n\t          var remaining = maxWait - (stamp - lastCalled),\n\t              isCalled = remaining <= 0 || remaining > maxWait;\n\t\n\t          if (isCalled) {\n\t            if (maxTimeoutId) {\n\t              maxTimeoutId = clearTimeout(maxTimeoutId);\n\t            }\n\t            lastCalled = stamp;\n\t            result = func.apply(thisArg, args);\n\t          }\n\t          else if (!maxTimeoutId) {\n\t            maxTimeoutId = setTimeout(maxDelayed, remaining);\n\t          }\n\t        }\n\t        if (isCalled && timeoutId) {\n\t          timeoutId = clearTimeout(timeoutId);\n\t        }\n\t        else if (!timeoutId && wait !== maxWait) {\n\t          timeoutId = setTimeout(delayed, wait);\n\t        }\n\t        if (leadingCall) {\n\t          isCalled = true;\n\t          result = func.apply(thisArg, args);\n\t        }\n\t        if (isCalled && !timeoutId && !maxTimeoutId) {\n\t          args = thisArg = undefined;\n\t        }\n\t        return result;\n\t      }\n\t      debounced.cancel = cancel;\n\t      return debounced;\n\t    }\n\t\n\t    /**\n\t     * Defers invoking the `func` until the current call stack has cleared. Any\n\t     * additional arguments are provided to `func` when it is invoked.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Function\n\t     * @param {Function} func The function to defer.\n\t     * @param {...*} [args] The arguments to invoke the function with.\n\t     * @returns {number} Returns the timer id.\n\t     * @example\n\t     *\n\t     * _.defer(function(text) {\n\t     *   console.log(text);\n\t     * }, 'deferred');\n\t     * // logs 'deferred' after one or more milliseconds\n\t     */\n\t    var defer = restParam(function(func, args) {\n\t      return baseDelay(func, 1, args);\n\t    });\n\t\n\t    /**\n\t     * Invokes `func` after `wait` milliseconds. Any additional arguments are\n\t     * provided to `func` when it is invoked.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Function\n\t     * @param {Function} func The function to delay.\n\t     * @param {number} wait The number of milliseconds to delay invocation.\n\t     * @param {...*} [args] The arguments to invoke the function with.\n\t     * @returns {number} Returns the timer id.\n\t     * @example\n\t     *\n\t     * _.delay(function(text) {\n\t     *   console.log(text);\n\t     * }, 1000, 'later');\n\t     * // => logs 'later' after one second\n\t     */\n\t    var delay = restParam(function(func, wait, args) {\n\t      return baseDelay(func, wait, args);\n\t    });\n\t\n\t    /**\n\t     * Creates a function that returns the result of invoking the provided\n\t     * functions with the `this` binding of the created function, where each\n\t     * successive invocation is supplied the return value of the previous.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Function\n\t     * @param {...Function} [funcs] Functions to invoke.\n\t     * @returns {Function} Returns the new function.\n\t     * @example\n\t     *\n\t     * function square(n) {\n\t     *   return n * n;\n\t     * }\n\t     *\n\t     * var addSquare = _.flow(_.add, square);\n\t     * addSquare(1, 2);\n\t     * // => 9\n\t     */\n\t    var flow = createFlow();\n\t\n\t    /**\n\t     * This method is like `_.flow` except that it creates a function that\n\t     * invokes the provided functions from right to left.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @alias backflow, compose\n\t     * @category Function\n\t     * @param {...Function} [funcs] Functions to invoke.\n\t     * @returns {Function} Returns the new function.\n\t     * @example\n\t     *\n\t     * function square(n) {\n\t     *   return n * n;\n\t     * }\n\t     *\n\t     * var addSquare = _.flowRight(square, _.add);\n\t     * addSquare(1, 2);\n\t     * // => 9\n\t     */\n\t    var flowRight = createFlow(true);\n\t\n\t    /**\n\t     * Creates a function that memoizes the result of `func`. If `resolver` is\n\t     * provided it determines the cache key for storing the result based on the\n\t     * arguments provided to the memoized function. By default, the first argument\n\t     * provided to the memoized function is coerced to a string and used as the\n\t     * cache key. The `func` is invoked with the `this` binding of the memoized\n\t     * function.\n\t     *\n\t     * **Note:** The cache is exposed as the `cache` property on the memoized\n\t     * function. Its creation may be customized by replacing the `_.memoize.Cache`\n\t     * constructor with one whose instances implement the [`Map`](http://ecma-international.org/ecma-262/6.0/#sec-properties-of-the-map-prototype-object)\n\t     * method interface of `get`, `has`, and `set`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Function\n\t     * @param {Function} func The function to have its output memoized.\n\t     * @param {Function} [resolver] The function to resolve the cache key.\n\t     * @returns {Function} Returns the new memoizing function.\n\t     * @example\n\t     *\n\t     * var upperCase = _.memoize(function(string) {\n\t     *   return string.toUpperCase();\n\t     * });\n\t     *\n\t     * upperCase('fred');\n\t     * // => 'FRED'\n\t     *\n\t     * // modifying the result cache\n\t     * upperCase.cache.set('fred', 'BARNEY');\n\t     * upperCase('fred');\n\t     * // => 'BARNEY'\n\t     *\n\t     * // replacing `_.memoize.Cache`\n\t     * var object = { 'user': 'fred' };\n\t     * var other = { 'user': 'barney' };\n\t     * var identity = _.memoize(_.identity);\n\t     *\n\t     * identity(object);\n\t     * // => { 'user': 'fred' }\n\t     * identity(other);\n\t     * // => { 'user': 'fred' }\n\t     *\n\t     * _.memoize.Cache = WeakMap;\n\t     * var identity = _.memoize(_.identity);\n\t     *\n\t     * identity(object);\n\t     * // => { 'user': 'fred' }\n\t     * identity(other);\n\t     * // => { 'user': 'barney' }\n\t     */\n\t    function memoize(func, resolver) {\n\t      if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {\n\t        throw new TypeError(FUNC_ERROR_TEXT);\n\t      }\n\t      var memoized = function() {\n\t        var args = arguments,\n\t            key = resolver ? resolver.apply(this, args) : args[0],\n\t            cache = memoized.cache;\n\t\n\t        if (cache.has(key)) {\n\t          return cache.get(key);\n\t        }\n\t        var result = func.apply(this, args);\n\t        memoized.cache = cache.set(key, result);\n\t        return result;\n\t      };\n\t      memoized.cache = new memoize.Cache;\n\t      return memoized;\n\t    }\n\t\n\t    /**\n\t     * Creates a function that runs each argument through a corresponding\n\t     * transform function.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Function\n\t     * @param {Function} func The function to wrap.\n\t     * @param {...(Function|Function[])} [transforms] The functions to transform\n\t     * arguments, specified as individual functions or arrays of functions.\n\t     * @returns {Function} Returns the new function.\n\t     * @example\n\t     *\n\t     * function doubled(n) {\n\t     *   return n * 2;\n\t     * }\n\t     *\n\t     * function square(n) {\n\t     *   return n * n;\n\t     * }\n\t     *\n\t     * var modded = _.modArgs(function(x, y) {\n\t     *   return [x, y];\n\t     * }, square, doubled);\n\t     *\n\t     * modded(1, 2);\n\t     * // => [1, 4]\n\t     *\n\t     * modded(5, 10);\n\t     * // => [25, 20]\n\t     */\n\t    var modArgs = restParam(function(func, transforms) {\n\t      transforms = baseFlatten(transforms);\n\t      if (typeof func != 'function' || !arrayEvery(transforms, baseIsFunction)) {\n\t        throw new TypeError(FUNC_ERROR_TEXT);\n\t      }\n\t      var length = transforms.length;\n\t      return restParam(function(args) {\n\t        var index = nativeMin(args.length, length);\n\t        while (index--) {\n\t          args[index] = transforms[index](args[index]);\n\t        }\n\t        return func.apply(this, args);\n\t      });\n\t    });\n\t\n\t    /**\n\t     * Creates a function that negates the result of the predicate `func`. The\n\t     * `func` predicate is invoked with the `this` binding and arguments of the\n\t     * created function.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Function\n\t     * @param {Function} predicate The predicate to negate.\n\t     * @returns {Function} Returns the new function.\n\t     * @example\n\t     *\n\t     * function isEven(n) {\n\t     *   return n % 2 == 0;\n\t     * }\n\t     *\n\t     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));\n\t     * // => [1, 3, 5]\n\t     */\n\t    function negate(predicate) {\n\t      if (typeof predicate != 'function') {\n\t        throw new TypeError(FUNC_ERROR_TEXT);\n\t      }\n\t      return function() {\n\t        return !predicate.apply(this, arguments);\n\t      };\n\t    }\n\t\n\t    /**\n\t     * Creates a function that is restricted to invoking `func` once. Repeat calls\n\t     * to the function return the value of the first call. The `func` is invoked\n\t     * with the `this` binding and arguments of the created function.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Function\n\t     * @param {Function} func The function to restrict.\n\t     * @returns {Function} Returns the new restricted function.\n\t     * @example\n\t     *\n\t     * var initialize = _.once(createApplication);\n\t     * initialize();\n\t     * initialize();\n\t     * // `initialize` invokes `createApplication` once\n\t     */\n\t    function once(func) {\n\t      return before(2, func);\n\t    }\n\t\n\t    /**\n\t     * Creates a function that invokes `func` with `partial` arguments prepended\n\t     * to those provided to the new function. This method is like `_.bind` except\n\t     * it does **not** alter the `this` binding.\n\t     *\n\t     * The `_.partial.placeholder` value, which defaults to `_` in monolithic\n\t     * builds, may be used as a placeholder for partially applied arguments.\n\t     *\n\t     * **Note:** This method does not set the \"length\" property of partially\n\t     * applied functions.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Function\n\t     * @param {Function} func The function to partially apply arguments to.\n\t     * @param {...*} [partials] The arguments to be partially applied.\n\t     * @returns {Function} Returns the new partially applied function.\n\t     * @example\n\t     *\n\t     * var greet = function(greeting, name) {\n\t     *   return greeting + ' ' + name;\n\t     * };\n\t     *\n\t     * var sayHelloTo = _.partial(greet, 'hello');\n\t     * sayHelloTo('fred');\n\t     * // => 'hello fred'\n\t     *\n\t     * // using placeholders\n\t     * var greetFred = _.partial(greet, _, 'fred');\n\t     * greetFred('hi');\n\t     * // => 'hi fred'\n\t     */\n\t    var partial = createPartial(PARTIAL_FLAG);\n\t\n\t    /**\n\t     * This method is like `_.partial` except that partially applied arguments\n\t     * are appended to those provided to the new function.\n\t     *\n\t     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic\n\t     * builds, may be used as a placeholder for partially applied arguments.\n\t     *\n\t     * **Note:** This method does not set the \"length\" property of partially\n\t     * applied functions.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Function\n\t     * @param {Function} func The function to partially apply arguments to.\n\t     * @param {...*} [partials] The arguments to be partially applied.\n\t     * @returns {Function} Returns the new partially applied function.\n\t     * @example\n\t     *\n\t     * var greet = function(greeting, name) {\n\t     *   return greeting + ' ' + name;\n\t     * };\n\t     *\n\t     * var greetFred = _.partialRight(greet, 'fred');\n\t     * greetFred('hi');\n\t     * // => 'hi fred'\n\t     *\n\t     * // using placeholders\n\t     * var sayHelloTo = _.partialRight(greet, 'hello', _);\n\t     * sayHelloTo('fred');\n\t     * // => 'hello fred'\n\t     */\n\t    var partialRight = createPartial(PARTIAL_RIGHT_FLAG);\n\t\n\t    /**\n\t     * Creates a function that invokes `func` with arguments arranged according\n\t     * to the specified indexes where the argument value at the first index is\n\t     * provided as the first argument, the argument value at the second index is\n\t     * provided as the second argument, and so on.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Function\n\t     * @param {Function} func The function to rearrange arguments for.\n\t     * @param {...(number|number[])} indexes The arranged argument indexes,\n\t     *  specified as individual indexes or arrays of indexes.\n\t     * @returns {Function} Returns the new function.\n\t     * @example\n\t     *\n\t     * var rearged = _.rearg(function(a, b, c) {\n\t     *   return [a, b, c];\n\t     * }, 2, 0, 1);\n\t     *\n\t     * rearged('b', 'c', 'a')\n\t     * // => ['a', 'b', 'c']\n\t     *\n\t     * var map = _.rearg(_.map, [1, 0]);\n\t     * map(function(n) {\n\t     *   return n * 3;\n\t     * }, [1, 2, 3]);\n\t     * // => [3, 6, 9]\n\t     */\n\t    var rearg = restParam(function(func, indexes) {\n\t      return createWrapper(func, REARG_FLAG, undefined, undefined, undefined, baseFlatten(indexes));\n\t    });\n\t\n\t    /**\n\t     * Creates a function that invokes `func` with the `this` binding of the\n\t     * created function and arguments from `start` and beyond provided as an array.\n\t     *\n\t     * **Note:** This method is based on the [rest parameter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Function\n\t     * @param {Function} func The function to apply a rest parameter to.\n\t     * @param {number} [start=func.length-1] The start position of the rest parameter.\n\t     * @returns {Function} Returns the new function.\n\t     * @example\n\t     *\n\t     * var say = _.restParam(function(what, names) {\n\t     *   return what + ' ' + _.initial(names).join(', ') +\n\t     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);\n\t     * });\n\t     *\n\t     * say('hello', 'fred', 'barney', 'pebbles');\n\t     * // => 'hello fred, barney, & pebbles'\n\t     */\n\t    function restParam(func, start) {\n\t      if (typeof func != 'function') {\n\t        throw new TypeError(FUNC_ERROR_TEXT);\n\t      }\n\t      start = nativeMax(start === undefined ? (func.length - 1) : (+start || 0), 0);\n\t      return function() {\n\t        var args = arguments,\n\t            index = -1,\n\t            length = nativeMax(args.length - start, 0),\n\t            rest = Array(length);\n\t\n\t        while (++index < length) {\n\t          rest[index] = args[start + index];\n\t        }\n\t        switch (start) {\n\t          case 0: return func.call(this, rest);\n\t          case 1: return func.call(this, args[0], rest);\n\t          case 2: return func.call(this, args[0], args[1], rest);\n\t        }\n\t        var otherArgs = Array(start + 1);\n\t        index = -1;\n\t        while (++index < start) {\n\t          otherArgs[index] = args[index];\n\t        }\n\t        otherArgs[start] = rest;\n\t        return func.apply(this, otherArgs);\n\t      };\n\t    }\n\t\n\t    /**\n\t     * Creates a function that invokes `func` with the `this` binding of the created\n\t     * function and an array of arguments much like [`Function#apply`](https://es5.github.io/#x15.3.4.3).\n\t     *\n\t     * **Note:** This method is based on the [spread operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Function\n\t     * @param {Function} func The function to spread arguments over.\n\t     * @returns {Function} Returns the new function.\n\t     * @example\n\t     *\n\t     * var say = _.spread(function(who, what) {\n\t     *   return who + ' says ' + what;\n\t     * });\n\t     *\n\t     * say(['fred', 'hello']);\n\t     * // => 'fred says hello'\n\t     *\n\t     * // with a Promise\n\t     * var numbers = Promise.all([\n\t     *   Promise.resolve(40),\n\t     *   Promise.resolve(36)\n\t     * ]);\n\t     *\n\t     * numbers.then(_.spread(function(x, y) {\n\t     *   return x + y;\n\t     * }));\n\t     * // => a Promise of 76\n\t     */\n\t    function spread(func) {\n\t      if (typeof func != 'function') {\n\t        throw new TypeError(FUNC_ERROR_TEXT);\n\t      }\n\t      return function(array) {\n\t        return func.apply(this, array);\n\t      };\n\t    }\n\t\n\t    /**\n\t     * Creates a throttled function that only invokes `func` at most once per\n\t     * every `wait` milliseconds. The throttled function comes with a `cancel`\n\t     * method to cancel delayed invocations. Provide an options object to indicate\n\t     * that `func` should be invoked on the leading and/or trailing edge of the\n\t     * `wait` timeout. Subsequent calls to the throttled function return the\n\t     * result of the last `func` call.\n\t     *\n\t     * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked\n\t     * on the trailing edge of the timeout only if the the throttled function is\n\t     * invoked more than once during the `wait` timeout.\n\t     *\n\t     * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)\n\t     * for details over the differences between `_.throttle` and `_.debounce`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Function\n\t     * @param {Function} func The function to throttle.\n\t     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.\n\t     * @param {Object} [options] The options object.\n\t     * @param {boolean} [options.leading=true] Specify invoking on the leading\n\t     *  edge of the timeout.\n\t     * @param {boolean} [options.trailing=true] Specify invoking on the trailing\n\t     *  edge of the timeout.\n\t     * @returns {Function} Returns the new throttled function.\n\t     * @example\n\t     *\n\t     * // avoid excessively updating the position while scrolling\n\t     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));\n\t     *\n\t     * // invoke `renewToken` when the click event is fired, but not more than once every 5 minutes\n\t     * jQuery('.interactive').on('click', _.throttle(renewToken, 300000, {\n\t     *   'trailing': false\n\t     * }));\n\t     *\n\t     * // cancel a trailing throttled call\n\t     * jQuery(window).on('popstate', throttled.cancel);\n\t     */\n\t    function throttle(func, wait, options) {\n\t      var leading = true,\n\t          trailing = true;\n\t\n\t      if (typeof func != 'function') {\n\t        throw new TypeError(FUNC_ERROR_TEXT);\n\t      }\n\t      if (options === false) {\n\t        leading = false;\n\t      } else if (isObject(options)) {\n\t        leading = 'leading' in options ? !!options.leading : leading;\n\t        trailing = 'trailing' in options ? !!options.trailing : trailing;\n\t      }\n\t      return debounce(func, wait, { 'leading': leading, 'maxWait': +wait, 'trailing': trailing });\n\t    }\n\t\n\t    /**\n\t     * Creates a function that provides `value` to the wrapper function as its\n\t     * first argument. Any additional arguments provided to the function are\n\t     * appended to those provided to the wrapper function. The wrapper is invoked\n\t     * with the `this` binding of the created function.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Function\n\t     * @param {*} value The value to wrap.\n\t     * @param {Function} wrapper The wrapper function.\n\t     * @returns {Function} Returns the new function.\n\t     * @example\n\t     *\n\t     * var p = _.wrap(_.escape, function(func, text) {\n\t     *   return '<p>' + func(text) + '</p>';\n\t     * });\n\t     *\n\t     * p('fred, barney, & pebbles');\n\t     * // => '<p>fred, barney, &amp; pebbles</p>'\n\t     */\n\t    function wrap(value, wrapper) {\n\t      wrapper = wrapper == null ? identity : wrapper;\n\t      return createWrapper(wrapper, PARTIAL_FLAG, undefined, [value], []);\n\t    }\n\t\n\t    /*------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * Creates a clone of `value`. If `isDeep` is `true` nested objects are cloned,\n\t     * otherwise they are assigned by reference. If `customizer` is provided it is\n\t     * invoked to produce the cloned values. If `customizer` returns `undefined`\n\t     * cloning is handled by the method instead. The `customizer` is bound to\n\t     * `thisArg` and invoked with two argument; (value [, index|key, object]).\n\t     *\n\t     * **Note:** This method is loosely based on the\n\t     * [structured clone algorithm](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm).\n\t     * The enumerable properties of `arguments` objects and objects created by\n\t     * constructors other than `Object` are cloned to plain `Object` objects. An\n\t     * empty object is returned for uncloneable values such as functions, DOM nodes,\n\t     * Maps, Sets, and WeakMaps.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Lang\n\t     * @param {*} value The value to clone.\n\t     * @param {boolean} [isDeep] Specify a deep clone.\n\t     * @param {Function} [customizer] The function to customize cloning values.\n\t     * @param {*} [thisArg] The `this` binding of `customizer`.\n\t     * @returns {*} Returns the cloned value.\n\t     * @example\n\t     *\n\t     * var users = [\n\t     *   { 'user': 'barney' },\n\t     *   { 'user': 'fred' }\n\t     * ];\n\t     *\n\t     * var shallow = _.clone(users);\n\t     * shallow[0] === users[0];\n\t     * // => true\n\t     *\n\t     * var deep = _.clone(users, true);\n\t     * deep[0] === users[0];\n\t     * // => false\n\t     *\n\t     * // using a customizer callback\n\t     * var el = _.clone(document.body, function(value) {\n\t     *   if (_.isElement(value)) {\n\t     *     return value.cloneNode(false);\n\t     *   }\n\t     * });\n\t     *\n\t     * el === document.body\n\t     * // => false\n\t     * el.nodeName\n\t     * // => BODY\n\t     * el.childNodes.length;\n\t     * // => 0\n\t     */\n\t    function clone(value, isDeep, customizer, thisArg) {\n\t      if (isDeep && typeof isDeep != 'boolean' && isIterateeCall(value, isDeep, customizer)) {\n\t        isDeep = false;\n\t      }\n\t      else if (typeof isDeep == 'function') {\n\t        thisArg = customizer;\n\t        customizer = isDeep;\n\t        isDeep = false;\n\t      }\n\t      return typeof customizer == 'function'\n\t        ? baseClone(value, isDeep, bindCallback(customizer, thisArg, 1))\n\t        : baseClone(value, isDeep);\n\t    }\n\t\n\t    /**\n\t     * Creates a deep clone of `value`. If `customizer` is provided it is invoked\n\t     * to produce the cloned values. If `customizer` returns `undefined` cloning\n\t     * is handled by the method instead. The `customizer` is bound to `thisArg`\n\t     * and invoked with two argument; (value [, index|key, object]).\n\t     *\n\t     * **Note:** This method is loosely based on the\n\t     * [structured clone algorithm](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm).\n\t     * The enumerable properties of `arguments` objects and objects created by\n\t     * constructors other than `Object` are cloned to plain `Object` objects. An\n\t     * empty object is returned for uncloneable values such as functions, DOM nodes,\n\t     * Maps, Sets, and WeakMaps.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Lang\n\t     * @param {*} value The value to deep clone.\n\t     * @param {Function} [customizer] The function to customize cloning values.\n\t     * @param {*} [thisArg] The `this` binding of `customizer`.\n\t     * @returns {*} Returns the deep cloned value.\n\t     * @example\n\t     *\n\t     * var users = [\n\t     *   { 'user': 'barney' },\n\t     *   { 'user': 'fred' }\n\t     * ];\n\t     *\n\t     * var deep = _.cloneDeep(users);\n\t     * deep[0] === users[0];\n\t     * // => false\n\t     *\n\t     * // using a customizer callback\n\t     * var el = _.cloneDeep(document.body, function(value) {\n\t     *   if (_.isElement(value)) {\n\t     *     return value.cloneNode(true);\n\t     *   }\n\t     * });\n\t     *\n\t     * el === document.body\n\t     * // => false\n\t     * el.nodeName\n\t     * // => BODY\n\t     * el.childNodes.length;\n\t     * // => 20\n\t     */\n\t    function cloneDeep(value, customizer, thisArg) {\n\t      return typeof customizer == 'function'\n\t        ? baseClone(value, true, bindCallback(customizer, thisArg, 1))\n\t        : baseClone(value, true);\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is greater than `other`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Lang\n\t     * @param {*} value The value to compare.\n\t     * @param {*} other The other value to compare.\n\t     * @returns {boolean} Returns `true` if `value` is greater than `other`, else `false`.\n\t     * @example\n\t     *\n\t     * _.gt(3, 1);\n\t     * // => true\n\t     *\n\t     * _.gt(3, 3);\n\t     * // => false\n\t     *\n\t     * _.gt(1, 3);\n\t     * // => false\n\t     */\n\t    function gt(value, other) {\n\t      return value > other;\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is greater than or equal to `other`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Lang\n\t     * @param {*} value The value to compare.\n\t     * @param {*} other The other value to compare.\n\t     * @returns {boolean} Returns `true` if `value` is greater than or equal to `other`, else `false`.\n\t     * @example\n\t     *\n\t     * _.gte(3, 1);\n\t     * // => true\n\t     *\n\t     * _.gte(3, 3);\n\t     * // => true\n\t     *\n\t     * _.gte(1, 3);\n\t     * // => false\n\t     */\n\t    function gte(value, other) {\n\t      return value >= other;\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is classified as an `arguments` object.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Lang\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n\t     * @example\n\t     *\n\t     * _.isArguments(function() { return arguments; }());\n\t     * // => true\n\t     *\n\t     * _.isArguments([1, 2, 3]);\n\t     * // => false\n\t     */\n\t    function isArguments(value) {\n\t      return isObjectLike(value) && isArrayLike(value) &&\n\t        hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is classified as an `Array` object.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Lang\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n\t     * @example\n\t     *\n\t     * _.isArray([1, 2, 3]);\n\t     * // => true\n\t     *\n\t     * _.isArray(function() { return arguments; }());\n\t     * // => false\n\t     */\n\t    var isArray = nativeIsArray || function(value) {\n\t      return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag;\n\t    };\n\t\n\t    /**\n\t     * Checks if `value` is classified as a boolean primitive or object.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Lang\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n\t     * @example\n\t     *\n\t     * _.isBoolean(false);\n\t     * // => true\n\t     *\n\t     * _.isBoolean(null);\n\t     * // => false\n\t     */\n\t    function isBoolean(value) {\n\t      return value === true || value === false || (isObjectLike(value) && objToString.call(value) == boolTag);\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is classified as a `Date` object.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Lang\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n\t     * @example\n\t     *\n\t     * _.isDate(new Date);\n\t     * // => true\n\t     *\n\t     * _.isDate('Mon April 23 2012');\n\t     * // => false\n\t     */\n\t    function isDate(value) {\n\t      return isObjectLike(value) && objToString.call(value) == dateTag;\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is a DOM element.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Lang\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.\n\t     * @example\n\t     *\n\t     * _.isElement(document.body);\n\t     * // => true\n\t     *\n\t     * _.isElement('<body>');\n\t     * // => false\n\t     */\n\t    function isElement(value) {\n\t      return !!value && value.nodeType === 1 && isObjectLike(value) && !isPlainObject(value);\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is empty. A value is considered empty unless it is an\n\t     * `arguments` object, array, string, or jQuery-like collection with a length\n\t     * greater than `0` or an object with own enumerable properties.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Lang\n\t     * @param {Array|Object|string} value The value to inspect.\n\t     * @returns {boolean} Returns `true` if `value` is empty, else `false`.\n\t     * @example\n\t     *\n\t     * _.isEmpty(null);\n\t     * // => true\n\t     *\n\t     * _.isEmpty(true);\n\t     * // => true\n\t     *\n\t     * _.isEmpty(1);\n\t     * // => true\n\t     *\n\t     * _.isEmpty([1, 2, 3]);\n\t     * // => false\n\t     *\n\t     * _.isEmpty({ 'a': 1 });\n\t     * // => false\n\t     */\n\t    function isEmpty(value) {\n\t      if (value == null) {\n\t        return true;\n\t      }\n\t      if (isArrayLike(value) && (isArray(value) || isString(value) || isArguments(value) ||\n\t          (isObjectLike(value) && isFunction(value.splice)))) {\n\t        return !value.length;\n\t      }\n\t      return !keys(value).length;\n\t    }\n\t\n\t    /**\n\t     * Performs a deep comparison between two values to determine if they are\n\t     * equivalent. If `customizer` is provided it is invoked to compare values.\n\t     * If `customizer` returns `undefined` comparisons are handled by the method\n\t     * instead. The `customizer` is bound to `thisArg` and invoked with three\n\t     * arguments: (value, other [, index|key]).\n\t     *\n\t     * **Note:** This method supports comparing arrays, booleans, `Date` objects,\n\t     * numbers, `Object` objects, regexes, and strings. Objects are compared by\n\t     * their own, not inherited, enumerable properties. Functions and DOM nodes\n\t     * are **not** supported. Provide a customizer function to extend support\n\t     * for comparing other values.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @alias eq\n\t     * @category Lang\n\t     * @param {*} value The value to compare.\n\t     * @param {*} other The other value to compare.\n\t     * @param {Function} [customizer] The function to customize value comparisons.\n\t     * @param {*} [thisArg] The `this` binding of `customizer`.\n\t     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n\t     * @example\n\t     *\n\t     * var object = { 'user': 'fred' };\n\t     * var other = { 'user': 'fred' };\n\t     *\n\t     * object == other;\n\t     * // => false\n\t     *\n\t     * _.isEqual(object, other);\n\t     * // => true\n\t     *\n\t     * // using a customizer callback\n\t     * var array = ['hello', 'goodbye'];\n\t     * var other = ['hi', 'goodbye'];\n\t     *\n\t     * _.isEqual(array, other, function(value, other) {\n\t     *   if (_.every([value, other], RegExp.prototype.test, /^h(?:i|ello)$/)) {\n\t     *     return true;\n\t     *   }\n\t     * });\n\t     * // => true\n\t     */\n\t    function isEqual(value, other, customizer, thisArg) {\n\t      customizer = typeof customizer == 'function' ? bindCallback(customizer, thisArg, 3) : undefined;\n\t      var result = customizer ? customizer(value, other) : undefined;\n\t      return  result === undefined ? baseIsEqual(value, other, customizer) : !!result;\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,\n\t     * `SyntaxError`, `TypeError`, or `URIError` object.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Lang\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.\n\t     * @example\n\t     *\n\t     * _.isError(new Error);\n\t     * // => true\n\t     *\n\t     * _.isError(Error);\n\t     * // => false\n\t     */\n\t    function isError(value) {\n\t      return isObjectLike(value) && typeof value.message == 'string' && objToString.call(value) == errorTag;\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is a finite primitive number.\n\t     *\n\t     * **Note:** This method is based on [`Number.isFinite`](http://ecma-international.org/ecma-262/6.0/#sec-number.isfinite).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Lang\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.\n\t     * @example\n\t     *\n\t     * _.isFinite(10);\n\t     * // => true\n\t     *\n\t     * _.isFinite('10');\n\t     * // => false\n\t     *\n\t     * _.isFinite(true);\n\t     * // => false\n\t     *\n\t     * _.isFinite(Object(10));\n\t     * // => false\n\t     *\n\t     * _.isFinite(Infinity);\n\t     * // => false\n\t     */\n\t    function isFinite(value) {\n\t      return typeof value == 'number' && nativeIsFinite(value);\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is classified as a `Function` object.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Lang\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n\t     * @example\n\t     *\n\t     * _.isFunction(_);\n\t     * // => true\n\t     *\n\t     * _.isFunction(/abc/);\n\t     * // => false\n\t     */\n\t    function isFunction(value) {\n\t      // The use of `Object#toString` avoids issues with the `typeof` operator\n\t      // in older versions of Chrome and Safari which return 'function' for regexes\n\t      // and Safari 8 equivalents which return 'object' for typed array constructors.\n\t      return isObject(value) && objToString.call(value) == funcTag;\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.\n\t     * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Lang\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n\t     * @example\n\t     *\n\t     * _.isObject({});\n\t     * // => true\n\t     *\n\t     * _.isObject([1, 2, 3]);\n\t     * // => true\n\t     *\n\t     * _.isObject(1);\n\t     * // => false\n\t     */\n\t    function isObject(value) {\n\t      // Avoid a V8 JIT bug in Chrome 19-20.\n\t      // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n\t      var type = typeof value;\n\t      return !!value && (type == 'object' || type == 'function');\n\t    }\n\t\n\t    /**\n\t     * Performs a deep comparison between `object` and `source` to determine if\n\t     * `object` contains equivalent property values. If `customizer` is provided\n\t     * it is invoked to compare values. If `customizer` returns `undefined`\n\t     * comparisons are handled by the method instead. The `customizer` is bound\n\t     * to `thisArg` and invoked with three arguments: (value, other, index|key).\n\t     *\n\t     * **Note:** This method supports comparing properties of arrays, booleans,\n\t     * `Date` objects, numbers, `Object` objects, regexes, and strings. Functions\n\t     * and DOM nodes are **not** supported. Provide a customizer function to extend\n\t     * support for comparing other values.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Lang\n\t     * @param {Object} object The object to inspect.\n\t     * @param {Object} source The object of property values to match.\n\t     * @param {Function} [customizer] The function to customize value comparisons.\n\t     * @param {*} [thisArg] The `this` binding of `customizer`.\n\t     * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n\t     * @example\n\t     *\n\t     * var object = { 'user': 'fred', 'age': 40 };\n\t     *\n\t     * _.isMatch(object, { 'age': 40 });\n\t     * // => true\n\t     *\n\t     * _.isMatch(object, { 'age': 36 });\n\t     * // => false\n\t     *\n\t     * // using a customizer callback\n\t     * var object = { 'greeting': 'hello' };\n\t     * var source = { 'greeting': 'hi' };\n\t     *\n\t     * _.isMatch(object, source, function(value, other) {\n\t     *   return _.every([value, other], RegExp.prototype.test, /^h(?:i|ello)$/) || undefined;\n\t     * });\n\t     * // => true\n\t     */\n\t    function isMatch(object, source, customizer, thisArg) {\n\t      customizer = typeof customizer == 'function' ? bindCallback(customizer, thisArg, 3) : undefined;\n\t      return baseIsMatch(object, getMatchData(source), customizer);\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is `NaN`.\n\t     *\n\t     * **Note:** This method is not the same as [`isNaN`](https://es5.github.io/#x15.1.2.4)\n\t     * which returns `true` for `undefined` and other non-numeric values.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Lang\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.\n\t     * @example\n\t     *\n\t     * _.isNaN(NaN);\n\t     * // => true\n\t     *\n\t     * _.isNaN(new Number(NaN));\n\t     * // => true\n\t     *\n\t     * isNaN(undefined);\n\t     * // => true\n\t     *\n\t     * _.isNaN(undefined);\n\t     * // => false\n\t     */\n\t    function isNaN(value) {\n\t      // An `NaN` primitive is the only value that is not equal to itself.\n\t      // Perform the `toStringTag` check first to avoid errors with some host objects in IE.\n\t      return isNumber(value) && value != +value;\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is a native function.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Lang\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is a native function, else `false`.\n\t     * @example\n\t     *\n\t     * _.isNative(Array.prototype.push);\n\t     * // => true\n\t     *\n\t     * _.isNative(_);\n\t     * // => false\n\t     */\n\t    function isNative(value) {\n\t      if (value == null) {\n\t        return false;\n\t      }\n\t      if (isFunction(value)) {\n\t        return reIsNative.test(fnToString.call(value));\n\t      }\n\t      return isObjectLike(value) && reIsHostCtor.test(value);\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is `null`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Lang\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.\n\t     * @example\n\t     *\n\t     * _.isNull(null);\n\t     * // => true\n\t     *\n\t     * _.isNull(void 0);\n\t     * // => false\n\t     */\n\t    function isNull(value) {\n\t      return value === null;\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is classified as a `Number` primitive or object.\n\t     *\n\t     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are classified\n\t     * as numbers, use the `_.isFinite` method.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Lang\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n\t     * @example\n\t     *\n\t     * _.isNumber(8.4);\n\t     * // => true\n\t     *\n\t     * _.isNumber(NaN);\n\t     * // => true\n\t     *\n\t     * _.isNumber('8.4');\n\t     * // => false\n\t     */\n\t    function isNumber(value) {\n\t      return typeof value == 'number' || (isObjectLike(value) && objToString.call(value) == numberTag);\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is a plain object, that is, an object created by the\n\t     * `Object` constructor or one with a `[[Prototype]]` of `null`.\n\t     *\n\t     * **Note:** This method assumes objects created by the `Object` constructor\n\t     * have no inherited enumerable properties.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Lang\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n\t     * @example\n\t     *\n\t     * function Foo() {\n\t     *   this.a = 1;\n\t     * }\n\t     *\n\t     * _.isPlainObject(new Foo);\n\t     * // => false\n\t     *\n\t     * _.isPlainObject([1, 2, 3]);\n\t     * // => false\n\t     *\n\t     * _.isPlainObject({ 'x': 0, 'y': 0 });\n\t     * // => true\n\t     *\n\t     * _.isPlainObject(Object.create(null));\n\t     * // => true\n\t     */\n\t    function isPlainObject(value) {\n\t      var Ctor;\n\t\n\t      // Exit early for non `Object` objects.\n\t      if (!(isObjectLike(value) && objToString.call(value) == objectTag && !isArguments(value)) ||\n\t          (!hasOwnProperty.call(value, 'constructor') && (Ctor = value.constructor, typeof Ctor == 'function' && !(Ctor instanceof Ctor)))) {\n\t        return false;\n\t      }\n\t      // IE < 9 iterates inherited properties before own properties. If the first\n\t      // iterated property is an object's own property then there are no inherited\n\t      // enumerable properties.\n\t      var result;\n\t      // In most environments an object's own properties are iterated before\n\t      // its inherited properties. If the last iterated property is an object's\n\t      // own property then there are no inherited enumerable properties.\n\t      baseForIn(value, function(subValue, key) {\n\t        result = key;\n\t      });\n\t      return result === undefined || hasOwnProperty.call(value, result);\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is classified as a `RegExp` object.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Lang\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n\t     * @example\n\t     *\n\t     * _.isRegExp(/abc/);\n\t     * // => true\n\t     *\n\t     * _.isRegExp('/abc/');\n\t     * // => false\n\t     */\n\t    function isRegExp(value) {\n\t      return isObject(value) && objToString.call(value) == regexpTag;\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is classified as a `String` primitive or object.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Lang\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n\t     * @example\n\t     *\n\t     * _.isString('abc');\n\t     * // => true\n\t     *\n\t     * _.isString(1);\n\t     * // => false\n\t     */\n\t    function isString(value) {\n\t      return typeof value == 'string' || (isObjectLike(value) && objToString.call(value) == stringTag);\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is classified as a typed array.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Lang\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n\t     * @example\n\t     *\n\t     * _.isTypedArray(new Uint8Array);\n\t     * // => true\n\t     *\n\t     * _.isTypedArray([]);\n\t     * // => false\n\t     */\n\t    function isTypedArray(value) {\n\t      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objToString.call(value)];\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is `undefined`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Lang\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.\n\t     * @example\n\t     *\n\t     * _.isUndefined(void 0);\n\t     * // => true\n\t     *\n\t     * _.isUndefined(null);\n\t     * // => false\n\t     */\n\t    function isUndefined(value) {\n\t      return value === undefined;\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is less than `other`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Lang\n\t     * @param {*} value The value to compare.\n\t     * @param {*} other The other value to compare.\n\t     * @returns {boolean} Returns `true` if `value` is less than `other`, else `false`.\n\t     * @example\n\t     *\n\t     * _.lt(1, 3);\n\t     * // => true\n\t     *\n\t     * _.lt(3, 3);\n\t     * // => false\n\t     *\n\t     * _.lt(3, 1);\n\t     * // => false\n\t     */\n\t    function lt(value, other) {\n\t      return value < other;\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is less than or equal to `other`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Lang\n\t     * @param {*} value The value to compare.\n\t     * @param {*} other The other value to compare.\n\t     * @returns {boolean} Returns `true` if `value` is less than or equal to `other`, else `false`.\n\t     * @example\n\t     *\n\t     * _.lte(1, 3);\n\t     * // => true\n\t     *\n\t     * _.lte(3, 3);\n\t     * // => true\n\t     *\n\t     * _.lte(3, 1);\n\t     * // => false\n\t     */\n\t    function lte(value, other) {\n\t      return value <= other;\n\t    }\n\t\n\t    /**\n\t     * Converts `value` to an array.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Lang\n\t     * @param {*} value The value to convert.\n\t     * @returns {Array} Returns the converted array.\n\t     * @example\n\t     *\n\t     * (function() {\n\t     *   return _.toArray(arguments).slice(1);\n\t     * }(1, 2, 3));\n\t     * // => [2, 3]\n\t     */\n\t    function toArray(value) {\n\t      var length = value ? getLength(value) : 0;\n\t      if (!isLength(length)) {\n\t        return values(value);\n\t      }\n\t      if (!length) {\n\t        return [];\n\t      }\n\t      return arrayCopy(value);\n\t    }\n\t\n\t    /**\n\t     * Converts `value` to a plain object flattening inherited enumerable\n\t     * properties of `value` to own properties of the plain object.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Lang\n\t     * @param {*} value The value to convert.\n\t     * @returns {Object} Returns the converted plain object.\n\t     * @example\n\t     *\n\t     * function Foo() {\n\t     *   this.b = 2;\n\t     * }\n\t     *\n\t     * Foo.prototype.c = 3;\n\t     *\n\t     * _.assign({ 'a': 1 }, new Foo);\n\t     * // => { 'a': 1, 'b': 2 }\n\t     *\n\t     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));\n\t     * // => { 'a': 1, 'b': 2, 'c': 3 }\n\t     */\n\t    function toPlainObject(value) {\n\t      return baseCopy(value, keysIn(value));\n\t    }\n\t\n\t    /*------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * Recursively merges own enumerable properties of the source object(s), that\n\t     * don't resolve to `undefined` into the destination object. Subsequent sources\n\t     * overwrite property assignments of previous sources. If `customizer` is\n\t     * provided it is invoked to produce the merged values of the destination and\n\t     * source properties. If `customizer` returns `undefined` merging is handled\n\t     * by the method instead. The `customizer` is bound to `thisArg` and invoked\n\t     * with five arguments: (objectValue, sourceValue, key, object, source).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Object\n\t     * @param {Object} object The destination object.\n\t     * @param {...Object} [sources] The source objects.\n\t     * @param {Function} [customizer] The function to customize assigned values.\n\t     * @param {*} [thisArg] The `this` binding of `customizer`.\n\t     * @returns {Object} Returns `object`.\n\t     * @example\n\t     *\n\t     * var users = {\n\t     *   'data': [{ 'user': 'barney' }, { 'user': 'fred' }]\n\t     * };\n\t     *\n\t     * var ages = {\n\t     *   'data': [{ 'age': 36 }, { 'age': 40 }]\n\t     * };\n\t     *\n\t     * _.merge(users, ages);\n\t     * // => { 'data': [{ 'user': 'barney', 'age': 36 }, { 'user': 'fred', 'age': 40 }] }\n\t     *\n\t     * // using a customizer callback\n\t     * var object = {\n\t     *   'fruits': ['apple'],\n\t     *   'vegetables': ['beet']\n\t     * };\n\t     *\n\t     * var other = {\n\t     *   'fruits': ['banana'],\n\t     *   'vegetables': ['carrot']\n\t     * };\n\t     *\n\t     * _.merge(object, other, function(a, b) {\n\t     *   if (_.isArray(a)) {\n\t     *     return a.concat(b);\n\t     *   }\n\t     * });\n\t     * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot'] }\n\t     */\n\t    var merge = createAssigner(baseMerge);\n\t\n\t    /**\n\t     * Assigns own enumerable properties of source object(s) to the destination\n\t     * object. Subsequent sources overwrite property assignments of previous sources.\n\t     * If `customizer` is provided it is invoked to produce the assigned values.\n\t     * The `customizer` is bound to `thisArg` and invoked with five arguments:\n\t     * (objectValue, sourceValue, key, object, source).\n\t     *\n\t     * **Note:** This method mutates `object` and is based on\n\t     * [`Object.assign`](http://ecma-international.org/ecma-262/6.0/#sec-object.assign).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @alias extend\n\t     * @category Object\n\t     * @param {Object} object The destination object.\n\t     * @param {...Object} [sources] The source objects.\n\t     * @param {Function} [customizer] The function to customize assigned values.\n\t     * @param {*} [thisArg] The `this` binding of `customizer`.\n\t     * @returns {Object} Returns `object`.\n\t     * @example\n\t     *\n\t     * _.assign({ 'user': 'barney' }, { 'age': 40 }, { 'user': 'fred' });\n\t     * // => { 'user': 'fred', 'age': 40 }\n\t     *\n\t     * // using a customizer callback\n\t     * var defaults = _.partialRight(_.assign, function(value, other) {\n\t     *   return _.isUndefined(value) ? other : value;\n\t     * });\n\t     *\n\t     * defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });\n\t     * // => { 'user': 'barney', 'age': 36 }\n\t     */\n\t    var assign = createAssigner(function(object, source, customizer) {\n\t      return customizer\n\t        ? assignWith(object, source, customizer)\n\t        : baseAssign(object, source);\n\t    });\n\t\n\t    /**\n\t     * Creates an object that inherits from the given `prototype` object. If a\n\t     * `properties` object is provided its own enumerable properties are assigned\n\t     * to the created object.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Object\n\t     * @param {Object} prototype The object to inherit from.\n\t     * @param {Object} [properties] The properties to assign to the object.\n\t     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n\t     * @returns {Object} Returns the new object.\n\t     * @example\n\t     *\n\t     * function Shape() {\n\t     *   this.x = 0;\n\t     *   this.y = 0;\n\t     * }\n\t     *\n\t     * function Circle() {\n\t     *   Shape.call(this);\n\t     * }\n\t     *\n\t     * Circle.prototype = _.create(Shape.prototype, {\n\t     *   'constructor': Circle\n\t     * });\n\t     *\n\t     * var circle = new Circle;\n\t     * circle instanceof Circle;\n\t     * // => true\n\t     *\n\t     * circle instanceof Shape;\n\t     * // => true\n\t     */\n\t    function create(prototype, properties, guard) {\n\t      var result = baseCreate(prototype);\n\t      if (guard && isIterateeCall(prototype, properties, guard)) {\n\t        properties = undefined;\n\t      }\n\t      return properties ? baseAssign(result, properties) : result;\n\t    }\n\t\n\t    /**\n\t     * Assigns own enumerable properties of source object(s) to the destination\n\t     * object for all destination properties that resolve to `undefined`. Once a\n\t     * property is set, additional values of the same property are ignored.\n\t     *\n\t     * **Note:** This method mutates `object`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Object\n\t     * @param {Object} object The destination object.\n\t     * @param {...Object} [sources] The source objects.\n\t     * @returns {Object} Returns `object`.\n\t     * @example\n\t     *\n\t     * _.defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });\n\t     * // => { 'user': 'barney', 'age': 36 }\n\t     */\n\t    var defaults = createDefaults(assign, assignDefaults);\n\t\n\t    /**\n\t     * This method is like `_.defaults` except that it recursively assigns\n\t     * default properties.\n\t     *\n\t     * **Note:** This method mutates `object`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Object\n\t     * @param {Object} object The destination object.\n\t     * @param {...Object} [sources] The source objects.\n\t     * @returns {Object} Returns `object`.\n\t     * @example\n\t     *\n\t     * _.defaultsDeep({ 'user': { 'name': 'barney' } }, { 'user': { 'name': 'fred', 'age': 36 } });\n\t     * // => { 'user': { 'name': 'barney', 'age': 36 } }\n\t     *\n\t     */\n\t    var defaultsDeep = createDefaults(merge, mergeDefaults);\n\t\n\t    /**\n\t     * This method is like `_.find` except that it returns the key of the first\n\t     * element `predicate` returns truthy for instead of the element itself.\n\t     *\n\t     * If a property name is provided for `predicate` the created `_.property`\n\t     * style callback returns the property value of the given element.\n\t     *\n\t     * If a value is also provided for `thisArg` the created `_.matchesProperty`\n\t     * style callback returns `true` for elements that have a matching property\n\t     * value, else `false`.\n\t     *\n\t     * If an object is provided for `predicate` the created `_.matches` style\n\t     * callback returns `true` for elements that have the properties of the given\n\t     * object, else `false`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Object\n\t     * @param {Object} object The object to search.\n\t     * @param {Function|Object|string} [predicate=_.identity] The function invoked\n\t     *  per iteration.\n\t     * @param {*} [thisArg] The `this` binding of `predicate`.\n\t     * @returns {string|undefined} Returns the key of the matched element, else `undefined`.\n\t     * @example\n\t     *\n\t     * var users = {\n\t     *   'barney':  { 'age': 36, 'active': true },\n\t     *   'fred':    { 'age': 40, 'active': false },\n\t     *   'pebbles': { 'age': 1,  'active': true }\n\t     * };\n\t     *\n\t     * _.findKey(users, function(chr) {\n\t     *   return chr.age < 40;\n\t     * });\n\t     * // => 'barney' (iteration order is not guaranteed)\n\t     *\n\t     * // using the `_.matches` callback shorthand\n\t     * _.findKey(users, { 'age': 1, 'active': true });\n\t     * // => 'pebbles'\n\t     *\n\t     * // using the `_.matchesProperty` callback shorthand\n\t     * _.findKey(users, 'active', false);\n\t     * // => 'fred'\n\t     *\n\t     * // using the `_.property` callback shorthand\n\t     * _.findKey(users, 'active');\n\t     * // => 'barney'\n\t     */\n\t    var findKey = createFindKey(baseForOwn);\n\t\n\t    /**\n\t     * This method is like `_.findKey` except that it iterates over elements of\n\t     * a collection in the opposite order.\n\t     *\n\t     * If a property name is provided for `predicate` the created `_.property`\n\t     * style callback returns the property value of the given element.\n\t     *\n\t     * If a value is also provided for `thisArg` the created `_.matchesProperty`\n\t     * style callback returns `true` for elements that have a matching property\n\t     * value, else `false`.\n\t     *\n\t     * If an object is provided for `predicate` the created `_.matches` style\n\t     * callback returns `true` for elements that have the properties of the given\n\t     * object, else `false`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Object\n\t     * @param {Object} object The object to search.\n\t     * @param {Function|Object|string} [predicate=_.identity] The function invoked\n\t     *  per iteration.\n\t     * @param {*} [thisArg] The `this` binding of `predicate`.\n\t     * @returns {string|undefined} Returns the key of the matched element, else `undefined`.\n\t     * @example\n\t     *\n\t     * var users = {\n\t     *   'barney':  { 'age': 36, 'active': true },\n\t     *   'fred':    { 'age': 40, 'active': false },\n\t     *   'pebbles': { 'age': 1,  'active': true }\n\t     * };\n\t     *\n\t     * _.findLastKey(users, function(chr) {\n\t     *   return chr.age < 40;\n\t     * });\n\t     * // => returns `pebbles` assuming `_.findKey` returns `barney`\n\t     *\n\t     * // using the `_.matches` callback shorthand\n\t     * _.findLastKey(users, { 'age': 36, 'active': true });\n\t     * // => 'barney'\n\t     *\n\t     * // using the `_.matchesProperty` callback shorthand\n\t     * _.findLastKey(users, 'active', false);\n\t     * // => 'fred'\n\t     *\n\t     * // using the `_.property` callback shorthand\n\t     * _.findLastKey(users, 'active');\n\t     * // => 'pebbles'\n\t     */\n\t    var findLastKey = createFindKey(baseForOwnRight);\n\t\n\t    /**\n\t     * Iterates over own and inherited enumerable properties of an object invoking\n\t     * `iteratee` for each property. The `iteratee` is bound to `thisArg` and invoked\n\t     * with three arguments: (value, key, object). Iteratee functions may exit\n\t     * iteration early by explicitly returning `false`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Object\n\t     * @param {Object} object The object to iterate over.\n\t     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n\t     * @param {*} [thisArg] The `this` binding of `iteratee`.\n\t     * @returns {Object} Returns `object`.\n\t     * @example\n\t     *\n\t     * function Foo() {\n\t     *   this.a = 1;\n\t     *   this.b = 2;\n\t     * }\n\t     *\n\t     * Foo.prototype.c = 3;\n\t     *\n\t     * _.forIn(new Foo, function(value, key) {\n\t     *   console.log(key);\n\t     * });\n\t     * // => logs 'a', 'b', and 'c' (iteration order is not guaranteed)\n\t     */\n\t    var forIn = createForIn(baseFor);\n\t\n\t    /**\n\t     * This method is like `_.forIn` except that it iterates over properties of\n\t     * `object` in the opposite order.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Object\n\t     * @param {Object} object The object to iterate over.\n\t     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n\t     * @param {*} [thisArg] The `this` binding of `iteratee`.\n\t     * @returns {Object} Returns `object`.\n\t     * @example\n\t     *\n\t     * function Foo() {\n\t     *   this.a = 1;\n\t     *   this.b = 2;\n\t     * }\n\t     *\n\t     * Foo.prototype.c = 3;\n\t     *\n\t     * _.forInRight(new Foo, function(value, key) {\n\t     *   console.log(key);\n\t     * });\n\t     * // => logs 'c', 'b', and 'a' assuming `_.forIn ` logs 'a', 'b', and 'c'\n\t     */\n\t    var forInRight = createForIn(baseForRight);\n\t\n\t    /**\n\t     * Iterates over own enumerable properties of an object invoking `iteratee`\n\t     * for each property. The `iteratee` is bound to `thisArg` and invoked with\n\t     * three arguments: (value, key, object). Iteratee functions may exit iteration\n\t     * early by explicitly returning `false`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Object\n\t     * @param {Object} object The object to iterate over.\n\t     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n\t     * @param {*} [thisArg] The `this` binding of `iteratee`.\n\t     * @returns {Object} Returns `object`.\n\t     * @example\n\t     *\n\t     * function Foo() {\n\t     *   this.a = 1;\n\t     *   this.b = 2;\n\t     * }\n\t     *\n\t     * Foo.prototype.c = 3;\n\t     *\n\t     * _.forOwn(new Foo, function(value, key) {\n\t     *   console.log(key);\n\t     * });\n\t     * // => logs 'a' and 'b' (iteration order is not guaranteed)\n\t     */\n\t    var forOwn = createForOwn(baseForOwn);\n\t\n\t    /**\n\t     * This method is like `_.forOwn` except that it iterates over properties of\n\t     * `object` in the opposite order.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Object\n\t     * @param {Object} object The object to iterate over.\n\t     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n\t     * @param {*} [thisArg] The `this` binding of `iteratee`.\n\t     * @returns {Object} Returns `object`.\n\t     * @example\n\t     *\n\t     * function Foo() {\n\t     *   this.a = 1;\n\t     *   this.b = 2;\n\t     * }\n\t     *\n\t     * Foo.prototype.c = 3;\n\t     *\n\t     * _.forOwnRight(new Foo, function(value, key) {\n\t     *   console.log(key);\n\t     * });\n\t     * // => logs 'b' and 'a' assuming `_.forOwn` logs 'a' and 'b'\n\t     */\n\t    var forOwnRight = createForOwn(baseForOwnRight);\n\t\n\t    /**\n\t     * Creates an array of function property names from all enumerable properties,\n\t     * own and inherited, of `object`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @alias methods\n\t     * @category Object\n\t     * @param {Object} object The object to inspect.\n\t     * @returns {Array} Returns the new array of property names.\n\t     * @example\n\t     *\n\t     * _.functions(_);\n\t     * // => ['after', 'ary', 'assign', ...]\n\t     */\n\t    function functions(object) {\n\t      return baseFunctions(object, keysIn(object));\n\t    }\n\t\n\t    /**\n\t     * Gets the property value at `path` of `object`. If the resolved value is\n\t     * `undefined` the `defaultValue` is used in its place.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Object\n\t     * @param {Object} object The object to query.\n\t     * @param {Array|string} path The path of the property to get.\n\t     * @param {*} [defaultValue] The value returned if the resolved value is `undefined`.\n\t     * @returns {*} Returns the resolved value.\n\t     * @example\n\t     *\n\t     * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n\t     *\n\t     * _.get(object, 'a[0].b.c');\n\t     * // => 3\n\t     *\n\t     * _.get(object, ['a', '0', 'b', 'c']);\n\t     * // => 3\n\t     *\n\t     * _.get(object, 'a.b.c', 'default');\n\t     * // => 'default'\n\t     */\n\t    function get(object, path, defaultValue) {\n\t      var result = object == null ? undefined : baseGet(object, toPath(path), path + '');\n\t      return result === undefined ? defaultValue : result;\n\t    }\n\t\n\t    /**\n\t     * Checks if `path` is a direct property.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Object\n\t     * @param {Object} object The object to query.\n\t     * @param {Array|string} path The path to check.\n\t     * @returns {boolean} Returns `true` if `path` is a direct property, else `false`.\n\t     * @example\n\t     *\n\t     * var object = { 'a': { 'b': { 'c': 3 } } };\n\t     *\n\t     * _.has(object, 'a');\n\t     * // => true\n\t     *\n\t     * _.has(object, 'a.b.c');\n\t     * // => true\n\t     *\n\t     * _.has(object, ['a', 'b', 'c']);\n\t     * // => true\n\t     */\n\t    function has(object, path) {\n\t      if (object == null) {\n\t        return false;\n\t      }\n\t      var result = hasOwnProperty.call(object, path);\n\t      if (!result && !isKey(path)) {\n\t        path = toPath(path);\n\t        object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));\n\t        if (object == null) {\n\t          return false;\n\t        }\n\t        path = last(path);\n\t        result = hasOwnProperty.call(object, path);\n\t      }\n\t      return result || (isLength(object.length) && isIndex(path, object.length) &&\n\t        (isArray(object) || isArguments(object)));\n\t    }\n\t\n\t    /**\n\t     * Creates an object composed of the inverted keys and values of `object`.\n\t     * If `object` contains duplicate values, subsequent values overwrite property\n\t     * assignments of previous values unless `multiValue` is `true`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Object\n\t     * @param {Object} object The object to invert.\n\t     * @param {boolean} [multiValue] Allow multiple values per key.\n\t     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n\t     * @returns {Object} Returns the new inverted object.\n\t     * @example\n\t     *\n\t     * var object = { 'a': 1, 'b': 2, 'c': 1 };\n\t     *\n\t     * _.invert(object);\n\t     * // => { '1': 'c', '2': 'b' }\n\t     *\n\t     * // with `multiValue`\n\t     * _.invert(object, true);\n\t     * // => { '1': ['a', 'c'], '2': ['b'] }\n\t     */\n\t    function invert(object, multiValue, guard) {\n\t      if (guard && isIterateeCall(object, multiValue, guard)) {\n\t        multiValue = undefined;\n\t      }\n\t      var index = -1,\n\t          props = keys(object),\n\t          length = props.length,\n\t          result = {};\n\t\n\t      while (++index < length) {\n\t        var key = props[index],\n\t            value = object[key];\n\t\n\t        if (multiValue) {\n\t          if (hasOwnProperty.call(result, value)) {\n\t            result[value].push(key);\n\t          } else {\n\t            result[value] = [key];\n\t          }\n\t        }\n\t        else {\n\t          result[value] = key;\n\t        }\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * Creates an array of the own enumerable property names of `object`.\n\t     *\n\t     * **Note:** Non-object values are coerced to objects. See the\n\t     * [ES spec](http://ecma-international.org/ecma-262/6.0/#sec-object.keys)\n\t     * for more details.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Object\n\t     * @param {Object} object The object to query.\n\t     * @returns {Array} Returns the array of property names.\n\t     * @example\n\t     *\n\t     * function Foo() {\n\t     *   this.a = 1;\n\t     *   this.b = 2;\n\t     * }\n\t     *\n\t     * Foo.prototype.c = 3;\n\t     *\n\t     * _.keys(new Foo);\n\t     * // => ['a', 'b'] (iteration order is not guaranteed)\n\t     *\n\t     * _.keys('hi');\n\t     * // => ['0', '1']\n\t     */\n\t    var keys = !nativeKeys ? shimKeys : function(object) {\n\t      var Ctor = object == null ? undefined : object.constructor;\n\t      if ((typeof Ctor == 'function' && Ctor.prototype === object) ||\n\t          (typeof object != 'function' && isArrayLike(object))) {\n\t        return shimKeys(object);\n\t      }\n\t      return isObject(object) ? nativeKeys(object) : [];\n\t    };\n\t\n\t    /**\n\t     * Creates an array of the own and inherited enumerable property names of `object`.\n\t     *\n\t     * **Note:** Non-object values are coerced to objects.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Object\n\t     * @param {Object} object The object to query.\n\t     * @returns {Array} Returns the array of property names.\n\t     * @example\n\t     *\n\t     * function Foo() {\n\t     *   this.a = 1;\n\t     *   this.b = 2;\n\t     * }\n\t     *\n\t     * Foo.prototype.c = 3;\n\t     *\n\t     * _.keysIn(new Foo);\n\t     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\n\t     */\n\t    function keysIn(object) {\n\t      if (object == null) {\n\t        return [];\n\t      }\n\t      if (!isObject(object)) {\n\t        object = Object(object);\n\t      }\n\t      var length = object.length;\n\t      length = (length && isLength(length) &&\n\t        (isArray(object) || isArguments(object)) && length) || 0;\n\t\n\t      var Ctor = object.constructor,\n\t          index = -1,\n\t          isProto = typeof Ctor == 'function' && Ctor.prototype === object,\n\t          result = Array(length),\n\t          skipIndexes = length > 0;\n\t\n\t      while (++index < length) {\n\t        result[index] = (index + '');\n\t      }\n\t      for (var key in object) {\n\t        if (!(skipIndexes && isIndex(key, length)) &&\n\t            !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {\n\t          result.push(key);\n\t        }\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * The opposite of `_.mapValues`; this method creates an object with the\n\t     * same values as `object` and keys generated by running each own enumerable\n\t     * property of `object` through `iteratee`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Object\n\t     * @param {Object} object The object to iterate over.\n\t     * @param {Function|Object|string} [iteratee=_.identity] The function invoked\n\t     *  per iteration.\n\t     * @param {*} [thisArg] The `this` binding of `iteratee`.\n\t     * @returns {Object} Returns the new mapped object.\n\t     * @example\n\t     *\n\t     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {\n\t     *   return key + value;\n\t     * });\n\t     * // => { 'a1': 1, 'b2': 2 }\n\t     */\n\t    var mapKeys = createObjectMapper(true);\n\t\n\t    /**\n\t     * Creates an object with the same keys as `object` and values generated by\n\t     * running each own enumerable property of `object` through `iteratee`. The\n\t     * iteratee function is bound to `thisArg` and invoked with three arguments:\n\t     * (value, key, object).\n\t     *\n\t     * If a property name is provided for `iteratee` the created `_.property`\n\t     * style callback returns the property value of the given element.\n\t     *\n\t     * If a value is also provided for `thisArg` the created `_.matchesProperty`\n\t     * style callback returns `true` for elements that have a matching property\n\t     * value, else `false`.\n\t     *\n\t     * If an object is provided for `iteratee` the created `_.matches` style\n\t     * callback returns `true` for elements that have the properties of the given\n\t     * object, else `false`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Object\n\t     * @param {Object} object The object to iterate over.\n\t     * @param {Function|Object|string} [iteratee=_.identity] The function invoked\n\t     *  per iteration.\n\t     * @param {*} [thisArg] The `this` binding of `iteratee`.\n\t     * @returns {Object} Returns the new mapped object.\n\t     * @example\n\t     *\n\t     * _.mapValues({ 'a': 1, 'b': 2 }, function(n) {\n\t     *   return n * 3;\n\t     * });\n\t     * // => { 'a': 3, 'b': 6 }\n\t     *\n\t     * var users = {\n\t     *   'fred':    { 'user': 'fred',    'age': 40 },\n\t     *   'pebbles': { 'user': 'pebbles', 'age': 1 }\n\t     * };\n\t     *\n\t     * // using the `_.property` callback shorthand\n\t     * _.mapValues(users, 'age');\n\t     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)\n\t     */\n\t    var mapValues = createObjectMapper();\n\t\n\t    /**\n\t     * The opposite of `_.pick`; this method creates an object composed of the\n\t     * own and inherited enumerable properties of `object` that are not omitted.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Object\n\t     * @param {Object} object The source object.\n\t     * @param {Function|...(string|string[])} [predicate] The function invoked per\n\t     *  iteration or property names to omit, specified as individual property\n\t     *  names or arrays of property names.\n\t     * @param {*} [thisArg] The `this` binding of `predicate`.\n\t     * @returns {Object} Returns the new object.\n\t     * @example\n\t     *\n\t     * var object = { 'user': 'fred', 'age': 40 };\n\t     *\n\t     * _.omit(object, 'age');\n\t     * // => { 'user': 'fred' }\n\t     *\n\t     * _.omit(object, _.isNumber);\n\t     * // => { 'user': 'fred' }\n\t     */\n\t    var omit = restParam(function(object, props) {\n\t      if (object == null) {\n\t        return {};\n\t      }\n\t      if (typeof props[0] != 'function') {\n\t        var props = arrayMap(baseFlatten(props), String);\n\t        return pickByArray(object, baseDifference(keysIn(object), props));\n\t      }\n\t      var predicate = bindCallback(props[0], props[1], 3);\n\t      return pickByCallback(object, function(value, key, object) {\n\t        return !predicate(value, key, object);\n\t      });\n\t    });\n\t\n\t    /**\n\t     * Creates a two dimensional array of the key-value pairs for `object`,\n\t     * e.g. `[[key1, value1], [key2, value2]]`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Object\n\t     * @param {Object} object The object to query.\n\t     * @returns {Array} Returns the new array of key-value pairs.\n\t     * @example\n\t     *\n\t     * _.pairs({ 'barney': 36, 'fred': 40 });\n\t     * // => [['barney', 36], ['fred', 40]] (iteration order is not guaranteed)\n\t     */\n\t    function pairs(object) {\n\t      object = toObject(object);\n\t\n\t      var index = -1,\n\t          props = keys(object),\n\t          length = props.length,\n\t          result = Array(length);\n\t\n\t      while (++index < length) {\n\t        var key = props[index];\n\t        result[index] = [key, object[key]];\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * Creates an object composed of the picked `object` properties. Property\n\t     * names may be specified as individual arguments or as arrays of property\n\t     * names. If `predicate` is provided it is invoked for each property of `object`\n\t     * picking the properties `predicate` returns truthy for. The predicate is\n\t     * bound to `thisArg` and invoked with three arguments: (value, key, object).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Object\n\t     * @param {Object} object The source object.\n\t     * @param {Function|...(string|string[])} [predicate] The function invoked per\n\t     *  iteration or property names to pick, specified as individual property\n\t     *  names or arrays of property names.\n\t     * @param {*} [thisArg] The `this` binding of `predicate`.\n\t     * @returns {Object} Returns the new object.\n\t     * @example\n\t     *\n\t     * var object = { 'user': 'fred', 'age': 40 };\n\t     *\n\t     * _.pick(object, 'user');\n\t     * // => { 'user': 'fred' }\n\t     *\n\t     * _.pick(object, _.isString);\n\t     * // => { 'user': 'fred' }\n\t     */\n\t    var pick = restParam(function(object, props) {\n\t      if (object == null) {\n\t        return {};\n\t      }\n\t      return typeof props[0] == 'function'\n\t        ? pickByCallback(object, bindCallback(props[0], props[1], 3))\n\t        : pickByArray(object, baseFlatten(props));\n\t    });\n\t\n\t    /**\n\t     * This method is like `_.get` except that if the resolved value is a function\n\t     * it is invoked with the `this` binding of its parent object and its result\n\t     * is returned.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Object\n\t     * @param {Object} object The object to query.\n\t     * @param {Array|string} path The path of the property to resolve.\n\t     * @param {*} [defaultValue] The value returned if the resolved value is `undefined`.\n\t     * @returns {*} Returns the resolved value.\n\t     * @example\n\t     *\n\t     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };\n\t     *\n\t     * _.result(object, 'a[0].b.c1');\n\t     * // => 3\n\t     *\n\t     * _.result(object, 'a[0].b.c2');\n\t     * // => 4\n\t     *\n\t     * _.result(object, 'a.b.c', 'default');\n\t     * // => 'default'\n\t     *\n\t     * _.result(object, 'a.b.c', _.constant('default'));\n\t     * // => 'default'\n\t     */\n\t    function result(object, path, defaultValue) {\n\t      var result = object == null ? undefined : object[path];\n\t      if (result === undefined) {\n\t        if (object != null && !isKey(path, object)) {\n\t          path = toPath(path);\n\t          object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));\n\t          result = object == null ? undefined : object[last(path)];\n\t        }\n\t        result = result === undefined ? defaultValue : result;\n\t      }\n\t      return isFunction(result) ? result.call(object) : result;\n\t    }\n\t\n\t    /**\n\t     * Sets the property value of `path` on `object`. If a portion of `path`\n\t     * does not exist it is created.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Object\n\t     * @param {Object} object The object to augment.\n\t     * @param {Array|string} path The path of the property to set.\n\t     * @param {*} value The value to set.\n\t     * @returns {Object} Returns `object`.\n\t     * @example\n\t     *\n\t     * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n\t     *\n\t     * _.set(object, 'a[0].b.c', 4);\n\t     * console.log(object.a[0].b.c);\n\t     * // => 4\n\t     *\n\t     * _.set(object, 'x[0].y.z', 5);\n\t     * console.log(object.x[0].y.z);\n\t     * // => 5\n\t     */\n\t    function set(object, path, value) {\n\t      if (object == null) {\n\t        return object;\n\t      }\n\t      var pathKey = (path + '');\n\t      path = (object[pathKey] != null || isKey(path, object)) ? [pathKey] : toPath(path);\n\t\n\t      var index = -1,\n\t          length = path.length,\n\t          lastIndex = length - 1,\n\t          nested = object;\n\t\n\t      while (nested != null && ++index < length) {\n\t        var key = path[index];\n\t        if (isObject(nested)) {\n\t          if (index == lastIndex) {\n\t            nested[key] = value;\n\t          } else if (nested[key] == null) {\n\t            nested[key] = isIndex(path[index + 1]) ? [] : {};\n\t          }\n\t        }\n\t        nested = nested[key];\n\t      }\n\t      return object;\n\t    }\n\t\n\t    /**\n\t     * An alternative to `_.reduce`; this method transforms `object` to a new\n\t     * `accumulator` object which is the result of running each of its own enumerable\n\t     * properties through `iteratee`, with each invocation potentially mutating\n\t     * the `accumulator` object. The `iteratee` is bound to `thisArg` and invoked\n\t     * with four arguments: (accumulator, value, key, object). Iteratee functions\n\t     * may exit iteration early by explicitly returning `false`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Object\n\t     * @param {Array|Object} object The object to iterate over.\n\t     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n\t     * @param {*} [accumulator] The custom accumulator value.\n\t     * @param {*} [thisArg] The `this` binding of `iteratee`.\n\t     * @returns {*} Returns the accumulated value.\n\t     * @example\n\t     *\n\t     * _.transform([2, 3, 4], function(result, n) {\n\t     *   result.push(n *= n);\n\t     *   return n % 2 == 0;\n\t     * });\n\t     * // => [4, 9]\n\t     *\n\t     * _.transform({ 'a': 1, 'b': 2 }, function(result, n, key) {\n\t     *   result[key] = n * 3;\n\t     * });\n\t     * // => { 'a': 3, 'b': 6 }\n\t     */\n\t    function transform(object, iteratee, accumulator, thisArg) {\n\t      var isArr = isArray(object) || isTypedArray(object);\n\t      iteratee = getCallback(iteratee, thisArg, 4);\n\t\n\t      if (accumulator == null) {\n\t        if (isArr || isObject(object)) {\n\t          var Ctor = object.constructor;\n\t          if (isArr) {\n\t            accumulator = isArray(object) ? new Ctor : [];\n\t          } else {\n\t            accumulator = baseCreate(isFunction(Ctor) ? Ctor.prototype : undefined);\n\t          }\n\t        } else {\n\t          accumulator = {};\n\t        }\n\t      }\n\t      (isArr ? arrayEach : baseForOwn)(object, function(value, index, object) {\n\t        return iteratee(accumulator, value, index, object);\n\t      });\n\t      return accumulator;\n\t    }\n\t\n\t    /**\n\t     * Creates an array of the own enumerable property values of `object`.\n\t     *\n\t     * **Note:** Non-object values are coerced to objects.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Object\n\t     * @param {Object} object The object to query.\n\t     * @returns {Array} Returns the array of property values.\n\t     * @example\n\t     *\n\t     * function Foo() {\n\t     *   this.a = 1;\n\t     *   this.b = 2;\n\t     * }\n\t     *\n\t     * Foo.prototype.c = 3;\n\t     *\n\t     * _.values(new Foo);\n\t     * // => [1, 2] (iteration order is not guaranteed)\n\t     *\n\t     * _.values('hi');\n\t     * // => ['h', 'i']\n\t     */\n\t    function values(object) {\n\t      return baseValues(object, keys(object));\n\t    }\n\t\n\t    /**\n\t     * Creates an array of the own and inherited enumerable property values\n\t     * of `object`.\n\t     *\n\t     * **Note:** Non-object values are coerced to objects.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Object\n\t     * @param {Object} object The object to query.\n\t     * @returns {Array} Returns the array of property values.\n\t     * @example\n\t     *\n\t     * function Foo() {\n\t     *   this.a = 1;\n\t     *   this.b = 2;\n\t     * }\n\t     *\n\t     * Foo.prototype.c = 3;\n\t     *\n\t     * _.valuesIn(new Foo);\n\t     * // => [1, 2, 3] (iteration order is not guaranteed)\n\t     */\n\t    function valuesIn(object) {\n\t      return baseValues(object, keysIn(object));\n\t    }\n\t\n\t    /*------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * Checks if `n` is between `start` and up to but not including, `end`. If\n\t     * `end` is not specified it is set to `start` with `start` then set to `0`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Number\n\t     * @param {number} n The number to check.\n\t     * @param {number} [start=0] The start of the range.\n\t     * @param {number} end The end of the range.\n\t     * @returns {boolean} Returns `true` if `n` is in the range, else `false`.\n\t     * @example\n\t     *\n\t     * _.inRange(3, 2, 4);\n\t     * // => true\n\t     *\n\t     * _.inRange(4, 8);\n\t     * // => true\n\t     *\n\t     * _.inRange(4, 2);\n\t     * // => false\n\t     *\n\t     * _.inRange(2, 2);\n\t     * // => false\n\t     *\n\t     * _.inRange(1.2, 2);\n\t     * // => true\n\t     *\n\t     * _.inRange(5.2, 4);\n\t     * // => false\n\t     */\n\t    function inRange(value, start, end) {\n\t      start = +start || 0;\n\t      if (end === undefined) {\n\t        end = start;\n\t        start = 0;\n\t      } else {\n\t        end = +end || 0;\n\t      }\n\t      return value >= nativeMin(start, end) && value < nativeMax(start, end);\n\t    }\n\t\n\t    /**\n\t     * Produces a random number between `min` and `max` (inclusive). If only one\n\t     * argument is provided a number between `0` and the given number is returned.\n\t     * If `floating` is `true`, or either `min` or `max` are floats, a floating-point\n\t     * number is returned instead of an integer.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Number\n\t     * @param {number} [min=0] The minimum possible value.\n\t     * @param {number} [max=1] The maximum possible value.\n\t     * @param {boolean} [floating] Specify returning a floating-point number.\n\t     * @returns {number} Returns the random number.\n\t     * @example\n\t     *\n\t     * _.random(0, 5);\n\t     * // => an integer between 0 and 5\n\t     *\n\t     * _.random(5);\n\t     * // => also an integer between 0 and 5\n\t     *\n\t     * _.random(5, true);\n\t     * // => a floating-point number between 0 and 5\n\t     *\n\t     * _.random(1.2, 5.2);\n\t     * // => a floating-point number between 1.2 and 5.2\n\t     */\n\t    function random(min, max, floating) {\n\t      if (floating && isIterateeCall(min, max, floating)) {\n\t        max = floating = undefined;\n\t      }\n\t      var noMin = min == null,\n\t          noMax = max == null;\n\t\n\t      if (floating == null) {\n\t        if (noMax && typeof min == 'boolean') {\n\t          floating = min;\n\t          min = 1;\n\t        }\n\t        else if (typeof max == 'boolean') {\n\t          floating = max;\n\t          noMax = true;\n\t        }\n\t      }\n\t      if (noMin && noMax) {\n\t        max = 1;\n\t        noMax = false;\n\t      }\n\t      min = +min || 0;\n\t      if (noMax) {\n\t        max = min;\n\t        min = 0;\n\t      } else {\n\t        max = +max || 0;\n\t      }\n\t      if (floating || min % 1 || max % 1) {\n\t        var rand = nativeRandom();\n\t        return nativeMin(min + (rand * (max - min + parseFloat('1e-' + ((rand + '').length - 1)))), max);\n\t      }\n\t      return baseRandom(min, max);\n\t    }\n\t\n\t    /*------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category String\n\t     * @param {string} [string=''] The string to convert.\n\t     * @returns {string} Returns the camel cased string.\n\t     * @example\n\t     *\n\t     * _.camelCase('Foo Bar');\n\t     * // => 'fooBar'\n\t     *\n\t     * _.camelCase('--foo-bar');\n\t     * // => 'fooBar'\n\t     *\n\t     * _.camelCase('__foo_bar__');\n\t     * // => 'fooBar'\n\t     */\n\t    var camelCase = createCompounder(function(result, word, index) {\n\t      word = word.toLowerCase();\n\t      return result + (index ? (word.charAt(0).toUpperCase() + word.slice(1)) : word);\n\t    });\n\t\n\t    /**\n\t     * Capitalizes the first character of `string`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category String\n\t     * @param {string} [string=''] The string to capitalize.\n\t     * @returns {string} Returns the capitalized string.\n\t     * @example\n\t     *\n\t     * _.capitalize('fred');\n\t     * // => 'Fred'\n\t     */\n\t    function capitalize(string) {\n\t      string = baseToString(string);\n\t      return string && (string.charAt(0).toUpperCase() + string.slice(1));\n\t    }\n\t\n\t    /**\n\t     * Deburrs `string` by converting [latin-1 supplementary letters](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)\n\t     * to basic latin letters and removing [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category String\n\t     * @param {string} [string=''] The string to deburr.\n\t     * @returns {string} Returns the deburred string.\n\t     * @example\n\t     *\n\t     * _.deburr('déjà vu');\n\t     * // => 'deja vu'\n\t     */\n\t    function deburr(string) {\n\t      string = baseToString(string);\n\t      return string && string.replace(reLatin1, deburrLetter).replace(reComboMark, '');\n\t    }\n\t\n\t    /**\n\t     * Checks if `string` ends with the given target string.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category String\n\t     * @param {string} [string=''] The string to search.\n\t     * @param {string} [target] The string to search for.\n\t     * @param {number} [position=string.length] The position to search from.\n\t     * @returns {boolean} Returns `true` if `string` ends with `target`, else `false`.\n\t     * @example\n\t     *\n\t     * _.endsWith('abc', 'c');\n\t     * // => true\n\t     *\n\t     * _.endsWith('abc', 'b');\n\t     * // => false\n\t     *\n\t     * _.endsWith('abc', 'b', 2);\n\t     * // => true\n\t     */\n\t    function endsWith(string, target, position) {\n\t      string = baseToString(string);\n\t      target = (target + '');\n\t\n\t      var length = string.length;\n\t      position = position === undefined\n\t        ? length\n\t        : nativeMin(position < 0 ? 0 : (+position || 0), length);\n\t\n\t      position -= target.length;\n\t      return position >= 0 && string.indexOf(target, position) == position;\n\t    }\n\t\n\t    /**\n\t     * Converts the characters \"&\", \"<\", \">\", '\"', \"'\", and \"\\`\", in `string` to\n\t     * their corresponding HTML entities.\n\t     *\n\t     * **Note:** No other characters are escaped. To escape additional characters\n\t     * use a third-party library like [_he_](https://mths.be/he).\n\t     *\n\t     * Though the \">\" character is escaped for symmetry, characters like\n\t     * \">\" and \"/\" don't need escaping in HTML and have no special meaning\n\t     * unless they're part of a tag or unquoted attribute value.\n\t     * See [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)\n\t     * (under \"semi-related fun fact\") for more details.\n\t     *\n\t     * Backticks are escaped because in Internet Explorer < 9, they can break out\n\t     * of attribute values or HTML comments. See [#59](https://html5sec.org/#59),\n\t     * [#102](https://html5sec.org/#102), [#108](https://html5sec.org/#108), and\n\t     * [#133](https://html5sec.org/#133) of the [HTML5 Security Cheatsheet](https://html5sec.org/)\n\t     * for more details.\n\t     *\n\t     * When working with HTML you should always [quote attribute values](http://wonko.com/post/html-escaping)\n\t     * to reduce XSS vectors.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category String\n\t     * @param {string} [string=''] The string to escape.\n\t     * @returns {string} Returns the escaped string.\n\t     * @example\n\t     *\n\t     * _.escape('fred, barney, & pebbles');\n\t     * // => 'fred, barney, &amp; pebbles'\n\t     */\n\t    function escape(string) {\n\t      // Reset `lastIndex` because in IE < 9 `String#replace` does not.\n\t      string = baseToString(string);\n\t      return (string && reHasUnescapedHtml.test(string))\n\t        ? string.replace(reUnescapedHtml, escapeHtmlChar)\n\t        : string;\n\t    }\n\t\n\t    /**\n\t     * Escapes the `RegExp` special characters \"\\\", \"/\", \"^\", \"$\", \".\", \"|\", \"?\",\n\t     * \"*\", \"+\", \"(\", \")\", \"[\", \"]\", \"{\" and \"}\" in `string`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category String\n\t     * @param {string} [string=''] The string to escape.\n\t     * @returns {string} Returns the escaped string.\n\t     * @example\n\t     *\n\t     * _.escapeRegExp('[lodash](https://lodash.com/)');\n\t     * // => '\\[lodash\\]\\(https:\\/\\/lodash\\.com\\/\\)'\n\t     */\n\t    function escapeRegExp(string) {\n\t      string = baseToString(string);\n\t      return (string && reHasRegExpChars.test(string))\n\t        ? string.replace(reRegExpChars, escapeRegExpChar)\n\t        : (string || '(?:)');\n\t    }\n\t\n\t    /**\n\t     * Converts `string` to [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category String\n\t     * @param {string} [string=''] The string to convert.\n\t     * @returns {string} Returns the kebab cased string.\n\t     * @example\n\t     *\n\t     * _.kebabCase('Foo Bar');\n\t     * // => 'foo-bar'\n\t     *\n\t     * _.kebabCase('fooBar');\n\t     * // => 'foo-bar'\n\t     *\n\t     * _.kebabCase('__foo_bar__');\n\t     * // => 'foo-bar'\n\t     */\n\t    var kebabCase = createCompounder(function(result, word, index) {\n\t      return result + (index ? '-' : '') + word.toLowerCase();\n\t    });\n\t\n\t    /**\n\t     * Pads `string` on the left and right sides if it's shorter than `length`.\n\t     * Padding characters are truncated if they can't be evenly divided by `length`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category String\n\t     * @param {string} [string=''] The string to pad.\n\t     * @param {number} [length=0] The padding length.\n\t     * @param {string} [chars=' '] The string used as padding.\n\t     * @returns {string} Returns the padded string.\n\t     * @example\n\t     *\n\t     * _.pad('abc', 8);\n\t     * // => '  abc   '\n\t     *\n\t     * _.pad('abc', 8, '_-');\n\t     * // => '_-abc_-_'\n\t     *\n\t     * _.pad('abc', 3);\n\t     * // => 'abc'\n\t     */\n\t    function pad(string, length, chars) {\n\t      string = baseToString(string);\n\t      length = +length;\n\t\n\t      var strLength = string.length;\n\t      if (strLength >= length || !nativeIsFinite(length)) {\n\t        return string;\n\t      }\n\t      var mid = (length - strLength) / 2,\n\t          leftLength = nativeFloor(mid),\n\t          rightLength = nativeCeil(mid);\n\t\n\t      chars = createPadding('', rightLength, chars);\n\t      return chars.slice(0, leftLength) + string + chars;\n\t    }\n\t\n\t    /**\n\t     * Pads `string` on the left side if it's shorter than `length`. Padding\n\t     * characters are truncated if they exceed `length`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category String\n\t     * @param {string} [string=''] The string to pad.\n\t     * @param {number} [length=0] The padding length.\n\t     * @param {string} [chars=' '] The string used as padding.\n\t     * @returns {string} Returns the padded string.\n\t     * @example\n\t     *\n\t     * _.padLeft('abc', 6);\n\t     * // => '   abc'\n\t     *\n\t     * _.padLeft('abc', 6, '_-');\n\t     * // => '_-_abc'\n\t     *\n\t     * _.padLeft('abc', 3);\n\t     * // => 'abc'\n\t     */\n\t    var padLeft = createPadDir();\n\t\n\t    /**\n\t     * Pads `string` on the right side if it's shorter than `length`. Padding\n\t     * characters are truncated if they exceed `length`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category String\n\t     * @param {string} [string=''] The string to pad.\n\t     * @param {number} [length=0] The padding length.\n\t     * @param {string} [chars=' '] The string used as padding.\n\t     * @returns {string} Returns the padded string.\n\t     * @example\n\t     *\n\t     * _.padRight('abc', 6);\n\t     * // => 'abc   '\n\t     *\n\t     * _.padRight('abc', 6, '_-');\n\t     * // => 'abc_-_'\n\t     *\n\t     * _.padRight('abc', 3);\n\t     * // => 'abc'\n\t     */\n\t    var padRight = createPadDir(true);\n\t\n\t    /**\n\t     * Converts `string` to an integer of the specified radix. If `radix` is\n\t     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a hexadecimal,\n\t     * in which case a `radix` of `16` is used.\n\t     *\n\t     * **Note:** This method aligns with the [ES5 implementation](https://es5.github.io/#E)\n\t     * of `parseInt`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category String\n\t     * @param {string} string The string to convert.\n\t     * @param {number} [radix] The radix to interpret `value` by.\n\t     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n\t     * @returns {number} Returns the converted integer.\n\t     * @example\n\t     *\n\t     * _.parseInt('08');\n\t     * // => 8\n\t     *\n\t     * _.map(['6', '08', '10'], _.parseInt);\n\t     * // => [6, 8, 10]\n\t     */\n\t    function parseInt(string, radix, guard) {\n\t      // Firefox < 21 and Opera < 15 follow ES3 for `parseInt`.\n\t      // Chrome fails to trim leading <BOM> whitespace characters.\n\t      // See https://code.google.com/p/v8/issues/detail?id=3109 for more details.\n\t      if (guard ? isIterateeCall(string, radix, guard) : radix == null) {\n\t        radix = 0;\n\t      } else if (radix) {\n\t        radix = +radix;\n\t      }\n\t      string = trim(string);\n\t      return nativeParseInt(string, radix || (reHasHexPrefix.test(string) ? 16 : 10));\n\t    }\n\t\n\t    /**\n\t     * Repeats the given string `n` times.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category String\n\t     * @param {string} [string=''] The string to repeat.\n\t     * @param {number} [n=0] The number of times to repeat the string.\n\t     * @returns {string} Returns the repeated string.\n\t     * @example\n\t     *\n\t     * _.repeat('*', 3);\n\t     * // => '***'\n\t     *\n\t     * _.repeat('abc', 2);\n\t     * // => 'abcabc'\n\t     *\n\t     * _.repeat('abc', 0);\n\t     * // => ''\n\t     */\n\t    function repeat(string, n) {\n\t      var result = '';\n\t      string = baseToString(string);\n\t      n = +n;\n\t      if (n < 1 || !string || !nativeIsFinite(n)) {\n\t        return result;\n\t      }\n\t      // Leverage the exponentiation by squaring algorithm for a faster repeat.\n\t      // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.\n\t      do {\n\t        if (n % 2) {\n\t          result += string;\n\t        }\n\t        n = nativeFloor(n / 2);\n\t        string += string;\n\t      } while (n);\n\t\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * Converts `string` to [snake case](https://en.wikipedia.org/wiki/Snake_case).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category String\n\t     * @param {string} [string=''] The string to convert.\n\t     * @returns {string} Returns the snake cased string.\n\t     * @example\n\t     *\n\t     * _.snakeCase('Foo Bar');\n\t     * // => 'foo_bar'\n\t     *\n\t     * _.snakeCase('fooBar');\n\t     * // => 'foo_bar'\n\t     *\n\t     * _.snakeCase('--foo-bar');\n\t     * // => 'foo_bar'\n\t     */\n\t    var snakeCase = createCompounder(function(result, word, index) {\n\t      return result + (index ? '_' : '') + word.toLowerCase();\n\t    });\n\t\n\t    /**\n\t     * Converts `string` to [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category String\n\t     * @param {string} [string=''] The string to convert.\n\t     * @returns {string} Returns the start cased string.\n\t     * @example\n\t     *\n\t     * _.startCase('--foo-bar');\n\t     * // => 'Foo Bar'\n\t     *\n\t     * _.startCase('fooBar');\n\t     * // => 'Foo Bar'\n\t     *\n\t     * _.startCase('__foo_bar__');\n\t     * // => 'Foo Bar'\n\t     */\n\t    var startCase = createCompounder(function(result, word, index) {\n\t      return result + (index ? ' ' : '') + (word.charAt(0).toUpperCase() + word.slice(1));\n\t    });\n\t\n\t    /**\n\t     * Checks if `string` starts with the given target string.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category String\n\t     * @param {string} [string=''] The string to search.\n\t     * @param {string} [target] The string to search for.\n\t     * @param {number} [position=0] The position to search from.\n\t     * @returns {boolean} Returns `true` if `string` starts with `target`, else `false`.\n\t     * @example\n\t     *\n\t     * _.startsWith('abc', 'a');\n\t     * // => true\n\t     *\n\t     * _.startsWith('abc', 'b');\n\t     * // => false\n\t     *\n\t     * _.startsWith('abc', 'b', 1);\n\t     * // => true\n\t     */\n\t    function startsWith(string, target, position) {\n\t      string = baseToString(string);\n\t      position = position == null\n\t        ? 0\n\t        : nativeMin(position < 0 ? 0 : (+position || 0), string.length);\n\t\n\t      return string.lastIndexOf(target, position) == position;\n\t    }\n\t\n\t    /**\n\t     * Creates a compiled template function that can interpolate data properties\n\t     * in \"interpolate\" delimiters, HTML-escape interpolated data properties in\n\t     * \"escape\" delimiters, and execute JavaScript in \"evaluate\" delimiters. Data\n\t     * properties may be accessed as free variables in the template. If a setting\n\t     * object is provided it takes precedence over `_.templateSettings` values.\n\t     *\n\t     * **Note:** In the development build `_.template` utilizes\n\t     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)\n\t     * for easier debugging.\n\t     *\n\t     * For more information on precompiling templates see\n\t     * [lodash's custom builds documentation](https://lodash.com/custom-builds).\n\t     *\n\t     * For more information on Chrome extension sandboxes see\n\t     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category String\n\t     * @param {string} [string=''] The template string.\n\t     * @param {Object} [options] The options object.\n\t     * @param {RegExp} [options.escape] The HTML \"escape\" delimiter.\n\t     * @param {RegExp} [options.evaluate] The \"evaluate\" delimiter.\n\t     * @param {Object} [options.imports] An object to import into the template as free variables.\n\t     * @param {RegExp} [options.interpolate] The \"interpolate\" delimiter.\n\t     * @param {string} [options.sourceURL] The sourceURL of the template's compiled source.\n\t     * @param {string} [options.variable] The data object variable name.\n\t     * @param- {Object} [otherOptions] Enables the legacy `options` param signature.\n\t     * @returns {Function} Returns the compiled template function.\n\t     * @example\n\t     *\n\t     * // using the \"interpolate\" delimiter to create a compiled template\n\t     * var compiled = _.template('hello <%= user %>!');\n\t     * compiled({ 'user': 'fred' });\n\t     * // => 'hello fred!'\n\t     *\n\t     * // using the HTML \"escape\" delimiter to escape data property values\n\t     * var compiled = _.template('<b><%- value %></b>');\n\t     * compiled({ 'value': '<script>' });\n\t     * // => '<b>&lt;script&gt;</b>'\n\t     *\n\t     * // using the \"evaluate\" delimiter to execute JavaScript and generate HTML\n\t     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');\n\t     * compiled({ 'users': ['fred', 'barney'] });\n\t     * // => '<li>fred</li><li>barney</li>'\n\t     *\n\t     * // using the internal `print` function in \"evaluate\" delimiters\n\t     * var compiled = _.template('<% print(\"hello \" + user); %>!');\n\t     * compiled({ 'user': 'barney' });\n\t     * // => 'hello barney!'\n\t     *\n\t     * // using the ES delimiter as an alternative to the default \"interpolate\" delimiter\n\t     * var compiled = _.template('hello ${ user }!');\n\t     * compiled({ 'user': 'pebbles' });\n\t     * // => 'hello pebbles!'\n\t     *\n\t     * // using custom template delimiters\n\t     * _.templateSettings.interpolate = /{{([\\s\\S]+?)}}/g;\n\t     * var compiled = _.template('hello {{ user }}!');\n\t     * compiled({ 'user': 'mustache' });\n\t     * // => 'hello mustache!'\n\t     *\n\t     * // using backslashes to treat delimiters as plain text\n\t     * var compiled = _.template('<%= \"\\\\<%- value %\\\\>\" %>');\n\t     * compiled({ 'value': 'ignored' });\n\t     * // => '<%- value %>'\n\t     *\n\t     * // using the `imports` option to import `jQuery` as `jq`\n\t     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';\n\t     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });\n\t     * compiled({ 'users': ['fred', 'barney'] });\n\t     * // => '<li>fred</li><li>barney</li>'\n\t     *\n\t     * // using the `sourceURL` option to specify a custom sourceURL for the template\n\t     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });\n\t     * compiled(data);\n\t     * // => find the source of \"greeting.jst\" under the Sources tab or Resources panel of the web inspector\n\t     *\n\t     * // using the `variable` option to ensure a with-statement isn't used in the compiled template\n\t     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });\n\t     * compiled.source;\n\t     * // => function(data) {\n\t     * //   var __t, __p = '';\n\t     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';\n\t     * //   return __p;\n\t     * // }\n\t     *\n\t     * // using the `source` property to inline compiled templates for meaningful\n\t     * // line numbers in error messages and a stack trace\n\t     * fs.writeFileSync(path.join(cwd, 'jst.js'), '\\\n\t     *   var JST = {\\\n\t     *     \"main\": ' + _.template(mainText).source + '\\\n\t     *   };\\\n\t     * ');\n\t     */\n\t    function template(string, options, otherOptions) {\n\t      // Based on John Resig's `tmpl` implementation (http://ejohn.org/blog/javascript-micro-templating/)\n\t      // and Laura Doktorova's doT.js (https://github.com/olado/doT).\n\t      var settings = lodash.templateSettings;\n\t\n\t      if (otherOptions && isIterateeCall(string, options, otherOptions)) {\n\t        options = otherOptions = undefined;\n\t      }\n\t      string = baseToString(string);\n\t      options = assignWith(baseAssign({}, otherOptions || options), settings, assignOwnDefaults);\n\t\n\t      var imports = assignWith(baseAssign({}, options.imports), settings.imports, assignOwnDefaults),\n\t          importsKeys = keys(imports),\n\t          importsValues = baseValues(imports, importsKeys);\n\t\n\t      var isEscaping,\n\t          isEvaluating,\n\t          index = 0,\n\t          interpolate = options.interpolate || reNoMatch,\n\t          source = \"__p += '\";\n\t\n\t      // Compile the regexp to match each delimiter.\n\t      var reDelimiters = RegExp(\n\t        (options.escape || reNoMatch).source + '|' +\n\t        interpolate.source + '|' +\n\t        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +\n\t        (options.evaluate || reNoMatch).source + '|$'\n\t      , 'g');\n\t\n\t      // Use a sourceURL for easier debugging.\n\t      var sourceURL = '//# sourceURL=' +\n\t        ('sourceURL' in options\n\t          ? options.sourceURL\n\t          : ('lodash.templateSources[' + (++templateCounter) + ']')\n\t        ) + '\\n';\n\t\n\t      string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {\n\t        interpolateValue || (interpolateValue = esTemplateValue);\n\t\n\t        // Escape characters that can't be included in string literals.\n\t        source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);\n\t\n\t        // Replace delimiters with snippets.\n\t        if (escapeValue) {\n\t          isEscaping = true;\n\t          source += \"' +\\n__e(\" + escapeValue + \") +\\n'\";\n\t        }\n\t        if (evaluateValue) {\n\t          isEvaluating = true;\n\t          source += \"';\\n\" + evaluateValue + \";\\n__p += '\";\n\t        }\n\t        if (interpolateValue) {\n\t          source += \"' +\\n((__t = (\" + interpolateValue + \")) == null ? '' : __t) +\\n'\";\n\t        }\n\t        index = offset + match.length;\n\t\n\t        // The JS engine embedded in Adobe products requires returning the `match`\n\t        // string in order to produce the correct `offset` value.\n\t        return match;\n\t      });\n\t\n\t      source += \"';\\n\";\n\t\n\t      // If `variable` is not specified wrap a with-statement around the generated\n\t      // code to add the data object to the top of the scope chain.\n\t      var variable = options.variable;\n\t      if (!variable) {\n\t        source = 'with (obj) {\\n' + source + '\\n}\\n';\n\t      }\n\t      // Cleanup code by stripping empty strings.\n\t      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)\n\t        .replace(reEmptyStringMiddle, '$1')\n\t        .replace(reEmptyStringTrailing, '$1;');\n\t\n\t      // Frame code as the function body.\n\t      source = 'function(' + (variable || 'obj') + ') {\\n' +\n\t        (variable\n\t          ? ''\n\t          : 'obj || (obj = {});\\n'\n\t        ) +\n\t        \"var __t, __p = ''\" +\n\t        (isEscaping\n\t           ? ', __e = _.escape'\n\t           : ''\n\t        ) +\n\t        (isEvaluating\n\t          ? ', __j = Array.prototype.join;\\n' +\n\t            \"function print() { __p += __j.call(arguments, '') }\\n\"\n\t          : ';\\n'\n\t        ) +\n\t        source +\n\t        'return __p\\n}';\n\t\n\t      var result = attempt(function() {\n\t        return Function(importsKeys, sourceURL + 'return ' + source).apply(undefined, importsValues);\n\t      });\n\t\n\t      // Provide the compiled function's source by its `toString` method or\n\t      // the `source` property as a convenience for inlining compiled templates.\n\t      result.source = source;\n\t      if (isError(result)) {\n\t        throw result;\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * Removes leading and trailing whitespace or specified characters from `string`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category String\n\t     * @param {string} [string=''] The string to trim.\n\t     * @param {string} [chars=whitespace] The characters to trim.\n\t     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n\t     * @returns {string} Returns the trimmed string.\n\t     * @example\n\t     *\n\t     * _.trim('  abc  ');\n\t     * // => 'abc'\n\t     *\n\t     * _.trim('-_-abc-_-', '_-');\n\t     * // => 'abc'\n\t     *\n\t     * _.map(['  foo  ', '  bar  '], _.trim);\n\t     * // => ['foo', 'bar']\n\t     */\n\t    function trim(string, chars, guard) {\n\t      var value = string;\n\t      string = baseToString(string);\n\t      if (!string) {\n\t        return string;\n\t      }\n\t      if (guard ? isIterateeCall(value, chars, guard) : chars == null) {\n\t        return string.slice(trimmedLeftIndex(string), trimmedRightIndex(string) + 1);\n\t      }\n\t      chars = (chars + '');\n\t      return string.slice(charsLeftIndex(string, chars), charsRightIndex(string, chars) + 1);\n\t    }\n\t\n\t    /**\n\t     * Removes leading whitespace or specified characters from `string`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category String\n\t     * @param {string} [string=''] The string to trim.\n\t     * @param {string} [chars=whitespace] The characters to trim.\n\t     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n\t     * @returns {string} Returns the trimmed string.\n\t     * @example\n\t     *\n\t     * _.trimLeft('  abc  ');\n\t     * // => 'abc  '\n\t     *\n\t     * _.trimLeft('-_-abc-_-', '_-');\n\t     * // => 'abc-_-'\n\t     */\n\t    function trimLeft(string, chars, guard) {\n\t      var value = string;\n\t      string = baseToString(string);\n\t      if (!string) {\n\t        return string;\n\t      }\n\t      if (guard ? isIterateeCall(value, chars, guard) : chars == null) {\n\t        return string.slice(trimmedLeftIndex(string));\n\t      }\n\t      return string.slice(charsLeftIndex(string, (chars + '')));\n\t    }\n\t\n\t    /**\n\t     * Removes trailing whitespace or specified characters from `string`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category String\n\t     * @param {string} [string=''] The string to trim.\n\t     * @param {string} [chars=whitespace] The characters to trim.\n\t     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n\t     * @returns {string} Returns the trimmed string.\n\t     * @example\n\t     *\n\t     * _.trimRight('  abc  ');\n\t     * // => '  abc'\n\t     *\n\t     * _.trimRight('-_-abc-_-', '_-');\n\t     * // => '-_-abc'\n\t     */\n\t    function trimRight(string, chars, guard) {\n\t      var value = string;\n\t      string = baseToString(string);\n\t      if (!string) {\n\t        return string;\n\t      }\n\t      if (guard ? isIterateeCall(value, chars, guard) : chars == null) {\n\t        return string.slice(0, trimmedRightIndex(string) + 1);\n\t      }\n\t      return string.slice(0, charsRightIndex(string, (chars + '')) + 1);\n\t    }\n\t\n\t    /**\n\t     * Truncates `string` if it's longer than the given maximum string length.\n\t     * The last characters of the truncated string are replaced with the omission\n\t     * string which defaults to \"...\".\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category String\n\t     * @param {string} [string=''] The string to truncate.\n\t     * @param {Object|number} [options] The options object or maximum string length.\n\t     * @param {number} [options.length=30] The maximum string length.\n\t     * @param {string} [options.omission='...'] The string to indicate text is omitted.\n\t     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.\n\t     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n\t     * @returns {string} Returns the truncated string.\n\t     * @example\n\t     *\n\t     * _.trunc('hi-diddly-ho there, neighborino');\n\t     * // => 'hi-diddly-ho there, neighbo...'\n\t     *\n\t     * _.trunc('hi-diddly-ho there, neighborino', 24);\n\t     * // => 'hi-diddly-ho there, n...'\n\t     *\n\t     * _.trunc('hi-diddly-ho there, neighborino', {\n\t     *   'length': 24,\n\t     *   'separator': ' '\n\t     * });\n\t     * // => 'hi-diddly-ho there,...'\n\t     *\n\t     * _.trunc('hi-diddly-ho there, neighborino', {\n\t     *   'length': 24,\n\t     *   'separator': /,? +/\n\t     * });\n\t     * // => 'hi-diddly-ho there...'\n\t     *\n\t     * _.trunc('hi-diddly-ho there, neighborino', {\n\t     *   'omission': ' [...]'\n\t     * });\n\t     * // => 'hi-diddly-ho there, neig [...]'\n\t     */\n\t    function trunc(string, options, guard) {\n\t      if (guard && isIterateeCall(string, options, guard)) {\n\t        options = undefined;\n\t      }\n\t      var length = DEFAULT_TRUNC_LENGTH,\n\t          omission = DEFAULT_TRUNC_OMISSION;\n\t\n\t      if (options != null) {\n\t        if (isObject(options)) {\n\t          var separator = 'separator' in options ? options.separator : separator;\n\t          length = 'length' in options ? (+options.length || 0) : length;\n\t          omission = 'omission' in options ? baseToString(options.omission) : omission;\n\t        } else {\n\t          length = +options || 0;\n\t        }\n\t      }\n\t      string = baseToString(string);\n\t      if (length >= string.length) {\n\t        return string;\n\t      }\n\t      var end = length - omission.length;\n\t      if (end < 1) {\n\t        return omission;\n\t      }\n\t      var result = string.slice(0, end);\n\t      if (separator == null) {\n\t        return result + omission;\n\t      }\n\t      if (isRegExp(separator)) {\n\t        if (string.slice(end).search(separator)) {\n\t          var match,\n\t              newEnd,\n\t              substring = string.slice(0, end);\n\t\n\t          if (!separator.global) {\n\t            separator = RegExp(separator.source, (reFlags.exec(separator) || '') + 'g');\n\t          }\n\t          separator.lastIndex = 0;\n\t          while ((match = separator.exec(substring))) {\n\t            newEnd = match.index;\n\t          }\n\t          result = result.slice(0, newEnd == null ? end : newEnd);\n\t        }\n\t      } else if (string.indexOf(separator, end) != end) {\n\t        var index = result.lastIndexOf(separator);\n\t        if (index > -1) {\n\t          result = result.slice(0, index);\n\t        }\n\t      }\n\t      return result + omission;\n\t    }\n\t\n\t    /**\n\t     * The inverse of `_.escape`; this method converts the HTML entities\n\t     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, `&#39;`, and `&#96;` in `string` to their\n\t     * corresponding characters.\n\t     *\n\t     * **Note:** No other HTML entities are unescaped. To unescape additional HTML\n\t     * entities use a third-party library like [_he_](https://mths.be/he).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category String\n\t     * @param {string} [string=''] The string to unescape.\n\t     * @returns {string} Returns the unescaped string.\n\t     * @example\n\t     *\n\t     * _.unescape('fred, barney, &amp; pebbles');\n\t     * // => 'fred, barney, & pebbles'\n\t     */\n\t    function unescape(string) {\n\t      string = baseToString(string);\n\t      return (string && reHasEscapedHtml.test(string))\n\t        ? string.replace(reEscapedHtml, unescapeHtmlChar)\n\t        : string;\n\t    }\n\t\n\t    /**\n\t     * Splits `string` into an array of its words.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category String\n\t     * @param {string} [string=''] The string to inspect.\n\t     * @param {RegExp|string} [pattern] The pattern to match words.\n\t     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n\t     * @returns {Array} Returns the words of `string`.\n\t     * @example\n\t     *\n\t     * _.words('fred, barney, & pebbles');\n\t     * // => ['fred', 'barney', 'pebbles']\n\t     *\n\t     * _.words('fred, barney, & pebbles', /[^, ]+/g);\n\t     * // => ['fred', 'barney', '&', 'pebbles']\n\t     */\n\t    function words(string, pattern, guard) {\n\t      if (guard && isIterateeCall(string, pattern, guard)) {\n\t        pattern = undefined;\n\t      }\n\t      string = baseToString(string);\n\t      return string.match(pattern || reWords) || [];\n\t    }\n\t\n\t    /*------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * Attempts to invoke `func`, returning either the result or the caught error\n\t     * object. Any additional arguments are provided to `func` when it is invoked.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Utility\n\t     * @param {Function} func The function to attempt.\n\t     * @returns {*} Returns the `func` result or error object.\n\t     * @example\n\t     *\n\t     * // avoid throwing errors for invalid selectors\n\t     * var elements = _.attempt(function(selector) {\n\t     *   return document.querySelectorAll(selector);\n\t     * }, '>_>');\n\t     *\n\t     * if (_.isError(elements)) {\n\t     *   elements = [];\n\t     * }\n\t     */\n\t    var attempt = restParam(function(func, args) {\n\t      try {\n\t        return func.apply(undefined, args);\n\t      } catch(e) {\n\t        return isError(e) ? e : new Error(e);\n\t      }\n\t    });\n\t\n\t    /**\n\t     * Creates a function that invokes `func` with the `this` binding of `thisArg`\n\t     * and arguments of the created function. If `func` is a property name the\n\t     * created callback returns the property value for a given element. If `func`\n\t     * is an object the created callback returns `true` for elements that contain\n\t     * the equivalent object properties, otherwise it returns `false`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @alias iteratee\n\t     * @category Utility\n\t     * @param {*} [func=_.identity] The value to convert to a callback.\n\t     * @param {*} [thisArg] The `this` binding of `func`.\n\t     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n\t     * @returns {Function} Returns the callback.\n\t     * @example\n\t     *\n\t     * var users = [\n\t     *   { 'user': 'barney', 'age': 36 },\n\t     *   { 'user': 'fred',   'age': 40 }\n\t     * ];\n\t     *\n\t     * // wrap to create custom callback shorthands\n\t     * _.callback = _.wrap(_.callback, function(callback, func, thisArg) {\n\t     *   var match = /^(.+?)__([gl]t)(.+)$/.exec(func);\n\t     *   if (!match) {\n\t     *     return callback(func, thisArg);\n\t     *   }\n\t     *   return function(object) {\n\t     *     return match[2] == 'gt'\n\t     *       ? object[match[1]] > match[3]\n\t     *       : object[match[1]] < match[3];\n\t     *   };\n\t     * });\n\t     *\n\t     * _.filter(users, 'age__gt36');\n\t     * // => [{ 'user': 'fred', 'age': 40 }]\n\t     */\n\t    function callback(func, thisArg, guard) {\n\t      if (guard && isIterateeCall(func, thisArg, guard)) {\n\t        thisArg = undefined;\n\t      }\n\t      return isObjectLike(func)\n\t        ? matches(func)\n\t        : baseCallback(func, thisArg);\n\t    }\n\t\n\t    /**\n\t     * Creates a function that returns `value`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Utility\n\t     * @param {*} value The value to return from the new function.\n\t     * @returns {Function} Returns the new function.\n\t     * @example\n\t     *\n\t     * var object = { 'user': 'fred' };\n\t     * var getter = _.constant(object);\n\t     *\n\t     * getter() === object;\n\t     * // => true\n\t     */\n\t    function constant(value) {\n\t      return function() {\n\t        return value;\n\t      };\n\t    }\n\t\n\t    /**\n\t     * This method returns the first argument provided to it.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Utility\n\t     * @param {*} value Any value.\n\t     * @returns {*} Returns `value`.\n\t     * @example\n\t     *\n\t     * var object = { 'user': 'fred' };\n\t     *\n\t     * _.identity(object) === object;\n\t     * // => true\n\t     */\n\t    function identity(value) {\n\t      return value;\n\t    }\n\t\n\t    /**\n\t     * Creates a function that performs a deep comparison between a given object\n\t     * and `source`, returning `true` if the given object has equivalent property\n\t     * values, else `false`.\n\t     *\n\t     * **Note:** This method supports comparing arrays, booleans, `Date` objects,\n\t     * numbers, `Object` objects, regexes, and strings. Objects are compared by\n\t     * their own, not inherited, enumerable properties. For comparing a single\n\t     * own or inherited property value see `_.matchesProperty`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Utility\n\t     * @param {Object} source The object of property values to match.\n\t     * @returns {Function} Returns the new function.\n\t     * @example\n\t     *\n\t     * var users = [\n\t     *   { 'user': 'barney', 'age': 36, 'active': true },\n\t     *   { 'user': 'fred',   'age': 40, 'active': false }\n\t     * ];\n\t     *\n\t     * _.filter(users, _.matches({ 'age': 40, 'active': false }));\n\t     * // => [{ 'user': 'fred', 'age': 40, 'active': false }]\n\t     */\n\t    function matches(source) {\n\t      return baseMatches(baseClone(source, true));\n\t    }\n\t\n\t    /**\n\t     * Creates a function that compares the property value of `path` on a given\n\t     * object to `value`.\n\t     *\n\t     * **Note:** This method supports comparing arrays, booleans, `Date` objects,\n\t     * numbers, `Object` objects, regexes, and strings. Objects are compared by\n\t     * their own, not inherited, enumerable properties.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Utility\n\t     * @param {Array|string} path The path of the property to get.\n\t     * @param {*} srcValue The value to match.\n\t     * @returns {Function} Returns the new function.\n\t     * @example\n\t     *\n\t     * var users = [\n\t     *   { 'user': 'barney' },\n\t     *   { 'user': 'fred' }\n\t     * ];\n\t     *\n\t     * _.find(users, _.matchesProperty('user', 'fred'));\n\t     * // => { 'user': 'fred' }\n\t     */\n\t    function matchesProperty(path, srcValue) {\n\t      return baseMatchesProperty(path, baseClone(srcValue, true));\n\t    }\n\t\n\t    /**\n\t     * Creates a function that invokes the method at `path` on a given object.\n\t     * Any additional arguments are provided to the invoked method.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Utility\n\t     * @param {Array|string} path The path of the method to invoke.\n\t     * @param {...*} [args] The arguments to invoke the method with.\n\t     * @returns {Function} Returns the new function.\n\t     * @example\n\t     *\n\t     * var objects = [\n\t     *   { 'a': { 'b': { 'c': _.constant(2) } } },\n\t     *   { 'a': { 'b': { 'c': _.constant(1) } } }\n\t     * ];\n\t     *\n\t     * _.map(objects, _.method('a.b.c'));\n\t     * // => [2, 1]\n\t     *\n\t     * _.invoke(_.sortBy(objects, _.method(['a', 'b', 'c'])), 'a.b.c');\n\t     * // => [1, 2]\n\t     */\n\t    var method = restParam(function(path, args) {\n\t      return function(object) {\n\t        return invokePath(object, path, args);\n\t      };\n\t    });\n\t\n\t    /**\n\t     * The opposite of `_.method`; this method creates a function that invokes\n\t     * the method at a given path on `object`. Any additional arguments are\n\t     * provided to the invoked method.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Utility\n\t     * @param {Object} object The object to query.\n\t     * @param {...*} [args] The arguments to invoke the method with.\n\t     * @returns {Function} Returns the new function.\n\t     * @example\n\t     *\n\t     * var array = _.times(3, _.constant),\n\t     *     object = { 'a': array, 'b': array, 'c': array };\n\t     *\n\t     * _.map(['a[2]', 'c[0]'], _.methodOf(object));\n\t     * // => [2, 0]\n\t     *\n\t     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));\n\t     * // => [2, 0]\n\t     */\n\t    var methodOf = restParam(function(object, args) {\n\t      return function(path) {\n\t        return invokePath(object, path, args);\n\t      };\n\t    });\n\t\n\t    /**\n\t     * Adds all own enumerable function properties of a source object to the\n\t     * destination object. If `object` is a function then methods are added to\n\t     * its prototype as well.\n\t     *\n\t     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to\n\t     * avoid conflicts caused by modifying the original.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Utility\n\t     * @param {Function|Object} [object=lodash] The destination object.\n\t     * @param {Object} source The object of functions to add.\n\t     * @param {Object} [options] The options object.\n\t     * @param {boolean} [options.chain=true] Specify whether the functions added\n\t     *  are chainable.\n\t     * @returns {Function|Object} Returns `object`.\n\t     * @example\n\t     *\n\t     * function vowels(string) {\n\t     *   return _.filter(string, function(v) {\n\t     *     return /[aeiou]/i.test(v);\n\t     *   });\n\t     * }\n\t     *\n\t     * _.mixin({ 'vowels': vowels });\n\t     * _.vowels('fred');\n\t     * // => ['e']\n\t     *\n\t     * _('fred').vowels().value();\n\t     * // => ['e']\n\t     *\n\t     * _.mixin({ 'vowels': vowels }, { 'chain': false });\n\t     * _('fred').vowels();\n\t     * // => ['e']\n\t     */\n\t    function mixin(object, source, options) {\n\t      if (options == null) {\n\t        var isObj = isObject(source),\n\t            props = isObj ? keys(source) : undefined,\n\t            methodNames = (props && props.length) ? baseFunctions(source, props) : undefined;\n\t\n\t        if (!(methodNames ? methodNames.length : isObj)) {\n\t          methodNames = false;\n\t          options = source;\n\t          source = object;\n\t          object = this;\n\t        }\n\t      }\n\t      if (!methodNames) {\n\t        methodNames = baseFunctions(source, keys(source));\n\t      }\n\t      var chain = true,\n\t          index = -1,\n\t          isFunc = isFunction(object),\n\t          length = methodNames.length;\n\t\n\t      if (options === false) {\n\t        chain = false;\n\t      } else if (isObject(options) && 'chain' in options) {\n\t        chain = options.chain;\n\t      }\n\t      while (++index < length) {\n\t        var methodName = methodNames[index],\n\t            func = source[methodName];\n\t\n\t        object[methodName] = func;\n\t        if (isFunc) {\n\t          object.prototype[methodName] = (function(func) {\n\t            return function() {\n\t              var chainAll = this.__chain__;\n\t              if (chain || chainAll) {\n\t                var result = object(this.__wrapped__),\n\t                    actions = result.__actions__ = arrayCopy(this.__actions__);\n\t\n\t                actions.push({ 'func': func, 'args': arguments, 'thisArg': object });\n\t                result.__chain__ = chainAll;\n\t                return result;\n\t              }\n\t              return func.apply(object, arrayPush([this.value()], arguments));\n\t            };\n\t          }(func));\n\t        }\n\t      }\n\t      return object;\n\t    }\n\t\n\t    /**\n\t     * Reverts the `_` variable to its previous value and returns a reference to\n\t     * the `lodash` function.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Utility\n\t     * @returns {Function} Returns the `lodash` function.\n\t     * @example\n\t     *\n\t     * var lodash = _.noConflict();\n\t     */\n\t    function noConflict() {\n\t      root._ = oldDash;\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * A no-operation function that returns `undefined` regardless of the\n\t     * arguments it receives.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Utility\n\t     * @example\n\t     *\n\t     * var object = { 'user': 'fred' };\n\t     *\n\t     * _.noop(object) === undefined;\n\t     * // => true\n\t     */\n\t    function noop() {\n\t      // No operation performed.\n\t    }\n\t\n\t    /**\n\t     * Creates a function that returns the property value at `path` on a\n\t     * given object.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Utility\n\t     * @param {Array|string} path The path of the property to get.\n\t     * @returns {Function} Returns the new function.\n\t     * @example\n\t     *\n\t     * var objects = [\n\t     *   { 'a': { 'b': { 'c': 2 } } },\n\t     *   { 'a': { 'b': { 'c': 1 } } }\n\t     * ];\n\t     *\n\t     * _.map(objects, _.property('a.b.c'));\n\t     * // => [2, 1]\n\t     *\n\t     * _.pluck(_.sortBy(objects, _.property(['a', 'b', 'c'])), 'a.b.c');\n\t     * // => [1, 2]\n\t     */\n\t    function property(path) {\n\t      return isKey(path) ? baseProperty(path) : basePropertyDeep(path);\n\t    }\n\t\n\t    /**\n\t     * The opposite of `_.property`; this method creates a function that returns\n\t     * the property value at a given path on `object`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Utility\n\t     * @param {Object} object The object to query.\n\t     * @returns {Function} Returns the new function.\n\t     * @example\n\t     *\n\t     * var array = [0, 1, 2],\n\t     *     object = { 'a': array, 'b': array, 'c': array };\n\t     *\n\t     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));\n\t     * // => [2, 0]\n\t     *\n\t     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));\n\t     * // => [2, 0]\n\t     */\n\t    function propertyOf(object) {\n\t      return function(path) {\n\t        return baseGet(object, toPath(path), path + '');\n\t      };\n\t    }\n\t\n\t    /**\n\t     * Creates an array of numbers (positive and/or negative) progressing from\n\t     * `start` up to, but not including, `end`. If `end` is not specified it is\n\t     * set to `start` with `start` then set to `0`. If `end` is less than `start`\n\t     * a zero-length range is created unless a negative `step` is specified.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Utility\n\t     * @param {number} [start=0] The start of the range.\n\t     * @param {number} end The end of the range.\n\t     * @param {number} [step=1] The value to increment or decrement by.\n\t     * @returns {Array} Returns the new array of numbers.\n\t     * @example\n\t     *\n\t     * _.range(4);\n\t     * // => [0, 1, 2, 3]\n\t     *\n\t     * _.range(1, 5);\n\t     * // => [1, 2, 3, 4]\n\t     *\n\t     * _.range(0, 20, 5);\n\t     * // => [0, 5, 10, 15]\n\t     *\n\t     * _.range(0, -4, -1);\n\t     * // => [0, -1, -2, -3]\n\t     *\n\t     * _.range(1, 4, 0);\n\t     * // => [1, 1, 1]\n\t     *\n\t     * _.range(0);\n\t     * // => []\n\t     */\n\t    function range(start, end, step) {\n\t      if (step && isIterateeCall(start, end, step)) {\n\t        end = step = undefined;\n\t      }\n\t      start = +start || 0;\n\t      step = step == null ? 1 : (+step || 0);\n\t\n\t      if (end == null) {\n\t        end = start;\n\t        start = 0;\n\t      } else {\n\t        end = +end || 0;\n\t      }\n\t      // Use `Array(length)` so engines like Chakra and V8 avoid slower modes.\n\t      // See https://youtu.be/XAqIpGU8ZZk#t=17m25s for more details.\n\t      var index = -1,\n\t          length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),\n\t          result = Array(length);\n\t\n\t      while (++index < length) {\n\t        result[index] = start;\n\t        start += step;\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * Invokes the iteratee function `n` times, returning an array of the results\n\t     * of each invocation. The `iteratee` is bound to `thisArg` and invoked with\n\t     * one argument; (index).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Utility\n\t     * @param {number} n The number of times to invoke `iteratee`.\n\t     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n\t     * @param {*} [thisArg] The `this` binding of `iteratee`.\n\t     * @returns {Array} Returns the array of results.\n\t     * @example\n\t     *\n\t     * var diceRolls = _.times(3, _.partial(_.random, 1, 6, false));\n\t     * // => [3, 6, 4]\n\t     *\n\t     * _.times(3, function(n) {\n\t     *   mage.castSpell(n);\n\t     * });\n\t     * // => invokes `mage.castSpell(n)` three times with `n` of `0`, `1`, and `2`\n\t     *\n\t     * _.times(3, function(n) {\n\t     *   this.cast(n);\n\t     * }, mage);\n\t     * // => also invokes `mage.castSpell(n)` three times\n\t     */\n\t    function times(n, iteratee, thisArg) {\n\t      n = nativeFloor(n);\n\t\n\t      // Exit early to avoid a JSC JIT bug in Safari 8\n\t      // where `Array(0)` is treated as `Array(1)`.\n\t      if (n < 1 || !nativeIsFinite(n)) {\n\t        return [];\n\t      }\n\t      var index = -1,\n\t          result = Array(nativeMin(n, MAX_ARRAY_LENGTH));\n\t\n\t      iteratee = bindCallback(iteratee, thisArg, 1);\n\t      while (++index < n) {\n\t        if (index < MAX_ARRAY_LENGTH) {\n\t          result[index] = iteratee(index);\n\t        } else {\n\t          iteratee(index);\n\t        }\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * Generates a unique ID. If `prefix` is provided the ID is appended to it.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Utility\n\t     * @param {string} [prefix] The value to prefix the ID with.\n\t     * @returns {string} Returns the unique ID.\n\t     * @example\n\t     *\n\t     * _.uniqueId('contact_');\n\t     * // => 'contact_104'\n\t     *\n\t     * _.uniqueId();\n\t     * // => '105'\n\t     */\n\t    function uniqueId(prefix) {\n\t      var id = ++idCounter;\n\t      return baseToString(prefix) + id;\n\t    }\n\t\n\t    /*------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * Adds two numbers.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Math\n\t     * @param {number} augend The first number to add.\n\t     * @param {number} addend The second number to add.\n\t     * @returns {number} Returns the sum.\n\t     * @example\n\t     *\n\t     * _.add(6, 4);\n\t     * // => 10\n\t     */\n\t    function add(augend, addend) {\n\t      return (+augend || 0) + (+addend || 0);\n\t    }\n\t\n\t    /**\n\t     * Calculates `n` rounded up to `precision`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Math\n\t     * @param {number} n The number to round up.\n\t     * @param {number} [precision=0] The precision to round up to.\n\t     * @returns {number} Returns the rounded up number.\n\t     * @example\n\t     *\n\t     * _.ceil(4.006);\n\t     * // => 5\n\t     *\n\t     * _.ceil(6.004, 2);\n\t     * // => 6.01\n\t     *\n\t     * _.ceil(6040, -2);\n\t     * // => 6100\n\t     */\n\t    var ceil = createRound('ceil');\n\t\n\t    /**\n\t     * Calculates `n` rounded down to `precision`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Math\n\t     * @param {number} n The number to round down.\n\t     * @param {number} [precision=0] The precision to round down to.\n\t     * @returns {number} Returns the rounded down number.\n\t     * @example\n\t     *\n\t     * _.floor(4.006);\n\t     * // => 4\n\t     *\n\t     * _.floor(0.046, 2);\n\t     * // => 0.04\n\t     *\n\t     * _.floor(4060, -2);\n\t     * // => 4000\n\t     */\n\t    var floor = createRound('floor');\n\t\n\t    /**\n\t     * Gets the maximum value of `collection`. If `collection` is empty or falsey\n\t     * `-Infinity` is returned. If an iteratee function is provided it is invoked\n\t     * for each value in `collection` to generate the criterion by which the value\n\t     * is ranked. The `iteratee` is bound to `thisArg` and invoked with three\n\t     * arguments: (value, index, collection).\n\t     *\n\t     * If a property name is provided for `iteratee` the created `_.property`\n\t     * style callback returns the property value of the given element.\n\t     *\n\t     * If a value is also provided for `thisArg` the created `_.matchesProperty`\n\t     * style callback returns `true` for elements that have a matching property\n\t     * value, else `false`.\n\t     *\n\t     * If an object is provided for `iteratee` the created `_.matches` style\n\t     * callback returns `true` for elements that have the properties of the given\n\t     * object, else `false`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Math\n\t     * @param {Array|Object|string} collection The collection to iterate over.\n\t     * @param {Function|Object|string} [iteratee] The function invoked per iteration.\n\t     * @param {*} [thisArg] The `this` binding of `iteratee`.\n\t     * @returns {*} Returns the maximum value.\n\t     * @example\n\t     *\n\t     * _.max([4, 2, 8, 6]);\n\t     * // => 8\n\t     *\n\t     * _.max([]);\n\t     * // => -Infinity\n\t     *\n\t     * var users = [\n\t     *   { 'user': 'barney', 'age': 36 },\n\t     *   { 'user': 'fred',   'age': 40 }\n\t     * ];\n\t     *\n\t     * _.max(users, function(chr) {\n\t     *   return chr.age;\n\t     * });\n\t     * // => { 'user': 'fred', 'age': 40 }\n\t     *\n\t     * // using the `_.property` callback shorthand\n\t     * _.max(users, 'age');\n\t     * // => { 'user': 'fred', 'age': 40 }\n\t     */\n\t    var max = createExtremum(gt, NEGATIVE_INFINITY);\n\t\n\t    /**\n\t     * Gets the minimum value of `collection`. If `collection` is empty or falsey\n\t     * `Infinity` is returned. If an iteratee function is provided it is invoked\n\t     * for each value in `collection` to generate the criterion by which the value\n\t     * is ranked. The `iteratee` is bound to `thisArg` and invoked with three\n\t     * arguments: (value, index, collection).\n\t     *\n\t     * If a property name is provided for `iteratee` the created `_.property`\n\t     * style callback returns the property value of the given element.\n\t     *\n\t     * If a value is also provided for `thisArg` the created `_.matchesProperty`\n\t     * style callback returns `true` for elements that have a matching property\n\t     * value, else `false`.\n\t     *\n\t     * If an object is provided for `iteratee` the created `_.matches` style\n\t     * callback returns `true` for elements that have the properties of the given\n\t     * object, else `false`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Math\n\t     * @param {Array|Object|string} collection The collection to iterate over.\n\t     * @param {Function|Object|string} [iteratee] The function invoked per iteration.\n\t     * @param {*} [thisArg] The `this` binding of `iteratee`.\n\t     * @returns {*} Returns the minimum value.\n\t     * @example\n\t     *\n\t     * _.min([4, 2, 8, 6]);\n\t     * // => 2\n\t     *\n\t     * _.min([]);\n\t     * // => Infinity\n\t     *\n\t     * var users = [\n\t     *   { 'user': 'barney', 'age': 36 },\n\t     *   { 'user': 'fred',   'age': 40 }\n\t     * ];\n\t     *\n\t     * _.min(users, function(chr) {\n\t     *   return chr.age;\n\t     * });\n\t     * // => { 'user': 'barney', 'age': 36 }\n\t     *\n\t     * // using the `_.property` callback shorthand\n\t     * _.min(users, 'age');\n\t     * // => { 'user': 'barney', 'age': 36 }\n\t     */\n\t    var min = createExtremum(lt, POSITIVE_INFINITY);\n\t\n\t    /**\n\t     * Calculates `n` rounded to `precision`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Math\n\t     * @param {number} n The number to round.\n\t     * @param {number} [precision=0] The precision to round to.\n\t     * @returns {number} Returns the rounded number.\n\t     * @example\n\t     *\n\t     * _.round(4.006);\n\t     * // => 4\n\t     *\n\t     * _.round(4.006, 2);\n\t     * // => 4.01\n\t     *\n\t     * _.round(4060, -2);\n\t     * // => 4100\n\t     */\n\t    var round = createRound('round');\n\t\n\t    /**\n\t     * Gets the sum of the values in `collection`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Math\n\t     * @param {Array|Object|string} collection The collection to iterate over.\n\t     * @param {Function|Object|string} [iteratee] The function invoked per iteration.\n\t     * @param {*} [thisArg] The `this` binding of `iteratee`.\n\t     * @returns {number} Returns the sum.\n\t     * @example\n\t     *\n\t     * _.sum([4, 6]);\n\t     * // => 10\n\t     *\n\t     * _.sum({ 'a': 4, 'b': 6 });\n\t     * // => 10\n\t     *\n\t     * var objects = [\n\t     *   { 'n': 4 },\n\t     *   { 'n': 6 }\n\t     * ];\n\t     *\n\t     * _.sum(objects, function(object) {\n\t     *   return object.n;\n\t     * });\n\t     * // => 10\n\t     *\n\t     * // using the `_.property` callback shorthand\n\t     * _.sum(objects, 'n');\n\t     * // => 10\n\t     */\n\t    function sum(collection, iteratee, thisArg) {\n\t      if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {\n\t        iteratee = undefined;\n\t      }\n\t      iteratee = getCallback(iteratee, thisArg, 3);\n\t      return iteratee.length == 1\n\t        ? arraySum(isArray(collection) ? collection : toIterable(collection), iteratee)\n\t        : baseSum(collection, iteratee);\n\t    }\n\t\n\t    /*------------------------------------------------------------------------*/\n\t\n\t    // Ensure wrappers are instances of `baseLodash`.\n\t    lodash.prototype = baseLodash.prototype;\n\t\n\t    LodashWrapper.prototype = baseCreate(baseLodash.prototype);\n\t    LodashWrapper.prototype.constructor = LodashWrapper;\n\t\n\t    LazyWrapper.prototype = baseCreate(baseLodash.prototype);\n\t    LazyWrapper.prototype.constructor = LazyWrapper;\n\t\n\t    // Add functions to the `Map` cache.\n\t    MapCache.prototype['delete'] = mapDelete;\n\t    MapCache.prototype.get = mapGet;\n\t    MapCache.prototype.has = mapHas;\n\t    MapCache.prototype.set = mapSet;\n\t\n\t    // Add functions to the `Set` cache.\n\t    SetCache.prototype.push = cachePush;\n\t\n\t    // Assign cache to `_.memoize`.\n\t    memoize.Cache = MapCache;\n\t\n\t    // Add functions that return wrapped values when chaining.\n\t    lodash.after = after;\n\t    lodash.ary = ary;\n\t    lodash.assign = assign;\n\t    lodash.at = at;\n\t    lodash.before = before;\n\t    lodash.bind = bind;\n\t    lodash.bindAll = bindAll;\n\t    lodash.bindKey = bindKey;\n\t    lodash.callback = callback;\n\t    lodash.chain = chain;\n\t    lodash.chunk = chunk;\n\t    lodash.compact = compact;\n\t    lodash.constant = constant;\n\t    lodash.countBy = countBy;\n\t    lodash.create = create;\n\t    lodash.curry = curry;\n\t    lodash.curryRight = curryRight;\n\t    lodash.debounce = debounce;\n\t    lodash.defaults = defaults;\n\t    lodash.defaultsDeep = defaultsDeep;\n\t    lodash.defer = defer;\n\t    lodash.delay = delay;\n\t    lodash.difference = difference;\n\t    lodash.drop = drop;\n\t    lodash.dropRight = dropRight;\n\t    lodash.dropRightWhile = dropRightWhile;\n\t    lodash.dropWhile = dropWhile;\n\t    lodash.fill = fill;\n\t    lodash.filter = filter;\n\t    lodash.flatten = flatten;\n\t    lodash.flattenDeep = flattenDeep;\n\t    lodash.flow = flow;\n\t    lodash.flowRight = flowRight;\n\t    lodash.forEach = forEach;\n\t    lodash.forEachRight = forEachRight;\n\t    lodash.forIn = forIn;\n\t    lodash.forInRight = forInRight;\n\t    lodash.forOwn = forOwn;\n\t    lodash.forOwnRight = forOwnRight;\n\t    lodash.functions = functions;\n\t    lodash.groupBy = groupBy;\n\t    lodash.indexBy = indexBy;\n\t    lodash.initial = initial;\n\t    lodash.intersection = intersection;\n\t    lodash.invert = invert;\n\t    lodash.invoke = invoke;\n\t    lodash.keys = keys;\n\t    lodash.keysIn = keysIn;\n\t    lodash.map = map;\n\t    lodash.mapKeys = mapKeys;\n\t    lodash.mapValues = mapValues;\n\t    lodash.matches = matches;\n\t    lodash.matchesProperty = matchesProperty;\n\t    lodash.memoize = memoize;\n\t    lodash.merge = merge;\n\t    lodash.method = method;\n\t    lodash.methodOf = methodOf;\n\t    lodash.mixin = mixin;\n\t    lodash.modArgs = modArgs;\n\t    lodash.negate = negate;\n\t    lodash.omit = omit;\n\t    lodash.once = once;\n\t    lodash.pairs = pairs;\n\t    lodash.partial = partial;\n\t    lodash.partialRight = partialRight;\n\t    lodash.partition = partition;\n\t    lodash.pick = pick;\n\t    lodash.pluck = pluck;\n\t    lodash.property = property;\n\t    lodash.propertyOf = propertyOf;\n\t    lodash.pull = pull;\n\t    lodash.pullAt = pullAt;\n\t    lodash.range = range;\n\t    lodash.rearg = rearg;\n\t    lodash.reject = reject;\n\t    lodash.remove = remove;\n\t    lodash.rest = rest;\n\t    lodash.restParam = restParam;\n\t    lodash.set = set;\n\t    lodash.shuffle = shuffle;\n\t    lodash.slice = slice;\n\t    lodash.sortBy = sortBy;\n\t    lodash.sortByAll = sortByAll;\n\t    lodash.sortByOrder = sortByOrder;\n\t    lodash.spread = spread;\n\t    lodash.take = take;\n\t    lodash.takeRight = takeRight;\n\t    lodash.takeRightWhile = takeRightWhile;\n\t    lodash.takeWhile = takeWhile;\n\t    lodash.tap = tap;\n\t    lodash.throttle = throttle;\n\t    lodash.thru = thru;\n\t    lodash.times = times;\n\t    lodash.toArray = toArray;\n\t    lodash.toPlainObject = toPlainObject;\n\t    lodash.transform = transform;\n\t    lodash.union = union;\n\t    lodash.uniq = uniq;\n\t    lodash.unzip = unzip;\n\t    lodash.unzipWith = unzipWith;\n\t    lodash.values = values;\n\t    lodash.valuesIn = valuesIn;\n\t    lodash.where = where;\n\t    lodash.without = without;\n\t    lodash.wrap = wrap;\n\t    lodash.xor = xor;\n\t    lodash.zip = zip;\n\t    lodash.zipObject = zipObject;\n\t    lodash.zipWith = zipWith;\n\t\n\t    // Add aliases.\n\t    lodash.backflow = flowRight;\n\t    lodash.collect = map;\n\t    lodash.compose = flowRight;\n\t    lodash.each = forEach;\n\t    lodash.eachRight = forEachRight;\n\t    lodash.extend = assign;\n\t    lodash.iteratee = callback;\n\t    lodash.methods = functions;\n\t    lodash.object = zipObject;\n\t    lodash.select = filter;\n\t    lodash.tail = rest;\n\t    lodash.unique = uniq;\n\t\n\t    // Add functions to `lodash.prototype`.\n\t    mixin(lodash, lodash);\n\t\n\t    /*------------------------------------------------------------------------*/\n\t\n\t    // Add functions that return unwrapped values when chaining.\n\t    lodash.add = add;\n\t    lodash.attempt = attempt;\n\t    lodash.camelCase = camelCase;\n\t    lodash.capitalize = capitalize;\n\t    lodash.ceil = ceil;\n\t    lodash.clone = clone;\n\t    lodash.cloneDeep = cloneDeep;\n\t    lodash.deburr = deburr;\n\t    lodash.endsWith = endsWith;\n\t    lodash.escape = escape;\n\t    lodash.escapeRegExp = escapeRegExp;\n\t    lodash.every = every;\n\t    lodash.find = find;\n\t    lodash.findIndex = findIndex;\n\t    lodash.findKey = findKey;\n\t    lodash.findLast = findLast;\n\t    lodash.findLastIndex = findLastIndex;\n\t    lodash.findLastKey = findLastKey;\n\t    lodash.findWhere = findWhere;\n\t    lodash.first = first;\n\t    lodash.floor = floor;\n\t    lodash.get = get;\n\t    lodash.gt = gt;\n\t    lodash.gte = gte;\n\t    lodash.has = has;\n\t    lodash.identity = identity;\n\t    lodash.includes = includes;\n\t    lodash.indexOf = indexOf;\n\t    lodash.inRange = inRange;\n\t    lodash.isArguments = isArguments;\n\t    lodash.isArray = isArray;\n\t    lodash.isBoolean = isBoolean;\n\t    lodash.isDate = isDate;\n\t    lodash.isElement = isElement;\n\t    lodash.isEmpty = isEmpty;\n\t    lodash.isEqual = isEqual;\n\t    lodash.isError = isError;\n\t    lodash.isFinite = isFinite;\n\t    lodash.isFunction = isFunction;\n\t    lodash.isMatch = isMatch;\n\t    lodash.isNaN = isNaN;\n\t    lodash.isNative = isNative;\n\t    lodash.isNull = isNull;\n\t    lodash.isNumber = isNumber;\n\t    lodash.isObject = isObject;\n\t    lodash.isPlainObject = isPlainObject;\n\t    lodash.isRegExp = isRegExp;\n\t    lodash.isString = isString;\n\t    lodash.isTypedArray = isTypedArray;\n\t    lodash.isUndefined = isUndefined;\n\t    lodash.kebabCase = kebabCase;\n\t    lodash.last = last;\n\t    lodash.lastIndexOf = lastIndexOf;\n\t    lodash.lt = lt;\n\t    lodash.lte = lte;\n\t    lodash.max = max;\n\t    lodash.min = min;\n\t    lodash.noConflict = noConflict;\n\t    lodash.noop = noop;\n\t    lodash.now = now;\n\t    lodash.pad = pad;\n\t    lodash.padLeft = padLeft;\n\t    lodash.padRight = padRight;\n\t    lodash.parseInt = parseInt;\n\t    lodash.random = random;\n\t    lodash.reduce = reduce;\n\t    lodash.reduceRight = reduceRight;\n\t    lodash.repeat = repeat;\n\t    lodash.result = result;\n\t    lodash.round = round;\n\t    lodash.runInContext = runInContext;\n\t    lodash.size = size;\n\t    lodash.snakeCase = snakeCase;\n\t    lodash.some = some;\n\t    lodash.sortedIndex = sortedIndex;\n\t    lodash.sortedLastIndex = sortedLastIndex;\n\t    lodash.startCase = startCase;\n\t    lodash.startsWith = startsWith;\n\t    lodash.sum = sum;\n\t    lodash.template = template;\n\t    lodash.trim = trim;\n\t    lodash.trimLeft = trimLeft;\n\t    lodash.trimRight = trimRight;\n\t    lodash.trunc = trunc;\n\t    lodash.unescape = unescape;\n\t    lodash.uniqueId = uniqueId;\n\t    lodash.words = words;\n\t\n\t    // Add aliases.\n\t    lodash.all = every;\n\t    lodash.any = some;\n\t    lodash.contains = includes;\n\t    lodash.eq = isEqual;\n\t    lodash.detect = find;\n\t    lodash.foldl = reduce;\n\t    lodash.foldr = reduceRight;\n\t    lodash.head = first;\n\t    lodash.include = includes;\n\t    lodash.inject = reduce;\n\t\n\t    mixin(lodash, (function() {\n\t      var source = {};\n\t      baseForOwn(lodash, function(func, methodName) {\n\t        if (!lodash.prototype[methodName]) {\n\t          source[methodName] = func;\n\t        }\n\t      });\n\t      return source;\n\t    }()), false);\n\t\n\t    /*------------------------------------------------------------------------*/\n\t\n\t    // Add functions capable of returning wrapped and unwrapped values when chaining.\n\t    lodash.sample = sample;\n\t\n\t    lodash.prototype.sample = function(n) {\n\t      if (!this.__chain__ && n == null) {\n\t        return sample(this.value());\n\t      }\n\t      return this.thru(function(value) {\n\t        return sample(value, n);\n\t      });\n\t    };\n\t\n\t    /*------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * The semantic version number.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @type string\n\t     */\n\t    lodash.VERSION = VERSION;\n\t\n\t    // Assign default placeholders.\n\t    arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {\n\t      lodash[methodName].placeholder = lodash;\n\t    });\n\t\n\t    // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.\n\t    arrayEach(['drop', 'take'], function(methodName, index) {\n\t      LazyWrapper.prototype[methodName] = function(n) {\n\t        var filtered = this.__filtered__;\n\t        if (filtered && !index) {\n\t          return new LazyWrapper(this);\n\t        }\n\t        n = n == null ? 1 : nativeMax(nativeFloor(n) || 0, 0);\n\t\n\t        var result = this.clone();\n\t        if (filtered) {\n\t          result.__takeCount__ = nativeMin(result.__takeCount__, n);\n\t        } else {\n\t          result.__views__.push({ 'size': n, 'type': methodName + (result.__dir__ < 0 ? 'Right' : '') });\n\t        }\n\t        return result;\n\t      };\n\t\n\t      LazyWrapper.prototype[methodName + 'Right'] = function(n) {\n\t        return this.reverse()[methodName](n).reverse();\n\t      };\n\t    });\n\t\n\t    // Add `LazyWrapper` methods that accept an `iteratee` value.\n\t    arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {\n\t      var type = index + 1,\n\t          isFilter = type != LAZY_MAP_FLAG;\n\t\n\t      LazyWrapper.prototype[methodName] = function(iteratee, thisArg) {\n\t        var result = this.clone();\n\t        result.__iteratees__.push({ 'iteratee': getCallback(iteratee, thisArg, 1), 'type': type });\n\t        result.__filtered__ = result.__filtered__ || isFilter;\n\t        return result;\n\t      };\n\t    });\n\t\n\t    // Add `LazyWrapper` methods for `_.first` and `_.last`.\n\t    arrayEach(['first', 'last'], function(methodName, index) {\n\t      var takeName = 'take' + (index ? 'Right' : '');\n\t\n\t      LazyWrapper.prototype[methodName] = function() {\n\t        return this[takeName](1).value()[0];\n\t      };\n\t    });\n\t\n\t    // Add `LazyWrapper` methods for `_.initial` and `_.rest`.\n\t    arrayEach(['initial', 'rest'], function(methodName, index) {\n\t      var dropName = 'drop' + (index ? '' : 'Right');\n\t\n\t      LazyWrapper.prototype[methodName] = function() {\n\t        return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);\n\t      };\n\t    });\n\t\n\t    // Add `LazyWrapper` methods for `_.pluck` and `_.where`.\n\t    arrayEach(['pluck', 'where'], function(methodName, index) {\n\t      var operationName = index ? 'filter' : 'map',\n\t          createCallback = index ? baseMatches : property;\n\t\n\t      LazyWrapper.prototype[methodName] = function(value) {\n\t        return this[operationName](createCallback(value));\n\t      };\n\t    });\n\t\n\t    LazyWrapper.prototype.compact = function() {\n\t      return this.filter(identity);\n\t    };\n\t\n\t    LazyWrapper.prototype.reject = function(predicate, thisArg) {\n\t      predicate = getCallback(predicate, thisArg, 1);\n\t      return this.filter(function(value) {\n\t        return !predicate(value);\n\t      });\n\t    };\n\t\n\t    LazyWrapper.prototype.slice = function(start, end) {\n\t      start = start == null ? 0 : (+start || 0);\n\t\n\t      var result = this;\n\t      if (result.__filtered__ && (start > 0 || end < 0)) {\n\t        return new LazyWrapper(result);\n\t      }\n\t      if (start < 0) {\n\t        result = result.takeRight(-start);\n\t      } else if (start) {\n\t        result = result.drop(start);\n\t      }\n\t      if (end !== undefined) {\n\t        end = (+end || 0);\n\t        result = end < 0 ? result.dropRight(-end) : result.take(end - start);\n\t      }\n\t      return result;\n\t    };\n\t\n\t    LazyWrapper.prototype.takeRightWhile = function(predicate, thisArg) {\n\t      return this.reverse().takeWhile(predicate, thisArg).reverse();\n\t    };\n\t\n\t    LazyWrapper.prototype.toArray = function() {\n\t      return this.take(POSITIVE_INFINITY);\n\t    };\n\t\n\t    // Add `LazyWrapper` methods to `lodash.prototype`.\n\t    baseForOwn(LazyWrapper.prototype, function(func, methodName) {\n\t      var checkIteratee = /^(?:filter|map|reject)|While$/.test(methodName),\n\t          retUnwrapped = /^(?:first|last)$/.test(methodName),\n\t          lodashFunc = lodash[retUnwrapped ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName];\n\t\n\t      if (!lodashFunc) {\n\t        return;\n\t      }\n\t      lodash.prototype[methodName] = function() {\n\t        var args = retUnwrapped ? [1] : arguments,\n\t            chainAll = this.__chain__,\n\t            value = this.__wrapped__,\n\t            isHybrid = !!this.__actions__.length,\n\t            isLazy = value instanceof LazyWrapper,\n\t            iteratee = args[0],\n\t            useLazy = isLazy || isArray(value);\n\t\n\t        if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {\n\t          // Avoid lazy use if the iteratee has a \"length\" value other than `1`.\n\t          isLazy = useLazy = false;\n\t        }\n\t        var interceptor = function(value) {\n\t          return (retUnwrapped && chainAll)\n\t            ? lodashFunc(value, 1)[0]\n\t            : lodashFunc.apply(undefined, arrayPush([value], args));\n\t        };\n\t\n\t        var action = { 'func': thru, 'args': [interceptor], 'thisArg': undefined },\n\t            onlyLazy = isLazy && !isHybrid;\n\t\n\t        if (retUnwrapped && !chainAll) {\n\t          if (onlyLazy) {\n\t            value = value.clone();\n\t            value.__actions__.push(action);\n\t            return func.call(value);\n\t          }\n\t          return lodashFunc.call(undefined, this.value())[0];\n\t        }\n\t        if (!retUnwrapped && useLazy) {\n\t          value = onlyLazy ? value : new LazyWrapper(this);\n\t          var result = func.apply(value, args);\n\t          result.__actions__.push(action);\n\t          return new LodashWrapper(result, chainAll);\n\t        }\n\t        return this.thru(interceptor);\n\t      };\n\t    });\n\t\n\t    // Add `Array` and `String` methods to `lodash.prototype`.\n\t    arrayEach(['join', 'pop', 'push', 'replace', 'shift', 'sort', 'splice', 'split', 'unshift'], function(methodName) {\n\t      var func = (/^(?:replace|split)$/.test(methodName) ? stringProto : arrayProto)[methodName],\n\t          chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',\n\t          retUnwrapped = /^(?:join|pop|replace|shift)$/.test(methodName);\n\t\n\t      lodash.prototype[methodName] = function() {\n\t        var args = arguments;\n\t        if (retUnwrapped && !this.__chain__) {\n\t          return func.apply(this.value(), args);\n\t        }\n\t        return this[chainName](function(value) {\n\t          return func.apply(value, args);\n\t        });\n\t      };\n\t    });\n\t\n\t    // Map minified function names to their real names.\n\t    baseForOwn(LazyWrapper.prototype, function(func, methodName) {\n\t      var lodashFunc = lodash[methodName];\n\t      if (lodashFunc) {\n\t        var key = lodashFunc.name,\n\t            names = realNames[key] || (realNames[key] = []);\n\t\n\t        names.push({ 'name': methodName, 'func': lodashFunc });\n\t      }\n\t    });\n\t\n\t    realNames[createHybridWrapper(undefined, BIND_KEY_FLAG).name] = [{ 'name': 'wrapper', 'func': undefined }];\n\t\n\t    // Add functions to the lazy wrapper.\n\t    LazyWrapper.prototype.clone = lazyClone;\n\t    LazyWrapper.prototype.reverse = lazyReverse;\n\t    LazyWrapper.prototype.value = lazyValue;\n\t\n\t    // Add chaining functions to the `lodash` wrapper.\n\t    lodash.prototype.chain = wrapperChain;\n\t    lodash.prototype.commit = wrapperCommit;\n\t    lodash.prototype.concat = wrapperConcat;\n\t    lodash.prototype.plant = wrapperPlant;\n\t    lodash.prototype.reverse = wrapperReverse;\n\t    lodash.prototype.toString = wrapperToString;\n\t    lodash.prototype.run = lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;\n\t\n\t    // Add function aliases to the `lodash` wrapper.\n\t    lodash.prototype.collect = lodash.prototype.map;\n\t    lodash.prototype.head = lodash.prototype.first;\n\t    lodash.prototype.select = lodash.prototype.filter;\n\t    lodash.prototype.tail = lodash.prototype.rest;\n\t\n\t    return lodash;\n\t  }\n\t\n\t  /*--------------------------------------------------------------------------*/\n\t\n\t  // Export lodash.\n\t  var _ = runInContext();\n\t\n\t  // Some AMD build optimizers like r.js check for condition patterns like the following:\n\t  if (true) {\n\t    // Expose lodash to the global object when an AMD loader is present to avoid\n\t    // errors in cases where lodash is loaded by a script tag and not intended\n\t    // as an AMD module. See http://requirejs.org/docs/errors.html#mismatch for\n\t    // more details.\n\t    root._ = _;\n\t\n\t    // Define as an anonymous module so, through path mapping, it can be\n\t    // referenced as the \"underscore\" module.\n\t    !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {\n\t      return _;\n\t    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t  }\n\t  // Check for `exports` after `define` in case a build optimizer adds an `exports` object.\n\t  else if (freeExports && freeModule) {\n\t    // Export for Node.js or RingoJS.\n\t    if (moduleExports) {\n\t      (freeModule.exports = _)._ = _;\n\t    }\n\t    // Export for Rhino with CommonJS support.\n\t    else {\n\t      freeExports._ = _;\n\t    }\n\t  }\n\t  else {\n\t    // Export for a browser or Rhino.\n\t    root._ = _;\n\t  }\n\t}.call(this));\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(50)(module), (function() { return this; }())))\n\n/***/ },\n/* 80 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar h = __webpack_require__(81)\n\t\n\tmodule.exports = h\n\n\n/***/ },\n/* 81 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar isArray = __webpack_require__(56);\n\t\n\tvar VNode = __webpack_require__(82);\n\tvar VText = __webpack_require__(83);\n\tvar isVNode = __webpack_require__(59);\n\tvar isVText = __webpack_require__(60);\n\tvar isWidget = __webpack_require__(61);\n\tvar isHook = __webpack_require__(66);\n\tvar isVThunk = __webpack_require__(62);\n\t\n\tvar parseTag = __webpack_require__(84);\n\tvar softSetHook = __webpack_require__(86);\n\tvar evHook = __webpack_require__(87);\n\t\n\tmodule.exports = h;\n\t\n\tfunction h(tagName, properties, children) {\n\t    var childNodes = [];\n\t    var tag, props, key, namespace;\n\t\n\t    if (!children && isChildren(properties)) {\n\t        children = properties;\n\t        props = {};\n\t    }\n\t\n\t    props = props || properties || {};\n\t    tag = parseTag(tagName, props);\n\t\n\t    // support keys\n\t    if (props.hasOwnProperty('key')) {\n\t        key = props.key;\n\t        props.key = undefined;\n\t    }\n\t\n\t    // support namespace\n\t    if (props.hasOwnProperty('namespace')) {\n\t        namespace = props.namespace;\n\t        props.namespace = undefined;\n\t    }\n\t\n\t    // fix cursor bug\n\t    if (tag === 'INPUT' &&\n\t        !namespace &&\n\t        props.hasOwnProperty('value') &&\n\t        props.value !== undefined &&\n\t        !isHook(props.value)\n\t    ) {\n\t        props.value = softSetHook(props.value);\n\t    }\n\t\n\t    transformProperties(props);\n\t\n\t    if (children !== undefined && children !== null) {\n\t        addChild(children, childNodes, tag, props);\n\t    }\n\t\n\t\n\t    return new VNode(tag, props, childNodes, key, namespace);\n\t}\n\t\n\tfunction addChild(c, childNodes, tag, props) {\n\t    if (typeof c === 'string') {\n\t        childNodes.push(new VText(c));\n\t    } else if (typeof c === 'number') {\n\t        childNodes.push(new VText(String(c)));\n\t    } else if (isChild(c)) {\n\t        childNodes.push(c);\n\t    } else if (isArray(c)) {\n\t        for (var i = 0; i < c.length; i++) {\n\t            addChild(c[i], childNodes, tag, props);\n\t        }\n\t    } else if (c === null || c === undefined) {\n\t        return;\n\t    } else {\n\t        throw UnexpectedVirtualElement({\n\t            foreignObject: c,\n\t            parentVnode: {\n\t                tagName: tag,\n\t                properties: props\n\t            }\n\t        });\n\t    }\n\t}\n\t\n\tfunction transformProperties(props) {\n\t    for (var propName in props) {\n\t        if (props.hasOwnProperty(propName)) {\n\t            var value = props[propName];\n\t\n\t            if (isHook(value)) {\n\t                continue;\n\t            }\n\t\n\t            if (propName.substr(0, 3) === 'ev-') {\n\t                // add ev-foo support\n\t                props[propName] = evHook(value);\n\t            }\n\t        }\n\t    }\n\t}\n\t\n\tfunction isChild(x) {\n\t    return isVNode(x) || isVText(x) || isWidget(x) || isVThunk(x);\n\t}\n\t\n\tfunction isChildren(x) {\n\t    return typeof x === 'string' || isArray(x) || isChild(x);\n\t}\n\t\n\tfunction UnexpectedVirtualElement(data) {\n\t    var err = new Error();\n\t\n\t    err.type = 'virtual-hyperscript.unexpected.virtual-element';\n\t    err.message = 'Unexpected virtual child passed to h().\\n' +\n\t        'Expected a VNode / Vthunk / VWidget / string but:\\n' +\n\t        'got:\\n' +\n\t        errorString(data.foreignObject) +\n\t        '.\\n' +\n\t        'The parent vnode is:\\n' +\n\t        errorString(data.parentVnode)\n\t        '\\n' +\n\t        'Suggested fix: change your `h(..., [ ... ])` callsite.';\n\t    err.foreignObject = data.foreignObject;\n\t    err.parentVnode = data.parentVnode;\n\t\n\t    return err;\n\t}\n\t\n\tfunction errorString(obj) {\n\t    try {\n\t        return JSON.stringify(obj, null, '    ');\n\t    } catch (e) {\n\t        return String(obj);\n\t    }\n\t}\n\n\n/***/ },\n/* 82 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar version = __webpack_require__(58)\n\tvar isVNode = __webpack_require__(59)\n\tvar isWidget = __webpack_require__(61)\n\tvar isThunk = __webpack_require__(62)\n\tvar isVHook = __webpack_require__(66)\n\t\n\tmodule.exports = VirtualNode\n\t\n\tvar noProperties = {}\n\tvar noChildren = []\n\t\n\tfunction VirtualNode(tagName, properties, children, key, namespace) {\n\t    this.tagName = tagName\n\t    this.properties = properties || noProperties\n\t    this.children = children || noChildren\n\t    this.key = key != null ? String(key) : undefined\n\t    this.namespace = (typeof namespace === \"string\") ? namespace : null\n\t\n\t    var count = (children && children.length) || 0\n\t    var descendants = 0\n\t    var hasWidgets = false\n\t    var hasThunks = false\n\t    var descendantHooks = false\n\t    var hooks\n\t\n\t    for (var propName in properties) {\n\t        if (properties.hasOwnProperty(propName)) {\n\t            var property = properties[propName]\n\t            if (isVHook(property) && property.unhook) {\n\t                if (!hooks) {\n\t                    hooks = {}\n\t                }\n\t\n\t                hooks[propName] = property\n\t            }\n\t        }\n\t    }\n\t\n\t    for (var i = 0; i < count; i++) {\n\t        var child = children[i]\n\t        if (isVNode(child)) {\n\t            descendants += child.count || 0\n\t\n\t            if (!hasWidgets && child.hasWidgets) {\n\t                hasWidgets = true\n\t            }\n\t\n\t            if (!hasThunks && child.hasThunks) {\n\t                hasThunks = true\n\t            }\n\t\n\t            if (!descendantHooks && (child.hooks || child.descendantHooks)) {\n\t                descendantHooks = true\n\t            }\n\t        } else if (!hasWidgets && isWidget(child)) {\n\t            if (typeof child.destroy === \"function\") {\n\t                hasWidgets = true\n\t            }\n\t        } else if (!hasThunks && isThunk(child)) {\n\t            hasThunks = true;\n\t        }\n\t    }\n\t\n\t    this.count = count + descendants\n\t    this.hasWidgets = hasWidgets\n\t    this.hasThunks = hasThunks\n\t    this.hooks = hooks\n\t    this.descendantHooks = descendantHooks\n\t}\n\t\n\tVirtualNode.prototype.version = version\n\tVirtualNode.prototype.type = \"VirtualNode\"\n\n\n/***/ },\n/* 83 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar version = __webpack_require__(58)\n\t\n\tmodule.exports = VirtualText\n\t\n\tfunction VirtualText(text) {\n\t    this.text = String(text)\n\t}\n\t\n\tVirtualText.prototype.version = version\n\tVirtualText.prototype.type = \"VirtualText\"\n\n\n/***/ },\n/* 84 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar split = __webpack_require__(85);\n\t\n\tvar classIdSplit = /([\\.#]?[a-zA-Z0-9\\u007F-\\uFFFF_:-]+)/;\n\tvar notClassId = /^\\.|#/;\n\t\n\tmodule.exports = parseTag;\n\t\n\tfunction parseTag(tag, props) {\n\t    if (!tag) {\n\t        return 'DIV';\n\t    }\n\t\n\t    var noId = !(props.hasOwnProperty('id'));\n\t\n\t    var tagParts = split(tag, classIdSplit);\n\t    var tagName = null;\n\t\n\t    if (notClassId.test(tagParts[1])) {\n\t        tagName = 'DIV';\n\t    }\n\t\n\t    var classes, part, type, i;\n\t\n\t    for (i = 0; i < tagParts.length; i++) {\n\t        part = tagParts[i];\n\t\n\t        if (!part) {\n\t            continue;\n\t        }\n\t\n\t        type = part.charAt(0);\n\t\n\t        if (!tagName) {\n\t            tagName = part;\n\t        } else if (type === '.') {\n\t            classes = classes || [];\n\t            classes.push(part.substring(1, part.length));\n\t        } else if (type === '#' && noId) {\n\t            props.id = part.substring(1, part.length);\n\t        }\n\t    }\n\t\n\t    if (classes) {\n\t        if (props.className) {\n\t            classes.push(props.className);\n\t        }\n\t\n\t        props.className = classes.join(' ');\n\t    }\n\t\n\t    return props.namespace ? tagName : tagName.toUpperCase();\n\t}\n\n\n/***/ },\n/* 85 */\n/***/ function(module, exports) {\n\n\t/*!\n\t * Cross-Browser Split 1.1.1\n\t * Copyright 2007-2012 Steven Levithan <stevenlevithan.com>\n\t * Available under the MIT License\n\t * ECMAScript compliant, uniform cross-browser split method\n\t */\n\t\n\t/**\n\t * Splits a string into an array of strings using a regex or string separator. Matches of the\n\t * separator are not included in the result array. However, if `separator` is a regex that contains\n\t * capturing groups, backreferences are spliced into the result each time `separator` is matched.\n\t * Fixes browser bugs compared to the native `String.prototype.split` and can be used reliably\n\t * cross-browser.\n\t * @param {String} str String to split.\n\t * @param {RegExp|String} separator Regex or string to use for separating the string.\n\t * @param {Number} [limit] Maximum number of items to include in the result array.\n\t * @returns {Array} Array of substrings.\n\t * @example\n\t *\n\t * // Basic use\n\t * split('a b c d', ' ');\n\t * // -> ['a', 'b', 'c', 'd']\n\t *\n\t * // With limit\n\t * split('a b c d', ' ', 2);\n\t * // -> ['a', 'b']\n\t *\n\t * // Backreferences in result array\n\t * split('..word1 word2..', /([a-z]+)(\\d+)/i);\n\t * // -> ['..', 'word', '1', ' ', 'word', '2', '..']\n\t */\n\tmodule.exports = (function split(undef) {\n\t\n\t  var nativeSplit = String.prototype.split,\n\t    compliantExecNpcg = /()??/.exec(\"\")[1] === undef,\n\t    // NPCG: nonparticipating capturing group\n\t    self;\n\t\n\t  self = function(str, separator, limit) {\n\t    // If `separator` is not a regex, use `nativeSplit`\n\t    if (Object.prototype.toString.call(separator) !== \"[object RegExp]\") {\n\t      return nativeSplit.call(str, separator, limit);\n\t    }\n\t    var output = [],\n\t      flags = (separator.ignoreCase ? \"i\" : \"\") + (separator.multiline ? \"m\" : \"\") + (separator.extended ? \"x\" : \"\") + // Proposed for ES6\n\t      (separator.sticky ? \"y\" : \"\"),\n\t      // Firefox 3+\n\t      lastLastIndex = 0,\n\t      // Make `global` and avoid `lastIndex` issues by working with a copy\n\t      separator = new RegExp(separator.source, flags + \"g\"),\n\t      separator2, match, lastIndex, lastLength;\n\t    str += \"\"; // Type-convert\n\t    if (!compliantExecNpcg) {\n\t      // Doesn't need flags gy, but they don't hurt\n\t      separator2 = new RegExp(\"^\" + separator.source + \"$(?!\\\\s)\", flags);\n\t    }\n\t    /* Values for `limit`, per the spec:\n\t     * If undefined: 4294967295 // Math.pow(2, 32) - 1\n\t     * If 0, Infinity, or NaN: 0\n\t     * If positive number: limit = Math.floor(limit); if (limit > 4294967295) limit -= 4294967296;\n\t     * If negative number: 4294967296 - Math.floor(Math.abs(limit))\n\t     * If other: Type-convert, then use the above rules\n\t     */\n\t    limit = limit === undef ? -1 >>> 0 : // Math.pow(2, 32) - 1\n\t    limit >>> 0; // ToUint32(limit)\n\t    while (match = separator.exec(str)) {\n\t      // `separator.lastIndex` is not reliable cross-browser\n\t      lastIndex = match.index + match[0].length;\n\t      if (lastIndex > lastLastIndex) {\n\t        output.push(str.slice(lastLastIndex, match.index));\n\t        // Fix browsers whose `exec` methods don't consistently return `undefined` for\n\t        // nonparticipating capturing groups\n\t        if (!compliantExecNpcg && match.length > 1) {\n\t          match[0].replace(separator2, function() {\n\t            for (var i = 1; i < arguments.length - 2; i++) {\n\t              if (arguments[i] === undef) {\n\t                match[i] = undef;\n\t              }\n\t            }\n\t          });\n\t        }\n\t        if (match.length > 1 && match.index < str.length) {\n\t          Array.prototype.push.apply(output, match.slice(1));\n\t        }\n\t        lastLength = match[0].length;\n\t        lastLastIndex = lastIndex;\n\t        if (output.length >= limit) {\n\t          break;\n\t        }\n\t      }\n\t      if (separator.lastIndex === match.index) {\n\t        separator.lastIndex++; // Avoid an infinite loop\n\t      }\n\t    }\n\t    if (lastLastIndex === str.length) {\n\t      if (lastLength || !separator.test(\"\")) {\n\t        output.push(\"\");\n\t      }\n\t    } else {\n\t      output.push(str.slice(lastLastIndex));\n\t    }\n\t    return output.length > limit ? output.slice(0, limit) : output;\n\t  };\n\t\n\t  return self;\n\t})();\n\n\n/***/ },\n/* 86 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tmodule.exports = SoftSetHook;\n\t\n\tfunction SoftSetHook(value) {\n\t    if (!(this instanceof SoftSetHook)) {\n\t        return new SoftSetHook(value);\n\t    }\n\t\n\t    this.value = value;\n\t}\n\t\n\tSoftSetHook.prototype.hook = function (node, propertyName) {\n\t    if (node[propertyName] !== this.value) {\n\t        node[propertyName] = this.value;\n\t    }\n\t};\n\n\n/***/ },\n/* 87 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar EvStore = __webpack_require__(88);\n\t\n\tmodule.exports = EvHook;\n\t\n\tfunction EvHook(value) {\n\t    if (!(this instanceof EvHook)) {\n\t        return new EvHook(value);\n\t    }\n\t\n\t    this.value = value;\n\t}\n\t\n\tEvHook.prototype.hook = function (node, propertyName) {\n\t    var es = EvStore(node);\n\t    var propName = propertyName.substr(3);\n\t\n\t    es[propName] = this.value;\n\t};\n\t\n\tEvHook.prototype.unhook = function(node, propertyName) {\n\t    var es = EvStore(node);\n\t    var propName = propertyName.substr(3);\n\t\n\t    es[propName] = undefined;\n\t};\n\n\n/***/ },\n/* 88 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar OneVersionConstraint = __webpack_require__(89);\n\t\n\tvar MY_VERSION = '7';\n\tOneVersionConstraint('ev-store', MY_VERSION);\n\t\n\tvar hashKey = '__EV_STORE_KEY@' + MY_VERSION;\n\t\n\tmodule.exports = EvStore;\n\t\n\tfunction EvStore(elem) {\n\t    var hash = elem[hashKey];\n\t\n\t    if (!hash) {\n\t        hash = elem[hashKey] = {};\n\t    }\n\t\n\t    return hash;\n\t}\n\n\n/***/ },\n/* 89 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar Individual = __webpack_require__(90);\n\t\n\tmodule.exports = OneVersion;\n\t\n\tfunction OneVersion(moduleName, version, defaultValue) {\n\t    var key = '__INDIVIDUAL_ONE_VERSION_' + moduleName;\n\t    var enforceKey = key + '_ENFORCE_SINGLETON';\n\t\n\t    var versionValue = Individual(enforceKey, version);\n\t\n\t    if (versionValue !== version) {\n\t        throw new Error('Can only have one copy of ' +\n\t            moduleName + '.\\n' +\n\t            'You already have version ' + versionValue +\n\t            ' installed.\\n' +\n\t            'This means you cannot install version ' + version);\n\t    }\n\t\n\t    return Individual(key, defaultValue);\n\t}\n\n\n/***/ },\n/* 90 */\n/***/ function(module, exports) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {'use strict';\n\t\n\t/*global window, global*/\n\t\n\tvar root = typeof window !== 'undefined' ?\n\t    window : typeof global !== 'undefined' ?\n\t    global : {};\n\t\n\tmodule.exports = Individual;\n\t\n\tfunction Individual(key, value) {\n\t    if (key in root) {\n\t        return root[key];\n\t    }\n\t\n\t    root[key] = value;\n\t\n\t    return value;\n\t}\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 91 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Individual = __webpack_require__(92)\n\tvar cuid = __webpack_require__(93)\n\tvar globalDocument = __webpack_require__(69)\n\t\n\tvar DOMDelegator = __webpack_require__(94)\n\t\n\tvar versionKey = \"13\"\n\tvar cacheKey = \"__DOM_DELEGATOR_CACHE@\" + versionKey\n\tvar cacheTokenKey = \"__DOM_DELEGATOR_CACHE_TOKEN@\" + versionKey\n\tvar delegatorCache = Individual(cacheKey, {\n\t    delegators: {}\n\t})\n\tvar commonEvents = [\n\t    \"blur\", \"change\", \"click\",  \"contextmenu\", \"dblclick\",\n\t    \"error\",\"focus\", \"focusin\", \"focusout\", \"input\", \"keydown\",\n\t    \"keypress\", \"keyup\", \"load\", \"mousedown\", \"mouseup\",\n\t    \"resize\", \"select\", \"submit\", \"touchcancel\",\n\t    \"touchend\", \"touchstart\", \"unload\"\n\t]\n\t\n\t/*  Delegator is a thin wrapper around a singleton `DOMDelegator`\n\t        instance.\n\t\n\t    Only one DOMDelegator should exist because we do not want\n\t        duplicate event listeners bound to the DOM.\n\t\n\t    `Delegator` will also `listenTo()` all events unless\n\t        every caller opts out of it\n\t*/\n\tmodule.exports = Delegator\n\t\n\tfunction Delegator(opts) {\n\t    opts = opts || {}\n\t    var document = opts.document || globalDocument\n\t\n\t    var cacheKey = document[cacheTokenKey]\n\t\n\t    if (!cacheKey) {\n\t        cacheKey =\n\t            document[cacheTokenKey] = cuid()\n\t    }\n\t\n\t    var delegator = delegatorCache.delegators[cacheKey]\n\t\n\t    if (!delegator) {\n\t        delegator = delegatorCache.delegators[cacheKey] =\n\t            new DOMDelegator(document)\n\t    }\n\t\n\t    if (opts.defaultEvents !== false) {\n\t        for (var i = 0; i < commonEvents.length; i++) {\n\t            delegator.listenTo(commonEvents[i])\n\t        }\n\t    }\n\t\n\t    return delegator\n\t}\n\t\n\tDelegator.allocateHandle = DOMDelegator.allocateHandle;\n\tDelegator.transformHandle = DOMDelegator.transformHandle;\n\n\n/***/ },\n/* 92 */\n/***/ function(module, exports) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {var root = typeof window !== 'undefined' ?\n\t    window : typeof global !== 'undefined' ?\n\t    global : {};\n\t\n\tmodule.exports = Individual\n\t\n\tfunction Individual(key, value) {\n\t    if (root[key]) {\n\t        return root[key]\n\t    }\n\t\n\t    Object.defineProperty(root, key, {\n\t        value: value\n\t        , configurable: true\n\t    })\n\t\n\t    return value\n\t}\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 93 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * cuid.js\n\t * Collision-resistant UID generator for browsers and node.\n\t * Sequential for fast db lookups and recency sorting.\n\t * Safe for element IDs and server-side lookups.\n\t *\n\t * Extracted from CLCTR\n\t *\n\t * Copyright (c) Eric Elliott 2012\n\t * MIT License\n\t */\n\t\n\t/*global window, navigator, document, require, process, module */\n\t(function (app) {\n\t  'use strict';\n\t  var namespace = 'cuid',\n\t    c = 0,\n\t    blockSize = 4,\n\t    base = 36,\n\t    discreteValues = Math.pow(base, blockSize),\n\t\n\t    pad = function pad(num, size) {\n\t      var s = \"000000000\" + num;\n\t      return s.substr(s.length-size);\n\t    },\n\t\n\t    randomBlock = function randomBlock() {\n\t      return pad((Math.random() *\n\t            discreteValues << 0)\n\t            .toString(base), blockSize);\n\t    },\n\t\n\t    safeCounter = function () {\n\t      c = (c < discreteValues) ? c : 0;\n\t      c++; // this is not subliminal\n\t      return c - 1;\n\t    },\n\t\n\t    api = function cuid() {\n\t      // Starting with a lowercase letter makes\n\t      // it HTML element ID friendly.\n\t      var letter = 'c', // hard-coded allows for sequential access\n\t\n\t        // timestamp\n\t        // warning: this exposes the exact date and time\n\t        // that the uid was created.\n\t        timestamp = (new Date().getTime()).toString(base),\n\t\n\t        // Prevent same-machine collisions.\n\t        counter,\n\t\n\t        // A few chars to generate distinct ids for different\n\t        // clients (so different computers are far less\n\t        // likely to generate the same id)\n\t        fingerprint = api.fingerprint(),\n\t\n\t        // Grab some more chars from Math.random()\n\t        random = randomBlock() + randomBlock();\n\t\n\t        counter = pad(safeCounter().toString(base), blockSize);\n\t\n\t      return  (letter + timestamp + counter + fingerprint + random);\n\t    };\n\t\n\t  api.slug = function slug() {\n\t    var date = new Date().getTime().toString(36),\n\t      counter,\n\t      print = api.fingerprint().slice(0,1) +\n\t        api.fingerprint().slice(-1),\n\t      random = randomBlock().slice(-2);\n\t\n\t      counter = safeCounter().toString(36).slice(-4);\n\t\n\t    return date.slice(-2) +\n\t      counter + print + random;\n\t  };\n\t\n\t  api.globalCount = function globalCount() {\n\t    // We want to cache the results of this\n\t    var cache = (function calc() {\n\t        var i,\n\t          count = 0;\n\t\n\t        for (i in window) {\n\t          count++;\n\t        }\n\t\n\t        return count;\n\t      }());\n\t\n\t    api.globalCount = function () { return cache; };\n\t    return cache;\n\t  };\n\t\n\t  api.fingerprint = function browserPrint() {\n\t    return pad((navigator.mimeTypes.length +\n\t      navigator.userAgent.length).toString(36) +\n\t      api.globalCount().toString(36), 4);\n\t  };\n\t\n\t  // don't change anything from here down.\n\t  if (app.register) {\n\t    app.register(namespace, api);\n\t  } else if (true) {\n\t    module.exports = api;\n\t  } else {\n\t    app[namespace] = api;\n\t  }\n\t\n\t}(this.applitude || this));\n\n\n/***/ },\n/* 94 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar globalDocument = __webpack_require__(69)\n\tvar EvStore = __webpack_require__(88)\n\tvar createStore = __webpack_require__(95)\n\t\n\tvar addEvent = __webpack_require__(97)\n\tvar removeEvent = __webpack_require__(98)\n\tvar ProxyEvent = __webpack_require__(99)\n\t\n\tvar HANDLER_STORE = createStore()\n\t\n\tmodule.exports = DOMDelegator\n\t\n\tfunction DOMDelegator(document) {\n\t    if (!(this instanceof DOMDelegator)) {\n\t        return new DOMDelegator(document);\n\t    }\n\t\n\t    document = document || globalDocument\n\t\n\t    this.target = document.documentElement\n\t    this.events = {}\n\t    this.rawEventListeners = {}\n\t    this.globalListeners = {}\n\t}\n\t\n\tDOMDelegator.prototype.addEventListener = addEvent\n\tDOMDelegator.prototype.removeEventListener = removeEvent\n\t\n\tDOMDelegator.allocateHandle =\n\t    function allocateHandle(func) {\n\t        var handle = new Handle()\n\t\n\t        HANDLER_STORE(handle).func = func;\n\t\n\t        return handle\n\t    }\n\t\n\tDOMDelegator.transformHandle =\n\t    function transformHandle(handle, broadcast) {\n\t        var func = HANDLER_STORE(handle).func\n\t\n\t        return this.allocateHandle(function (ev) {\n\t            broadcast(ev, func);\n\t        })\n\t    }\n\t\n\tDOMDelegator.prototype.addGlobalEventListener =\n\t    function addGlobalEventListener(eventName, fn) {\n\t        var listeners = this.globalListeners[eventName] || [];\n\t        if (listeners.indexOf(fn) === -1) {\n\t            listeners.push(fn)\n\t        }\n\t\n\t        this.globalListeners[eventName] = listeners;\n\t    }\n\t\n\tDOMDelegator.prototype.removeGlobalEventListener =\n\t    function removeGlobalEventListener(eventName, fn) {\n\t        var listeners = this.globalListeners[eventName] || [];\n\t\n\t        var index = listeners.indexOf(fn)\n\t        if (index !== -1) {\n\t            listeners.splice(index, 1)\n\t        }\n\t    }\n\t\n\tDOMDelegator.prototype.listenTo = function listenTo(eventName) {\n\t    if (!(eventName in this.events)) {\n\t        this.events[eventName] = 0;\n\t    }\n\t\n\t    this.events[eventName]++;\n\t\n\t    if (this.events[eventName] !== 1) {\n\t        return\n\t    }\n\t\n\t    var listener = this.rawEventListeners[eventName]\n\t    if (!listener) {\n\t        listener = this.rawEventListeners[eventName] =\n\t            createHandler(eventName, this)\n\t    }\n\t\n\t    this.target.addEventListener(eventName, listener, true)\n\t}\n\t\n\tDOMDelegator.prototype.unlistenTo = function unlistenTo(eventName) {\n\t    if (!(eventName in this.events)) {\n\t        this.events[eventName] = 0;\n\t    }\n\t\n\t    if (this.events[eventName] === 0) {\n\t        throw new Error(\"already unlistened to event.\");\n\t    }\n\t\n\t    this.events[eventName]--;\n\t\n\t    if (this.events[eventName] !== 0) {\n\t        return\n\t    }\n\t\n\t    var listener = this.rawEventListeners[eventName]\n\t\n\t    if (!listener) {\n\t        throw new Error(\"dom-delegator#unlistenTo: cannot \" +\n\t            \"unlisten to \" + eventName)\n\t    }\n\t\n\t    this.target.removeEventListener(eventName, listener, true)\n\t}\n\t\n\tfunction createHandler(eventName, delegator) {\n\t    var globalListeners = delegator.globalListeners;\n\t    var delegatorTarget = delegator.target;\n\t\n\t    return handler\n\t\n\t    function handler(ev) {\n\t        var globalHandlers = globalListeners[eventName] || []\n\t\n\t        if (globalHandlers.length > 0) {\n\t            var globalEvent = new ProxyEvent(ev);\n\t            globalEvent.currentTarget = delegatorTarget;\n\t            callListeners(globalHandlers, globalEvent)\n\t        }\n\t\n\t        findAndInvokeListeners(ev.target, ev, eventName)\n\t    }\n\t}\n\t\n\tfunction findAndInvokeListeners(elem, ev, eventName) {\n\t    var listener = getListener(elem, eventName)\n\t\n\t    if (listener && listener.handlers.length > 0) {\n\t        var listenerEvent = new ProxyEvent(ev);\n\t        listenerEvent.currentTarget = listener.currentTarget\n\t        callListeners(listener.handlers, listenerEvent)\n\t\n\t        if (listenerEvent._bubbles) {\n\t            var nextTarget = listener.currentTarget.parentNode\n\t            findAndInvokeListeners(nextTarget, ev, eventName)\n\t        }\n\t    }\n\t}\n\t\n\tfunction getListener(target, type) {\n\t    // terminate recursion if parent is `null`\n\t    if (target === null || typeof target === \"undefined\") {\n\t        return null\n\t    }\n\t\n\t    var events = EvStore(target)\n\t    // fetch list of handler fns for this event\n\t    var handler = events[type]\n\t    var allHandler = events.event\n\t\n\t    if (!handler && !allHandler) {\n\t        return getListener(target.parentNode, type)\n\t    }\n\t\n\t    var handlers = [].concat(handler || [], allHandler || [])\n\t    return new Listener(target, handlers)\n\t}\n\t\n\tfunction callListeners(handlers, ev) {\n\t    handlers.forEach(function (handler) {\n\t        if (typeof handler === \"function\") {\n\t            handler(ev)\n\t        } else if (typeof handler.handleEvent === \"function\") {\n\t            handler.handleEvent(ev)\n\t        } else if (handler.type === \"dom-delegator-handle\") {\n\t            HANDLER_STORE(handler).func(ev)\n\t        } else {\n\t            throw new Error(\"dom-delegator: unknown handler \" +\n\t                \"found: \" + JSON.stringify(handlers));\n\t        }\n\t    })\n\t}\n\t\n\tfunction Listener(target, handlers) {\n\t    this.currentTarget = target\n\t    this.handlers = handlers\n\t}\n\t\n\tfunction Handle() {\n\t    this.type = \"dom-delegator-handle\"\n\t}\n\n\n/***/ },\n/* 95 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar hiddenStore = __webpack_require__(96);\n\t\n\tmodule.exports = createStore;\n\t\n\tfunction createStore() {\n\t    var key = {};\n\t\n\t    return function (obj) {\n\t        if ((typeof obj !== 'object' || obj === null) &&\n\t            typeof obj !== 'function'\n\t        ) {\n\t            throw new Error('Weakmap-shim: Key must be object')\n\t        }\n\t\n\t        var store = obj.valueOf(key);\n\t        return store && store.identity === key ?\n\t            store : hiddenStore(obj, key);\n\t    };\n\t}\n\n\n/***/ },\n/* 96 */\n/***/ function(module, exports) {\n\n\tmodule.exports = hiddenStore;\n\t\n\tfunction hiddenStore(obj, key) {\n\t    var store = { identity: key };\n\t    var valueOf = obj.valueOf;\n\t\n\t    Object.defineProperty(obj, \"valueOf\", {\n\t        value: function (value) {\n\t            return value !== key ?\n\t                valueOf.apply(this, arguments) : store;\n\t        },\n\t        writable: true\n\t    });\n\t\n\t    return store;\n\t}\n\n\n/***/ },\n/* 97 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar EvStore = __webpack_require__(88)\n\t\n\tmodule.exports = addEvent\n\t\n\tfunction addEvent(target, type, handler) {\n\t    var events = EvStore(target)\n\t    var event = events[type]\n\t\n\t    if (!event) {\n\t        events[type] = handler\n\t    } else if (Array.isArray(event)) {\n\t        if (event.indexOf(handler) === -1) {\n\t            event.push(handler)\n\t        }\n\t    } else if (event !== handler) {\n\t        events[type] = [event, handler]\n\t    }\n\t}\n\n\n/***/ },\n/* 98 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar EvStore = __webpack_require__(88)\n\t\n\tmodule.exports = removeEvent\n\t\n\tfunction removeEvent(target, type, handler) {\n\t    var events = EvStore(target)\n\t    var event = events[type]\n\t\n\t    if (!event) {\n\t        return\n\t    } else if (Array.isArray(event)) {\n\t        var index = event.indexOf(handler)\n\t        if (index !== -1) {\n\t            event.splice(index, 1)\n\t        }\n\t    } else if (event === handler) {\n\t        events[type] = null\n\t    }\n\t}\n\n\n/***/ },\n/* 99 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar inherits = __webpack_require__(100)\n\t\n\tvar ALL_PROPS = [\n\t    \"altKey\", \"bubbles\", \"cancelable\", \"ctrlKey\",\n\t    \"eventPhase\", \"metaKey\", \"relatedTarget\", \"shiftKey\",\n\t    \"target\", \"timeStamp\", \"type\", \"view\", \"which\"\n\t]\n\tvar KEY_PROPS = [\"char\", \"charCode\", \"key\", \"keyCode\"]\n\tvar MOUSE_PROPS = [\n\t    \"button\", \"buttons\", \"clientX\", \"clientY\", \"layerX\",\n\t    \"layerY\", \"offsetX\", \"offsetY\", \"pageX\", \"pageY\",\n\t    \"screenX\", \"screenY\", \"toElement\"\n\t]\n\t\n\tvar rkeyEvent = /^key|input/\n\tvar rmouseEvent = /^(?:mouse|pointer|contextmenu)|click/\n\t\n\tmodule.exports = ProxyEvent\n\t\n\tfunction ProxyEvent(ev) {\n\t    if (!(this instanceof ProxyEvent)) {\n\t        return new ProxyEvent(ev)\n\t    }\n\t\n\t    if (rkeyEvent.test(ev.type)) {\n\t        return new KeyEvent(ev)\n\t    } else if (rmouseEvent.test(ev.type)) {\n\t        return new MouseEvent(ev)\n\t    }\n\t\n\t    for (var i = 0; i < ALL_PROPS.length; i++) {\n\t        var propKey = ALL_PROPS[i]\n\t        this[propKey] = ev[propKey]\n\t    }\n\t\n\t    this._rawEvent = ev\n\t    this._bubbles = false;\n\t}\n\t\n\tProxyEvent.prototype.preventDefault = function () {\n\t    this._rawEvent.preventDefault()\n\t}\n\t\n\tProxyEvent.prototype.startPropagation = function () {\n\t    this._bubbles = true;\n\t}\n\t\n\tfunction MouseEvent(ev) {\n\t    for (var i = 0; i < ALL_PROPS.length; i++) {\n\t        var propKey = ALL_PROPS[i]\n\t        this[propKey] = ev[propKey]\n\t    }\n\t\n\t    for (var j = 0; j < MOUSE_PROPS.length; j++) {\n\t        var mousePropKey = MOUSE_PROPS[j]\n\t        this[mousePropKey] = ev[mousePropKey]\n\t    }\n\t\n\t    this._rawEvent = ev\n\t}\n\t\n\tinherits(MouseEvent, ProxyEvent)\n\t\n\tfunction KeyEvent(ev) {\n\t    for (var i = 0; i < ALL_PROPS.length; i++) {\n\t        var propKey = ALL_PROPS[i]\n\t        this[propKey] = ev[propKey]\n\t    }\n\t\n\t    for (var j = 0; j < KEY_PROPS.length; j++) {\n\t        var keyPropKey = KEY_PROPS[j]\n\t        this[keyPropKey] = ev[keyPropKey]\n\t    }\n\t\n\t    this._rawEvent = ev\n\t}\n\t\n\tinherits(KeyEvent, ProxyEvent)\n\n\n/***/ },\n/* 100 */\n/***/ function(module, exports) {\n\n\tif (typeof Object.create === 'function') {\n\t  // implementation from standard node.js 'util' module\n\t  module.exports = function inherits(ctor, superCtor) {\n\t    ctor.super_ = superCtor\n\t    ctor.prototype = Object.create(superCtor.prototype, {\n\t      constructor: {\n\t        value: ctor,\n\t        enumerable: false,\n\t        writable: true,\n\t        configurable: true\n\t      }\n\t    });\n\t  };\n\t} else {\n\t  // old school shim for old browsers\n\t  module.exports = function inherits(ctor, superCtor) {\n\t    ctor.super_ = superCtor\n\t    var TempCtor = function () {}\n\t    TempCtor.prototype = superCtor.prototype\n\t    ctor.prototype = new TempCtor()\n\t    ctor.prototype.constructor = ctor\n\t  }\n\t}\n\n\n/***/ },\n/* 101 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(102);\n\n/***/ },\n/* 102 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {/**\n\t * @license\n\t * lodash 4.0.0 (Custom Build) <https://lodash.com/>\n\t * Build: `lodash -d -o ./lodash.js`\n\t * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>\n\t * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n\t * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n\t * Available under MIT license <https://lodash.com/license>\n\t */\n\t;(function() {\n\t\n\t  /** Used as a safe reference for `undefined` in pre-ES5 environments. */\n\t  var undefined;\n\t\n\t  /** Used as the semantic version number. */\n\t  var VERSION = '4.0.0';\n\t\n\t  /** Used to compose bitmasks for wrapper metadata. */\n\t  var BIND_FLAG = 1,\n\t      BIND_KEY_FLAG = 2,\n\t      CURRY_BOUND_FLAG = 4,\n\t      CURRY_FLAG = 8,\n\t      CURRY_RIGHT_FLAG = 16,\n\t      PARTIAL_FLAG = 32,\n\t      PARTIAL_RIGHT_FLAG = 64,\n\t      ARY_FLAG = 128,\n\t      REARG_FLAG = 256,\n\t      FLIP_FLAG = 512;\n\t\n\t  /** Used to compose bitmasks for comparison styles. */\n\t  var UNORDERED_COMPARE_FLAG = 1,\n\t      PARTIAL_COMPARE_FLAG = 2;\n\t\n\t  /** Used as default options for `_.truncate`. */\n\t  var DEFAULT_TRUNC_LENGTH = 30,\n\t      DEFAULT_TRUNC_OMISSION = '...';\n\t\n\t  /** Used to detect hot functions by number of calls within a span of milliseconds. */\n\t  var HOT_COUNT = 150,\n\t      HOT_SPAN = 16;\n\t\n\t  /** Used as the size to enable large array optimizations. */\n\t  var LARGE_ARRAY_SIZE = 200;\n\t\n\t  /** Used to indicate the type of lazy iteratees. */\n\t  var LAZY_FILTER_FLAG = 1,\n\t      LAZY_MAP_FLAG = 2,\n\t      LAZY_WHILE_FLAG = 3;\n\t\n\t  /** Used as the `TypeError` message for \"Functions\" methods. */\n\t  var FUNC_ERROR_TEXT = 'Expected a function';\n\t\n\t  /** Used to stand-in for `undefined` hash values. */\n\t  var HASH_UNDEFINED = '__lodash_hash_undefined__';\n\t\n\t  /** Used as references for various `Number` constants. */\n\t  var INFINITY = 1 / 0,\n\t      MAX_SAFE_INTEGER = 9007199254740991,\n\t      MAX_INTEGER = 1.7976931348623157e+308,\n\t      NAN = 0 / 0;\n\t\n\t  /** Used as references for the maximum length and index of an array. */\n\t  var MAX_ARRAY_LENGTH = 4294967295,\n\t      MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,\n\t      HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;\n\t\n\t  /** Used as the internal argument placeholder. */\n\t  var PLACEHOLDER = '__lodash_placeholder__';\n\t\n\t  /** `Object#toString` result references. */\n\t  var argsTag = '[object Arguments]',\n\t      arrayTag = '[object Array]',\n\t      boolTag = '[object Boolean]',\n\t      dateTag = '[object Date]',\n\t      errorTag = '[object Error]',\n\t      funcTag = '[object Function]',\n\t      genTag = '[object GeneratorFunction]',\n\t      mapTag = '[object Map]',\n\t      numberTag = '[object Number]',\n\t      objectTag = '[object Object]',\n\t      regexpTag = '[object RegExp]',\n\t      setTag = '[object Set]',\n\t      stringTag = '[object String]',\n\t      symbolTag = '[object Symbol]',\n\t      weakMapTag = '[object WeakMap]';\n\t\n\t  var arrayBufferTag = '[object ArrayBuffer]',\n\t      float32Tag = '[object Float32Array]',\n\t      float64Tag = '[object Float64Array]',\n\t      int8Tag = '[object Int8Array]',\n\t      int16Tag = '[object Int16Array]',\n\t      int32Tag = '[object Int32Array]',\n\t      uint8Tag = '[object Uint8Array]',\n\t      uint8ClampedTag = '[object Uint8ClampedArray]',\n\t      uint16Tag = '[object Uint16Array]',\n\t      uint32Tag = '[object Uint32Array]';\n\t\n\t  /** Used to match empty string literals in compiled template source. */\n\t  var reEmptyStringLeading = /\\b__p \\+= '';/g,\n\t      reEmptyStringMiddle = /\\b(__p \\+=) '' \\+/g,\n\t      reEmptyStringTrailing = /(__e\\(.*?\\)|\\b__t\\)) \\+\\n'';/g;\n\t\n\t  /** Used to match HTML entities and HTML characters. */\n\t  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39|#96);/g,\n\t      reUnescapedHtml = /[&<>\"'`]/g,\n\t      reHasEscapedHtml = RegExp(reEscapedHtml.source),\n\t      reHasUnescapedHtml = RegExp(reUnescapedHtml.source);\n\t\n\t  /** Used to match template delimiters. */\n\t  var reEscape = /<%-([\\s\\S]+?)%>/g,\n\t      reEvaluate = /<%([\\s\\S]+?)%>/g,\n\t      reInterpolate = /<%=([\\s\\S]+?)%>/g;\n\t\n\t  /** Used to match property names within property paths. */\n\t  var reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n\t      reIsPlainProp = /^\\w*$/,\n\t      rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]/g;\n\t\n\t  /** Used to match `RegExp` [syntax characters](http://ecma-international.org/ecma-262/6.0/#sec-patterns). */\n\t  var reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g,\n\t      reHasRegExpChar = RegExp(reRegExpChar.source);\n\t\n\t  /** Used to match leading and trailing whitespace. */\n\t  var reTrim = /^\\s+|\\s+$/g,\n\t      reTrimStart = /^\\s+/,\n\t      reTrimEnd = /\\s+$/;\n\t\n\t  /** Used to match backslashes in property paths. */\n\t  var reEscapeChar = /\\\\(\\\\)?/g;\n\t\n\t  /** Used to match [ES template delimiters](http://ecma-international.org/ecma-262/6.0/#sec-template-literal-lexical-components). */\n\t  var reEsTemplate = /\\$\\{([^\\\\}]*(?:\\\\.[^\\\\}]*)*)\\}/g;\n\t\n\t  /** Used to match `RegExp` flags from their coerced string values. */\n\t  var reFlags = /\\w*$/;\n\t\n\t  /** Used to detect hexadecimal string values. */\n\t  var reHasHexPrefix = /^0x/i;\n\t\n\t  /** Used to detect bad signed hexadecimal string values. */\n\t  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\t\n\t  /** Used to detect binary string values. */\n\t  var reIsBinary = /^0b[01]+$/i;\n\t\n\t  /** Used to detect host constructors (Safari > 5). */\n\t  var reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\t\n\t  /** Used to detect octal string values. */\n\t  var reIsOctal = /^0o[0-7]+$/i;\n\t\n\t  /** Used to detect unsigned integer values. */\n\t  var reIsUint = /^(?:0|[1-9]\\d*)$/;\n\t\n\t  /** Used to match latin-1 supplementary letters (excluding mathematical operators). */\n\t  var reLatin1 = /[\\xc0-\\xd6\\xd8-\\xde\\xdf-\\xf6\\xf8-\\xff]/g;\n\t\n\t  /** Used to ensure capturing order of template delimiters. */\n\t  var reNoMatch = /($^)/;\n\t\n\t  /** Used to match unescaped characters in compiled string literals. */\n\t  var reUnescapedString = /['\\n\\r\\u2028\\u2029\\\\]/g;\n\t\n\t  /** Used to compose unicode character classes. */\n\t  var rsAstralRange = '\\\\ud800-\\\\udfff',\n\t      rsComboRange = '\\\\u0300-\\\\u036f\\\\ufe20-\\\\ufe23',\n\t      rsDingbatRange = '\\\\u2700-\\\\u27bf',\n\t      rsLowerRange = 'a-z\\\\xdf-\\\\xf6\\\\xf8-\\\\xff',\n\t      rsMathOpRange = '\\\\xac\\\\xb1\\\\xd7\\\\xf7',\n\t      rsNonCharRange = '\\\\x00-\\\\x2f\\\\x3a-\\\\x40\\\\x5b-\\\\x60\\\\x7b-\\\\xbf',\n\t      rsQuoteRange = '\\\\u2018\\\\u2019\\\\u201c\\\\u201d',\n\t      rsSpaceRange = ' \\\\t\\\\x0b\\\\f\\\\xa0\\\\ufeff\\\\n\\\\r\\\\u2028\\\\u2029\\\\u1680\\\\u180e\\\\u2000\\\\u2001\\\\u2002\\\\u2003\\\\u2004\\\\u2005\\\\u2006\\\\u2007\\\\u2008\\\\u2009\\\\u200a\\\\u202f\\\\u205f\\\\u3000',\n\t      rsUpperRange = 'A-Z\\\\xc0-\\\\xd6\\\\xd8-\\\\xde',\n\t      rsVarRange = '\\\\ufe0e\\\\ufe0f',\n\t      rsBreakRange = rsMathOpRange + rsNonCharRange + rsQuoteRange + rsSpaceRange;\n\t\n\t  /** Used to compose unicode capture groups. */\n\t  var rsAstral = '[' + rsAstralRange + ']',\n\t      rsBreak = '[' + rsBreakRange + ']',\n\t      rsCombo = '[' + rsComboRange + ']',\n\t      rsDigits = '\\\\d+',\n\t      rsDingbat = '[' + rsDingbatRange + ']',\n\t      rsLower = '[' + rsLowerRange + ']',\n\t      rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',\n\t      rsModifier = '(?:\\\\ud83c[\\\\udffb-\\\\udfff])',\n\t      rsNonAstral = '[^' + rsAstralRange + ']',\n\t      rsRegional = '(?:\\\\ud83c[\\\\udde6-\\\\uddff]){2}',\n\t      rsSurrPair = '[\\\\ud800-\\\\udbff][\\\\udc00-\\\\udfff]',\n\t      rsUpper = '[' + rsUpperRange + ']',\n\t      rsZWJ = '\\\\u200d';\n\t\n\t  /** Used to compose unicode regexes. */\n\t  var rsLowerMisc = '(?:' + rsLower + '|' + rsMisc + ')',\n\t      rsUpperMisc = '(?:' + rsUpper + '|' + rsMisc + ')',\n\t      reOptMod = rsModifier + '?',\n\t      rsOptVar = '[' + rsVarRange + ']?',\n\t      rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',\n\t      rsSeq = rsOptVar + reOptMod + rsOptJoin,\n\t      rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq,\n\t      rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';\n\t\n\t  /** Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks). */\n\t  var reComboMark = RegExp(rsCombo, 'g');\n\t\n\t  /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */\n\t  var reComplexSymbol = RegExp(rsSymbol + rsSeq, 'g');\n\t\n\t  /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */\n\t  var reHasComplexSymbol = RegExp('[' + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + ']');\n\t\n\t  /** Used to match non-compound words composed of alphanumeric characters. */\n\t  var reBasicWord = /[a-zA-Z0-9]+/g;\n\t\n\t  /** Used to match complex or compound words. */\n\t  var reComplexWord = RegExp([\n\t    rsUpper + '?' + rsLower + '+(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',\n\t    rsUpperMisc + '+(?=' + [rsBreak, rsUpper + rsLowerMisc, '$'].join('|') + ')',\n\t    rsUpper + '?' + rsLowerMisc + '+',\n\t    rsDigits + '(?:' + rsLowerMisc + '+)?',\n\t    rsEmoji\n\t  ].join('|'), 'g');\n\t\n\t  /** Used to detect strings that need a more robust regexp to match words. */\n\t  var reHasComplexWord = /[a-z][A-Z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;\n\t\n\t  /** Used to assign default `context` object properties. */\n\t  var contextProps = [\n\t    'Array', 'Date', 'Error', 'Float32Array', 'Float64Array', 'Function',\n\t    'Int8Array', 'Int16Array', 'Int32Array', 'Map', 'Math', 'Object',\n\t    'Reflect', 'RegExp', 'Set', 'String', 'Symbol', 'TypeError', 'Uint8Array',\n\t    'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap', '_',\n\t    'clearTimeout', 'isFinite', 'parseInt', 'setTimeout'\n\t  ];\n\t\n\t  /** Used to make template sourceURLs easier to identify. */\n\t  var templateCounter = -1;\n\t\n\t  /** Used to identify `toStringTag` values of typed arrays. */\n\t  var typedArrayTags = {};\n\t  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\n\t  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\n\t  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\n\t  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\n\t  typedArrayTags[uint32Tag] = true;\n\t  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =\n\t  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\n\t  typedArrayTags[dateTag] = typedArrayTags[errorTag] =\n\t  typedArrayTags[funcTag] = typedArrayTags[mapTag] =\n\t  typedArrayTags[numberTag] = typedArrayTags[objectTag] =\n\t  typedArrayTags[regexpTag] = typedArrayTags[setTag] =\n\t  typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;\n\t\n\t  /** Used to identify `toStringTag` values supported by `_.clone`. */\n\t  var cloneableTags = {};\n\t  cloneableTags[argsTag] = cloneableTags[arrayTag] =\n\t  cloneableTags[arrayBufferTag] = cloneableTags[boolTag] =\n\t  cloneableTags[dateTag] = cloneableTags[float32Tag] =\n\t  cloneableTags[float64Tag] = cloneableTags[int8Tag] =\n\t  cloneableTags[int16Tag] = cloneableTags[int32Tag] =\n\t  cloneableTags[mapTag] = cloneableTags[numberTag] =\n\t  cloneableTags[objectTag] = cloneableTags[regexpTag] =\n\t  cloneableTags[setTag] = cloneableTags[stringTag] =\n\t  cloneableTags[symbolTag] = cloneableTags[uint8Tag] =\n\t  cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] =\n\t  cloneableTags[uint32Tag] = true;\n\t  cloneableTags[errorTag] = cloneableTags[funcTag] =\n\t  cloneableTags[weakMapTag] = false;\n\t\n\t  /** Used to map latin-1 supplementary letters to basic latin letters. */\n\t  var deburredLetters = {\n\t    '\\xc0': 'A',  '\\xc1': 'A', '\\xc2': 'A', '\\xc3': 'A', '\\xc4': 'A', '\\xc5': 'A',\n\t    '\\xe0': 'a',  '\\xe1': 'a', '\\xe2': 'a', '\\xe3': 'a', '\\xe4': 'a', '\\xe5': 'a',\n\t    '\\xc7': 'C',  '\\xe7': 'c',\n\t    '\\xd0': 'D',  '\\xf0': 'd',\n\t    '\\xc8': 'E',  '\\xc9': 'E', '\\xca': 'E', '\\xcb': 'E',\n\t    '\\xe8': 'e',  '\\xe9': 'e', '\\xea': 'e', '\\xeb': 'e',\n\t    '\\xcC': 'I',  '\\xcd': 'I', '\\xce': 'I', '\\xcf': 'I',\n\t    '\\xeC': 'i',  '\\xed': 'i', '\\xee': 'i', '\\xef': 'i',\n\t    '\\xd1': 'N',  '\\xf1': 'n',\n\t    '\\xd2': 'O',  '\\xd3': 'O', '\\xd4': 'O', '\\xd5': 'O', '\\xd6': 'O', '\\xd8': 'O',\n\t    '\\xf2': 'o',  '\\xf3': 'o', '\\xf4': 'o', '\\xf5': 'o', '\\xf6': 'o', '\\xf8': 'o',\n\t    '\\xd9': 'U',  '\\xda': 'U', '\\xdb': 'U', '\\xdc': 'U',\n\t    '\\xf9': 'u',  '\\xfa': 'u', '\\xfb': 'u', '\\xfc': 'u',\n\t    '\\xdd': 'Y',  '\\xfd': 'y', '\\xff': 'y',\n\t    '\\xc6': 'Ae', '\\xe6': 'ae',\n\t    '\\xde': 'Th', '\\xfe': 'th',\n\t    '\\xdf': 'ss'\n\t  };\n\t\n\t  /** Used to map characters to HTML entities. */\n\t  var htmlEscapes = {\n\t    '&': '&amp;',\n\t    '<': '&lt;',\n\t    '>': '&gt;',\n\t    '\"': '&quot;',\n\t    \"'\": '&#39;',\n\t    '`': '&#96;'\n\t  };\n\t\n\t  /** Used to map HTML entities to characters. */\n\t  var htmlUnescapes = {\n\t    '&amp;': '&',\n\t    '&lt;': '<',\n\t    '&gt;': '>',\n\t    '&quot;': '\"',\n\t    '&#39;': \"'\",\n\t    '&#96;': '`'\n\t  };\n\t\n\t  /** Used to determine if values are of the language type `Object`. */\n\t  var objectTypes = {\n\t    'function': true,\n\t    'object': true\n\t  };\n\t\n\t  /** Used to escape characters for inclusion in compiled string literals. */\n\t  var stringEscapes = {\n\t    '\\\\': '\\\\',\n\t    \"'\": \"'\",\n\t    '\\n': 'n',\n\t    '\\r': 'r',\n\t    '\\u2028': 'u2028',\n\t    '\\u2029': 'u2029'\n\t  };\n\t\n\t  /** Built-in method references without a dependency on `root`. */\n\t  var freeParseFloat = parseFloat,\n\t      freeParseInt = parseInt;\n\t\n\t  /** Detect free variable `exports`. */\n\t  var freeExports = (objectTypes[typeof exports] && exports && !exports.nodeType) ? exports : null;\n\t\n\t  /** Detect free variable `module`. */\n\t  var freeModule = (objectTypes[typeof module] && module && !module.nodeType) ? module : null;\n\t\n\t  /** Detect free variable `global` from Node.js. */\n\t  var freeGlobal = checkGlobal(freeExports && freeModule && typeof global == 'object' && global);\n\t\n\t  /** Detect free variable `self`. */\n\t  var freeSelf = checkGlobal(objectTypes[typeof self] && self);\n\t\n\t  /** Detect free variable `window`. */\n\t  var freeWindow = checkGlobal(objectTypes[typeof window] && window);\n\t\n\t  /** Detect the popular CommonJS extension `module.exports`. */\n\t  var moduleExports = (freeModule && freeModule.exports === freeExports) ? freeExports : null;\n\t\n\t  /** Detect `this` as the global object. */\n\t  var thisGlobal = checkGlobal(objectTypes[typeof this] && this);\n\t\n\t  /**\n\t   * Used as a reference to the global object.\n\t   *\n\t   * The `this` value is used if it's the global object to avoid Greasemonkey's\n\t   * restricted `window` object, otherwise the `window` object is used.\n\t   */\n\t  var root = freeGlobal || ((freeWindow !== (thisGlobal && thisGlobal.window)) && freeWindow) || freeSelf || thisGlobal || Function('return this')();\n\t\n\t  /*--------------------------------------------------------------------------*/\n\t\n\t  /**\n\t   * Adds the key-value `pair` to `map`.\n\t   *\n\t   * @private\n\t   * @param {Object} map The map to modify.\n\t   * @param {Array} pair The key-value pair to add.\n\t   * @returns {Object} Returns `map`.\n\t   */\n\t  function addMapEntry(map, pair) {\n\t    map.set(pair[0], pair[1]);\n\t    return map;\n\t  }\n\t\n\t  /**\n\t   * Adds `value` to `set`.\n\t   *\n\t   * @private\n\t   * @param {Object} set The set to modify.\n\t   * @param {*} value The value to add.\n\t   * @returns {Object} Returns `set`.\n\t   */\n\t  function addSetEntry(set, value) {\n\t    set.add(value);\n\t    return set;\n\t  }\n\t\n\t  /**\n\t   * A faster alternative to `Function#apply`, this function invokes `func`\n\t   * with the `this` binding of `thisArg` and the arguments of `args`.\n\t   *\n\t   * @private\n\t   * @param {Function} func The function to invoke.\n\t   * @param {*} thisArg The `this` binding of `func`.\n\t   * @param {...*} [args] The arguments to invoke `func` with.\n\t   * @returns {*} Returns the result of `func`.\n\t   */\n\t  function apply(func, thisArg, args) {\n\t    var length = args ? args.length : 0;\n\t    switch (length) {\n\t      case 0: return func.call(thisArg);\n\t      case 1: return func.call(thisArg, args[0]);\n\t      case 2: return func.call(thisArg, args[0], args[1]);\n\t      case 3: return func.call(thisArg, args[0], args[1], args[2]);\n\t    }\n\t    return func.apply(thisArg, args);\n\t  }\n\t\n\t  /**\n\t   * Creates a new array concatenating `array` with `other`.\n\t   *\n\t   * @private\n\t   * @param {Array} array The first array to concatenate.\n\t   * @param {Array} other The second array to concatenate.\n\t   * @returns {Array} Returns the new concatenated array.\n\t   */\n\t  function arrayConcat(array, other) {\n\t    var index = -1,\n\t        length = array.length,\n\t        othIndex = -1,\n\t        othLength = other.length,\n\t        result = Array(length + othLength);\n\t\n\t    while (++index < length) {\n\t      result[index] = array[index];\n\t    }\n\t    while (++othIndex < othLength) {\n\t      result[index++] = other[othIndex];\n\t    }\n\t    return result;\n\t  }\n\t\n\t  /**\n\t   * A specialized version of `_.forEach` for arrays without support for\n\t   * iteratee shorthands.\n\t   *\n\t   * @private\n\t   * @param {Array} array The array to iterate over.\n\t   * @param {Function} iteratee The function invoked per iteration.\n\t   * @returns {Array} Returns `array`.\n\t   */\n\t  function arrayEach(array, iteratee) {\n\t    var index = -1,\n\t        length = array.length;\n\t\n\t    while (++index < length) {\n\t      if (iteratee(array[index], index, array) === false) {\n\t        break;\n\t      }\n\t    }\n\t    return array;\n\t  }\n\t\n\t  /**\n\t   * A specialized version of `_.forEachRight` for arrays without support for\n\t   * iteratee shorthands.\n\t   *\n\t   * @private\n\t   * @param {Array} array The array to iterate over.\n\t   * @param {Function} iteratee The function invoked per iteration.\n\t   * @returns {Array} Returns `array`.\n\t   */\n\t  function arrayEachRight(array, iteratee) {\n\t    var length = array.length;\n\t\n\t    while (length--) {\n\t      if (iteratee(array[length], length, array) === false) {\n\t        break;\n\t      }\n\t    }\n\t    return array;\n\t  }\n\t\n\t  /**\n\t   * A specialized version of `_.every` for arrays without support for\n\t   * iteratee shorthands.\n\t   *\n\t   * @private\n\t   * @param {Array} array The array to iterate over.\n\t   * @param {Function} predicate The function invoked per iteration.\n\t   * @returns {boolean} Returns `true` if all elements pass the predicate check, else `false`.\n\t   */\n\t  function arrayEvery(array, predicate) {\n\t    var index = -1,\n\t        length = array.length;\n\t\n\t    while (++index < length) {\n\t      if (!predicate(array[index], index, array)) {\n\t        return false;\n\t      }\n\t    }\n\t    return true;\n\t  }\n\t\n\t  /**\n\t   * A specialized version of `_.filter` for arrays without support for\n\t   * iteratee shorthands.\n\t   *\n\t   * @private\n\t   * @param {Array} array The array to iterate over.\n\t   * @param {Function} predicate The function invoked per iteration.\n\t   * @returns {Array} Returns the new filtered array.\n\t   */\n\t  function arrayFilter(array, predicate) {\n\t    var index = -1,\n\t        length = array.length,\n\t        resIndex = -1,\n\t        result = [];\n\t\n\t    while (++index < length) {\n\t      var value = array[index];\n\t      if (predicate(value, index, array)) {\n\t        result[++resIndex] = value;\n\t      }\n\t    }\n\t    return result;\n\t  }\n\t\n\t  /**\n\t   * A specialized version of `_.includes` for arrays without support for\n\t   * specifying an index to search from.\n\t   *\n\t   * @private\n\t   * @param {Array} array The array to search.\n\t   * @param {*} target The value to search for.\n\t   * @returns {boolean} Returns `true` if `target` is found, else `false`.\n\t   */\n\t  function arrayIncludes(array, value) {\n\t    return !!array.length && baseIndexOf(array, value, 0) > -1;\n\t  }\n\t\n\t  /**\n\t   * A specialized version of `_.includesWith` for arrays without support for\n\t   * specifying an index to search from.\n\t   *\n\t   * @private\n\t   * @param {Array} array The array to search.\n\t   * @param {*} target The value to search for.\n\t   * @param {Function} comparator The comparator invoked per element.\n\t   * @returns {boolean} Returns `true` if `target` is found, else `false`.\n\t   */\n\t  function arrayIncludesWith(array, value, comparator) {\n\t    var index = -1,\n\t        length = array.length;\n\t\n\t    while (++index < length) {\n\t      if (comparator(value, array[index])) {\n\t        return true;\n\t      }\n\t    }\n\t    return false;\n\t  }\n\t\n\t  /**\n\t   * A specialized version of `_.map` for arrays without support for iteratee\n\t   * shorthands.\n\t   *\n\t   * @private\n\t   * @param {Array} array The array to iterate over.\n\t   * @param {Function} iteratee The function invoked per iteration.\n\t   * @returns {Array} Returns the new mapped array.\n\t   */\n\t  function arrayMap(array, iteratee) {\n\t    var index = -1,\n\t        length = array.length,\n\t        result = Array(length);\n\t\n\t    while (++index < length) {\n\t      result[index] = iteratee(array[index], index, array);\n\t    }\n\t    return result;\n\t  }\n\t\n\t  /**\n\t   * Appends the elements of `values` to `array`.\n\t   *\n\t   * @private\n\t   * @param {Array} array The array to modify.\n\t   * @param {Array} values The values to append.\n\t   * @returns {Array} Returns `array`.\n\t   */\n\t  function arrayPush(array, values) {\n\t    var index = -1,\n\t        length = values.length,\n\t        offset = array.length;\n\t\n\t    while (++index < length) {\n\t      array[offset + index] = values[index];\n\t    }\n\t    return array;\n\t  }\n\t\n\t  /**\n\t   * A specialized version of `_.reduce` for arrays without support for\n\t   * iteratee shorthands.\n\t   *\n\t   * @private\n\t   * @param {Array} array The array to iterate over.\n\t   * @param {Function} iteratee The function invoked per iteration.\n\t   * @param {*} [accumulator] The initial value.\n\t   * @param {boolean} [initFromArray] Specify using the first element of `array` as the initial value.\n\t   * @returns {*} Returns the accumulated value.\n\t   */\n\t  function arrayReduce(array, iteratee, accumulator, initFromArray) {\n\t    var index = -1,\n\t        length = array.length;\n\t\n\t    if (initFromArray && length) {\n\t      accumulator = array[++index];\n\t    }\n\t    while (++index < length) {\n\t      accumulator = iteratee(accumulator, array[index], index, array);\n\t    }\n\t    return accumulator;\n\t  }\n\t\n\t  /**\n\t   * A specialized version of `_.reduceRight` for arrays without support for\n\t   * iteratee shorthands.\n\t   *\n\t   * @private\n\t   * @param {Array} array The array to iterate over.\n\t   * @param {Function} iteratee The function invoked per iteration.\n\t   * @param {*} [accumulator] The initial value.\n\t   * @param {boolean} [initFromArray] Specify using the last element of `array` as the initial value.\n\t   * @returns {*} Returns the accumulated value.\n\t   */\n\t  function arrayReduceRight(array, iteratee, accumulator, initFromArray) {\n\t    var length = array.length;\n\t    if (initFromArray && length) {\n\t      accumulator = array[--length];\n\t    }\n\t    while (length--) {\n\t      accumulator = iteratee(accumulator, array[length], length, array);\n\t    }\n\t    return accumulator;\n\t  }\n\t\n\t  /**\n\t   * A specialized version of `_.some` for arrays without support for iteratee\n\t   * shorthands.\n\t   *\n\t   * @private\n\t   * @param {Array} array The array to iterate over.\n\t   * @param {Function} predicate The function invoked per iteration.\n\t   * @returns {boolean} Returns `true` if any element passes the predicate check, else `false`.\n\t   */\n\t  function arraySome(array, predicate) {\n\t    var index = -1,\n\t        length = array.length;\n\t\n\t    while (++index < length) {\n\t      if (predicate(array[index], index, array)) {\n\t        return true;\n\t      }\n\t    }\n\t    return false;\n\t  }\n\t\n\t  /**\n\t   * The base implementation of methods like `_.max` and `_.min` which accepts a\n\t   * `comparator` to determine the extremum value.\n\t   *\n\t   * @private\n\t   * @param {Array} array The array to iterate over.\n\t   * @param {Function} iteratee The iteratee invoked per iteration.\n\t   * @param {Function} comparator The comparator used to compare values.\n\t   * @returns {*} Returns the extremum value.\n\t   */\n\t  function baseExtremum(array, iteratee, comparator) {\n\t    var index = -1,\n\t        length = array.length;\n\t\n\t    while (++index < length) {\n\t      var value = array[index],\n\t          current = iteratee(value);\n\t\n\t      if (current != null && (computed === undefined\n\t            ? current === current\n\t            : comparator(current, computed)\n\t          )) {\n\t        var computed = current,\n\t            result = value;\n\t      }\n\t    }\n\t    return result;\n\t  }\n\t\n\t  /**\n\t   * The base implementation of methods like `_.find` and `_.findKey`, without\n\t   * support for iteratee shorthands, which iterates over `collection` using\n\t   * the provided `eachFunc`.\n\t   *\n\t   * @private\n\t   * @param {Array|Object} collection The collection to search.\n\t   * @param {Function} predicate The function invoked per iteration.\n\t   * @param {Function} eachFunc The function to iterate over `collection`.\n\t   * @param {boolean} [retKey] Specify returning the key of the found element instead of the element itself.\n\t   * @returns {*} Returns the found element or its key, else `undefined`.\n\t   */\n\t  function baseFind(collection, predicate, eachFunc, retKey) {\n\t    var result;\n\t    eachFunc(collection, function(value, key, collection) {\n\t      if (predicate(value, key, collection)) {\n\t        result = retKey ? key : value;\n\t        return false;\n\t      }\n\t    });\n\t    return result;\n\t  }\n\t\n\t  /**\n\t   * The base implementation of `_.findIndex` and `_.findLastIndex` without\n\t   * support for iteratee shorthands.\n\t   *\n\t   * @private\n\t   * @param {Array} array The array to search.\n\t   * @param {Function} predicate The function invoked per iteration.\n\t   * @param {boolean} [fromRight] Specify iterating from right to left.\n\t   * @returns {number} Returns the index of the matched value, else `-1`.\n\t   */\n\t  function baseFindIndex(array, predicate, fromRight) {\n\t    var length = array.length,\n\t        index = fromRight ? length : -1;\n\t\n\t    while ((fromRight ? index-- : ++index < length)) {\n\t      if (predicate(array[index], index, array)) {\n\t        return index;\n\t      }\n\t    }\n\t    return -1;\n\t  }\n\t\n\t  /**\n\t   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.\n\t   *\n\t   * @private\n\t   * @param {Array} array The array to search.\n\t   * @param {*} value The value to search for.\n\t   * @param {number} fromIndex The index to search from.\n\t   * @returns {number} Returns the index of the matched value, else `-1`.\n\t   */\n\t  function baseIndexOf(array, value, fromIndex) {\n\t    if (value !== value) {\n\t      return indexOfNaN(array, fromIndex);\n\t    }\n\t    var index = fromIndex - 1,\n\t        length = array.length;\n\t\n\t    while (++index < length) {\n\t      if (array[index] === value) {\n\t        return index;\n\t      }\n\t    }\n\t    return -1;\n\t  }\n\t\n\t  /**\n\t   * The base implementation of `_.reduce` and `_.reduceRight`, without support\n\t   * for iteratee shorthands, which iterates over `collection` using the provided\n\t   * `eachFunc`.\n\t   *\n\t   * @private\n\t   * @param {Array|Object} collection The collection to iterate over.\n\t   * @param {Function} iteratee The function invoked per iteration.\n\t   * @param {*} accumulator The initial value.\n\t   * @param {boolean} initFromCollection Specify using the first or last element of `collection` as the initial value.\n\t   * @param {Function} eachFunc The function to iterate over `collection`.\n\t   * @returns {*} Returns the accumulated value.\n\t   */\n\t  function baseReduce(collection, iteratee, accumulator, initFromCollection, eachFunc) {\n\t    eachFunc(collection, function(value, index, collection) {\n\t      accumulator = initFromCollection\n\t        ? (initFromCollection = false, value)\n\t        : iteratee(accumulator, value, index, collection);\n\t    });\n\t    return accumulator;\n\t  }\n\t\n\t  /**\n\t   * The base implementation of `_.sortBy` which uses `comparer` to define\n\t   * the sort order of `array` and replaces criteria objects with their\n\t   * corresponding values.\n\t   *\n\t   * @private\n\t   * @param {Array} array The array to sort.\n\t   * @param {Function} comparer The function to define sort order.\n\t   * @returns {Array} Returns `array`.\n\t   */\n\t  function baseSortBy(array, comparer) {\n\t    var length = array.length;\n\t\n\t    array.sort(comparer);\n\t    while (length--) {\n\t      array[length] = array[length].value;\n\t    }\n\t    return array;\n\t  }\n\t\n\t  /**\n\t   * The base implementation of `_.sum` without support for iteratee shorthands.\n\t   *\n\t   * @private\n\t   * @param {Array} array The array to iterate over.\n\t   * @param {Function} iteratee The function invoked per iteration.\n\t   * @returns {number} Returns the sum.\n\t   */\n\t  function baseSum(array, iteratee) {\n\t    var result,\n\t        index = -1,\n\t        length = array.length;\n\t\n\t    while (++index < length) {\n\t      var current = iteratee(array[index]);\n\t      if (current !== undefined) {\n\t        result = result === undefined ? current : (result + current);\n\t      }\n\t    }\n\t    return result;\n\t  }\n\t\n\t  /**\n\t   * The base implementation of `_.times` without support for iteratee shorthands\n\t   * or max array length checks.\n\t   *\n\t   * @private\n\t   * @param {number} n The number of times to invoke `iteratee`.\n\t   * @param {Function} iteratee The function invoked per iteration.\n\t   * @returns {Array} Returns the array of results.\n\t   */\n\t  function baseTimes(n, iteratee) {\n\t    var index = -1,\n\t        result = Array(n);\n\t\n\t    while (++index < n) {\n\t      result[index] = iteratee(index);\n\t    }\n\t    return result;\n\t  }\n\t\n\t  /**\n\t   * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array\n\t   * of key-value pairs for `object` corresponding to the property names of `props`.\n\t   *\n\t   * @private\n\t   * @param {Object} object The object to query.\n\t   * @param {Array} props The property names to get values for.\n\t   * @returns {Object} Returns the new array of key-value pairs.\n\t   */\n\t  function baseToPairs(object, props) {\n\t    return arrayMap(props, function(key) {\n\t      return [key, object[key]];\n\t    });\n\t  }\n\t\n\t  /**\n\t   * The base implementation of `_.unary` without support for storing wrapper metadata.\n\t   *\n\t   * @private\n\t   * @param {Function} func The function to cap arguments for.\n\t   * @returns {Function} Returns the new function.\n\t   */\n\t  function baseUnary(func) {\n\t    return function(value) {\n\t      return func(value);\n\t    };\n\t  }\n\t\n\t  /**\n\t   * The base implementation of `_.values` and `_.valuesIn` which creates an\n\t   * array of `object` property values corresponding to the property names\n\t   * of `props`.\n\t   *\n\t   * @private\n\t   * @param {Object} object The object to query.\n\t   * @param {Array} props The property names to get values for.\n\t   * @returns {Object} Returns the array of property values.\n\t   */\n\t  function baseValues(object, props) {\n\t    return arrayMap(props, function(key) {\n\t      return object[key];\n\t    });\n\t  }\n\t\n\t  /**\n\t   * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol\n\t   * that is not found in the character symbols.\n\t   *\n\t   * @private\n\t   * @param {Array} strSymbols The string symbols to inspect.\n\t   * @param {Array} chrSymbols The character symbols to find.\n\t   * @returns {number} Returns the index of the first unmatched string symbol.\n\t   */\n\t  function charsStartIndex(strSymbols, chrSymbols) {\n\t    var index = -1,\n\t        length = strSymbols.length;\n\t\n\t    while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}\n\t    return index;\n\t  }\n\t\n\t  /**\n\t   * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol\n\t   * that is not found in the character symbols.\n\t   *\n\t   * @private\n\t   * @param {Array} strSymbols The string symbols to inspect.\n\t   * @param {Array} chrSymbols The character symbols to find.\n\t   * @returns {number} Returns the index of the last unmatched string symbol.\n\t   */\n\t  function charsEndIndex(strSymbols, chrSymbols) {\n\t    var index = strSymbols.length;\n\t\n\t    while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}\n\t    return index;\n\t  }\n\t\n\t  /**\n\t   * Checks if `value` is a global object.\n\t   *\n\t   * @private\n\t   * @param {*} value The value to check.\n\t   * @returns {null|Object} Returns `value` if it's a global object, else `null`.\n\t   */\n\t  function checkGlobal(value) {\n\t    return (value && value.Object === Object) ? value : null;\n\t  }\n\t\n\t  /**\n\t   * Compares values to sort them in ascending order.\n\t   *\n\t   * @private\n\t   * @param {*} value The value to compare.\n\t   * @param {*} other The other value to compare.\n\t   * @returns {number} Returns the sort order indicator for `value`.\n\t   */\n\t  function compareAscending(value, other) {\n\t    if (value !== other) {\n\t      var valIsNull = value === null,\n\t          valIsUndef = value === undefined,\n\t          valIsReflexive = value === value;\n\t\n\t      var othIsNull = other === null,\n\t          othIsUndef = other === undefined,\n\t          othIsReflexive = other === other;\n\t\n\t      if ((value > other && !othIsNull) || !valIsReflexive ||\n\t          (valIsNull && !othIsUndef && othIsReflexive) ||\n\t          (valIsUndef && othIsReflexive)) {\n\t        return 1;\n\t      }\n\t      if ((value < other && !valIsNull) || !othIsReflexive ||\n\t          (othIsNull && !valIsUndef && valIsReflexive) ||\n\t          (othIsUndef && valIsReflexive)) {\n\t        return -1;\n\t      }\n\t    }\n\t    return 0;\n\t  }\n\t\n\t  /**\n\t   * Used by `_.orderBy` to compare multiple properties of a value to another\n\t   * and stable sort them.\n\t   *\n\t   * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,\n\t   * specify an order of \"desc\" for descending or \"asc\" for ascending sort order\n\t   * of corresponding values.\n\t   *\n\t   * @private\n\t   * @param {Object} object The object to compare.\n\t   * @param {Object} other The other object to compare.\n\t   * @param {boolean[]|string[]} orders The order to sort by for each property.\n\t   * @returns {number} Returns the sort order indicator for `object`.\n\t   */\n\t  function compareMultiple(object, other, orders) {\n\t    var index = -1,\n\t        objCriteria = object.criteria,\n\t        othCriteria = other.criteria,\n\t        length = objCriteria.length,\n\t        ordersLength = orders.length;\n\t\n\t    while (++index < length) {\n\t      var result = compareAscending(objCriteria[index], othCriteria[index]);\n\t      if (result) {\n\t        if (index >= ordersLength) {\n\t          return result;\n\t        }\n\t        var order = orders[index];\n\t        return result * (order == 'desc' ? -1 : 1);\n\t      }\n\t    }\n\t    // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications\n\t    // that causes it, under certain circumstances, to provide the same value for\n\t    // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247\n\t    // for more details.\n\t    //\n\t    // This also ensures a stable sort in V8 and other engines.\n\t    // See https://code.google.com/p/v8/issues/detail?id=90 for more details.\n\t    return object.index - other.index;\n\t  }\n\t\n\t  /**\n\t   * Used by `_.deburr` to convert latin-1 supplementary letters to basic latin letters.\n\t   *\n\t   * @private\n\t   * @param {string} letter The matched letter to deburr.\n\t   * @returns {string} Returns the deburred letter.\n\t   */\n\t  function deburrLetter(letter) {\n\t    return deburredLetters[letter];\n\t  }\n\t\n\t  /**\n\t   * Used by `_.escape` to convert characters to HTML entities.\n\t   *\n\t   * @private\n\t   * @param {string} chr The matched character to escape.\n\t   * @returns {string} Returns the escaped character.\n\t   */\n\t  function escapeHtmlChar(chr) {\n\t    return htmlEscapes[chr];\n\t  }\n\t\n\t  /**\n\t   * Used by `_.template` to escape characters for inclusion in compiled string literals.\n\t   *\n\t   * @private\n\t   * @param {string} chr The matched character to escape.\n\t   * @returns {string} Returns the escaped character.\n\t   */\n\t  function escapeStringChar(chr) {\n\t    return '\\\\' + stringEscapes[chr];\n\t  }\n\t\n\t  /**\n\t   * Gets the index at which the first occurrence of `NaN` is found in `array`.\n\t   *\n\t   * @private\n\t   * @param {Array} array The array to search.\n\t   * @param {number} fromIndex The index to search from.\n\t   * @param {boolean} [fromRight] Specify iterating from right to left.\n\t   * @returns {number} Returns the index of the matched `NaN`, else `-1`.\n\t   */\n\t  function indexOfNaN(array, fromIndex, fromRight) {\n\t    var length = array.length,\n\t        index = fromIndex + (fromRight ? 0 : -1);\n\t\n\t    while ((fromRight ? index-- : ++index < length)) {\n\t      var other = array[index];\n\t      if (other !== other) {\n\t        return index;\n\t      }\n\t    }\n\t    return -1;\n\t  }\n\t\n\t  /**\n\t   * Checks if `value` is a host object in IE < 9.\n\t   *\n\t   * @private\n\t   * @param {*} value The value to check.\n\t   * @returns {boolean} Returns `true` if `value` is a host object, else `false`.\n\t   */\n\t  function isHostObject(value) {\n\t    // Many host objects are `Object` objects that can coerce to strings\n\t    // despite having improperly defined `toString` methods.\n\t    var result = false;\n\t    if (value != null && typeof value.toString != 'function') {\n\t      try {\n\t        result = !!(value + '');\n\t      } catch (e) {}\n\t    }\n\t    return result;\n\t  }\n\t\n\t  /**\n\t   * Checks if `value` is a valid array-like index.\n\t   *\n\t   * @private\n\t   * @param {*} value The value to check.\n\t   * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n\t   * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n\t   */\n\t  function isIndex(value, length) {\n\t    value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;\n\t    length = length == null ? MAX_SAFE_INTEGER : length;\n\t    return value > -1 && value % 1 == 0 && value < length;\n\t  }\n\t\n\t  /**\n\t   * Converts `iterator` to an array.\n\t   *\n\t   * @private\n\t   * @param {Object} iterator The iterator to convert.\n\t   * @returns {Array} Returns the converted array.\n\t   */\n\t  function iteratorToArray(iterator) {\n\t    var data,\n\t        result = [];\n\t\n\t    while (!(data = iterator.next()).done) {\n\t      result.push(data.value);\n\t    }\n\t    return result;\n\t  }\n\t\n\t  /**\n\t   * Converts `map` to an array.\n\t   *\n\t   * @private\n\t   * @param {Object} map The map to convert.\n\t   * @returns {Array} Returns the converted array.\n\t   */\n\t  function mapToArray(map) {\n\t    var index = -1,\n\t        result = Array(map.size);\n\t\n\t    map.forEach(function(value, key) {\n\t      result[++index] = [key, value];\n\t    });\n\t    return result;\n\t  }\n\t\n\t  /**\n\t   * Replaces all `placeholder` elements in `array` with an internal placeholder\n\t   * and returns an array of their indexes.\n\t   *\n\t   * @private\n\t   * @param {Array} array The array to modify.\n\t   * @param {*} placeholder The placeholder to replace.\n\t   * @returns {Array} Returns the new array of placeholder indexes.\n\t   */\n\t  function replaceHolders(array, placeholder) {\n\t    var index = -1,\n\t        length = array.length,\n\t        resIndex = -1,\n\t        result = [];\n\t\n\t    while (++index < length) {\n\t      if (array[index] === placeholder) {\n\t        array[index] = PLACEHOLDER;\n\t        result[++resIndex] = index;\n\t      }\n\t    }\n\t    return result;\n\t  }\n\t\n\t  /**\n\t   * Converts `set` to an array.\n\t   *\n\t   * @private\n\t   * @param {Object} set The set to convert.\n\t   * @returns {Array} Returns the converted array.\n\t   */\n\t  function setToArray(set) {\n\t    var index = -1,\n\t        result = Array(set.size);\n\t\n\t    set.forEach(function(value) {\n\t      result[++index] = value;\n\t    });\n\t    return result;\n\t  }\n\t\n\t  /**\n\t   * Gets the number of symbols in `string`.\n\t   *\n\t   * @param {string} string The string to inspect.\n\t   * @returns {number} Returns the string size.\n\t   */\n\t  function stringSize(string) {\n\t    if (!(string && reHasComplexSymbol.test(string))) {\n\t      return string.length;\n\t    }\n\t    var result = reComplexSymbol.lastIndex = 0;\n\t    while (reComplexSymbol.test(string)) {\n\t      result++;\n\t    }\n\t    return result;\n\t  }\n\t\n\t  /**\n\t   * Converts `string` to an array.\n\t   *\n\t   * @private\n\t   * @param {string} string The string to convert.\n\t   * @returns {Array} Returns the converted array.\n\t   */\n\t  function stringToArray(string) {\n\t    return string.match(reComplexSymbol);\n\t  }\n\t\n\t  /**\n\t   * Used by `_.unescape` to convert HTML entities to characters.\n\t   *\n\t   * @private\n\t   * @param {string} chr The matched character to unescape.\n\t   * @returns {string} Returns the unescaped character.\n\t   */\n\t  function unescapeHtmlChar(chr) {\n\t    return htmlUnescapes[chr];\n\t  }\n\t\n\t  /*--------------------------------------------------------------------------*/\n\t\n\t  /**\n\t   * Create a new pristine `lodash` function using the `context` object.\n\t   *\n\t   * @static\n\t   * @memberOf _\n\t   * @category Util\n\t   * @param {Object} [context=root] The context object.\n\t   * @returns {Function} Returns a new `lodash` function.\n\t   * @example\n\t   *\n\t   * _.mixin({ 'foo': _.constant('foo') });\n\t   *\n\t   * var lodash = _.runInContext();\n\t   * lodash.mixin({ 'bar': lodash.constant('bar') });\n\t   *\n\t   * _.isFunction(_.foo);\n\t   * // => true\n\t   * _.isFunction(_.bar);\n\t   * // => false\n\t   *\n\t   * lodash.isFunction(lodash.foo);\n\t   * // => false\n\t   * lodash.isFunction(lodash.bar);\n\t   * // => true\n\t   *\n\t   * // using `context` to mock `Date#getTime` use in `_.now`\n\t   * var mock = _.runInContext({\n\t   *   'Date': function() {\n\t   *     return { 'getTime': getTimeMock };\n\t   *   }\n\t   * });\n\t   *\n\t   * // or creating a suped-up `defer` in Node.js\n\t   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;\n\t   */\n\t  function runInContext(context) {\n\t    context = context ? _.defaults({}, context, _.pick(root, contextProps)) : root;\n\t\n\t    /** Built-in constructor references. */\n\t    var Date = context.Date,\n\t        Error = context.Error,\n\t        Math = context.Math,\n\t        RegExp = context.RegExp,\n\t        TypeError = context.TypeError;\n\t\n\t    /** Used for built-in method references. */\n\t    var arrayProto = context.Array.prototype,\n\t        objectProto = context.Object.prototype;\n\t\n\t    /** Used to resolve the decompiled source of functions. */\n\t    var funcToString = context.Function.prototype.toString;\n\t\n\t    /** Used to check objects for own properties. */\n\t    var hasOwnProperty = objectProto.hasOwnProperty;\n\t\n\t    /** Used to generate unique IDs. */\n\t    var idCounter = 0;\n\t\n\t    /** Used to infer the `Object` constructor. */\n\t    var objectCtorString = funcToString.call(Object);\n\t\n\t    /**\n\t     * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\n\t     * of values.\n\t     */\n\t    var objectToString = objectProto.toString;\n\t\n\t    /** Used to restore the original `_` reference in `_.noConflict`. */\n\t    var oldDash = root._;\n\t\n\t    /** Used to detect if a method is native. */\n\t    var reIsNative = RegExp('^' +\n\t      funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n\t      .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n\t    );\n\t\n\t    /** Built-in value references. */\n\t    var _Symbol = context.Symbol,\n\t        Reflect = context.Reflect,\n\t        Uint8Array = context.Uint8Array,\n\t        clearTimeout = context.clearTimeout,\n\t        enumerate = Reflect ? Reflect.enumerate : undefined,\n\t        getPrototypeOf = Object.getPrototypeOf,\n\t        getOwnPropertySymbols = Object.getOwnPropertySymbols,\n\t        iteratorSymbol = typeof (iteratorSymbol = _Symbol && _Symbol.iterator) == 'symbol' ? iteratorSymbol : undefined,\n\t        propertyIsEnumerable = objectProto.propertyIsEnumerable,\n\t        setTimeout = context.setTimeout,\n\t        splice = arrayProto.splice;\n\t\n\t    /* Built-in method references for those with the same name as other `lodash` methods. */\n\t    var nativeCeil = Math.ceil,\n\t        nativeFloor = Math.floor,\n\t        nativeIsFinite = context.isFinite,\n\t        nativeJoin = arrayProto.join,\n\t        nativeKeys = Object.keys,\n\t        nativeMax = Math.max,\n\t        nativeMin = Math.min,\n\t        nativeParseInt = context.parseInt,\n\t        nativeRandom = Math.random,\n\t        nativeReverse = arrayProto.reverse;\n\t\n\t    /* Built-in method references that are verified to be native. */\n\t    var Map = getNative(context, 'Map'),\n\t        Set = getNative(context, 'Set'),\n\t        WeakMap = getNative(context, 'WeakMap'),\n\t        nativeCreate = getNative(Object, 'create');\n\t\n\t    /** Used to store function metadata. */\n\t    var metaMap = WeakMap && new WeakMap;\n\t\n\t    /** Used to detect maps and sets. */\n\t    var mapCtorString = Map ? funcToString.call(Map) : '',\n\t        setCtorString = Set ? funcToString.call(Set) : '';\n\t\n\t    /** Used to convert symbols to primitives and strings. */\n\t    var symbolProto = _Symbol ? _Symbol.prototype : undefined,\n\t        symbolValueOf = _Symbol ? symbolProto.valueOf : undefined,\n\t        symbolToString = _Symbol ? symbolProto.toString : undefined;\n\t\n\t    /** Used to lookup unminified function names. */\n\t    var realNames = {};\n\t\n\t    /*------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * Creates a `lodash` object which wraps `value` to enable implicit method\n\t     * chaining. Methods that operate on and return arrays, collections, and\n\t     * functions can be chained together. Methods that retrieve a single value or\n\t     * may return a primitive value will automatically end the chain sequence and\n\t     * return the unwrapped value. Otherwise, the value must be unwrapped with\n\t     * `_#value`.\n\t     *\n\t     * Explicit chaining, which must be unwrapped with `_#value` in all cases,\n\t     * may be enabled using `_.chain`.\n\t     *\n\t     * The execution of chained methods is lazy, that is, it's deferred until\n\t     * `_#value` is implicitly or explicitly called.\n\t     *\n\t     * Lazy evaluation allows several methods to support shortcut fusion. Shortcut\n\t     * fusion is an optimization to merge iteratee calls; this avoids the creation\n\t     * of intermediate arrays and can greatly reduce the number of iteratee executions.\n\t     * Sections of a chain sequence qualify for shortcut fusion if the section is\n\t     * applied to an array of at least two hundred elements and any iteratees\n\t     * accept only one argument. The heuristic for whether a section qualifies\n\t     * for shortcut fusion is subject to change.\n\t     *\n\t     * Chaining is supported in custom builds as long as the `_#value` method is\n\t     * directly or indirectly included in the build.\n\t     *\n\t     * In addition to lodash methods, wrappers have `Array` and `String` methods.\n\t     *\n\t     * The wrapper `Array` methods are:\n\t     * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`\n\t     *\n\t     * The wrapper `String` methods are:\n\t     * `replace` and `split`\n\t     *\n\t     * The wrapper methods that support shortcut fusion are:\n\t     * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,\n\t     * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,\n\t     * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`\n\t     *\n\t     * The chainable wrapper methods are:\n\t     * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`,\n\t     * `at`, `before`, `bind`, `bindAll`, `bindKey`, `chain`, `chunk`, `commit`,\n\t     * `compact`, `concat`, `conforms`,  `constant`, `countBy`, `create`, `curry`,\n\t     * `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`, `difference`,\n\t     * `differenceBy`, `differenceWith`,  `drop`, `dropRight`, `dropRightWhile`,\n\t     * `dropWhile`, `fill`, `filter`, `flatten`, `flattenDeep`, `flip`, `flow`,\n\t     * `flowRight`, `forEach`, `forEachRight`, `forIn`, `forInRight`, `forOwn`,\n\t     * `forOwnRight`, `fromPairs`, `functions`, `functionsIn`, `groupBy`, `initial`,\n\t     * `intersection`, `intersectionBy`, `intersectionWith`, invert`, `invokeMap`,\n\t     * `iteratee`, `keyBy`, `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`,\n\t     * `matches`, `matchesProperty`, `memoize`, `merge`, `mergeWith`, `method`,\n\t     * `methodOf`, `mixin`, `negate`, `nthArg`, `omit`, `omitBy`, `once`, `orderBy`,\n\t     * `over`, `overArgs`, `overEvery`, `overSome`, `partial`, `partialRight`,\n\t     * `partition`, `pick`, `pickBy`, `plant`, `property`, `propertyOf`, `pull`,\n\t     * `pullAll`, `pullAllBy`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`,\n\t     * `reject`, `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`,\n\t     * `shuffle`, `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`,\n\t     * `takeRight`, `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`,\n\t     * `toArray`, `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`,\n\t     * `unary`, `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`,\n\t     * `unset`, `unshift`, `unzip`, `unzipWith`, `values`, `valuesIn`, `without`,\n\t     * `wrap`, `xor`, `xorBy`, `xorWith`, `zip`, `zipObject`, and `zipWith`\n\t     *\n\t     * The wrapper methods that are **not** chainable by default are:\n\t     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,\n\t     * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `deburr`, `endsWith`, `eq`,\n\t     * `escape`, `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`,\n\t     * `findLast`, `findLastIndex`, `findLastKey`, `floor`, `get`, `gt`, `gte`,\n\t     * `has`, `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`,\n\t     * `invoke`, `isArguments`, `isArray`, `isArrayLike`, `isArrayLikeObject`,\n\t     * `isBoolean`, `isDate`, `isElement`, `isEmpty`, `isEqual`, `isEqualWith`,\n\t     * `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`, `isMatch`,\n\t     * `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`, `isNumber`,\n\t     * `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`, `isSafeInteger`,\n\t     * `isString`, `isUndefined`, `isTypedArray`, `join`, `kebabCase`, `last`,\n\t     * `lastIndexOf`, `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`,\n\t     * `mean`, `min`, `minBy`, `noConflict`, `noop`, `now`, `pad`, `padEnd`,\n\t     * `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`, `repeat`,\n\t     * `result`, `round`, `runInContext`, `sample`, `shift`, `size`, `snakeCase`,\n\t     * `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`, `sortedLastIndexBy`,\n\t     * `startCase`, `startsWith`, `subtract`, `sum`, sumBy`, `template`, `times`,\n\t     * `toLower`, `toInteger`, `toLength`, `toNumber`, `toSafeInteger`, toString`,\n\t     * `toUpper`, `trim`, `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`,\n\t     * `upperCase`, `upperFirst`, `value`, and `words`\n\t     *\n\t     * @name _\n\t     * @constructor\n\t     * @category Seq\n\t     * @param {*} value The value to wrap in a `lodash` instance.\n\t     * @returns {Object} Returns the new `lodash` wrapper instance.\n\t     * @example\n\t     *\n\t     * function square(n) {\n\t     *   return n * n;\n\t     * }\n\t     *\n\t     * var wrapped = _([1, 2, 3]);\n\t     *\n\t     * // returns an unwrapped value\n\t     * wrapped.reduce(_.add);\n\t     * // => 6\n\t     *\n\t     * // returns a wrapped value\n\t     * var squares = wrapped.map(square);\n\t     *\n\t     * _.isArray(squares);\n\t     * // => false\n\t     *\n\t     * _.isArray(squares.value());\n\t     * // => true\n\t     */\n\t    function lodash(value) {\n\t      if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {\n\t        if (value instanceof LodashWrapper) {\n\t          return value;\n\t        }\n\t        if (hasOwnProperty.call(value, '__wrapped__')) {\n\t          return wrapperClone(value);\n\t        }\n\t      }\n\t      return new LodashWrapper(value);\n\t    }\n\t\n\t    /**\n\t     * The function whose prototype all chaining wrappers inherit from.\n\t     *\n\t     * @private\n\t     */\n\t    function baseLodash() {\n\t      // No operation performed.\n\t    }\n\t\n\t    /**\n\t     * The base constructor for creating `lodash` wrapper objects.\n\t     *\n\t     * @private\n\t     * @param {*} value The value to wrap.\n\t     * @param {boolean} [chainAll] Enable chaining for all wrapper methods.\n\t     */\n\t    function LodashWrapper(value, chainAll) {\n\t      this.__wrapped__ = value;\n\t      this.__actions__ = [];\n\t      this.__chain__ = !!chainAll;\n\t      this.__index__ = 0;\n\t      this.__values__ = undefined;\n\t    }\n\t\n\t    /**\n\t     * By default, the template delimiters used by lodash are like those in\n\t     * embedded Ruby (ERB). Change the following template settings to use\n\t     * alternative delimiters.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @type Object\n\t     */\n\t    lodash.templateSettings = {\n\t\n\t      /**\n\t       * Used to detect `data` property values to be HTML-escaped.\n\t       *\n\t       * @memberOf _.templateSettings\n\t       * @type RegExp\n\t       */\n\t      'escape': reEscape,\n\t\n\t      /**\n\t       * Used to detect code to be evaluated.\n\t       *\n\t       * @memberOf _.templateSettings\n\t       * @type RegExp\n\t       */\n\t      'evaluate': reEvaluate,\n\t\n\t      /**\n\t       * Used to detect `data` property values to inject.\n\t       *\n\t       * @memberOf _.templateSettings\n\t       * @type RegExp\n\t       */\n\t      'interpolate': reInterpolate,\n\t\n\t      /**\n\t       * Used to reference the data object in the template text.\n\t       *\n\t       * @memberOf _.templateSettings\n\t       * @type string\n\t       */\n\t      'variable': '',\n\t\n\t      /**\n\t       * Used to import variables into the compiled template.\n\t       *\n\t       * @memberOf _.templateSettings\n\t       * @type Object\n\t       */\n\t      'imports': {\n\t\n\t        /**\n\t         * A reference to the `lodash` function.\n\t         *\n\t         * @memberOf _.templateSettings.imports\n\t         * @type Function\n\t         */\n\t        '_': lodash\n\t      }\n\t    };\n\t\n\t    /*------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.\n\t     *\n\t     * @private\n\t     * @param {*} value The value to wrap.\n\t     */\n\t    function LazyWrapper(value) {\n\t      this.__wrapped__ = value;\n\t      this.__actions__ = [];\n\t      this.__dir__ = 1;\n\t      this.__filtered__ = false;\n\t      this.__iteratees__ = [];\n\t      this.__takeCount__ = MAX_ARRAY_LENGTH;\n\t      this.__views__ = [];\n\t    }\n\t\n\t    /**\n\t     * Creates a clone of the lazy wrapper object.\n\t     *\n\t     * @private\n\t     * @name clone\n\t     * @memberOf LazyWrapper\n\t     * @returns {Object} Returns the cloned `LazyWrapper` object.\n\t     */\n\t    function lazyClone() {\n\t      var result = new LazyWrapper(this.__wrapped__);\n\t      result.__actions__ = copyArray(this.__actions__);\n\t      result.__dir__ = this.__dir__;\n\t      result.__filtered__ = this.__filtered__;\n\t      result.__iteratees__ = copyArray(this.__iteratees__);\n\t      result.__takeCount__ = this.__takeCount__;\n\t      result.__views__ = copyArray(this.__views__);\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * Reverses the direction of lazy iteration.\n\t     *\n\t     * @private\n\t     * @name reverse\n\t     * @memberOf LazyWrapper\n\t     * @returns {Object} Returns the new reversed `LazyWrapper` object.\n\t     */\n\t    function lazyReverse() {\n\t      if (this.__filtered__) {\n\t        var result = new LazyWrapper(this);\n\t        result.__dir__ = -1;\n\t        result.__filtered__ = true;\n\t      } else {\n\t        result = this.clone();\n\t        result.__dir__ *= -1;\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * Extracts the unwrapped value from its lazy wrapper.\n\t     *\n\t     * @private\n\t     * @name value\n\t     * @memberOf LazyWrapper\n\t     * @returns {*} Returns the unwrapped value.\n\t     */\n\t    function lazyValue() {\n\t      var array = this.__wrapped__.value(),\n\t          dir = this.__dir__,\n\t          isArr = isArray(array),\n\t          isRight = dir < 0,\n\t          arrLength = isArr ? array.length : 0,\n\t          view = getView(0, arrLength, this.__views__),\n\t          start = view.start,\n\t          end = view.end,\n\t          length = end - start,\n\t          index = isRight ? end : (start - 1),\n\t          iteratees = this.__iteratees__,\n\t          iterLength = iteratees.length,\n\t          resIndex = 0,\n\t          takeCount = nativeMin(length, this.__takeCount__);\n\t\n\t      if (!isArr || arrLength < LARGE_ARRAY_SIZE || (arrLength == length && takeCount == length)) {\n\t        return baseWrapperValue(array, this.__actions__);\n\t      }\n\t      var result = [];\n\t\n\t      outer:\n\t      while (length-- && resIndex < takeCount) {\n\t        index += dir;\n\t\n\t        var iterIndex = -1,\n\t            value = array[index];\n\t\n\t        while (++iterIndex < iterLength) {\n\t          var data = iteratees[iterIndex],\n\t              iteratee = data.iteratee,\n\t              type = data.type,\n\t              computed = iteratee(value);\n\t\n\t          if (type == LAZY_MAP_FLAG) {\n\t            value = computed;\n\t          } else if (!computed) {\n\t            if (type == LAZY_FILTER_FLAG) {\n\t              continue outer;\n\t            } else {\n\t              break outer;\n\t            }\n\t          }\n\t        }\n\t        result[resIndex++] = value;\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /*------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * Creates an hash object.\n\t     *\n\t     * @private\n\t     * @returns {Object} Returns the new hash object.\n\t     */\n\t    function Hash() {}\n\t\n\t    /**\n\t     * Removes `key` and its value from the hash.\n\t     *\n\t     * @private\n\t     * @param {Object} hash The hash to modify.\n\t     * @param {string} key The key of the value to remove.\n\t     * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n\t     */\n\t    function hashDelete(hash, key) {\n\t      return hashHas(hash, key) && delete hash[key];\n\t    }\n\t\n\t    /**\n\t     * Gets the hash value for `key`.\n\t     *\n\t     * @private\n\t     * @param {Object} hash The hash to query.\n\t     * @param {string} key The key of the value to get.\n\t     * @returns {*} Returns the entry value.\n\t     */\n\t    function hashGet(hash, key) {\n\t      if (nativeCreate) {\n\t        var result = hash[key];\n\t        return result === HASH_UNDEFINED ? undefined : result;\n\t      }\n\t      return hasOwnProperty.call(hash, key) ? hash[key] : undefined;\n\t    }\n\t\n\t    /**\n\t     * Checks if a hash value for `key` exists.\n\t     *\n\t     * @private\n\t     * @param {Object} hash The hash to query.\n\t     * @param {string} key The key of the entry to check.\n\t     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n\t     */\n\t    function hashHas(hash, key) {\n\t      return nativeCreate ? hash[key] !== undefined : hasOwnProperty.call(hash, key);\n\t    }\n\t\n\t    /**\n\t     * Sets the hash `key` to `value`.\n\t     *\n\t     * @private\n\t     * @param {Object} hash The hash to modify.\n\t     * @param {string} key The key of the value to set.\n\t     * @param {*} value The value to set.\n\t     */\n\t    function hashSet(hash, key, value) {\n\t      hash[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n\t    }\n\t\n\t    /*------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * Creates a map cache object to store key-value pairs.\n\t     *\n\t     * @private\n\t     * @param {Array} [values] The values to cache.\n\t     */\n\t    function MapCache(values) {\n\t      var index = -1,\n\t          length = values ? values.length : 0;\n\t\n\t      this.clear();\n\t      while (++index < length) {\n\t        var entry = values[index];\n\t        this.set(entry[0], entry[1]);\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Removes all key-value entries from the map.\n\t     *\n\t     * @private\n\t     * @name clear\n\t     * @memberOf MapCache\n\t     */\n\t    function mapClear() {\n\t      this.__data__ = { 'hash': new Hash, 'map': Map ? new Map : [], 'string': new Hash };\n\t    }\n\t\n\t    /**\n\t     * Removes `key` and its value from the map.\n\t     *\n\t     * @private\n\t     * @name delete\n\t     * @memberOf MapCache\n\t     * @param {string} key The key of the value to remove.\n\t     * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n\t     */\n\t    function mapDelete(key) {\n\t      var data = this.__data__;\n\t      if (isKeyable(key)) {\n\t        return hashDelete(typeof key == 'string' ? data.string : data.hash, key);\n\t      }\n\t      return Map ? data.map['delete'](key) : assocDelete(data.map, key);\n\t    }\n\t\n\t    /**\n\t     * Gets the map value for `key`.\n\t     *\n\t     * @private\n\t     * @name get\n\t     * @memberOf MapCache\n\t     * @param {string} key The key of the value to get.\n\t     * @returns {*} Returns the entry value.\n\t     */\n\t    function mapGet(key) {\n\t      var data = this.__data__;\n\t      if (isKeyable(key)) {\n\t        return hashGet(typeof key == 'string' ? data.string : data.hash, key);\n\t      }\n\t      return Map ? data.map.get(key) : assocGet(data.map, key);\n\t    }\n\t\n\t    /**\n\t     * Checks if a map value for `key` exists.\n\t     *\n\t     * @private\n\t     * @name has\n\t     * @memberOf MapCache\n\t     * @param {string} key The key of the entry to check.\n\t     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n\t     */\n\t    function mapHas(key) {\n\t      var data = this.__data__;\n\t      if (isKeyable(key)) {\n\t        return hashHas(typeof key == 'string' ? data.string : data.hash, key);\n\t      }\n\t      return Map ? data.map.has(key) : assocHas(data.map, key);\n\t    }\n\t\n\t    /**\n\t     * Sets the map `key` to `value`.\n\t     *\n\t     * @private\n\t     * @name set\n\t     * @memberOf MapCache\n\t     * @param {string} key The key of the value to set.\n\t     * @param {*} value The value to set.\n\t     * @returns {Object} Returns the map cache object.\n\t     */\n\t    function mapSet(key, value) {\n\t      var data = this.__data__;\n\t      if (isKeyable(key)) {\n\t        hashSet(typeof key == 'string' ? data.string : data.hash, key, value);\n\t      } else if (Map) {\n\t        data.map.set(key, value);\n\t      } else {\n\t        assocSet(data.map, key, value);\n\t      }\n\t      return this;\n\t    }\n\t\n\t    /*------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     *\n\t     * Creates a set cache object to store unique values.\n\t     *\n\t     * @private\n\t     * @param {Array} [values] The values to cache.\n\t     */\n\t    function SetCache(values) {\n\t      var index = -1,\n\t          length = values ? values.length : 0;\n\t\n\t      this.__data__ = new MapCache;\n\t      while (++index < length) {\n\t        this.push(values[index]);\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is in `cache`.\n\t     *\n\t     * @private\n\t     * @param {Object} cache The set cache to search.\n\t     * @param {*} value The value to search for.\n\t     * @returns {number} Returns `true` if `value` is found, else `false`.\n\t     */\n\t    function cacheHas(cache, value) {\n\t      var map = cache.__data__;\n\t      if (isKeyable(value)) {\n\t        var data = map.__data__,\n\t            hash = typeof value == 'string' ? data.string : data.hash;\n\t\n\t        return hash[value] === HASH_UNDEFINED;\n\t      }\n\t      return map.has(value);\n\t    }\n\t\n\t    /**\n\t     * Adds `value` to the set cache.\n\t     *\n\t     * @private\n\t     * @name push\n\t     * @memberOf SetCache\n\t     * @param {*} value The value to cache.\n\t     */\n\t    function cachePush(value) {\n\t      var map = this.__data__;\n\t      if (isKeyable(value)) {\n\t        var data = map.__data__,\n\t            hash = typeof value == 'string' ? data.string : data.hash;\n\t\n\t        hash[value] = HASH_UNDEFINED;\n\t      }\n\t      else {\n\t        map.set(value, HASH_UNDEFINED);\n\t      }\n\t    }\n\t\n\t    /*------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * Creates a stack cache object to store key-value pairs.\n\t     *\n\t     * @private\n\t     * @param {Array} [values] The values to cache.\n\t     */\n\t    function Stack(values) {\n\t      var index = -1,\n\t          length = values ? values.length : 0;\n\t\n\t      this.clear();\n\t      while (++index < length) {\n\t        var entry = values[index];\n\t        this.set(entry[0], entry[1]);\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Removes all key-value entries from the stack.\n\t     *\n\t     * @private\n\t     * @name clear\n\t     * @memberOf Stack\n\t     */\n\t    function stackClear() {\n\t      this.__data__ = { 'array': [], 'map': null };\n\t    }\n\t\n\t    /**\n\t     * Removes `key` and its value from the stack.\n\t     *\n\t     * @private\n\t     * @name delete\n\t     * @memberOf Stack\n\t     * @param {string} key The key of the value to remove.\n\t     * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n\t     */\n\t    function stackDelete(key) {\n\t      var data = this.__data__,\n\t          array = data.array;\n\t\n\t      return array ? assocDelete(array, key) : data.map['delete'](key);\n\t    }\n\t\n\t    /**\n\t     * Gets the stack value for `key`.\n\t     *\n\t     * @private\n\t     * @name get\n\t     * @memberOf Stack\n\t     * @param {string} key The key of the value to get.\n\t     * @returns {*} Returns the entry value.\n\t     */\n\t    function stackGet(key) {\n\t      var data = this.__data__,\n\t          array = data.array;\n\t\n\t      return array ? assocGet(array, key) : data.map.get(key);\n\t    }\n\t\n\t    /**\n\t     * Checks if a stack value for `key` exists.\n\t     *\n\t     * @private\n\t     * @name has\n\t     * @memberOf Stack\n\t     * @param {string} key The key of the entry to check.\n\t     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n\t     */\n\t    function stackHas(key) {\n\t      var data = this.__data__,\n\t          array = data.array;\n\t\n\t      return array ? assocHas(array, key) : data.map.has(key);\n\t    }\n\t\n\t    /**\n\t     * Sets the stack `key` to `value`.\n\t     *\n\t     * @private\n\t     * @name set\n\t     * @memberOf Stack\n\t     * @param {string} key The key of the value to set.\n\t     * @param {*} value The value to set.\n\t     * @returns {Object} Returns the stack cache object.\n\t     */\n\t    function stackSet(key, value) {\n\t      var data = this.__data__,\n\t          array = data.array;\n\t\n\t      if (array) {\n\t        if (array.length < (LARGE_ARRAY_SIZE - 1)) {\n\t          assocSet(array, key, value);\n\t        } else {\n\t          data.array = null;\n\t          data.map = new MapCache(array);\n\t        }\n\t      }\n\t      var map = data.map;\n\t      if (map) {\n\t        map.set(key, value);\n\t      }\n\t      return this;\n\t    }\n\t\n\t    /*------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * Removes `key` and its value from the associative array.\n\t     *\n\t     * @private\n\t     * @param {Array} array The array to query.\n\t     * @param {string} key The key of the value to remove.\n\t     * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n\t     */\n\t    function assocDelete(array, key) {\n\t      var index = assocIndexOf(array, key);\n\t      if (index < 0) {\n\t        return false;\n\t      }\n\t      var lastIndex = array.length - 1;\n\t      if (index == lastIndex) {\n\t        array.pop();\n\t      } else {\n\t        splice.call(array, index, 1);\n\t      }\n\t      return true;\n\t    }\n\t\n\t    /**\n\t     * Gets the associative array value for `key`.\n\t     *\n\t     * @private\n\t     * @param {Array} array The array to query.\n\t     * @param {string} key The key of the value to get.\n\t     * @returns {*} Returns the entry value.\n\t     */\n\t    function assocGet(array, key) {\n\t      var index = assocIndexOf(array, key);\n\t      return index < 0 ? undefined : array[index][1];\n\t    }\n\t\n\t    /**\n\t     * Checks if an associative array value for `key` exists.\n\t     *\n\t     * @private\n\t     * @param {Array} array The array to query.\n\t     * @param {string} key The key of the entry to check.\n\t     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n\t     */\n\t    function assocHas(array, key) {\n\t      return assocIndexOf(array, key) > -1;\n\t    }\n\t\n\t    /**\n\t     * Gets the index at which the first occurrence of `key` is found in `array`\n\t     * of key-value pairs.\n\t     *\n\t     * @private\n\t     * @param {Array} array The array to search.\n\t     * @param {*} key The key to search for.\n\t     * @returns {number} Returns the index of the matched value, else `-1`.\n\t     */\n\t    function assocIndexOf(array, key) {\n\t      var length = array.length;\n\t      while (length--) {\n\t        if (eq(array[length][0], key)) {\n\t          return length;\n\t        }\n\t      }\n\t      return -1;\n\t    }\n\t\n\t    /**\n\t     * Sets the associative array `key` to `value`.\n\t     *\n\t     * @private\n\t     * @param {Array} array The array to modify.\n\t     * @param {string} key The key of the value to set.\n\t     * @param {*} value The value to set.\n\t     */\n\t    function assocSet(array, key, value) {\n\t      var index = assocIndexOf(array, key);\n\t      if (index < 0) {\n\t        array.push([key, value]);\n\t      } else {\n\t        array[index][1] = value;\n\t      }\n\t    }\n\t\n\t    /*------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * Used by `_.defaults` to customize its `_.assignIn` use.\n\t     *\n\t     * @private\n\t     * @param {*} objValue The destination value.\n\t     * @param {*} srcValue The source value.\n\t     * @param {string} key The key of the property to assign.\n\t     * @param {Object} object The parent object of `objValue`.\n\t     * @returns {*} Returns the value to assign.\n\t     */\n\t    function assignInDefaults(objValue, srcValue, key, object) {\n\t      if (objValue === undefined ||\n\t          (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {\n\t        return srcValue;\n\t      }\n\t      return objValue;\n\t    }\n\t\n\t    /**\n\t     * This function is like `assignValue` except that it doesn't assign `undefined` values.\n\t     *\n\t     * @private\n\t     * @param {Object} object The object to modify.\n\t     * @param {string} key The key of the property to assign.\n\t     * @param {*} value The value to assign.\n\t     */\n\t    function assignMergeValue(object, key, value) {\n\t      if ((value !== undefined && !eq(object[key], value)) ||\n\t          (typeof key == 'number' && value === undefined && !(key in object))) {\n\t        object[key] = value;\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Assigns `value` to `key` of `object` if the existing value is not equivalent\n\t     * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)\n\t     * for equality comparisons.\n\t     *\n\t     * @private\n\t     * @param {Object} object The object to modify.\n\t     * @param {string} key The key of the property to assign.\n\t     * @param {*} value The value to assign.\n\t     */\n\t    function assignValue(object, key, value) {\n\t      var objValue = object[key];\n\t      if ((!eq(objValue, value) ||\n\t            (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) ||\n\t          (value === undefined && !(key in object))) {\n\t        object[key] = value;\n\t      }\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.assign` without support for multiple sources\n\t     * or `customizer` functions.\n\t     *\n\t     * @private\n\t     * @param {Object} object The destination object.\n\t     * @param {Object} source The source object.\n\t     * @returns {Object} Returns `object`.\n\t     */\n\t    function baseAssign(object, source) {\n\t      return object && copyObject(source, keys(source), object);\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.at` without support for individual paths.\n\t     *\n\t     * @private\n\t     * @param {Object} object The object to iterate over.\n\t     * @param {string[]} paths The property paths of elements to pick.\n\t     * @returns {Array} Returns the new array of picked elements.\n\t     */\n\t    function baseAt(object, paths) {\n\t      var index = -1,\n\t          isNil = object == null,\n\t          length = paths.length,\n\t          result = Array(length);\n\t\n\t      while (++index < length) {\n\t        result[index] = isNil ? undefined : get(object, paths[index]);\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.clamp` which doesn't coerce arguments to numbers.\n\t     *\n\t     * @private\n\t     * @param {number} number The number to clamp.\n\t     * @param {number} [lower] The lower bound.\n\t     * @param {number} upper The upper bound.\n\t     * @returns {number} Returns the clamped number.\n\t     */\n\t    function baseClamp(number, lower, upper) {\n\t      if (number === number) {\n\t        if (upper !== undefined) {\n\t          number = number <= upper ? number : upper;\n\t        }\n\t        if (lower !== undefined) {\n\t          number = number >= lower ? number : lower;\n\t        }\n\t      }\n\t      return number;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.clone` and `_.cloneDeep` which tracks\n\t     * traversed objects.\n\t     *\n\t     * @private\n\t     * @param {*} value The value to clone.\n\t     * @param {boolean} [isDeep] Specify a deep clone.\n\t     * @param {Function} [customizer] The function to customize cloning.\n\t     * @param {string} [key] The key of `value`.\n\t     * @param {Object} [object] The parent object of `value`.\n\t     * @param {Object} [stack] Tracks traversed objects and their clone counterparts.\n\t     * @returns {*} Returns the cloned value.\n\t     */\n\t    function baseClone(value, isDeep, customizer, key, object, stack) {\n\t      var result;\n\t      if (customizer) {\n\t        result = object ? customizer(value, key, object, stack) : customizer(value);\n\t      }\n\t      if (result !== undefined) {\n\t        return result;\n\t      }\n\t      if (!isObject(value)) {\n\t        return value;\n\t      }\n\t      var isArr = isArray(value);\n\t      if (isArr) {\n\t        result = initCloneArray(value);\n\t        if (!isDeep) {\n\t          return copyArray(value, result);\n\t        }\n\t      } else {\n\t        var tag = getTag(value),\n\t            isFunc = tag == funcTag || tag == genTag;\n\t\n\t        if (tag == objectTag || tag == argsTag || (isFunc && !object)) {\n\t          if (isHostObject(value)) {\n\t            return object ? value : {};\n\t          }\n\t          result = initCloneObject(isFunc ? {} : value);\n\t          if (!isDeep) {\n\t            return copySymbols(value, baseAssign(result, value));\n\t          }\n\t        } else {\n\t          return cloneableTags[tag]\n\t            ? initCloneByTag(value, tag, isDeep)\n\t            : (object ? value : {});\n\t        }\n\t      }\n\t      // Check for circular references and return its corresponding clone.\n\t      stack || (stack = new Stack);\n\t      var stacked = stack.get(value);\n\t      if (stacked) {\n\t        return stacked;\n\t      }\n\t      stack.set(value, result);\n\t\n\t      // Recursively populate clone (susceptible to call stack limits).\n\t      (isArr ? arrayEach : baseForOwn)(value, function(subValue, key) {\n\t        assignValue(result, key, baseClone(subValue, isDeep, customizer, key, value, stack));\n\t      });\n\t      return isArr ? result : copySymbols(value, result);\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.conforms` which doesn't clone `source`.\n\t     *\n\t     * @private\n\t     * @param {Object} source The object of property predicates to conform to.\n\t     * @returns {Function} Returns the new function.\n\t     */\n\t    function baseConforms(source) {\n\t      var props = keys(source),\n\t          length = props.length;\n\t\n\t      return function(object) {\n\t        if (object == null) {\n\t          return !length;\n\t        }\n\t        var index = length;\n\t        while (index--) {\n\t          var key = props[index],\n\t              predicate = source[key],\n\t              value = object[key];\n\t\n\t          if ((value === undefined && !(key in Object(object))) || !predicate(value)) {\n\t            return false;\n\t          }\n\t        }\n\t        return true;\n\t      };\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.create` without support for assigning\n\t     * properties to the created object.\n\t     *\n\t     * @private\n\t     * @param {Object} prototype The object to inherit from.\n\t     * @returns {Object} Returns the new object.\n\t     */\n\t    var baseCreate = (function() {\n\t      function object() {}\n\t      return function(prototype) {\n\t        if (isObject(prototype)) {\n\t          object.prototype = prototype;\n\t          var result = new object;\n\t          object.prototype = undefined;\n\t        }\n\t        return result || {};\n\t      };\n\t    }());\n\t\n\t    /**\n\t     * The base implementation of `_.delay` and `_.defer` which accepts an array\n\t     * of `func` arguments.\n\t     *\n\t     * @private\n\t     * @param {Function} func The function to delay.\n\t     * @param {number} wait The number of milliseconds to delay invocation.\n\t     * @param {Object} args The arguments provide to `func`.\n\t     * @returns {number} Returns the timer id.\n\t     */\n\t    function baseDelay(func, wait, args) {\n\t      if (typeof func != 'function') {\n\t        throw new TypeError(FUNC_ERROR_TEXT);\n\t      }\n\t      return setTimeout(function() { func.apply(undefined, args); }, wait);\n\t    }\n\t\n\t    /**\n\t     * The base implementation of methods like `_.difference` without support for\n\t     * excluding multiple arrays or iteratee shorthands.\n\t     *\n\t     * @private\n\t     * @param {Array} array The array to inspect.\n\t     * @param {Array} values The values to exclude.\n\t     * @param {Function} [iteratee] The iteratee invoked per element.\n\t     * @param {Function} [comparator] The comparator invoked per element.\n\t     * @returns {Array} Returns the new array of filtered values.\n\t     */\n\t    function baseDifference(array, values, iteratee, comparator) {\n\t      var index = -1,\n\t          includes = arrayIncludes,\n\t          isCommon = true,\n\t          length = array.length,\n\t          result = [],\n\t          valuesLength = values.length;\n\t\n\t      if (!length) {\n\t        return result;\n\t      }\n\t      if (iteratee) {\n\t        values = arrayMap(values, baseUnary(iteratee));\n\t      }\n\t      if (comparator) {\n\t        includes = arrayIncludesWith;\n\t        isCommon = false;\n\t      }\n\t      else if (values.length >= LARGE_ARRAY_SIZE) {\n\t        includes = cacheHas;\n\t        isCommon = false;\n\t        values = new SetCache(values);\n\t      }\n\t      outer:\n\t      while (++index < length) {\n\t        var value = array[index],\n\t            computed = iteratee ? iteratee(value) : value;\n\t\n\t        if (isCommon && computed === computed) {\n\t          var valuesIndex = valuesLength;\n\t          while (valuesIndex--) {\n\t            if (values[valuesIndex] === computed) {\n\t              continue outer;\n\t            }\n\t          }\n\t          result.push(value);\n\t        }\n\t        else if (!includes(values, computed, comparator)) {\n\t          result.push(value);\n\t        }\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.forEach` without support for iteratee shorthands.\n\t     *\n\t     * @private\n\t     * @param {Array|Object} collection The collection to iterate over.\n\t     * @param {Function} iteratee The function invoked per iteration.\n\t     * @returns {Array|Object} Returns `collection`.\n\t     */\n\t    var baseEach = createBaseEach(baseForOwn);\n\t\n\t    /**\n\t     * The base implementation of `_.forEachRight` without support for iteratee shorthands.\n\t     *\n\t     * @private\n\t     * @param {Array|Object} collection The collection to iterate over.\n\t     * @param {Function} iteratee The function invoked per iteration.\n\t     * @returns {Array|Object} Returns `collection`.\n\t     */\n\t    var baseEachRight = createBaseEach(baseForOwnRight, true);\n\t\n\t    /**\n\t     * The base implementation of `_.every` without support for iteratee shorthands.\n\t     *\n\t     * @private\n\t     * @param {Array|Object} collection The collection to iterate over.\n\t     * @param {Function} predicate The function invoked per iteration.\n\t     * @returns {boolean} Returns `true` if all elements pass the predicate check, else `false`\n\t     */\n\t    function baseEvery(collection, predicate) {\n\t      var result = true;\n\t      baseEach(collection, function(value, index, collection) {\n\t        result = !!predicate(value, index, collection);\n\t        return result;\n\t      });\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.fill` without an iteratee call guard.\n\t     *\n\t     * @private\n\t     * @param {Array} array The array to fill.\n\t     * @param {*} value The value to fill `array` with.\n\t     * @param {number} [start=0] The start position.\n\t     * @param {number} [end=array.length] The end position.\n\t     * @returns {Array} Returns `array`.\n\t     */\n\t    function baseFill(array, value, start, end) {\n\t      var length = array.length;\n\t\n\t      start = toInteger(start);\n\t      if (start < 0) {\n\t        start = -start > length ? 0 : (length + start);\n\t      }\n\t      end = (end === undefined || end > length) ? length : toInteger(end);\n\t      if (end < 0) {\n\t        end += length;\n\t      }\n\t      end = start > end ? 0 : toLength(end);\n\t      while (start < end) {\n\t        array[start++] = value;\n\t      }\n\t      return array;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.filter` without support for iteratee shorthands.\n\t     *\n\t     * @private\n\t     * @param {Array|Object} collection The collection to iterate over.\n\t     * @param {Function} predicate The function invoked per iteration.\n\t     * @returns {Array} Returns the new filtered array.\n\t     */\n\t    function baseFilter(collection, predicate) {\n\t      var result = [];\n\t      baseEach(collection, function(value, index, collection) {\n\t        if (predicate(value, index, collection)) {\n\t          result.push(value);\n\t        }\n\t      });\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.flatten` with support for restricting flattening.\n\t     *\n\t     * @private\n\t     * @param {Array} array The array to flatten.\n\t     * @param {boolean} [isDeep] Specify a deep flatten.\n\t     * @param {boolean} [isStrict] Restrict flattening to arrays-like objects.\n\t     * @param {Array} [result=[]] The initial result value.\n\t     * @returns {Array} Returns the new flattened array.\n\t     */\n\t    function baseFlatten(array, isDeep, isStrict, result) {\n\t      result || (result = []);\n\t\n\t      var index = -1,\n\t          length = array.length;\n\t\n\t      while (++index < length) {\n\t        var value = array[index];\n\t        if (isArrayLikeObject(value) &&\n\t            (isStrict || isArray(value) || isArguments(value))) {\n\t          if (isDeep) {\n\t            // Recursively flatten arrays (susceptible to call stack limits).\n\t            baseFlatten(value, isDeep, isStrict, result);\n\t          } else {\n\t            arrayPush(result, value);\n\t          }\n\t        } else if (!isStrict) {\n\t          result[result.length] = value;\n\t        }\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `baseForIn` and `baseForOwn` which iterates\n\t     * over `object` properties returned by `keysFunc` invoking `iteratee` for\n\t     * each property. Iteratee functions may exit iteration early by explicitly\n\t     * returning `false`.\n\t     *\n\t     * @private\n\t     * @param {Object} object The object to iterate over.\n\t     * @param {Function} iteratee The function invoked per iteration.\n\t     * @param {Function} keysFunc The function to get the keys of `object`.\n\t     * @returns {Object} Returns `object`.\n\t     */\n\t    var baseFor = createBaseFor();\n\t\n\t    /**\n\t     * This function is like `baseFor` except that it iterates over properties\n\t     * in the opposite order.\n\t     *\n\t     * @private\n\t     * @param {Object} object The object to iterate over.\n\t     * @param {Function} iteratee The function invoked per iteration.\n\t     * @param {Function} keysFunc The function to get the keys of `object`.\n\t     * @returns {Object} Returns `object`.\n\t     */\n\t    var baseForRight = createBaseFor(true);\n\t\n\t    /**\n\t     * The base implementation of `_.forIn` without support for iteratee shorthands.\n\t     *\n\t     * @private\n\t     * @param {Object} object The object to iterate over.\n\t     * @param {Function} iteratee The function invoked per iteration.\n\t     * @returns {Object} Returns `object`.\n\t     */\n\t    function baseForIn(object, iteratee) {\n\t      return object == null ? object : baseFor(object, iteratee, keysIn);\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.forOwn` without support for iteratee shorthands.\n\t     *\n\t     * @private\n\t     * @param {Object} object The object to iterate over.\n\t     * @param {Function} iteratee The function invoked per iteration.\n\t     * @returns {Object} Returns `object`.\n\t     */\n\t    function baseForOwn(object, iteratee) {\n\t      return object && baseFor(object, iteratee, keys);\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.forOwnRight` without support for iteratee shorthands.\n\t     *\n\t     * @private\n\t     * @param {Object} object The object to iterate over.\n\t     * @param {Function} iteratee The function invoked per iteration.\n\t     * @returns {Object} Returns `object`.\n\t     */\n\t    function baseForOwnRight(object, iteratee) {\n\t      return object && baseForRight(object, iteratee, keys);\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.functions` which creates an array of\n\t     * `object` function property names filtered from those provided.\n\t     *\n\t     * @private\n\t     * @param {Object} object The object to inspect.\n\t     * @param {Array} props The property names to filter.\n\t     * @returns {Array} Returns the new array of filtered property names.\n\t     */\n\t    function baseFunctions(object, props) {\n\t      return arrayFilter(props, function(key) {\n\t        return isFunction(object[key]);\n\t      });\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.get` without support for default values.\n\t     *\n\t     * @private\n\t     * @param {Object} object The object to query.\n\t     * @param {Array|string} path The path of the property to get.\n\t     * @returns {*} Returns the resolved value.\n\t     */\n\t    function baseGet(object, path) {\n\t      path = isKey(path, object) ? [path + ''] : baseToPath(path);\n\t\n\t      var index = 0,\n\t          length = path.length;\n\t\n\t      while (object != null && index < length) {\n\t        object = object[path[index++]];\n\t      }\n\t      return (index && index == length) ? object : undefined;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.has` without support for deep paths.\n\t     *\n\t     * @private\n\t     * @param {Object} object The object to query.\n\t     * @param {Array|string} key The key to check.\n\t     * @returns {boolean} Returns `true` if `key` exists, else `false`.\n\t     */\n\t    function baseHas(object, key) {\n\t      // Avoid a bug in IE 10-11 where objects with a [[Prototype]] of `null`,\n\t      // that are composed entirely of index properties, return `false` for\n\t      // `hasOwnProperty` checks of them.\n\t      return hasOwnProperty.call(object, key) ||\n\t        (typeof object == 'object' && key in object && getPrototypeOf(object) === null);\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.hasIn` without support for deep paths.\n\t     *\n\t     * @private\n\t     * @param {Object} object The object to query.\n\t     * @param {Array|string} key The key to check.\n\t     * @returns {boolean} Returns `true` if `key` exists, else `false`.\n\t     */\n\t    function baseHasIn(object, key) {\n\t      return key in Object(object);\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.inRange` which doesn't coerce arguments to numbers.\n\t     *\n\t     * @private\n\t     * @param {number} number The number to check.\n\t     * @param {number} start The start of the range.\n\t     * @param {number} end The end of the range.\n\t     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.\n\t     */\n\t    function baseInRange(number, start, end) {\n\t      return number >= nativeMin(start, end) && number < nativeMax(start, end);\n\t    }\n\t\n\t    /**\n\t     * The base implementation of methods like `_.intersection`, without support\n\t     * for iteratee shorthands, that accepts an array of arrays to inspect.\n\t     *\n\t     * @private\n\t     * @param {Array} arrays The arrays to inspect.\n\t     * @param {Function} [iteratee] The iteratee invoked per element.\n\t     * @param {Function} [comparator] The comparator invoked per element.\n\t     * @returns {Array} Returns the new array of shared values.\n\t     */\n\t    function baseIntersection(arrays, iteratee, comparator) {\n\t      var includes = comparator ? arrayIncludesWith : arrayIncludes,\n\t          othLength = arrays.length,\n\t          othIndex = othLength,\n\t          caches = Array(othLength),\n\t          result = [];\n\t\n\t      while (othIndex--) {\n\t        var array = arrays[othIndex];\n\t        if (othIndex && iteratee) {\n\t          array = arrayMap(array, baseUnary(iteratee));\n\t        }\n\t        caches[othIndex] = !comparator && (iteratee || array.length >= 120)\n\t          ? new SetCache(othIndex && array)\n\t          : undefined;\n\t      }\n\t      array = arrays[0];\n\t\n\t      var index = -1,\n\t          length = array.length,\n\t          seen = caches[0];\n\t\n\t      outer:\n\t      while (++index < length) {\n\t        var value = array[index],\n\t            computed = iteratee ? iteratee(value) : value;\n\t\n\t        if (!(seen ? cacheHas(seen, computed) : includes(result, computed, comparator))) {\n\t          var othIndex = othLength;\n\t          while (--othIndex) {\n\t            var cache = caches[othIndex];\n\t            if (!(cache ? cacheHas(cache, computed) : includes(arrays[othIndex], computed, comparator))) {\n\t              continue outer;\n\t            }\n\t          }\n\t          if (seen) {\n\t            seen.push(computed);\n\t          }\n\t          result.push(value);\n\t        }\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.invoke` without support for individual\n\t     * method arguments.\n\t     *\n\t     *\n\t     * @private\n\t     * @param {Object} object The object to query.\n\t     * @param {Array|string} path The path of the method to invoke.\n\t     * @param {Array} args The arguments to invoke the method with.\n\t     * @returns {*} Returns the result of the invoked method.\n\t     */\n\t    function baseInvoke(object, path, args) {\n\t      if (!isKey(path, object)) {\n\t        path = baseToPath(path);\n\t        object = parent(object, path);\n\t        path = last(path);\n\t      }\n\t      var func = object == null ? object : object[path];\n\t      return func == null ? undefined : apply(func, object, args);\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.isEqual` which supports partial comparisons\n\t     * and tracks traversed objects.\n\t     *\n\t     * @private\n\t     * @param {*} value The value to compare.\n\t     * @param {*} other The other value to compare.\n\t     * @param {Function} [customizer] The function to customize comparisons.\n\t     * @param {boolean} [bitmask] The bitmask of comparison flags.\n\t     *  The bitmask may be composed of the following flags:\n\t     *     1 - Unordered comparison\n\t     *     2 - Partial comparison\n\t     * @param {Object} [stack] Tracks traversed `value` and `other` objects.\n\t     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n\t     */\n\t    function baseIsEqual(value, other, customizer, bitmask, stack) {\n\t      if (value === other) {\n\t        return true;\n\t      }\n\t      if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {\n\t        return value !== value && other !== other;\n\t      }\n\t      return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);\n\t    }\n\t\n\t    /**\n\t     * A specialized version of `baseIsEqual` for arrays and objects which performs\n\t     * deep comparisons and tracks traversed objects enabling objects with circular\n\t     * references to be compared.\n\t     *\n\t     * @private\n\t     * @param {Object} object The object to compare.\n\t     * @param {Object} other The other object to compare.\n\t     * @param {Function} equalFunc The function to determine equivalents of values.\n\t     * @param {Function} [customizer] The function to customize comparisons.\n\t     * @param {number} [bitmask] The bitmask of comparison flags. See `baseIsEqual` for more details.\n\t     * @param {Object} [stack] Tracks traversed `object` and `other` objects.\n\t     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n\t     */\n\t    function baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {\n\t      var objIsArr = isArray(object),\n\t          othIsArr = isArray(other),\n\t          objTag = arrayTag,\n\t          othTag = arrayTag;\n\t\n\t      if (!objIsArr) {\n\t        objTag = getTag(object);\n\t        if (objTag == argsTag) {\n\t          objTag = objectTag;\n\t        } else if (objTag != objectTag) {\n\t          objIsArr = isTypedArray(object);\n\t        }\n\t      }\n\t      if (!othIsArr) {\n\t        othTag = getTag(other);\n\t        if (othTag == argsTag) {\n\t          othTag = objectTag;\n\t        } else if (othTag != objectTag) {\n\t          othIsArr = isTypedArray(other);\n\t        }\n\t      }\n\t      var objIsObj = objTag == objectTag && !isHostObject(object),\n\t          othIsObj = othTag == objectTag && !isHostObject(other),\n\t          isSameTag = objTag == othTag;\n\t\n\t      if (isSameTag && !(objIsArr || objIsObj)) {\n\t        return equalByTag(object, other, objTag, equalFunc, customizer, bitmask);\n\t      }\n\t      var isPartial = bitmask & PARTIAL_COMPARE_FLAG;\n\t      if (!isPartial) {\n\t        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\n\t            othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\t\n\t        if (objIsWrapped || othIsWrapped) {\n\t          return equalFunc(objIsWrapped ? object.value() : object, othIsWrapped ? other.value() : other, customizer, bitmask, stack);\n\t        }\n\t      }\n\t      if (!isSameTag) {\n\t        return false;\n\t      }\n\t      stack || (stack = new Stack);\n\t      return (objIsArr ? equalArrays : equalObjects)(object, other, equalFunc, customizer, bitmask, stack);\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.isMatch` without support for iteratee shorthands.\n\t     *\n\t     * @private\n\t     * @param {Object} object The object to inspect.\n\t     * @param {Object} source The object of property values to match.\n\t     * @param {Array} matchData The property names, values, and compare flags to match.\n\t     * @param {Function} [customizer] The function to customize comparisons.\n\t     * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n\t     */\n\t    function baseIsMatch(object, source, matchData, customizer) {\n\t      var index = matchData.length,\n\t          length = index,\n\t          noCustomizer = !customizer;\n\t\n\t      if (object == null) {\n\t        return !length;\n\t      }\n\t      object = Object(object);\n\t      while (index--) {\n\t        var data = matchData[index];\n\t        if ((noCustomizer && data[2])\n\t              ? data[1] !== object[data[0]]\n\t              : !(data[0] in object)\n\t            ) {\n\t          return false;\n\t        }\n\t      }\n\t      while (++index < length) {\n\t        data = matchData[index];\n\t        var key = data[0],\n\t            objValue = object[key],\n\t            srcValue = data[1];\n\t\n\t        if (noCustomizer && data[2]) {\n\t          if (objValue === undefined && !(key in object)) {\n\t            return false;\n\t          }\n\t        } else {\n\t          var stack = new Stack,\n\t              result = customizer ? customizer(objValue, srcValue, key, object, source, stack) : undefined;\n\t\n\t          if (!(result === undefined ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack) : result)) {\n\t            return false;\n\t          }\n\t        }\n\t      }\n\t      return true;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.iteratee`.\n\t     *\n\t     * @private\n\t     * @param {*} [value=_.identity] The value to convert to an iteratee.\n\t     * @returns {Function} Returns the iteratee.\n\t     */\n\t    function baseIteratee(value) {\n\t      var type = typeof value;\n\t      if (type == 'function') {\n\t        return value;\n\t      }\n\t      if (value == null) {\n\t        return identity;\n\t      }\n\t      if (type == 'object') {\n\t        return isArray(value)\n\t          ? baseMatchesProperty(value[0], value[1])\n\t          : baseMatches(value);\n\t      }\n\t      return property(value);\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.keys` which doesn't skip the constructor\n\t     * property of prototypes or treat sparse arrays as dense.\n\t     *\n\t     * @private\n\t     * @type Function\n\t     * @param {Object} object The object to query.\n\t     * @returns {Array} Returns the array of property names.\n\t     */\n\t    function baseKeys(object) {\n\t      return nativeKeys(Object(object));\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.keysIn` which doesn't skip the constructor\n\t     * property of prototypes or treat sparse arrays as dense.\n\t     *\n\t     * @private\n\t     * @param {Object} object The object to query.\n\t     * @returns {Array} Returns the array of property names.\n\t     */\n\t    function baseKeysIn(object) {\n\t      object = object == null ? object : Object(object);\n\t\n\t      var result = [];\n\t      for (var key in object) {\n\t        result.push(key);\n\t      }\n\t      return result;\n\t    }\n\t\n\t    // Fallback for IE < 9 with es6-shim.\n\t    if (enumerate && !propertyIsEnumerable.call({ 'valueOf': 1 }, 'valueOf')) {\n\t      baseKeysIn = function(object) {\n\t        return iteratorToArray(enumerate(object));\n\t      };\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.map` without support for iteratee shorthands.\n\t     *\n\t     * @private\n\t     * @param {Array|Object} collection The collection to iterate over.\n\t     * @param {Function} iteratee The function invoked per iteration.\n\t     * @returns {Array} Returns the new mapped array.\n\t     */\n\t    function baseMap(collection, iteratee) {\n\t      var index = -1,\n\t          result = isArrayLike(collection) ? Array(collection.length) : [];\n\t\n\t      baseEach(collection, function(value, key, collection) {\n\t        result[++index] = iteratee(value, key, collection);\n\t      });\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.matches` which doesn't clone `source`.\n\t     *\n\t     * @private\n\t     * @param {Object} source The object of property values to match.\n\t     * @returns {Function} Returns the new function.\n\t     */\n\t    function baseMatches(source) {\n\t      var matchData = getMatchData(source);\n\t      if (matchData.length == 1 && matchData[0][2]) {\n\t        var key = matchData[0][0],\n\t            value = matchData[0][1];\n\t\n\t        return function(object) {\n\t          if (object == null) {\n\t            return false;\n\t          }\n\t          return object[key] === value &&\n\t            (value !== undefined || (key in Object(object)));\n\t        };\n\t      }\n\t      return function(object) {\n\t        return object === source || baseIsMatch(object, source, matchData);\n\t      };\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.\n\t     *\n\t     * @private\n\t     * @param {string} path The path of the property to get.\n\t     * @param {*} srcValue The value to match.\n\t     * @returns {Function} Returns the new function.\n\t     */\n\t    function baseMatchesProperty(path, srcValue) {\n\t      return function(object) {\n\t        var objValue = get(object, path);\n\t        return (objValue === undefined && objValue === srcValue)\n\t          ? hasIn(object, path)\n\t          : baseIsEqual(srcValue, objValue, undefined, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG);\n\t      };\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.merge` without support for multiple sources.\n\t     *\n\t     * @private\n\t     * @param {Object} object The destination object.\n\t     * @param {Object} source The source object.\n\t     * @param {Function} [customizer] The function to customize merged values.\n\t     * @param {Object} [stack] Tracks traversed source values and their merged counterparts.\n\t     */\n\t    function baseMerge(object, source, customizer, stack) {\n\t      if (object === source) {\n\t        return;\n\t      }\n\t      var props = (isArray(source) || isTypedArray(source)) ? undefined : keysIn(source);\n\t      arrayEach(props || source, function(srcValue, key) {\n\t        if (props) {\n\t          key = srcValue;\n\t          srcValue = source[key];\n\t        }\n\t        if (isObject(srcValue)) {\n\t          stack || (stack = new Stack);\n\t          baseMergeDeep(object, source, key, baseMerge, customizer, stack);\n\t        }\n\t        else {\n\t          var newValue = customizer ? customizer(object[key], srcValue, (key + ''), object, source, stack) : undefined;\n\t          if (newValue === undefined) {\n\t            newValue = srcValue;\n\t          }\n\t          assignMergeValue(object, key, newValue);\n\t        }\n\t      });\n\t    }\n\t\n\t    /**\n\t     * A specialized version of `baseMerge` for arrays and objects which performs\n\t     * deep merges and tracks traversed objects enabling objects with circular\n\t     * references to be merged.\n\t     *\n\t     * @private\n\t     * @param {Object} object The destination object.\n\t     * @param {Object} source The source object.\n\t     * @param {string} key The key of the value to merge.\n\t     * @param {Function} mergeFunc The function to merge values.\n\t     * @param {Function} [customizer] The function to customize assigned values.\n\t     * @param {Object} [stack] Tracks traversed source values and their merged counterparts.\n\t     */\n\t    function baseMergeDeep(object, source, key, mergeFunc, customizer, stack) {\n\t      var objValue = object[key],\n\t          srcValue = source[key],\n\t          stacked = stack.get(srcValue) || stack.get(objValue);\n\t\n\t      if (stacked) {\n\t        assignMergeValue(object, key, stacked);\n\t        return;\n\t      }\n\t      var newValue = customizer ? customizer(objValue, srcValue, (key + ''), object, source, stack) : undefined,\n\t          isCommon = newValue === undefined;\n\t\n\t      if (isCommon) {\n\t        newValue = srcValue;\n\t        if (isArray(srcValue) || isTypedArray(srcValue)) {\n\t          newValue = isArray(objValue)\n\t            ? objValue\n\t            : ((isArrayLikeObject(objValue)) ? copyArray(objValue) : baseClone(srcValue));\n\t        }\n\t        else if (isPlainObject(srcValue) || isArguments(srcValue)) {\n\t          newValue = isArguments(objValue)\n\t            ? toPlainObject(objValue)\n\t            : (isObject(objValue) ? objValue : baseClone(srcValue));\n\t        }\n\t        else {\n\t          isCommon = isFunction(srcValue);\n\t        }\n\t      }\n\t      stack.set(srcValue, newValue);\n\t\n\t      if (isCommon) {\n\t        // Recursively merge objects and arrays (susceptible to call stack limits).\n\t        mergeFunc(newValue, srcValue, customizer, stack);\n\t      }\n\t      assignMergeValue(object, key, newValue);\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.orderBy` without param guards.\n\t     *\n\t     * @private\n\t     * @param {Array|Object} collection The collection to iterate over.\n\t     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.\n\t     * @param {string[]} orders The sort orders of `iteratees`.\n\t     * @returns {Array} Returns the new sorted array.\n\t     */\n\t    function baseOrderBy(collection, iteratees, orders) {\n\t      var index = -1,\n\t          toIteratee = getIteratee();\n\t\n\t      iteratees = arrayMap(iteratees.length ? iteratees : Array(1), function(iteratee) {\n\t        return toIteratee(iteratee);\n\t      });\n\t\n\t      var result = baseMap(collection, function(value, key, collection) {\n\t        var criteria = arrayMap(iteratees, function(iteratee) {\n\t          return iteratee(value);\n\t        });\n\t        return { 'criteria': criteria, 'index': ++index, 'value': value };\n\t      });\n\t\n\t      return baseSortBy(result, function(object, other) {\n\t        return compareMultiple(object, other, orders);\n\t      });\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.pick` without support for individual\n\t     * property names.\n\t     *\n\t     * @private\n\t     * @param {Object} object The source object.\n\t     * @param {string[]} props The property names to pick.\n\t     * @returns {Object} Returns the new object.\n\t     */\n\t    function basePick(object, props) {\n\t      object = Object(object);\n\t      return arrayReduce(props, function(result, key) {\n\t        if (key in object) {\n\t          result[key] = object[key];\n\t        }\n\t        return result;\n\t      }, {});\n\t    }\n\t\n\t    /**\n\t     * The base implementation of  `_.pickBy` without support for iteratee shorthands.\n\t     *\n\t     * @private\n\t     * @param {Object} object The source object.\n\t     * @param {Function} predicate The function invoked per property.\n\t     * @returns {Object} Returns the new object.\n\t     */\n\t    function basePickBy(object, predicate) {\n\t      var result = {};\n\t      baseForIn(object, function(value, key) {\n\t        if (predicate(value)) {\n\t          result[key] = value;\n\t        }\n\t      });\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.property` without support for deep paths.\n\t     *\n\t     * @private\n\t     * @param {string} key The key of the property to get.\n\t     * @returns {Function} Returns the new function.\n\t     */\n\t    function baseProperty(key) {\n\t      return function(object) {\n\t        return object == null ? undefined : object[key];\n\t      };\n\t    }\n\t\n\t    /**\n\t     * A specialized version of `baseProperty` which supports deep paths.\n\t     *\n\t     * @private\n\t     * @param {Array|string} path The path of the property to get.\n\t     * @returns {Function} Returns the new function.\n\t     */\n\t    function basePropertyDeep(path) {\n\t      return function(object) {\n\t        return baseGet(object, path);\n\t      };\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.pullAll`.\n\t     *\n\t     * @private\n\t     * @param {Array} array The array to modify.\n\t     * @param {Array} values The values to remove.\n\t     * @returns {Array} Returns `array`.\n\t     */\n\t    function basePullAll(array, values) {\n\t      return basePullAllBy(array, values);\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.pullAllBy` without support for iteratee\n\t     * shorthands.\n\t     *\n\t     * @private\n\t     * @param {Array} array The array to modify.\n\t     * @param {Array} values The values to remove.\n\t     * @param {Function} [iteratee] The iteratee invoked per element.\n\t     * @returns {Array} Returns `array`.\n\t     */\n\t    function basePullAllBy(array, values, iteratee) {\n\t      var index = -1,\n\t          length = values.length,\n\t          seen = array;\n\t\n\t      if (iteratee) {\n\t        seen = arrayMap(array, function(value) { return iteratee(value); });\n\t      }\n\t      while (++index < length) {\n\t        var fromIndex = 0,\n\t            value = values[index],\n\t            computed = iteratee ? iteratee(value) : value;\n\t\n\t        while ((fromIndex = baseIndexOf(seen, computed, fromIndex)) > -1) {\n\t          if (seen !== array) {\n\t            splice.call(seen, fromIndex, 1);\n\t          }\n\t          splice.call(array, fromIndex, 1);\n\t        }\n\t      }\n\t      return array;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.pullAt` without support for individual\n\t     * indexes or capturing the removed elements.\n\t     *\n\t     * @private\n\t     * @param {Array} array The array to modify.\n\t     * @param {number[]} indexes The indexes of elements to remove.\n\t     * @returns {Array} Returns `array`.\n\t     */\n\t    function basePullAt(array, indexes) {\n\t      var length = array ? indexes.length : 0,\n\t          lastIndex = length - 1;\n\t\n\t      while (length--) {\n\t        var index = indexes[length];\n\t        if (lastIndex == length || index != previous) {\n\t          var previous = index;\n\t          if (isIndex(index)) {\n\t            splice.call(array, index, 1);\n\t          }\n\t          else if (!isKey(index, array)) {\n\t            var path = baseToPath(index),\n\t                object = parent(array, path);\n\t\n\t            if (object != null) {\n\t              delete object[last(path)];\n\t            }\n\t          }\n\t          else {\n\t            delete array[index];\n\t          }\n\t        }\n\t      }\n\t      return array;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.random` without support for returning\n\t     * floating-point numbers.\n\t     *\n\t     * @private\n\t     * @param {number} lower The lower bound.\n\t     * @param {number} upper The upper bound.\n\t     * @returns {number} Returns the random number.\n\t     */\n\t    function baseRandom(lower, upper) {\n\t      return lower + nativeFloor(nativeRandom() * (upper - lower + 1));\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.range` and `_.rangeRight` which doesn't\n\t     * coerce arguments to numbers.\n\t     *\n\t     * @private\n\t     * @param {number} start The start of the range.\n\t     * @param {number} end The end of the range.\n\t     * @param {number} step The value to increment or decrement by.\n\t     * @param {boolean} [fromRight] Specify iterating from right to left.\n\t     * @returns {Array} Returns the new array of numbers.\n\t     */\n\t    function baseRange(start, end, step, fromRight) {\n\t      var index = -1,\n\t          length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),\n\t          result = Array(length);\n\t\n\t      while (length--) {\n\t        result[fromRight ? length : ++index] = start;\n\t        start += step;\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.set`.\n\t     *\n\t     * @private\n\t     * @param {Object} object The object to query.\n\t     * @param {Array|string} path The path of the property to set.\n\t     * @param {*} value The value to set.\n\t     * @param {Function} [customizer] The function to customize path creation.\n\t     * @returns {Object} Returns `object`.\n\t     */\n\t    function baseSet(object, path, value, customizer) {\n\t      path = isKey(path, object) ? [path + ''] : baseToPath(path);\n\t\n\t      var index = -1,\n\t          length = path.length,\n\t          lastIndex = length - 1,\n\t          nested = object;\n\t\n\t      while (nested != null && ++index < length) {\n\t        var key = path[index];\n\t        if (isObject(nested)) {\n\t          var newValue = value;\n\t          if (index != lastIndex) {\n\t            var objValue = nested[key];\n\t            newValue = customizer ? customizer(objValue, key, nested) : undefined;\n\t            if (newValue === undefined) {\n\t              newValue = objValue == null ? (isIndex(path[index + 1]) ? [] : {}) : objValue;\n\t            }\n\t          }\n\t          assignValue(nested, key, newValue);\n\t        }\n\t        nested = nested[key];\n\t      }\n\t      return object;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `setData` without support for hot loop detection.\n\t     *\n\t     * @private\n\t     * @param {Function} func The function to associate metadata with.\n\t     * @param {*} data The metadata.\n\t     * @returns {Function} Returns `func`.\n\t     */\n\t    var baseSetData = !metaMap ? identity : function(func, data) {\n\t      metaMap.set(func, data);\n\t      return func;\n\t    };\n\t\n\t    /**\n\t     * The base implementation of `_.slice` without an iteratee call guard.\n\t     *\n\t     * @private\n\t     * @param {Array} array The array to slice.\n\t     * @param {number} [start=0] The start position.\n\t     * @param {number} [end=array.length] The end position.\n\t     * @returns {Array} Returns the slice of `array`.\n\t     */\n\t    function baseSlice(array, start, end) {\n\t      var index = -1,\n\t          length = array.length;\n\t\n\t      if (start < 0) {\n\t        start = -start > length ? 0 : (length + start);\n\t      }\n\t      end = end > length ? length : end;\n\t      if (end < 0) {\n\t        end += length;\n\t      }\n\t      length = start > end ? 0 : ((end - start) >>> 0);\n\t      start >>>= 0;\n\t\n\t      var result = Array(length);\n\t      while (++index < length) {\n\t        result[index] = array[index + start];\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.some` without support for iteratee shorthands.\n\t     *\n\t     * @private\n\t     * @param {Array|Object} collection The collection to iterate over.\n\t     * @param {Function} predicate The function invoked per iteration.\n\t     * @returns {boolean} Returns `true` if any element passes the predicate check, else `false`.\n\t     */\n\t    function baseSome(collection, predicate) {\n\t      var result;\n\t\n\t      baseEach(collection, function(value, index, collection) {\n\t        result = predicate(value, index, collection);\n\t        return !result;\n\t      });\n\t      return !!result;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which\n\t     * performs a binary search of `array` to determine the index at which `value`\n\t     * should be inserted into `array` in order to maintain its sort order.\n\t     *\n\t     * @private\n\t     * @param {Array} array The sorted array to inspect.\n\t     * @param {*} value The value to evaluate.\n\t     * @param {boolean} [retHighest] Specify returning the highest qualified index.\n\t     * @returns {number} Returns the index at which `value` should be inserted\n\t     *  into `array`.\n\t     */\n\t    function baseSortedIndex(array, value, retHighest) {\n\t      var low = 0,\n\t          high = array ? array.length : low;\n\t\n\t      if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {\n\t        while (low < high) {\n\t          var mid = (low + high) >>> 1,\n\t              computed = array[mid];\n\t\n\t          if ((retHighest ? (computed <= value) : (computed < value)) && computed !== null) {\n\t            low = mid + 1;\n\t          } else {\n\t            high = mid;\n\t          }\n\t        }\n\t        return high;\n\t      }\n\t      return baseSortedIndexBy(array, value, identity, retHighest);\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`\n\t     * which invokes `iteratee` for `value` and each element of `array` to compute\n\t     * their sort ranking. The iteratee is invoked with one argument; (value).\n\t     *\n\t     * @private\n\t     * @param {Array} array The sorted array to inspect.\n\t     * @param {*} value The value to evaluate.\n\t     * @param {Function} iteratee The iteratee invoked per element.\n\t     * @param {boolean} [retHighest] Specify returning the highest qualified index.\n\t     * @returns {number} Returns the index at which `value` should be inserted into `array`.\n\t     */\n\t    function baseSortedIndexBy(array, value, iteratee, retHighest) {\n\t      value = iteratee(value);\n\t\n\t      var low = 0,\n\t          high = array ? array.length : 0,\n\t          valIsNaN = value !== value,\n\t          valIsNull = value === null,\n\t          valIsUndef = value === undefined;\n\t\n\t      while (low < high) {\n\t        var mid = nativeFloor((low + high) / 2),\n\t            computed = iteratee(array[mid]),\n\t            isDef = computed !== undefined,\n\t            isReflexive = computed === computed;\n\t\n\t        if (valIsNaN) {\n\t          var setLow = isReflexive || retHighest;\n\t        } else if (valIsNull) {\n\t          setLow = isReflexive && isDef && (retHighest || computed != null);\n\t        } else if (valIsUndef) {\n\t          setLow = isReflexive && (retHighest || isDef);\n\t        } else if (computed == null) {\n\t          setLow = false;\n\t        } else {\n\t          setLow = retHighest ? (computed <= value) : (computed < value);\n\t        }\n\t        if (setLow) {\n\t          low = mid + 1;\n\t        } else {\n\t          high = mid;\n\t        }\n\t      }\n\t      return nativeMin(high, MAX_ARRAY_INDEX);\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.sortedUniq`.\n\t     *\n\t     * @private\n\t     * @param {Array} array The array to inspect.\n\t     * @returns {Array} Returns the new duplicate free array.\n\t     */\n\t    function baseSortedUniq(array) {\n\t      return baseSortedUniqBy(array);\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.sortedUniqBy` without support for iteratee\n\t     * shorthands.\n\t     *\n\t     * @private\n\t     * @param {Array} array The array to inspect.\n\t     * @param {Function} [iteratee] The iteratee invoked per element.\n\t     * @returns {Array} Returns the new duplicate free array.\n\t     */\n\t    function baseSortedUniqBy(array, iteratee) {\n\t      var index = 0,\n\t          length = array.length,\n\t          value = array[0],\n\t          computed = iteratee ? iteratee(value) : value,\n\t          seen = computed,\n\t          resIndex = 0,\n\t          result = [value];\n\t\n\t      while (++index < length) {\n\t        value = array[index],\n\t        computed = iteratee ? iteratee(value) : value;\n\t\n\t        if (!eq(computed, seen)) {\n\t          seen = computed;\n\t          result[++resIndex] = value;\n\t        }\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.toPath` which only converts `value` to a\n\t     * path if it's not one.\n\t     *\n\t     * @private\n\t     * @param {*} value The value to process.\n\t     * @returns {Array} Returns the property path array.\n\t     */\n\t    function baseToPath(value) {\n\t      return isArray(value) ? value : stringToPath(value);\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.uniqBy` without support for iteratee shorthands.\n\t     *\n\t     * @private\n\t     * @param {Array} array The array to inspect.\n\t     * @param {Function} [iteratee] The iteratee invoked per element.\n\t     * @param {Function} [comparator] The comparator invoked per element.\n\t     * @returns {Array} Returns the new duplicate free array.\n\t     */\n\t    function baseUniq(array, iteratee, comparator) {\n\t      var index = -1,\n\t          includes = arrayIncludes,\n\t          length = array.length,\n\t          isCommon = true,\n\t          result = [],\n\t          seen = result;\n\t\n\t      if (comparator) {\n\t        isCommon = false;\n\t        includes = arrayIncludesWith;\n\t      }\n\t      else if (length >= LARGE_ARRAY_SIZE) {\n\t        var set = iteratee ? null : createSet(array);\n\t        if (set) {\n\t          return setToArray(set);\n\t        }\n\t        isCommon = false;\n\t        includes = cacheHas;\n\t        seen = new SetCache;\n\t      }\n\t      else {\n\t        seen = iteratee ? [] : result;\n\t      }\n\t      outer:\n\t      while (++index < length) {\n\t        var value = array[index],\n\t            computed = iteratee ? iteratee(value) : value;\n\t\n\t        if (isCommon && computed === computed) {\n\t          var seenIndex = seen.length;\n\t          while (seenIndex--) {\n\t            if (seen[seenIndex] === computed) {\n\t              continue outer;\n\t            }\n\t          }\n\t          if (iteratee) {\n\t            seen.push(computed);\n\t          }\n\t          result.push(value);\n\t        }\n\t        else if (!includes(seen, computed, comparator)) {\n\t          if (seen !== result) {\n\t            seen.push(computed);\n\t          }\n\t          result.push(value);\n\t        }\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `_.unset`.\n\t     *\n\t     * @private\n\t     * @param {Object} object The object to modify.\n\t     * @param {Array|string} path The path of the property to unset.\n\t     * @returns {boolean} Returns `true` if the property is deleted, else `false`.\n\t     */\n\t    function baseUnset(object, path) {\n\t      path = isKey(path, object) ? [path + ''] : baseToPath(path);\n\t      object = parent(object, path);\n\t      var key = last(path);\n\t      return (object != null && has(object, key)) ? delete object[key] : true;\n\t    }\n\t\n\t    /**\n\t     * The base implementation of methods like `_.dropWhile` and `_.takeWhile`\n\t     * without support for iteratee shorthands.\n\t     *\n\t     * @private\n\t     * @param {Array} array The array to query.\n\t     * @param {Function} predicate The function invoked per iteration.\n\t     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.\n\t     * @param {boolean} [fromRight] Specify iterating from right to left.\n\t     * @returns {Array} Returns the slice of `array`.\n\t     */\n\t    function baseWhile(array, predicate, isDrop, fromRight) {\n\t      var length = array.length,\n\t          index = fromRight ? length : -1;\n\t\n\t      while ((fromRight ? index-- : ++index < length) &&\n\t        predicate(array[index], index, array)) {}\n\t\n\t      return isDrop\n\t        ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))\n\t        : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));\n\t    }\n\t\n\t    /**\n\t     * The base implementation of `wrapperValue` which returns the result of\n\t     * performing a sequence of actions on the unwrapped `value`, where each\n\t     * successive action is supplied the return value of the previous.\n\t     *\n\t     * @private\n\t     * @param {*} value The unwrapped value.\n\t     * @param {Array} actions Actions to perform to resolve the unwrapped value.\n\t     * @returns {*} Returns the resolved value.\n\t     */\n\t    function baseWrapperValue(value, actions) {\n\t      var result = value;\n\t      if (result instanceof LazyWrapper) {\n\t        result = result.value();\n\t      }\n\t      return arrayReduce(actions, function(result, action) {\n\t        return action.func.apply(action.thisArg, arrayPush([result], action.args));\n\t      }, result);\n\t    }\n\t\n\t    /**\n\t     * The base implementation of methods like `_.xor`, without support for\n\t     * iteratee shorthands, that accepts an array of arrays to inspect.\n\t     *\n\t     * @private\n\t     * @param {Array} arrays The arrays to inspect.\n\t     * @param {Function} [iteratee] The iteratee invoked per element.\n\t     * @param {Function} [comparator] The comparator invoked per element.\n\t     * @returns {Array} Returns the new array of values.\n\t     */\n\t    function baseXor(arrays, iteratee, comparator) {\n\t      var index = -1,\n\t          length = arrays.length;\n\t\n\t      while (++index < length) {\n\t        var result = result\n\t          ? arrayPush(\n\t              baseDifference(result, arrays[index], iteratee, comparator),\n\t              baseDifference(arrays[index], result, iteratee, comparator)\n\t            )\n\t          : arrays[index];\n\t      }\n\t      return (result && result.length) ? baseUniq(result, iteratee, comparator) : [];\n\t    }\n\t\n\t    /**\n\t     * Creates a clone of `buffer`.\n\t     *\n\t     * @private\n\t     * @param {ArrayBuffer} buffer The array buffer to clone.\n\t     * @returns {ArrayBuffer} Returns the cloned array buffer.\n\t     */\n\t    function cloneBuffer(buffer) {\n\t      var Ctor = buffer.constructor,\n\t          result = new Ctor(buffer.byteLength),\n\t          view = new Uint8Array(result);\n\t\n\t      view.set(new Uint8Array(buffer));\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * Creates a clone of `map`.\n\t     *\n\t     * @private\n\t     * @param {Object} map The map to clone.\n\t     * @returns {Object} Returns the cloned map.\n\t     */\n\t    function cloneMap(map) {\n\t      var Ctor = map.constructor;\n\t      return arrayReduce(mapToArray(map), addMapEntry, new Ctor);\n\t    }\n\t\n\t    /**\n\t     * Creates a clone of `regexp`.\n\t     *\n\t     * @private\n\t     * @param {Object} regexp The regexp to clone.\n\t     * @returns {Object} Returns the cloned regexp.\n\t     */\n\t    function cloneRegExp(regexp) {\n\t      var Ctor = regexp.constructor,\n\t          result = new Ctor(regexp.source, reFlags.exec(regexp));\n\t\n\t      result.lastIndex = regexp.lastIndex;\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * Creates a clone of `set`.\n\t     *\n\t     * @private\n\t     * @param {Object} set The set to clone.\n\t     * @returns {Object} Returns the cloned set.\n\t     */\n\t    function cloneSet(set) {\n\t      var Ctor = set.constructor;\n\t      return arrayReduce(setToArray(set), addSetEntry, new Ctor);\n\t    }\n\t\n\t    /**\n\t     * Creates a clone of the `symbol` object.\n\t     *\n\t     * @private\n\t     * @param {Object} symbol The symbol object to clone.\n\t     * @returns {Object} Returns the cloned symbol object.\n\t     */\n\t    function cloneSymbol(symbol) {\n\t      return _Symbol ? Object(symbolValueOf.call(symbol)) : {};\n\t    }\n\t\n\t    /**\n\t     * Creates a clone of `typedArray`.\n\t     *\n\t     * @private\n\t     * @param {Object} typedArray The typed array to clone.\n\t     * @param {boolean} [isDeep] Specify a deep clone.\n\t     * @returns {Object} Returns the cloned typed array.\n\t     */\n\t    function cloneTypedArray(typedArray, isDeep) {\n\t      var buffer = typedArray.buffer,\n\t          Ctor = typedArray.constructor;\n\t\n\t      return new Ctor(isDeep ? cloneBuffer(buffer) : buffer, typedArray.byteOffset, typedArray.length);\n\t    }\n\t\n\t    /**\n\t     * Creates an array that is the composition of partially applied arguments,\n\t     * placeholders, and provided arguments into a single array of arguments.\n\t     *\n\t     * @private\n\t     * @param {Array|Object} args The provided arguments.\n\t     * @param {Array} partials The arguments to prepend to those provided.\n\t     * @param {Array} holders The `partials` placeholder indexes.\n\t     * @returns {Array} Returns the new array of composed arguments.\n\t     */\n\t    function composeArgs(args, partials, holders) {\n\t      var holdersLength = holders.length,\n\t          argsIndex = -1,\n\t          argsLength = nativeMax(args.length - holdersLength, 0),\n\t          leftIndex = -1,\n\t          leftLength = partials.length,\n\t          result = Array(leftLength + argsLength);\n\t\n\t      while (++leftIndex < leftLength) {\n\t        result[leftIndex] = partials[leftIndex];\n\t      }\n\t      while (++argsIndex < holdersLength) {\n\t        result[holders[argsIndex]] = args[argsIndex];\n\t      }\n\t      while (argsLength--) {\n\t        result[leftIndex++] = args[argsIndex++];\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * This function is like `composeArgs` except that the arguments composition\n\t     * is tailored for `_.partialRight`.\n\t     *\n\t     * @private\n\t     * @param {Array|Object} args The provided arguments.\n\t     * @param {Array} partials The arguments to append to those provided.\n\t     * @param {Array} holders The `partials` placeholder indexes.\n\t     * @returns {Array} Returns the new array of composed arguments.\n\t     */\n\t    function composeArgsRight(args, partials, holders) {\n\t      var holdersIndex = -1,\n\t          holdersLength = holders.length,\n\t          argsIndex = -1,\n\t          argsLength = nativeMax(args.length - holdersLength, 0),\n\t          rightIndex = -1,\n\t          rightLength = partials.length,\n\t          result = Array(argsLength + rightLength);\n\t\n\t      while (++argsIndex < argsLength) {\n\t        result[argsIndex] = args[argsIndex];\n\t      }\n\t      var offset = argsIndex;\n\t      while (++rightIndex < rightLength) {\n\t        result[offset + rightIndex] = partials[rightIndex];\n\t      }\n\t      while (++holdersIndex < holdersLength) {\n\t        result[offset + holders[holdersIndex]] = args[argsIndex++];\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * Copies the values of `source` to `array`.\n\t     *\n\t     * @private\n\t     * @param {Array} source The array to copy values from.\n\t     * @param {Array} [array=[]] The array to copy values to.\n\t     * @returns {Array} Returns `array`.\n\t     */\n\t    function copyArray(source, array) {\n\t      var index = -1,\n\t          length = source.length;\n\t\n\t      array || (array = Array(length));\n\t      while (++index < length) {\n\t        array[index] = source[index];\n\t      }\n\t      return array;\n\t    }\n\t\n\t    /**\n\t     * Copies properties of `source` to `object`.\n\t     *\n\t     * @private\n\t     * @param {Object} source The object to copy properties from.\n\t     * @param {Array} props The property names to copy.\n\t     * @param {Object} [object={}] The object to copy properties to.\n\t     * @returns {Object} Returns `object`.\n\t     */\n\t    function copyObject(source, props, object) {\n\t      return copyObjectWith(source, props, object);\n\t    }\n\t\n\t    /**\n\t     * This function is like `copyObject` except that it accepts a function to\n\t     * customize copied values.\n\t     *\n\t     * @private\n\t     * @param {Object} source The object to copy properties from.\n\t     * @param {Array} props The property names to copy.\n\t     * @param {Object} [object={}] The object to copy properties to.\n\t     * @param {Function} [customizer] The function to customize copied values.\n\t     * @returns {Object} Returns `object`.\n\t     */\n\t    function copyObjectWith(source, props, object, customizer) {\n\t      object || (object = {});\n\t\n\t      var index = -1,\n\t          length = props.length;\n\t\n\t      while (++index < length) {\n\t        var key = props[index],\n\t            newValue = customizer ? customizer(object[key], source[key], key, object, source) : source[key];\n\t\n\t        assignValue(object, key, newValue);\n\t      }\n\t      return object;\n\t    }\n\t\n\t    /**\n\t     * Copies own symbol properties of `source` to `object`.\n\t     *\n\t     * @private\n\t     * @param {Object} source The object to copy symbols from.\n\t     * @param {Object} [object={}] The object to copy symbols to.\n\t     * @returns {Object} Returns `object`.\n\t     */\n\t    function copySymbols(source, object) {\n\t      return copyObject(source, getSymbols(source), object);\n\t    }\n\t\n\t    /**\n\t     * Creates a function like `_.groupBy`.\n\t     *\n\t     * @private\n\t     * @param {Function} setter The function to set keys and values of the accumulator object.\n\t     * @param {Function} [initializer] The function to initialize the accumulator object.\n\t     * @returns {Function} Returns the new aggregator function.\n\t     */\n\t    function createAggregator(setter, initializer) {\n\t      return function(collection, iteratee) {\n\t        var result = initializer ? initializer() : {};\n\t        iteratee = getIteratee(iteratee);\n\t\n\t        if (isArray(collection)) {\n\t          var index = -1,\n\t              length = collection.length;\n\t\n\t          while (++index < length) {\n\t            var value = collection[index];\n\t            setter(result, value, iteratee(value), collection);\n\t          }\n\t        } else {\n\t          baseEach(collection, function(value, key, collection) {\n\t            setter(result, value, iteratee(value), collection);\n\t          });\n\t        }\n\t        return result;\n\t      };\n\t    }\n\t\n\t    /**\n\t     * Creates a function like `_.assign`.\n\t     *\n\t     * @private\n\t     * @param {Function} assigner The function to assign values.\n\t     * @returns {Function} Returns the new assigner function.\n\t     */\n\t    function createAssigner(assigner) {\n\t      return rest(function(object, sources) {\n\t        var index = -1,\n\t            length = sources.length,\n\t            customizer = length > 1 ? sources[length - 1] : undefined,\n\t            guard = length > 2 ? sources[2] : undefined;\n\t\n\t        customizer = typeof customizer == 'function' ? (length--, customizer) : undefined;\n\t        if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n\t          customizer = length < 3 ? undefined : customizer;\n\t          length = 1;\n\t        }\n\t        object = Object(object);\n\t        while (++index < length) {\n\t          var source = sources[index];\n\t          if (source) {\n\t            assigner(object, source, customizer);\n\t          }\n\t        }\n\t        return object;\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Creates a `baseEach` or `baseEachRight` function.\n\t     *\n\t     * @private\n\t     * @param {Function} eachFunc The function to iterate over a collection.\n\t     * @param {boolean} [fromRight] Specify iterating from right to left.\n\t     * @returns {Function} Returns the new base function.\n\t     */\n\t    function createBaseEach(eachFunc, fromRight) {\n\t      return function(collection, iteratee) {\n\t        if (collection == null) {\n\t          return collection;\n\t        }\n\t        if (!isArrayLike(collection)) {\n\t          return eachFunc(collection, iteratee);\n\t        }\n\t        var length = collection.length,\n\t            index = fromRight ? length : -1,\n\t            iterable = Object(collection);\n\t\n\t        while ((fromRight ? index-- : ++index < length)) {\n\t          if (iteratee(iterable[index], index, iterable) === false) {\n\t            break;\n\t          }\n\t        }\n\t        return collection;\n\t      };\n\t    }\n\t\n\t    /**\n\t     * Creates a base function for methods like `_.forIn`.\n\t     *\n\t     * @private\n\t     * @param {boolean} [fromRight] Specify iterating from right to left.\n\t     * @returns {Function} Returns the new base function.\n\t     */\n\t    function createBaseFor(fromRight) {\n\t      return function(object, iteratee, keysFunc) {\n\t        var index = -1,\n\t            iterable = Object(object),\n\t            props = keysFunc(object),\n\t            length = props.length;\n\t\n\t        while (length--) {\n\t          var key = props[fromRight ? length : ++index];\n\t          if (iteratee(iterable[key], key, iterable) === false) {\n\t            break;\n\t          }\n\t        }\n\t        return object;\n\t      };\n\t    }\n\t\n\t    /**\n\t     * Creates a function that wraps `func` to invoke it with the optional `this`\n\t     * binding of `thisArg`.\n\t     *\n\t     * @private\n\t     * @param {Function} func The function to wrap.\n\t     * @param {number} bitmask The bitmask of wrapper flags. See `createWrapper` for more details.\n\t     * @param {*} [thisArg] The `this` binding of `func`.\n\t     * @returns {Function} Returns the new wrapped function.\n\t     */\n\t    function createBaseWrapper(func, bitmask, thisArg) {\n\t      var isBind = bitmask & BIND_FLAG,\n\t          Ctor = createCtorWrapper(func);\n\t\n\t      function wrapper() {\n\t        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;\n\t        return fn.apply(isBind ? thisArg : this, arguments);\n\t      }\n\t      return wrapper;\n\t    }\n\t\n\t    /**\n\t     * Creates a function like `_.lowerFirst`.\n\t     *\n\t     * @private\n\t     * @param {string} methodName The name of the `String` case method to use.\n\t     * @returns {Function} Returns the new function.\n\t     */\n\t    function createCaseFirst(methodName) {\n\t      return function(string) {\n\t        string = toString(string);\n\t\n\t        var strSymbols = reHasComplexSymbol.test(string) ? stringToArray(string) : undefined,\n\t            chr = strSymbols ? strSymbols[0] : string.charAt(0),\n\t            trailing = strSymbols ? strSymbols.slice(1).join('') : string.slice(1);\n\t\n\t        return chr[methodName]() + trailing;\n\t      };\n\t    }\n\t\n\t    /**\n\t     * Creates a function like `_.camelCase`.\n\t     *\n\t     * @private\n\t     * @param {Function} callback The function to combine each word.\n\t     * @returns {Function} Returns the new compounder function.\n\t     */\n\t    function createCompounder(callback) {\n\t      return function(string) {\n\t        return arrayReduce(words(deburr(string)), callback, '');\n\t      };\n\t    }\n\t\n\t    /**\n\t     * Creates a function that produces an instance of `Ctor` regardless of\n\t     * whether it was invoked as part of a `new` expression or by `call` or `apply`.\n\t     *\n\t     * @private\n\t     * @param {Function} Ctor The constructor to wrap.\n\t     * @returns {Function} Returns the new wrapped function.\n\t     */\n\t    function createCtorWrapper(Ctor) {\n\t      return function() {\n\t        // Use a `switch` statement to work with class constructors.\n\t        // See http://ecma-international.org/ecma-262/6.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist\n\t        // for more details.\n\t        var args = arguments;\n\t        switch (args.length) {\n\t          case 0: return new Ctor;\n\t          case 1: return new Ctor(args[0]);\n\t          case 2: return new Ctor(args[0], args[1]);\n\t          case 3: return new Ctor(args[0], args[1], args[2]);\n\t          case 4: return new Ctor(args[0], args[1], args[2], args[3]);\n\t          case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);\n\t          case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);\n\t          case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);\n\t        }\n\t        var thisBinding = baseCreate(Ctor.prototype),\n\t            result = Ctor.apply(thisBinding, args);\n\t\n\t        // Mimic the constructor's `return` behavior.\n\t        // See https://es5.github.io/#x13.2.2 for more details.\n\t        return isObject(result) ? result : thisBinding;\n\t      };\n\t    }\n\t\n\t    /**\n\t     * Creates a function that wraps `func` to enable currying.\n\t     *\n\t     * @private\n\t     * @param {Function} func The function to wrap.\n\t     * @param {number} bitmask The bitmask of wrapper flags. See `createWrapper` for more details.\n\t     * @param {number} arity The arity of `func`.\n\t     * @returns {Function} Returns the new wrapped function.\n\t     */\n\t    function createCurryWrapper(func, bitmask, arity) {\n\t      var Ctor = createCtorWrapper(func);\n\t\n\t      function wrapper() {\n\t        var length = arguments.length,\n\t            index = length,\n\t            args = Array(length),\n\t            fn = (this && this !== root && this instanceof wrapper) ? Ctor : func,\n\t            placeholder = wrapper.placeholder;\n\t\n\t        while (index--) {\n\t          args[index] = arguments[index];\n\t        }\n\t        var holders = (length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder)\n\t          ? []\n\t          : replaceHolders(args, placeholder);\n\t\n\t        length -= holders.length;\n\t        return length < arity\n\t          ? createRecurryWrapper(func, bitmask, createHybridWrapper, placeholder, undefined, args, holders, undefined, undefined, arity - length)\n\t          : apply(fn, this, args);\n\t      }\n\t      return wrapper;\n\t    }\n\t\n\t    /**\n\t     * Creates a `_.flow` or `_.flowRight` function.\n\t     *\n\t     * @private\n\t     * @param {boolean} [fromRight] Specify iterating from right to left.\n\t     * @returns {Function} Returns the new flow function.\n\t     */\n\t    function createFlow(fromRight) {\n\t      return rest(function(funcs) {\n\t        funcs = baseFlatten(funcs);\n\t\n\t        var length = funcs.length,\n\t            index = length,\n\t            prereq = LodashWrapper.prototype.thru;\n\t\n\t        if (fromRight) {\n\t          funcs.reverse();\n\t        }\n\t        while (index--) {\n\t          var func = funcs[index];\n\t          if (typeof func != 'function') {\n\t            throw new TypeError(FUNC_ERROR_TEXT);\n\t          }\n\t          if (prereq && !wrapper && getFuncName(func) == 'wrapper') {\n\t            var wrapper = new LodashWrapper([], true);\n\t          }\n\t        }\n\t        index = wrapper ? index : length;\n\t        while (++index < length) {\n\t          func = funcs[index];\n\t\n\t          var funcName = getFuncName(func),\n\t              data = funcName == 'wrapper' ? getData(func) : undefined;\n\t\n\t          if (data && isLaziable(data[0]) && data[1] == (ARY_FLAG | CURRY_FLAG | PARTIAL_FLAG | REARG_FLAG) && !data[4].length && data[9] == 1) {\n\t            wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);\n\t          } else {\n\t            wrapper = (func.length == 1 && isLaziable(func)) ? wrapper[funcName]() : wrapper.thru(func);\n\t          }\n\t        }\n\t        return function() {\n\t          var args = arguments,\n\t              value = args[0];\n\t\n\t          if (wrapper && args.length == 1 && isArray(value) && value.length >= LARGE_ARRAY_SIZE) {\n\t            return wrapper.plant(value).value();\n\t          }\n\t          var index = 0,\n\t              result = length ? funcs[index].apply(this, args) : value;\n\t\n\t          while (++index < length) {\n\t            result = funcs[index].call(this, result);\n\t          }\n\t          return result;\n\t        };\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Creates a function that wraps `func` to invoke it with optional `this`\n\t     * binding of `thisArg`, partial application, and currying.\n\t     *\n\t     * @private\n\t     * @param {Function|string} func The function or method name to wrap.\n\t     * @param {number} bitmask The bitmask of wrapper flags. See `createWrapper` for more details.\n\t     * @param {*} [thisArg] The `this` binding of `func`.\n\t     * @param {Array} [partials] The arguments to prepend to those provided to the new function.\n\t     * @param {Array} [holders] The `partials` placeholder indexes.\n\t     * @param {Array} [partialsRight] The arguments to append to those provided to the new function.\n\t     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.\n\t     * @param {Array} [argPos] The argument positions of the new function.\n\t     * @param {number} [ary] The arity cap of `func`.\n\t     * @param {number} [arity] The arity of `func`.\n\t     * @returns {Function} Returns the new wrapped function.\n\t     */\n\t    function createHybridWrapper(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {\n\t      var isAry = bitmask & ARY_FLAG,\n\t          isBind = bitmask & BIND_FLAG,\n\t          isBindKey = bitmask & BIND_KEY_FLAG,\n\t          isCurry = bitmask & CURRY_FLAG,\n\t          isCurryRight = bitmask & CURRY_RIGHT_FLAG,\n\t          isFlip = bitmask & FLIP_FLAG,\n\t          Ctor = isBindKey ? undefined : createCtorWrapper(func);\n\t\n\t      function wrapper() {\n\t        var length = arguments.length,\n\t            index = length,\n\t            args = Array(length);\n\t\n\t        while (index--) {\n\t          args[index] = arguments[index];\n\t        }\n\t        if (partials) {\n\t          args = composeArgs(args, partials, holders);\n\t        }\n\t        if (partialsRight) {\n\t          args = composeArgsRight(args, partialsRight, holdersRight);\n\t        }\n\t        if (isCurry || isCurryRight) {\n\t          var placeholder = wrapper.placeholder,\n\t              argsHolders = replaceHolders(args, placeholder);\n\t\n\t          length -= argsHolders.length;\n\t          if (length < arity) {\n\t            return createRecurryWrapper(func, bitmask, createHybridWrapper, placeholder, thisArg, args, argsHolders, argPos, ary, arity - length);\n\t          }\n\t        }\n\t        var thisBinding = isBind ? thisArg : this,\n\t            fn = isBindKey ? thisBinding[func] : func;\n\t\n\t        if (argPos) {\n\t          args = reorder(args, argPos);\n\t        } else if (isFlip && args.length > 1) {\n\t          args.reverse();\n\t        }\n\t        if (isAry && ary < args.length) {\n\t          args.length = ary;\n\t        }\n\t        if (this && this !== root && this instanceof wrapper) {\n\t          fn = Ctor || createCtorWrapper(fn);\n\t        }\n\t        return fn.apply(thisBinding, args);\n\t      }\n\t      return wrapper;\n\t    }\n\t\n\t    /**\n\t     * Creates a function like `_.over`.\n\t     *\n\t     * @private\n\t     * @param {Function} arrayFunc The function to iterate over iteratees.\n\t     * @returns {Function} Returns the new invoker function.\n\t     */\n\t    function createOver(arrayFunc) {\n\t      return rest(function(iteratees) {\n\t        iteratees = arrayMap(baseFlatten(iteratees), getIteratee());\n\t        return rest(function(args) {\n\t          var thisArg = this;\n\t          return arrayFunc(iteratees, function(iteratee) {\n\t            return apply(iteratee, thisArg, args);\n\t          });\n\t        });\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Creates the padding for `string` based on `length`. The `chars` string\n\t     * is truncated if the number of characters exceeds `length`.\n\t     *\n\t     * @private\n\t     * @param {string} string The string to create padding for.\n\t     * @param {number} [length=0] The padding length.\n\t     * @param {string} [chars=' '] The string used as padding.\n\t     * @returns {string} Returns the padding for `string`.\n\t     */\n\t    function createPadding(string, length, chars) {\n\t      length = toInteger(length);\n\t\n\t      var strLength = stringSize(string);\n\t      if (!length || strLength >= length) {\n\t        return '';\n\t      }\n\t      var padLength = length - strLength;\n\t      chars = chars === undefined ? ' ' : (chars + '');\n\t\n\t      var result = repeat(chars, nativeCeil(padLength / stringSize(chars)));\n\t      return reHasComplexSymbol.test(chars)\n\t        ? stringToArray(result).slice(0, padLength).join('')\n\t        : result.slice(0, padLength);\n\t    }\n\t\n\t    /**\n\t     * Creates a function that wraps `func` to invoke it with the optional `this`\n\t     * binding of `thisArg` and the `partials` prepended to those provided to\n\t     * the wrapper.\n\t     *\n\t     * @private\n\t     * @param {Function} func The function to wrap.\n\t     * @param {number} bitmask The bitmask of wrapper flags. See `createWrapper` for more details.\n\t     * @param {*} thisArg The `this` binding of `func`.\n\t     * @param {Array} partials The arguments to prepend to those provided to the new function.\n\t     * @returns {Function} Returns the new wrapped function.\n\t     */\n\t    function createPartialWrapper(func, bitmask, thisArg, partials) {\n\t      var isBind = bitmask & BIND_FLAG,\n\t          Ctor = createCtorWrapper(func);\n\t\n\t      function wrapper() {\n\t        var argsIndex = -1,\n\t            argsLength = arguments.length,\n\t            leftIndex = -1,\n\t            leftLength = partials.length,\n\t            args = Array(leftLength + argsLength),\n\t            fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;\n\t\n\t        while (++leftIndex < leftLength) {\n\t          args[leftIndex] = partials[leftIndex];\n\t        }\n\t        while (argsLength--) {\n\t          args[leftIndex++] = arguments[++argsIndex];\n\t        }\n\t        return apply(fn, isBind ? thisArg : this, args);\n\t      }\n\t      return wrapper;\n\t    }\n\t\n\t    /**\n\t     * Creates a `_.range` or `_.rangeRight` function.\n\t     *\n\t     * @private\n\t     * @param {boolean} [fromRight] Specify iterating from right to left.\n\t     * @returns {Function} Returns the new range function.\n\t     */\n\t    function createRange(fromRight) {\n\t      return function(start, end, step) {\n\t        if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {\n\t          end = step = undefined;\n\t        }\n\t        // Ensure the sign of `-0` is preserved.\n\t        start = toNumber(start);\n\t        start = start === start ? start : 0;\n\t        if (end === undefined) {\n\t          end = start;\n\t          start = 0;\n\t        } else {\n\t          end = toNumber(end) || 0;\n\t        }\n\t        step = step === undefined ? (start < end ? 1 : -1) : (toNumber(step) || 0);\n\t        return baseRange(start, end, step, fromRight);\n\t      };\n\t    }\n\t\n\t    /**\n\t     * Creates a function that wraps `func` to continue currying.\n\t     *\n\t     * @private\n\t     * @param {Function} func The function to wrap.\n\t     * @param {number} bitmask The bitmask of wrapper flags. See `createWrapper` for more details.\n\t     * @param {Function} wrapFunc The function to create the `func` wrapper.\n\t     * @param {*} placeholder The placeholder to replace.\n\t     * @param {*} [thisArg] The `this` binding of `func`.\n\t     * @param {Array} [partials] The arguments to prepend to those provided to the new function.\n\t     * @param {Array} [holders] The `partials` placeholder indexes.\n\t     * @param {Array} [argPos] The argument positions of the new function.\n\t     * @param {number} [ary] The arity cap of `func`.\n\t     * @param {number} [arity] The arity of `func`.\n\t     * @returns {Function} Returns the new wrapped function.\n\t     */\n\t    function createRecurryWrapper(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {\n\t      var isCurry = bitmask & CURRY_FLAG,\n\t          newArgPos = argPos ? copyArray(argPos) : undefined,\n\t          newsHolders = isCurry ? holders : undefined,\n\t          newHoldersRight = isCurry ? undefined : holders,\n\t          newPartials = isCurry ? partials : undefined,\n\t          newPartialsRight = isCurry ? undefined : partials;\n\t\n\t      bitmask |= (isCurry ? PARTIAL_FLAG : PARTIAL_RIGHT_FLAG);\n\t      bitmask &= ~(isCurry ? PARTIAL_RIGHT_FLAG : PARTIAL_FLAG);\n\t\n\t      if (!(bitmask & CURRY_BOUND_FLAG)) {\n\t        bitmask &= ~(BIND_FLAG | BIND_KEY_FLAG);\n\t      }\n\t      var newData = [func, bitmask, thisArg, newPartials, newsHolders, newPartialsRight, newHoldersRight, newArgPos, ary, arity],\n\t          result = wrapFunc.apply(undefined, newData);\n\t\n\t      if (isLaziable(func)) {\n\t        setData(result, newData);\n\t      }\n\t      result.placeholder = placeholder;\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * Creates a function like `_.round`.\n\t     *\n\t     * @private\n\t     * @param {string} methodName The name of the `Math` method to use when rounding.\n\t     * @returns {Function} Returns the new round function.\n\t     */\n\t    function createRound(methodName) {\n\t      var func = Math[methodName];\n\t      return function(number, precision) {\n\t        number = toNumber(number);\n\t        precision = toInteger(precision);\n\t        if (precision) {\n\t          // Shift with exponential notation to avoid floating-point issues.\n\t          // See [MDN](https://mdn.io/round#Examples) for more details.\n\t          var pair = (toString(number) + 'e').split('e'),\n\t              value = func(pair[0] + 'e' + (+pair[1] + precision));\n\t\n\t          pair = (toString(value) + 'e').split('e');\n\t          return +(pair[0] + 'e' + (+pair[1] - precision));\n\t        }\n\t        return func(number);\n\t      };\n\t    }\n\t\n\t    /**\n\t     * Creates a set of `values`.\n\t     *\n\t     * @private\n\t     * @param {Array} values The values to add to the set.\n\t     * @returns {Object} Returns the new set.\n\t     */\n\t    var createSet = !(Set && new Set([1, 2]).size === 2) ? noop : function(values) {\n\t      return new Set(values);\n\t    };\n\t\n\t    /**\n\t     * Creates a function that either curries or invokes `func` with optional\n\t     * `this` binding and partially applied arguments.\n\t     *\n\t     * @private\n\t     * @param {Function|string} func The function or method name to wrap.\n\t     * @param {number} bitmask The bitmask of wrapper flags.\n\t     *  The bitmask may be composed of the following flags:\n\t     *     1 - `_.bind`\n\t     *     2 - `_.bindKey`\n\t     *     4 - `_.curry` or `_.curryRight` of a bound function\n\t     *     8 - `_.curry`\n\t     *    16 - `_.curryRight`\n\t     *    32 - `_.partial`\n\t     *    64 - `_.partialRight`\n\t     *   128 - `_.rearg`\n\t     *   256 - `_.ary`\n\t     * @param {*} [thisArg] The `this` binding of `func`.\n\t     * @param {Array} [partials] The arguments to be partially applied.\n\t     * @param {Array} [holders] The `partials` placeholder indexes.\n\t     * @param {Array} [argPos] The argument positions of the new function.\n\t     * @param {number} [ary] The arity cap of `func`.\n\t     * @param {number} [arity] The arity of `func`.\n\t     * @returns {Function} Returns the new wrapped function.\n\t     */\n\t    function createWrapper(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {\n\t      var isBindKey = bitmask & BIND_KEY_FLAG;\n\t      if (!isBindKey && typeof func != 'function') {\n\t        throw new TypeError(FUNC_ERROR_TEXT);\n\t      }\n\t      var length = partials ? partials.length : 0;\n\t      if (!length) {\n\t        bitmask &= ~(PARTIAL_FLAG | PARTIAL_RIGHT_FLAG);\n\t        partials = holders = undefined;\n\t      }\n\t      ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0);\n\t      arity = arity === undefined ? arity : toInteger(arity);\n\t      length -= holders ? holders.length : 0;\n\t\n\t      if (bitmask & PARTIAL_RIGHT_FLAG) {\n\t        var partialsRight = partials,\n\t            holdersRight = holders;\n\t\n\t        partials = holders = undefined;\n\t      }\n\t      var data = isBindKey ? undefined : getData(func),\n\t          newData = [func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity];\n\t\n\t      if (data) {\n\t        mergeData(newData, data);\n\t      }\n\t      func = newData[0];\n\t      bitmask = newData[1];\n\t      thisArg = newData[2];\n\t      partials = newData[3];\n\t      holders = newData[4];\n\t      arity = newData[9] = newData[9] == null\n\t        ? (isBindKey ? 0 : func.length)\n\t        : nativeMax(newData[9] - length, 0);\n\t\n\t      if (!arity && bitmask & (CURRY_FLAG | CURRY_RIGHT_FLAG)) {\n\t        bitmask &= ~(CURRY_FLAG | CURRY_RIGHT_FLAG);\n\t      }\n\t      if (!bitmask || bitmask == BIND_FLAG) {\n\t        var result = createBaseWrapper(func, bitmask, thisArg);\n\t      } else if (bitmask == CURRY_FLAG || bitmask == CURRY_RIGHT_FLAG) {\n\t        result = createCurryWrapper(func, bitmask, arity);\n\t      } else if ((bitmask == PARTIAL_FLAG || bitmask == (BIND_FLAG | PARTIAL_FLAG)) && !holders.length) {\n\t        result = createPartialWrapper(func, bitmask, thisArg, partials);\n\t      } else {\n\t        result = createHybridWrapper.apply(undefined, newData);\n\t      }\n\t      var setter = data ? baseSetData : setData;\n\t      return setter(result, newData);\n\t    }\n\t\n\t    /**\n\t     * A specialized version of `baseIsEqualDeep` for arrays with support for\n\t     * partial deep comparisons.\n\t     *\n\t     * @private\n\t     * @param {Array} array The array to compare.\n\t     * @param {Array} other The other array to compare.\n\t     * @param {Function} equalFunc The function to determine equivalents of values.\n\t     * @param {Function} [customizer] The function to customize comparisons.\n\t     * @param {number} [bitmask] The bitmask of comparison flags. See `baseIsEqual` for more details.\n\t     * @param {Object} [stack] Tracks traversed `array` and `other` objects.\n\t     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n\t     */\n\t    function equalArrays(array, other, equalFunc, customizer, bitmask, stack) {\n\t      var index = -1,\n\t          isPartial = bitmask & PARTIAL_COMPARE_FLAG,\n\t          isUnordered = bitmask & UNORDERED_COMPARE_FLAG,\n\t          arrLength = array.length,\n\t          othLength = other.length;\n\t\n\t      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n\t        return false;\n\t      }\n\t      // Assume cyclic values are equal.\n\t      var stacked = stack.get(array);\n\t      if (stacked) {\n\t        return stacked == other;\n\t      }\n\t      var result = true;\n\t      stack.set(array, other);\n\t\n\t      // Ignore non-index properties.\n\t      while (++index < arrLength) {\n\t        var arrValue = array[index],\n\t            othValue = other[index];\n\t\n\t        if (customizer) {\n\t          var compared = isPartial\n\t            ? customizer(othValue, arrValue, index, other, array, stack)\n\t            : customizer(arrValue, othValue, index, array, other, stack);\n\t        }\n\t        if (compared !== undefined) {\n\t          if (compared) {\n\t            continue;\n\t          }\n\t          result = false;\n\t          break;\n\t        }\n\t        // Recursively compare arrays (susceptible to call stack limits).\n\t        if (isUnordered) {\n\t          if (!arraySome(other, function(othValue) {\n\t                return arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack);\n\t              })) {\n\t            result = false;\n\t            break;\n\t          }\n\t        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {\n\t          result = false;\n\t          break;\n\t        }\n\t      }\n\t      stack['delete'](array);\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * A specialized version of `baseIsEqualDeep` for comparing objects of\n\t     * the same `toStringTag`.\n\t     *\n\t     * **Note:** This function only supports comparing values with tags of\n\t     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n\t     *\n\t     * @private\n\t     * @param {Object} object The object to compare.\n\t     * @param {Object} other The other object to compare.\n\t     * @param {string} tag The `toStringTag` of the objects to compare.\n\t     * @param {Function} equalFunc The function to determine equivalents of values.\n\t     * @param {Function} [customizer] The function to customize comparisons.\n\t     * @param {number} [bitmask] The bitmask of comparison flags. See `baseIsEqual` for more details.\n\t     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n\t     */\n\t    function equalByTag(object, other, tag, equalFunc, customizer, bitmask) {\n\t      switch (tag) {\n\t        case arrayBufferTag:\n\t          if ((object.byteLength != other.byteLength) ||\n\t              !equalFunc(new Uint8Array(object), new Uint8Array(other))) {\n\t            return false;\n\t          }\n\t          return true;\n\t\n\t        case boolTag:\n\t        case dateTag:\n\t          // Coerce dates and booleans to numbers, dates to milliseconds and booleans\n\t          // to `1` or `0` treating invalid dates coerced to `NaN` as not equal.\n\t          return +object == +other;\n\t\n\t        case errorTag:\n\t          return object.name == other.name && object.message == other.message;\n\t\n\t        case numberTag:\n\t          // Treat `NaN` vs. `NaN` as equal.\n\t          return (object != +object) ? other != +other : object == +other;\n\t\n\t        case regexpTag:\n\t        case stringTag:\n\t          // Coerce regexes to strings and treat strings primitives and string\n\t          // objects as equal. See https://es5.github.io/#x15.10.6.4 for more details.\n\t          return object == (other + '');\n\t\n\t        case mapTag:\n\t          var convert = mapToArray;\n\t\n\t        case setTag:\n\t          var isPartial = bitmask & PARTIAL_COMPARE_FLAG;\n\t          convert || (convert = setToArray);\n\t\n\t          // Recursively compare objects (susceptible to call stack limits).\n\t          return (isPartial || object.size == other.size) &&\n\t            equalFunc(convert(object), convert(other), customizer, bitmask | UNORDERED_COMPARE_FLAG);\n\t\n\t        case symbolTag:\n\t          return !!_Symbol && (symbolValueOf.call(object) == symbolValueOf.call(other));\n\t      }\n\t      return false;\n\t    }\n\t\n\t    /**\n\t     * A specialized version of `baseIsEqualDeep` for objects with support for\n\t     * partial deep comparisons.\n\t     *\n\t     * @private\n\t     * @param {Object} object The object to compare.\n\t     * @param {Object} other The other object to compare.\n\t     * @param {Function} equalFunc The function to determine equivalents of values.\n\t     * @param {Function} [customizer] The function to customize comparisons.\n\t     * @param {number} [bitmask] The bitmask of comparison flags. See `baseIsEqual` for more details.\n\t     * @param {Object} [stack] Tracks traversed `object` and `other` objects.\n\t     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n\t     */\n\t    function equalObjects(object, other, equalFunc, customizer, bitmask, stack) {\n\t      var isPartial = bitmask & PARTIAL_COMPARE_FLAG,\n\t          isUnordered = bitmask & UNORDERED_COMPARE_FLAG,\n\t          objProps = keys(object),\n\t          objLength = objProps.length,\n\t          othProps = keys(other),\n\t          othLength = othProps.length;\n\t\n\t      if (objLength != othLength && !isPartial) {\n\t        return false;\n\t      }\n\t      var index = objLength;\n\t      while (index--) {\n\t        var key = objProps[index];\n\t        if (!(isPartial ? key in other : baseHas(other, key)) ||\n\t            !(isUnordered || key == othProps[index])) {\n\t          return false;\n\t        }\n\t      }\n\t      // Assume cyclic values are equal.\n\t      var stacked = stack.get(object);\n\t      if (stacked) {\n\t        return stacked == other;\n\t      }\n\t      var result = true;\n\t      stack.set(object, other);\n\t\n\t      var skipCtor = isPartial;\n\t      while (++index < objLength) {\n\t        key = objProps[index];\n\t        var objValue = object[key],\n\t            othValue = other[key];\n\t\n\t        if (customizer) {\n\t          var compared = isPartial\n\t            ? customizer(othValue, objValue, key, other, object, stack)\n\t            : customizer(objValue, othValue, key, object, other, stack);\n\t        }\n\t        // Recursively compare objects (susceptible to call stack limits).\n\t        if (!(compared === undefined\n\t              ? (objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack))\n\t              : compared\n\t            )) {\n\t          result = false;\n\t          break;\n\t        }\n\t        skipCtor || (skipCtor = key == 'constructor');\n\t      }\n\t      if (result && !skipCtor) {\n\t        var objCtor = object.constructor,\n\t            othCtor = other.constructor;\n\t\n\t        // Non `Object` object instances with different constructors are not equal.\n\t        if (objCtor != othCtor &&\n\t            ('constructor' in object && 'constructor' in other) &&\n\t            !(typeof objCtor == 'function' && objCtor instanceof objCtor &&\n\t              typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n\t          result = false;\n\t        }\n\t      }\n\t      stack['delete'](object);\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * Gets metadata for `func`.\n\t     *\n\t     * @private\n\t     * @param {Function} func The function to query.\n\t     * @returns {*} Returns the metadata for `func`.\n\t     */\n\t    var getData = !metaMap ? noop : function(func) {\n\t      return metaMap.get(func);\n\t    };\n\t\n\t    /**\n\t     * Gets the name of `func`.\n\t     *\n\t     * @private\n\t     * @param {Function} func The function to query.\n\t     * @returns {string} Returns the function name.\n\t     */\n\t    function getFuncName(func) {\n\t      var result = (func.name + ''),\n\t          array = realNames[result],\n\t          length = array ? array.length : 0;\n\t\n\t      while (length--) {\n\t        var data = array[length],\n\t            otherFunc = data.func;\n\t        if (otherFunc == null || otherFunc == func) {\n\t          return data.name;\n\t        }\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * Gets the appropriate \"iteratee\" function. If the `_.iteratee` method is\n\t     * customized this function returns the custom method, otherwise it returns\n\t     * `baseIteratee`. If arguments are provided the chosen function is invoked\n\t     * with them and its result is returned.\n\t     *\n\t     * @private\n\t     * @param {*} [value] The value to convert to an iteratee.\n\t     * @param {number} [arity] The arity of the created iteratee.\n\t     * @returns {Function} Returns the chosen function or its result.\n\t     */\n\t    function getIteratee() {\n\t      var result = lodash.iteratee || iteratee;\n\t      result = result === iteratee ? baseIteratee : result;\n\t      return arguments.length ? result(arguments[0], arguments[1]) : result;\n\t    }\n\t\n\t    /**\n\t     * Gets the \"length\" property value of `object`.\n\t     *\n\t     * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)\n\t     * that affects Safari on at least iOS 8.1-8.3 ARM64.\n\t     *\n\t     * @private\n\t     * @param {Object} object The object to query.\n\t     * @returns {*} Returns the \"length\" value.\n\t     */\n\t    var getLength = baseProperty('length');\n\t\n\t    /**\n\t     * Gets the property names, values, and compare flags of `object`.\n\t     *\n\t     * @private\n\t     * @param {Object} object The object to query.\n\t     * @returns {Array} Returns the match data of `object`.\n\t     */\n\t    function getMatchData(object) {\n\t      var result = toPairs(object),\n\t          length = result.length;\n\t\n\t      while (length--) {\n\t        result[length][2] = isStrictComparable(result[length][1]);\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * Gets the native function at `key` of `object`.\n\t     *\n\t     * @private\n\t     * @param {Object} object The object to query.\n\t     * @param {string} key The key of the method to get.\n\t     * @returns {*} Returns the function if it's native, else `undefined`.\n\t     */\n\t    function getNative(object, key) {\n\t      var value = object == null ? undefined : object[key];\n\t      return isNative(value) ? value : undefined;\n\t    }\n\t\n\t    /**\n\t     * Creates an array of the own symbol properties of `object`.\n\t     *\n\t     * @private\n\t     * @param {Object} object The object to query.\n\t     * @returns {Array} Returns the array of symbols.\n\t     */\n\t    var getSymbols = getOwnPropertySymbols || function() {\n\t      return [];\n\t    };\n\t\n\t    /**\n\t     * Gets the `toStringTag` of `value`.\n\t     *\n\t     * @private\n\t     * @param {*} value The value to query.\n\t     * @returns {string} Returns the `toStringTag`.\n\t     */\n\t    function getTag(value) {\n\t      return objectToString.call(value);\n\t    }\n\t\n\t    // Fallback for IE 11 providing `toStringTag` values for maps and sets.\n\t    if ((Map && getTag(new Map) != mapTag) || (Set && getTag(new Set) != setTag)) {\n\t      getTag = function(value) {\n\t        var result = objectToString.call(value),\n\t            Ctor = result == objectTag ? value.constructor : null,\n\t            ctorString = typeof Ctor == 'function' ? funcToString.call(Ctor) : '';\n\t\n\t        if (ctorString) {\n\t          if (ctorString == mapCtorString) {\n\t            return mapTag;\n\t          }\n\t          if (ctorString == setCtorString) {\n\t            return setTag;\n\t          }\n\t        }\n\t        return result;\n\t      };\n\t    }\n\t\n\t    /**\n\t     * Gets the view, applying any `transforms` to the `start` and `end` positions.\n\t     *\n\t     * @private\n\t     * @param {number} start The start of the view.\n\t     * @param {number} end The end of the view.\n\t     * @param {Array} transforms The transformations to apply to the view.\n\t     * @returns {Object} Returns an object containing the `start` and `end`\n\t     *  positions of the view.\n\t     */\n\t    function getView(start, end, transforms) {\n\t      var index = -1,\n\t          length = transforms.length;\n\t\n\t      while (++index < length) {\n\t        var data = transforms[index],\n\t            size = data.size;\n\t\n\t        switch (data.type) {\n\t          case 'drop':      start += size; break;\n\t          case 'dropRight': end -= size; break;\n\t          case 'take':      end = nativeMin(end, start + size); break;\n\t          case 'takeRight': start = nativeMax(start, end - size); break;\n\t        }\n\t      }\n\t      return { 'start': start, 'end': end };\n\t    }\n\t\n\t    /**\n\t     * Checks if `path` exists on `object`.\n\t     *\n\t     * @private\n\t     * @param {Object} object The object to query.\n\t     * @param {Array|string} path The path to check.\n\t     * @param {Function} hasFunc The function to check properties.\n\t     * @returns {boolean} Returns `true` if `path` exists, else `false`.\n\t     */\n\t    function hasPath(object, path, hasFunc) {\n\t      if (object == null) {\n\t        return false;\n\t      }\n\t      var result = hasFunc(object, path);\n\t      if (!result && !isKey(path)) {\n\t        path = baseToPath(path);\n\t        object = parent(object, path);\n\t        if (object != null) {\n\t          path = last(path);\n\t          result = hasFunc(object, path);\n\t        }\n\t      }\n\t      return result || (isLength(object && object.length) && isIndex(path, object.length) &&\n\t        (isArray(object) || isString(object) || isArguments(object)));\n\t    }\n\t\n\t    /**\n\t     * Initializes an array clone.\n\t     *\n\t     * @private\n\t     * @param {Array} array The array to clone.\n\t     * @returns {Array} Returns the initialized clone.\n\t     */\n\t    function initCloneArray(array) {\n\t      var length = array.length,\n\t          result = array.constructor(length);\n\t\n\t      // Add properties assigned by `RegExp#exec`.\n\t      if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {\n\t        result.index = array.index;\n\t        result.input = array.input;\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * Initializes an object clone.\n\t     *\n\t     * @private\n\t     * @param {Object} object The object to clone.\n\t     * @returns {Object} Returns the initialized clone.\n\t     */\n\t    function initCloneObject(object) {\n\t      var Ctor = object.constructor;\n\t      return baseCreate(isFunction(Ctor) ? Ctor.prototype : undefined);\n\t    }\n\t\n\t    /**\n\t     * Initializes an object clone based on its `toStringTag`.\n\t     *\n\t     * **Note:** This function only supports cloning values with tags of\n\t     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n\t     *\n\t     * @private\n\t     * @param {Object} object The object to clone.\n\t     * @param {string} tag The `toStringTag` of the object to clone.\n\t     * @param {boolean} [isDeep] Specify a deep clone.\n\t     * @returns {Object} Returns the initialized clone.\n\t     */\n\t    function initCloneByTag(object, tag, isDeep) {\n\t      var Ctor = object.constructor;\n\t      switch (tag) {\n\t        case arrayBufferTag:\n\t          return cloneBuffer(object);\n\t\n\t        case boolTag:\n\t        case dateTag:\n\t          return new Ctor(+object);\n\t\n\t        case float32Tag: case float64Tag:\n\t        case int8Tag: case int16Tag: case int32Tag:\n\t        case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:\n\t          return cloneTypedArray(object, isDeep);\n\t\n\t        case mapTag:\n\t          return cloneMap(object);\n\t\n\t        case numberTag:\n\t        case stringTag:\n\t          return new Ctor(object);\n\t\n\t        case regexpTag:\n\t          return cloneRegExp(object);\n\t\n\t        case setTag:\n\t          return cloneSet(object);\n\t\n\t        case symbolTag:\n\t          return cloneSymbol(object);\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Creates an array of index keys for `object` values of arrays,\n\t     * `arguments` objects, and strings, otherwise `null` is returned.\n\t     *\n\t     * @private\n\t     * @param {Object} object The object to query.\n\t     * @returns {Array|null} Returns index keys, else `null`.\n\t     */\n\t    function indexKeys(object) {\n\t      var length = object ? object.length : undefined;\n\t      return (isLength(length) && (isArray(object) || isString(object) || isArguments(object)))\n\t        ? baseTimes(length, String)\n\t        : null;\n\t    }\n\t\n\t    /**\n\t     * Checks if the provided arguments are from an iteratee call.\n\t     *\n\t     * @private\n\t     * @param {*} value The potential iteratee value argument.\n\t     * @param {*} index The potential iteratee index or key argument.\n\t     * @param {*} object The potential iteratee object argument.\n\t     * @returns {boolean} Returns `true` if the arguments are from an iteratee call, else `false`.\n\t     */\n\t    function isIterateeCall(value, index, object) {\n\t      if (!isObject(object)) {\n\t        return false;\n\t      }\n\t      var type = typeof index;\n\t      if (type == 'number'\n\t          ? (isArrayLike(object) && isIndex(index, object.length))\n\t          : (type == 'string' && index in object)) {\n\t        return eq(object[index], value);\n\t      }\n\t      return false;\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is a property name and not a property path.\n\t     *\n\t     * @private\n\t     * @param {*} value The value to check.\n\t     * @param {Object} [object] The object to query keys on.\n\t     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n\t     */\n\t    function isKey(value, object) {\n\t      if (typeof value == 'number') {\n\t        return true;\n\t      }\n\t      return !isArray(value) &&\n\t        (reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n\t          (object != null && value in Object(object)));\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is suitable for use as unique object key.\n\t     *\n\t     * @private\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n\t     */\n\t    function isKeyable(value) {\n\t      var type = typeof value;\n\t      return type == 'number' || type == 'boolean' ||\n\t        (type == 'string' && value !== '__proto__') || value == null;\n\t    }\n\t\n\t    /**\n\t     * Checks if `func` has a lazy counterpart.\n\t     *\n\t     * @private\n\t     * @param {Function} func The function to check.\n\t     * @returns {boolean} Returns `true` if `func` has a lazy counterpart, else `false`.\n\t     */\n\t    function isLaziable(func) {\n\t      var funcName = getFuncName(func),\n\t          other = lodash[funcName];\n\t\n\t      if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {\n\t        return false;\n\t      }\n\t      if (func === other) {\n\t        return true;\n\t      }\n\t      var data = getData(other);\n\t      return !!data && func === data[0];\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is likely a prototype object.\n\t     *\n\t     * @private\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n\t     */\n\t    function isPrototype(value) {\n\t      var Ctor = value && value.constructor,\n\t          proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\t\n\t      return value === proto;\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.\n\t     *\n\t     * @private\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` if suitable for strict\n\t     *  equality comparisons, else `false`.\n\t     */\n\t    function isStrictComparable(value) {\n\t      return value === value && !isObject(value);\n\t    }\n\t\n\t    /**\n\t     * Merges the function metadata of `source` into `data`.\n\t     *\n\t     * Merging metadata reduces the number of wrappers used to invoke a function.\n\t     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`\n\t     * may be applied regardless of execution order. Methods like `_.ary` and `_.rearg`\n\t     * modify function arguments, making the order in which they are executed important,\n\t     * preventing the merging of metadata. However, we make an exception for a safe\n\t     * combined case where curried functions have `_.ary` and or `_.rearg` applied.\n\t     *\n\t     * @private\n\t     * @param {Array} data The destination metadata.\n\t     * @param {Array} source The source metadata.\n\t     * @returns {Array} Returns `data`.\n\t     */\n\t    function mergeData(data, source) {\n\t      var bitmask = data[1],\n\t          srcBitmask = source[1],\n\t          newBitmask = bitmask | srcBitmask,\n\t          isCommon = newBitmask < (BIND_FLAG | BIND_KEY_FLAG | ARY_FLAG);\n\t\n\t      var isCombo =\n\t        (srcBitmask == ARY_FLAG && (bitmask == CURRY_FLAG)) ||\n\t        (srcBitmask == ARY_FLAG && (bitmask == REARG_FLAG) && (data[7].length <= source[8])) ||\n\t        (srcBitmask == (ARY_FLAG | REARG_FLAG) && (source[7].length <= source[8]) && (bitmask == CURRY_FLAG));\n\t\n\t      // Exit early if metadata can't be merged.\n\t      if (!(isCommon || isCombo)) {\n\t        return data;\n\t      }\n\t      // Use source `thisArg` if available.\n\t      if (srcBitmask & BIND_FLAG) {\n\t        data[2] = source[2];\n\t        // Set when currying a bound function.\n\t        newBitmask |= (bitmask & BIND_FLAG) ? 0 : CURRY_BOUND_FLAG;\n\t      }\n\t      // Compose partial arguments.\n\t      var value = source[3];\n\t      if (value) {\n\t        var partials = data[3];\n\t        data[3] = partials ? composeArgs(partials, value, source[4]) : copyArray(value);\n\t        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : copyArray(source[4]);\n\t      }\n\t      // Compose partial right arguments.\n\t      value = source[5];\n\t      if (value) {\n\t        partials = data[5];\n\t        data[5] = partials ? composeArgsRight(partials, value, source[6]) : copyArray(value);\n\t        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : copyArray(source[6]);\n\t      }\n\t      // Use source `argPos` if available.\n\t      value = source[7];\n\t      if (value) {\n\t        data[7] = copyArray(value);\n\t      }\n\t      // Use source `ary` if it's smaller.\n\t      if (srcBitmask & ARY_FLAG) {\n\t        data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);\n\t      }\n\t      // Use source `arity` if one is not provided.\n\t      if (data[9] == null) {\n\t        data[9] = source[9];\n\t      }\n\t      // Use source `func` and merge bitmasks.\n\t      data[0] = source[0];\n\t      data[1] = newBitmask;\n\t\n\t      return data;\n\t    }\n\t\n\t    /**\n\t     * Used by `_.defaultsDeep` to customize its `_.merge` use.\n\t     *\n\t     * @private\n\t     * @param {*} objValue The destination value.\n\t     * @param {*} srcValue The source value.\n\t     * @param {string} key The key of the property to merge.\n\t     * @param {Object} object The parent object of `objValue`.\n\t     * @param {Object} source The parent object of `srcValue`.\n\t     * @param {Object} [stack] Tracks traversed source values and their merged counterparts.\n\t     * @returns {*} Returns the value to assign.\n\t     */\n\t    function mergeDefaults(objValue, srcValue, key, object, source, stack) {\n\t      if (isObject(objValue) && isObject(srcValue)) {\n\t        stack.set(srcValue, objValue);\n\t        baseMerge(objValue, srcValue, mergeDefaults, stack);\n\t      }\n\t      return objValue === undefined ? baseClone(srcValue) : objValue;\n\t    }\n\t\n\t    /**\n\t     * Gets the parent value at `path` of `object`.\n\t     *\n\t     * @private\n\t     * @param {Object} object The object to query.\n\t     * @param {Array} path The path to get the parent value of.\n\t     * @returns {*} Returns the parent value.\n\t     */\n\t    function parent(object, path) {\n\t      return path.length == 1 ? object : get(object, baseSlice(path, 0, -1));\n\t    }\n\t\n\t    /**\n\t     * Reorder `array` according to the specified indexes where the element at\n\t     * the first index is assigned as the first element, the element at\n\t     * the second index is assigned as the second element, and so on.\n\t     *\n\t     * @private\n\t     * @param {Array} array The array to reorder.\n\t     * @param {Array} indexes The arranged array indexes.\n\t     * @returns {Array} Returns `array`.\n\t     */\n\t    function reorder(array, indexes) {\n\t      var arrLength = array.length,\n\t          length = nativeMin(indexes.length, arrLength),\n\t          oldArray = copyArray(array);\n\t\n\t      while (length--) {\n\t        var index = indexes[length];\n\t        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;\n\t      }\n\t      return array;\n\t    }\n\t\n\t    /**\n\t     * Sets metadata for `func`.\n\t     *\n\t     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short\n\t     * period of time, it will trip its breaker and transition to an identity function\n\t     * to avoid garbage collection pauses in V8. See [V8 issue 2070](https://code.google.com/p/v8/issues/detail?id=2070)\n\t     * for more details.\n\t     *\n\t     * @private\n\t     * @param {Function} func The function to associate metadata with.\n\t     * @param {*} data The metadata.\n\t     * @returns {Function} Returns `func`.\n\t     */\n\t    var setData = (function() {\n\t      var count = 0,\n\t          lastCalled = 0;\n\t\n\t      return function(key, value) {\n\t        var stamp = now(),\n\t            remaining = HOT_SPAN - (stamp - lastCalled);\n\t\n\t        lastCalled = stamp;\n\t        if (remaining > 0) {\n\t          if (++count >= HOT_COUNT) {\n\t            return key;\n\t          }\n\t        } else {\n\t          count = 0;\n\t        }\n\t        return baseSetData(key, value);\n\t      };\n\t    }());\n\t\n\t    /**\n\t     * Converts `string` to a property path array.\n\t     *\n\t     * @private\n\t     * @param {string} string The string to convert.\n\t     * @returns {Array} Returns the property path array.\n\t     */\n\t    function stringToPath(string) {\n\t      var result = [];\n\t      toString(string).replace(rePropName, function(match, number, quote, string) {\n\t        result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));\n\t      });\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * Converts `value` to an array-like object if it's not one.\n\t     *\n\t     * @private\n\t     * @param {*} value The value to process.\n\t     * @returns {Array} Returns the array-like object.\n\t     */\n\t    function toArrayLikeObject(value) {\n\t      return isArrayLikeObject(value) ? value : [];\n\t    }\n\t\n\t    /**\n\t     * Converts `value` to a function if it's not one.\n\t     *\n\t     * @private\n\t     * @param {*} value The value to process.\n\t     * @returns {Function} Returns the function.\n\t     */\n\t    function toFunction(value) {\n\t      return typeof value == 'function' ? value : identity;\n\t    }\n\t\n\t    /**\n\t     * Creates a clone of `wrapper`.\n\t     *\n\t     * @private\n\t     * @param {Object} wrapper The wrapper to clone.\n\t     * @returns {Object} Returns the cloned wrapper.\n\t     */\n\t    function wrapperClone(wrapper) {\n\t      if (wrapper instanceof LazyWrapper) {\n\t        return wrapper.clone();\n\t      }\n\t      var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);\n\t      result.__actions__ = copyArray(wrapper.__actions__);\n\t      result.__index__  = wrapper.__index__;\n\t      result.__values__ = wrapper.__values__;\n\t      return result;\n\t    }\n\t\n\t    /*------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * Creates an array of elements split into groups the length of `size`.\n\t     * If `array` can't be split evenly, the final chunk will be the remaining\n\t     * elements.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {Array} array The array to process.\n\t     * @param {number} [size=0] The length of each chunk.\n\t     * @returns {Array} Returns the new array containing chunks.\n\t     * @example\n\t     *\n\t     * _.chunk(['a', 'b', 'c', 'd'], 2);\n\t     * // => [['a', 'b'], ['c', 'd']]\n\t     *\n\t     * _.chunk(['a', 'b', 'c', 'd'], 3);\n\t     * // => [['a', 'b', 'c'], ['d']]\n\t     */\n\t    function chunk(array, size) {\n\t      size = nativeMax(toInteger(size), 0);\n\t\n\t      var length = array ? array.length : 0;\n\t      if (!length || size < 1) {\n\t        return [];\n\t      }\n\t      var index = 0,\n\t          resIndex = -1,\n\t          result = Array(nativeCeil(length / size));\n\t\n\t      while (index < length) {\n\t        result[++resIndex] = baseSlice(array, index, (index += size));\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * Creates an array with all falsey values removed. The values `false`, `null`,\n\t     * `0`, `\"\"`, `undefined`, and `NaN` are falsey.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {Array} array The array to compact.\n\t     * @returns {Array} Returns the new array of filtered values.\n\t     * @example\n\t     *\n\t     * _.compact([0, 1, false, 2, '', 3]);\n\t     * // => [1, 2, 3]\n\t     */\n\t    function compact(array) {\n\t      var index = -1,\n\t          length = array ? array.length : 0,\n\t          resIndex = -1,\n\t          result = [];\n\t\n\t      while (++index < length) {\n\t        var value = array[index];\n\t        if (value) {\n\t          result[++resIndex] = value;\n\t        }\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * Creates a new array concatenating `array` with any additional arrays\n\t     * and/or values.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {Array} array The array to concatenate.\n\t     * @param {...*} [values] The values to concatenate.\n\t     * @returns {Array} Returns the new concatenated array.\n\t     * @example\n\t     *\n\t     * var array = [1];\n\t     * var other = _.concat(array, 2, [3], [[4]]);\n\t     *\n\t     * console.log(other);\n\t     * // => [1, 2, 3, [4]]\n\t     *\n\t     * console.log(array);\n\t     * // => [1]\n\t     */\n\t    var concat = rest(function(array, values) {\n\t      values = baseFlatten(values);\n\t      return arrayConcat(isArray(array) ? array : [Object(array)], values);\n\t    });\n\t\n\t    /**\n\t     * Creates an array of unique `array` values not included in the other\n\t     * provided arrays using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)\n\t     * for equality comparisons.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {Array} array The array to inspect.\n\t     * @param {...Array} [values] The values to exclude.\n\t     * @returns {Array} Returns the new array of filtered values.\n\t     * @example\n\t     *\n\t     * _.difference([3, 2, 1], [4, 2]);\n\t     * // => [3, 1]\n\t     */\n\t    var difference = rest(function(array, values) {\n\t      return isArrayLikeObject(array)\n\t        ? baseDifference(array, baseFlatten(values, false, true))\n\t        : [];\n\t    });\n\t\n\t    /**\n\t     * This method is like `_.difference` except that it accepts `iteratee` which\n\t     * is invoked for each element of `array` and `values` to generate the criterion\n\t     * by which uniqueness is computed. The iteratee is invoked with one argument: (value).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {Array} array The array to inspect.\n\t     * @param {...Array} [values] The values to exclude.\n\t     * @param {Function|Object|string} [iteratee=_.identity] The iteratee invoked per element.\n\t     * @returns {Array} Returns the new array of filtered values.\n\t     * @example\n\t     *\n\t     * _.differenceBy([3.1, 2.2, 1.3], [4.4, 2.5], Math.floor);\n\t     * // => [3.1, 1.3]\n\t     *\n\t     * // using the `_.property` iteratee shorthand\n\t     * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');\n\t     * // => [{ 'x': 2 }]\n\t     */\n\t    var differenceBy = rest(function(array, values) {\n\t      var iteratee = last(values);\n\t      if (isArrayLikeObject(iteratee)) {\n\t        iteratee = undefined;\n\t      }\n\t      return isArrayLikeObject(array)\n\t        ? baseDifference(array, baseFlatten(values, false, true), getIteratee(iteratee))\n\t        : [];\n\t    });\n\t\n\t    /**\n\t     * This method is like `_.difference` except that it accepts `comparator`\n\t     * which is invoked to compare elements of `array` to `values`. The comparator\n\t     * is invoked with two arguments: (arrVal, othVal).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {Array} array The array to inspect.\n\t     * @param {...Array} [values] The values to exclude.\n\t     * @param {Function} [comparator] The comparator invoked per element.\n\t     * @returns {Array} Returns the new array of filtered values.\n\t     * @example\n\t     *\n\t     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\n\t     *\n\t     * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);\n\t     * // => [{ 'x': 2, 'y': 1 }]\n\t     */\n\t    var differenceWith = rest(function(array, values) {\n\t      var comparator = last(values);\n\t      if (isArrayLikeObject(comparator)) {\n\t        comparator = undefined;\n\t      }\n\t      return isArrayLikeObject(array)\n\t        ? baseDifference(array, baseFlatten(values, false, true), undefined, comparator)\n\t        : [];\n\t    });\n\t\n\t    /**\n\t     * Creates a slice of `array` with `n` elements dropped from the beginning.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {Array} array The array to query.\n\t     * @param {number} [n=1] The number of elements to drop.\n\t     * @param- {Object} [guard] Enables use as an iteratee for functions like `_.map`.\n\t     * @returns {Array} Returns the slice of `array`.\n\t     * @example\n\t     *\n\t     * _.drop([1, 2, 3]);\n\t     * // => [2, 3]\n\t     *\n\t     * _.drop([1, 2, 3], 2);\n\t     * // => [3]\n\t     *\n\t     * _.drop([1, 2, 3], 5);\n\t     * // => []\n\t     *\n\t     * _.drop([1, 2, 3], 0);\n\t     * // => [1, 2, 3]\n\t     */\n\t    function drop(array, n, guard) {\n\t      var length = array ? array.length : 0;\n\t      if (!length) {\n\t        return [];\n\t      }\n\t      n = (guard || n === undefined) ? 1 : toInteger(n);\n\t      return baseSlice(array, n < 0 ? 0 : n, length);\n\t    }\n\t\n\t    /**\n\t     * Creates a slice of `array` with `n` elements dropped from the end.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {Array} array The array to query.\n\t     * @param {number} [n=1] The number of elements to drop.\n\t     * @param- {Object} [guard] Enables use as an iteratee for functions like `_.map`.\n\t     * @returns {Array} Returns the slice of `array`.\n\t     * @example\n\t     *\n\t     * _.dropRight([1, 2, 3]);\n\t     * // => [1, 2]\n\t     *\n\t     * _.dropRight([1, 2, 3], 2);\n\t     * // => [1]\n\t     *\n\t     * _.dropRight([1, 2, 3], 5);\n\t     * // => []\n\t     *\n\t     * _.dropRight([1, 2, 3], 0);\n\t     * // => [1, 2, 3]\n\t     */\n\t    function dropRight(array, n, guard) {\n\t      var length = array ? array.length : 0;\n\t      if (!length) {\n\t        return [];\n\t      }\n\t      n = (guard || n === undefined) ? 1 : toInteger(n);\n\t      n = length - n;\n\t      return baseSlice(array, 0, n < 0 ? 0 : n);\n\t    }\n\t\n\t    /**\n\t     * Creates a slice of `array` excluding elements dropped from the end.\n\t     * Elements are dropped until `predicate` returns falsey. The predicate is\n\t     * invoked with three arguments: (value, index, array).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {Array} array The array to query.\n\t     * @param {Function|Object|string} [predicate=_.identity] The function invoked per iteration.\n\t     * @returns {Array} Returns the slice of `array`.\n\t     * @example\n\t     *\n\t     * var users = [\n\t     *   { 'user': 'barney',  'active': true },\n\t     *   { 'user': 'fred',    'active': false },\n\t     *   { 'user': 'pebbles', 'active': false }\n\t     * ];\n\t     *\n\t     * _.dropRightWhile(users, function(o) { return !o.active; });\n\t     * // => objects for ['barney']\n\t     *\n\t     * // using the `_.matches` iteratee shorthand\n\t     * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });\n\t     * // => objects for ['barney', 'fred']\n\t     *\n\t     * // using the `_.matchesProperty` iteratee shorthand\n\t     * _.dropRightWhile(users, ['active', false]);\n\t     * // => objects for ['barney']\n\t     *\n\t     * // using the `_.property` iteratee shorthand\n\t     * _.dropRightWhile(users, 'active');\n\t     * // => objects for ['barney', 'fred', 'pebbles']\n\t     */\n\t    function dropRightWhile(array, predicate) {\n\t      return (array && array.length)\n\t        ? baseWhile(array, getIteratee(predicate, 3), true, true)\n\t        : [];\n\t    }\n\t\n\t    /**\n\t     * Creates a slice of `array` excluding elements dropped from the beginning.\n\t     * Elements are dropped until `predicate` returns falsey. The predicate is\n\t     * invoked with three arguments: (value, index, array).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {Array} array The array to query.\n\t     * @param {Function|Object|string} [predicate=_.identity] The function invoked per iteration.\n\t     * @returns {Array} Returns the slice of `array`.\n\t     * @example\n\t     *\n\t     * var users = [\n\t     *   { 'user': 'barney',  'active': false },\n\t     *   { 'user': 'fred',    'active': false },\n\t     *   { 'user': 'pebbles', 'active': true }\n\t     * ];\n\t     *\n\t     * _.dropWhile(users, function(o) { return !o.active; });\n\t     * // => objects for ['pebbles']\n\t     *\n\t     * // using the `_.matches` iteratee shorthand\n\t     * _.dropWhile(users, { 'user': 'barney', 'active': false });\n\t     * // => objects for ['fred', 'pebbles']\n\t     *\n\t     * // using the `_.matchesProperty` iteratee shorthand\n\t     * _.dropWhile(users, ['active', false]);\n\t     * // => objects for ['pebbles']\n\t     *\n\t     * // using the `_.property` iteratee shorthand\n\t     * _.dropWhile(users, 'active');\n\t     * // => objects for ['barney', 'fred', 'pebbles']\n\t     */\n\t    function dropWhile(array, predicate) {\n\t      return (array && array.length)\n\t        ? baseWhile(array, getIteratee(predicate, 3), true)\n\t        : [];\n\t    }\n\t\n\t    /**\n\t     * Fills elements of `array` with `value` from `start` up to, but not\n\t     * including, `end`.\n\t     *\n\t     * **Note:** This method mutates `array`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {Array} array The array to fill.\n\t     * @param {*} value The value to fill `array` with.\n\t     * @param {number} [start=0] The start position.\n\t     * @param {number} [end=array.length] The end position.\n\t     * @returns {Array} Returns `array`.\n\t     * @example\n\t     *\n\t     * var array = [1, 2, 3];\n\t     *\n\t     * _.fill(array, 'a');\n\t     * console.log(array);\n\t     * // => ['a', 'a', 'a']\n\t     *\n\t     * _.fill(Array(3), 2);\n\t     * // => [2, 2, 2]\n\t     *\n\t     * _.fill([4, 6, 8, 10], '*', 1, 3);\n\t     * // => [4, '*', '*', 10]\n\t     */\n\t    function fill(array, value, start, end) {\n\t      var length = array ? array.length : 0;\n\t      if (!length) {\n\t        return [];\n\t      }\n\t      if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {\n\t        start = 0;\n\t        end = length;\n\t      }\n\t      return baseFill(array, value, start, end);\n\t    }\n\t\n\t    /**\n\t     * This method is like `_.find` except that it returns the index of the first\n\t     * element `predicate` returns truthy for instead of the element itself.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {Array} array The array to search.\n\t     * @param {Function|Object|string} [predicate=_.identity] The function invoked per iteration.\n\t     * @returns {number} Returns the index of the found element, else `-1`.\n\t     * @example\n\t     *\n\t     * var users = [\n\t     *   { 'user': 'barney',  'active': false },\n\t     *   { 'user': 'fred',    'active': false },\n\t     *   { 'user': 'pebbles', 'active': true }\n\t     * ];\n\t     *\n\t     * _.findIndex(users, function(o) { return o.user == 'barney'; });\n\t     * // => 0\n\t     *\n\t     * // using the `_.matches` iteratee shorthand\n\t     * _.findIndex(users, { 'user': 'fred', 'active': false });\n\t     * // => 1\n\t     *\n\t     * // using the `_.matchesProperty` iteratee shorthand\n\t     * _.findIndex(users, ['active', false]);\n\t     * // => 0\n\t     *\n\t     * // using the `_.property` iteratee shorthand\n\t     * _.findIndex(users, 'active');\n\t     * // => 2\n\t     */\n\t    function findIndex(array, predicate) {\n\t      return (array && array.length)\n\t        ? baseFindIndex(array, getIteratee(predicate, 3))\n\t        : -1;\n\t    }\n\t\n\t    /**\n\t     * This method is like `_.findIndex` except that it iterates over elements\n\t     * of `collection` from right to left.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {Array} array The array to search.\n\t     * @param {Function|Object|string} [predicate=_.identity] The function invoked per iteration.\n\t     * @returns {number} Returns the index of the found element, else `-1`.\n\t     * @example\n\t     *\n\t     * var users = [\n\t     *   { 'user': 'barney',  'active': true },\n\t     *   { 'user': 'fred',    'active': false },\n\t     *   { 'user': 'pebbles', 'active': false }\n\t     * ];\n\t     *\n\t     * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });\n\t     * // => 2\n\t     *\n\t     * // using the `_.matches` iteratee shorthand\n\t     * _.findLastIndex(users, { 'user': 'barney', 'active': true });\n\t     * // => 0\n\t     *\n\t     * // using the `_.matchesProperty` iteratee shorthand\n\t     * _.findLastIndex(users, ['active', false]);\n\t     * // => 2\n\t     *\n\t     * // using the `_.property` iteratee shorthand\n\t     * _.findLastIndex(users, 'active');\n\t     * // => 0\n\t     */\n\t    function findLastIndex(array, predicate) {\n\t      return (array && array.length)\n\t        ? baseFindIndex(array, getIteratee(predicate, 3), true)\n\t        : -1;\n\t    }\n\t\n\t    /**\n\t     * Creates an array of flattened values by running each element in `array`\n\t     * through `iteratee` and concating its result to the other mapped values.\n\t     * The iteratee is invoked with three arguments: (value, index|key, array).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {Array} array The array to iterate over.\n\t     * @param {Function|Object|string} [iteratee=_.identity] The function invoked per iteration.\n\t     * @returns {Array} Returns the new array.\n\t     * @example\n\t     *\n\t     * function duplicate(n) {\n\t     *   return [n, n];\n\t     * }\n\t     *\n\t     * _.flatMap([1, 2], duplicate);\n\t     * // => [1, 1, 2, 2]\n\t     */\n\t    function flatMap(array, iteratee) {\n\t      var length = array ? array.length : 0;\n\t      return length ? baseFlatten(arrayMap(array, getIteratee(iteratee, 3))) : [];\n\t    }\n\t\n\t    /**\n\t     * Flattens `array` a single level.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {Array} array The array to flatten.\n\t     * @returns {Array} Returns the new flattened array.\n\t     * @example\n\t     *\n\t     * _.flatten([1, [2, 3, [4]]]);\n\t     * // => [1, 2, 3, [4]]\n\t     */\n\t    function flatten(array) {\n\t      var length = array ? array.length : 0;\n\t      return length ? baseFlatten(array) : [];\n\t    }\n\t\n\t    /**\n\t     * This method is like `_.flatten` except that it recursively flattens `array`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {Array} array The array to recursively flatten.\n\t     * @returns {Array} Returns the new flattened array.\n\t     * @example\n\t     *\n\t     * _.flattenDeep([1, [2, 3, [4]]]);\n\t     * // => [1, 2, 3, 4]\n\t     */\n\t    function flattenDeep(array) {\n\t      var length = array ? array.length : 0;\n\t      return length ? baseFlatten(array, true) : [];\n\t    }\n\t\n\t    /**\n\t     * The inverse of `_.toPairs`; this method returns an object composed\n\t     * from key-value `pairs`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {Array} pairs The key-value pairs.\n\t     * @returns {Object} Returns the new object.\n\t     * @example\n\t     *\n\t     * _.fromPairs([['fred', 30], ['barney', 40]]);\n\t     * // => { 'fred': 30, 'barney': 40 }\n\t     */\n\t    function fromPairs(pairs) {\n\t      var index = -1,\n\t          length = pairs ? pairs.length : 0,\n\t          result = {};\n\t\n\t      while (++index < length) {\n\t        var pair = pairs[index];\n\t        baseSet(result, pair[0], pair[1]);\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * Gets the first element of `array`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @alias first\n\t     * @category Array\n\t     * @param {Array} array The array to query.\n\t     * @returns {*} Returns the first element of `array`.\n\t     * @example\n\t     *\n\t     * _.head([1, 2, 3]);\n\t     * // => 1\n\t     *\n\t     * _.head([]);\n\t     * // => undefined\n\t     */\n\t    function head(array) {\n\t      return array ? array[0] : undefined;\n\t    }\n\t\n\t    /**\n\t     * Gets the index at which the first occurrence of `value` is found in `array`\n\t     * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)\n\t     * for equality comparisons. If `fromIndex` is negative, it's used as the offset\n\t     * from the end of `array`. If `array` is sorted providing `true` for `fromIndex`\n\t     * performs a faster binary search.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {Array} array The array to search.\n\t     * @param {*} value The value to search for.\n\t     * @param {number} [fromIndex=0] The index to search from.\n\t     * @returns {number} Returns the index of the matched value, else `-1`.\n\t     * @example\n\t     *\n\t     * _.indexOf([1, 2, 1, 2], 2);\n\t     * // => 1\n\t     *\n\t     * // using `fromIndex`\n\t     * _.indexOf([1, 2, 1, 2], 2, 2);\n\t     * // => 3\n\t     */\n\t    function indexOf(array, value, fromIndex) {\n\t      var length = array ? array.length : 0;\n\t      if (!length) {\n\t        return -1;\n\t      }\n\t      fromIndex = toInteger(fromIndex);\n\t      if (fromIndex < 0) {\n\t        fromIndex = nativeMax(length + fromIndex, 0);\n\t      }\n\t      return baseIndexOf(array, value, fromIndex);\n\t    }\n\t\n\t    /**\n\t     * Gets all but the last element of `array`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {Array} array The array to query.\n\t     * @returns {Array} Returns the slice of `array`.\n\t     * @example\n\t     *\n\t     * _.initial([1, 2, 3]);\n\t     * // => [1, 2]\n\t     */\n\t    function initial(array) {\n\t      return dropRight(array, 1);\n\t    }\n\t\n\t    /**\n\t     * Creates an array of unique values that are included in all of the provided\n\t     * arrays using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)\n\t     * for equality comparisons.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {...Array} [arrays] The arrays to inspect.\n\t     * @returns {Array} Returns the new array of shared values.\n\t     * @example\n\t     * _.intersection([2, 1], [4, 2], [1, 2]);\n\t     * // => [2]\n\t     */\n\t    var intersection = rest(function(arrays) {\n\t      var mapped = arrayMap(arrays, toArrayLikeObject);\n\t      return (mapped.length && mapped[0] === arrays[0])\n\t        ? baseIntersection(mapped)\n\t        : [];\n\t    });\n\t\n\t    /**\n\t     * This method is like `_.intersection` except that it accepts `iteratee`\n\t     * which is invoked for each element of each `arrays` to generate the criterion\n\t     * by which uniqueness is computed. The iteratee is invoked with one argument: (value).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {...Array} [arrays] The arrays to inspect.\n\t     * @param {Function|Object|string} [iteratee=_.identity] The iteratee invoked per element.\n\t     * @returns {Array} Returns the new array of shared values.\n\t     * @example\n\t     *\n\t     * _.intersectionBy([2.1, 1.2], [4.3, 2.4], Math.floor);\n\t     * // => [2.1]\n\t     *\n\t     * // using the `_.property` iteratee shorthand\n\t     * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');\n\t     * // => [{ 'x': 1 }]\n\t     */\n\t    var intersectionBy = rest(function(arrays) {\n\t      var iteratee = last(arrays),\n\t          mapped = arrayMap(arrays, toArrayLikeObject);\n\t\n\t      if (iteratee === last(mapped)) {\n\t        iteratee = undefined;\n\t      } else {\n\t        mapped.pop();\n\t      }\n\t      return (mapped.length && mapped[0] === arrays[0])\n\t        ? baseIntersection(mapped, getIteratee(iteratee))\n\t        : [];\n\t    });\n\t\n\t    /**\n\t     * This method is like `_.intersection` except that it accepts `comparator`\n\t     * which is invoked to compare elements of `arrays`. The comparator is invoked\n\t     * with two arguments: (arrVal, othVal).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {...Array} [arrays] The arrays to inspect.\n\t     * @param {Function} [comparator] The comparator invoked per element.\n\t     * @returns {Array} Returns the new array of shared values.\n\t     * @example\n\t     *\n\t     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\n\t     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];\n\t     *\n\t     * _.intersectionWith(objects, others, _.isEqual);\n\t     * // => [{ 'x': 1, 'y': 2 }]\n\t     */\n\t    var intersectionWith = rest(function(arrays) {\n\t      var comparator = last(arrays),\n\t          mapped = arrayMap(arrays, toArrayLikeObject);\n\t\n\t      if (comparator === last(mapped)) {\n\t        comparator = undefined;\n\t      } else {\n\t        mapped.pop();\n\t      }\n\t      return (mapped.length && mapped[0] === arrays[0])\n\t        ? baseIntersection(mapped, undefined, comparator)\n\t        : [];\n\t    });\n\t\n\t    /**\n\t     * Converts all elements in `array` into a string separated by `separator`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {Array} array The array to convert.\n\t     * @param {string} [separator=','] The element separator.\n\t     * @returns {string} Returns the joined string.\n\t     * @example\n\t     *\n\t     * _.join(['a', 'b', 'c'], '~');\n\t     * // => 'a~b~c'\n\t     */\n\t    function join(array, separator) {\n\t      return array ? nativeJoin.call(array, separator) : '';\n\t    }\n\t\n\t    /**\n\t     * Gets the last element of `array`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {Array} array The array to query.\n\t     * @returns {*} Returns the last element of `array`.\n\t     * @example\n\t     *\n\t     * _.last([1, 2, 3]);\n\t     * // => 3\n\t     */\n\t    function last(array) {\n\t      var length = array ? array.length : 0;\n\t      return length ? array[length - 1] : undefined;\n\t    }\n\t\n\t    /**\n\t     * This method is like `_.indexOf` except that it iterates over elements of\n\t     * `array` from right to left.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {Array} array The array to search.\n\t     * @param {*} value The value to search for.\n\t     * @param {number} [fromIndex=array.length-1] The index to search from.\n\t     * @returns {number} Returns the index of the matched value, else `-1`.\n\t     * @example\n\t     *\n\t     * _.lastIndexOf([1, 2, 1, 2], 2);\n\t     * // => 3\n\t     *\n\t     * // using `fromIndex`\n\t     * _.lastIndexOf([1, 2, 1, 2], 2, 2);\n\t     * // => 1\n\t     */\n\t    function lastIndexOf(array, value, fromIndex) {\n\t      var length = array ? array.length : 0;\n\t      if (!length) {\n\t        return -1;\n\t      }\n\t      var index = length;\n\t      if (fromIndex !== undefined) {\n\t        index = toInteger(fromIndex);\n\t        index = (index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1)) + 1;\n\t      }\n\t      if (value !== value) {\n\t        return indexOfNaN(array, index, true);\n\t      }\n\t      while (index--) {\n\t        if (array[index] === value) {\n\t          return index;\n\t        }\n\t      }\n\t      return -1;\n\t    }\n\t\n\t    /**\n\t     * Removes all provided values from `array` using\n\t     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)\n\t     * for equality comparisons.\n\t     *\n\t     * **Note:** Unlike `_.without`, this method mutates `array`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {Array} array The array to modify.\n\t     * @param {...*} [values] The values to remove.\n\t     * @returns {Array} Returns `array`.\n\t     * @example\n\t     *\n\t     * var array = [1, 2, 3, 1, 2, 3];\n\t     *\n\t     * _.pull(array, 2, 3);\n\t     * console.log(array);\n\t     * // => [1, 1]\n\t     */\n\t    var pull = rest(pullAll);\n\t\n\t    /**\n\t     * This method is like `_.pull` except that it accepts an array of values to remove.\n\t     *\n\t     * **Note:** Unlike `_.difference`, this method mutates `array`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {Array} array The array to modify.\n\t     * @param {Array} values The values to remove.\n\t     * @returns {Array} Returns `array`.\n\t     * @example\n\t     *\n\t     * var array = [1, 2, 3, 1, 2, 3];\n\t     *\n\t     * _.pull(array, [2, 3]);\n\t     * console.log(array);\n\t     * // => [1, 1]\n\t     */\n\t    function pullAll(array, values) {\n\t      return (array && array.length && values && values.length)\n\t        ? basePullAll(array, values)\n\t        : array;\n\t    }\n\t\n\t    /**\n\t     * This method is like `_.pullAll` except that it accepts `iteratee` which is\n\t     * invoked for each element of `array` and `values` to to generate the criterion\n\t     * by which uniqueness is computed. The iteratee is invoked with one argument: (value).\n\t     *\n\t     * **Note:** Unlike `_.differenceBy`, this method mutates `array`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {Array} array The array to modify.\n\t     * @param {Array} values The values to remove.\n\t     * @param {Function|Object|string} [iteratee=_.identity] The iteratee invoked per element.\n\t     * @returns {Array} Returns `array`.\n\t     * @example\n\t     *\n\t     * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];\n\t     *\n\t     * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');\n\t     * console.log(array);\n\t     * // => [{ 'x': 2 }]\n\t     */\n\t    function pullAllBy(array, values, iteratee) {\n\t      return (array && array.length && values && values.length)\n\t        ? basePullAllBy(array, values, getIteratee(iteratee))\n\t        : array;\n\t    }\n\t\n\t    /**\n\t     * Removes elements from `array` corresponding to `indexes` and returns an\n\t     * array of removed elements.\n\t     *\n\t     * **Note:** Unlike `_.at`, this method mutates `array`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {Array} array The array to modify.\n\t     * @param {...(number|number[])} [indexes] The indexes of elements to remove,\n\t     *  specified individually or in arrays.\n\t     * @returns {Array} Returns the new array of removed elements.\n\t     * @example\n\t     *\n\t     * var array = [5, 10, 15, 20];\n\t     * var evens = _.pullAt(array, 1, 3);\n\t     *\n\t     * console.log(array);\n\t     * // => [5, 15]\n\t     *\n\t     * console.log(evens);\n\t     * // => [10, 20]\n\t     */\n\t    var pullAt = rest(function(array, indexes) {\n\t      indexes = arrayMap(baseFlatten(indexes), String);\n\t\n\t      var result = baseAt(array, indexes);\n\t      basePullAt(array, indexes.sort(compareAscending));\n\t      return result;\n\t    });\n\t\n\t    /**\n\t     * Removes all elements from `array` that `predicate` returns truthy for\n\t     * and returns an array of the removed elements. The predicate is invoked with\n\t     * three arguments: (value, index, array).\n\t     *\n\t     * **Note:** Unlike `_.filter`, this method mutates `array`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {Array} array The array to modify.\n\t     * @param {Function|Object|string} [predicate=_.identity] The function invoked per iteration.\n\t     * @returns {Array} Returns the new array of removed elements.\n\t     * @example\n\t     *\n\t     * var array = [1, 2, 3, 4];\n\t     * var evens = _.remove(array, function(n) {\n\t     *   return n % 2 == 0;\n\t     * });\n\t     *\n\t     * console.log(array);\n\t     * // => [1, 3]\n\t     *\n\t     * console.log(evens);\n\t     * // => [2, 4]\n\t     */\n\t    function remove(array, predicate) {\n\t      var result = [];\n\t      if (!(array && array.length)) {\n\t        return result;\n\t      }\n\t      var index = -1,\n\t          indexes = [],\n\t          length = array.length;\n\t\n\t      predicate = getIteratee(predicate, 3);\n\t      while (++index < length) {\n\t        var value = array[index];\n\t        if (predicate(value, index, array)) {\n\t          result.push(value);\n\t          indexes.push(index);\n\t        }\n\t      }\n\t      basePullAt(array, indexes);\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * Reverses `array` so that the first element becomes the last, the second\n\t     * element becomes the second to last, and so on.\n\t     *\n\t     * **Note:** This method mutates `array` and is based on\n\t     * [`Array#reverse`](https://mdn.io/Array/reverse).\n\t     *\n\t     * @memberOf _\n\t     * @category Array\n\t     * @returns {Array} Returns `array`.\n\t     * @example\n\t     *\n\t     * var array = [1, 2, 3];\n\t     *\n\t     * _.reverse(array);\n\t     * // => [3, 2, 1]\n\t     *\n\t     * console.log(array);\n\t     * // => [3, 2, 1]\n\t     */\n\t    function reverse(array) {\n\t      return array ? nativeReverse.call(array) : array;\n\t    }\n\t\n\t    /**\n\t     * Creates a slice of `array` from `start` up to, but not including, `end`.\n\t     *\n\t     * **Note:** This method is used instead of [`Array#slice`](https://mdn.io/Array/slice)\n\t     * to ensure dense arrays are returned.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {Array} array The array to slice.\n\t     * @param {number} [start=0] The start position.\n\t     * @param {number} [end=array.length] The end position.\n\t     * @returns {Array} Returns the slice of `array`.\n\t     */\n\t    function slice(array, start, end) {\n\t      var length = array ? array.length : 0;\n\t      if (!length) {\n\t        return [];\n\t      }\n\t      if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {\n\t        start = 0;\n\t        end = length;\n\t      }\n\t      else {\n\t        start = start == null ? 0 : toInteger(start);\n\t        end = end === undefined ? length : toInteger(end);\n\t      }\n\t      return baseSlice(array, start, end);\n\t    }\n\t\n\t    /**\n\t     * Uses a binary search to determine the lowest index at which `value` should\n\t     * be inserted into `array` in order to maintain its sort order.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {Array} array The sorted array to inspect.\n\t     * @param {*} value The value to evaluate.\n\t     * @returns {number} Returns the index at which `value` should be inserted into `array`.\n\t     * @example\n\t     *\n\t     * _.sortedIndex([30, 50], 40);\n\t     * // => 1\n\t     *\n\t     * _.sortedIndex([4, 5], 4);\n\t     * // => 0\n\t     */\n\t    function sortedIndex(array, value) {\n\t      return baseSortedIndex(array, value);\n\t    }\n\t\n\t    /**\n\t     * This method is like `_.sortedIndex` except that it accepts `iteratee`\n\t     * which is invoked for `value` and each element of `array` to compute their\n\t     * sort ranking. The iteratee is invoked with one argument: (value).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {Array} array The sorted array to inspect.\n\t     * @param {*} value The value to evaluate.\n\t     * @param {Function|Object|string} [iteratee=_.identity] The iteratee invoked per element.\n\t     * @returns {number} Returns the index at which `value` should be inserted into `array`.\n\t     * @example\n\t     *\n\t     * var dict = { 'thirty': 30, 'forty': 40, 'fifty': 50 };\n\t     *\n\t     * _.sortedIndexBy(['thirty', 'fifty'], 'forty', _.propertyOf(dict));\n\t     * // => 1\n\t     *\n\t     * // using the `_.property` iteratee shorthand\n\t     * _.sortedIndexBy([{ 'x': 4 }, { 'x': 5 }], { 'x': 4 }, 'x');\n\t     * // => 0\n\t     */\n\t    function sortedIndexBy(array, value, iteratee) {\n\t      return baseSortedIndexBy(array, value, getIteratee(iteratee));\n\t    }\n\t\n\t    /**\n\t     * This method is like `_.indexOf` except that it performs a binary\n\t     * search on a sorted `array`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {Array} array The array to search.\n\t     * @param {*} value The value to search for.\n\t     * @returns {number} Returns the index of the matched value, else `-1`.\n\t     * @example\n\t     *\n\t     * _.sortedIndexOf([1, 1, 2, 2], 2);\n\t     * // => 2\n\t     */\n\t    function sortedIndexOf(array, value) {\n\t      var length = array ? array.length : 0;\n\t      if (length) {\n\t        var index = baseSortedIndex(array, value);\n\t        if (index < length && eq(array[index], value)) {\n\t          return index;\n\t        }\n\t      }\n\t      return -1;\n\t    }\n\t\n\t    /**\n\t     * This method is like `_.sortedIndex` except that it returns the highest\n\t     * index at which `value` should be inserted into `array` in order to\n\t     * maintain its sort order.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {Array} array The sorted array to inspect.\n\t     * @param {*} value The value to evaluate.\n\t     * @returns {number} Returns the index at which `value` should be inserted into `array`.\n\t     * @example\n\t     *\n\t     * _.sortedLastIndex([4, 5], 4);\n\t     * // => 1\n\t     */\n\t    function sortedLastIndex(array, value) {\n\t      return baseSortedIndex(array, value, true);\n\t    }\n\t\n\t    /**\n\t     * This method is like `_.sortedLastIndex` except that it accepts `iteratee`\n\t     * which is invoked for `value` and each element of `array` to compute their\n\t     * sort ranking. The iteratee is invoked with one argument: (value).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {Array} array The sorted array to inspect.\n\t     * @param {*} value The value to evaluate.\n\t     * @param {Function|Object|string} [iteratee=_.identity] The iteratee invoked per element.\n\t     * @returns {number} Returns the index at which `value` should be inserted into `array`.\n\t     * @example\n\t     *\n\t     * // using the `_.property` iteratee shorthand\n\t     * _.sortedLastIndexBy([{ 'x': 4 }, { 'x': 5 }], { 'x': 4 }, 'x');\n\t     * // => 1\n\t     */\n\t    function sortedLastIndexBy(array, value, iteratee) {\n\t      return baseSortedIndexBy(array, value, getIteratee(iteratee), true);\n\t    }\n\t\n\t    /**\n\t     * This method is like `_.lastIndexOf` except that it performs a binary\n\t     * search on a sorted `array`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {Array} array The array to search.\n\t     * @param {*} value The value to search for.\n\t     * @returns {number} Returns the index of the matched value, else `-1`.\n\t     * @example\n\t     *\n\t     * _.sortedLastIndexOf([1, 1, 2, 2], 2);\n\t     * // => 3\n\t     */\n\t    function sortedLastIndexOf(array, value) {\n\t      var length = array ? array.length : 0;\n\t      if (length) {\n\t        var index = baseSortedIndex(array, value, true) - 1;\n\t        if (eq(array[index], value)) {\n\t          return index;\n\t        }\n\t      }\n\t      return -1;\n\t    }\n\t\n\t    /**\n\t     * This method is like `_.uniq` except that it's designed and optimized\n\t     * for sorted arrays.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {Array} array The array to inspect.\n\t     * @returns {Array} Returns the new duplicate free array.\n\t     * @example\n\t     *\n\t     * _.sortedUniq([1, 1, 2]);\n\t     * // => [1, 2]\n\t     */\n\t    function sortedUniq(array) {\n\t      return (array && array.length)\n\t        ? baseSortedUniq(array)\n\t        : [];\n\t    }\n\t\n\t    /**\n\t     * This method is like `_.uniqBy` except that it's designed and optimized\n\t     * for sorted arrays.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {Array} array The array to inspect.\n\t     * @param {Function} [iteratee] The iteratee invoked per element.\n\t     * @returns {Array} Returns the new duplicate free array.\n\t     * @example\n\t     *\n\t     * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);\n\t     * // => [1.1, 2.2]\n\t     */\n\t    function sortedUniqBy(array, iteratee) {\n\t      return (array && array.length)\n\t        ? baseSortedUniqBy(array, getIteratee(iteratee))\n\t        : [];\n\t    }\n\t\n\t    /**\n\t     * Gets all but the first element of `array`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {Array} array The array to query.\n\t     * @returns {Array} Returns the slice of `array`.\n\t     * @example\n\t     *\n\t     * _.tail([1, 2, 3]);\n\t     * // => [2, 3]\n\t     */\n\t    function tail(array) {\n\t      return drop(array, 1);\n\t    }\n\t\n\t    /**\n\t     * Creates a slice of `array` with `n` elements taken from the beginning.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {Array} array The array to query.\n\t     * @param {number} [n=1] The number of elements to take.\n\t     * @param- {Object} [guard] Enables use as an iteratee for functions like `_.map`.\n\t     * @returns {Array} Returns the slice of `array`.\n\t     * @example\n\t     *\n\t     * _.take([1, 2, 3]);\n\t     * // => [1]\n\t     *\n\t     * _.take([1, 2, 3], 2);\n\t     * // => [1, 2]\n\t     *\n\t     * _.take([1, 2, 3], 5);\n\t     * // => [1, 2, 3]\n\t     *\n\t     * _.take([1, 2, 3], 0);\n\t     * // => []\n\t     */\n\t    function take(array, n, guard) {\n\t      if (!(array && array.length)) {\n\t        return [];\n\t      }\n\t      n = (guard || n === undefined) ? 1 : toInteger(n);\n\t      return baseSlice(array, 0, n < 0 ? 0 : n);\n\t    }\n\t\n\t    /**\n\t     * Creates a slice of `array` with `n` elements taken from the end.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {Array} array The array to query.\n\t     * @param {number} [n=1] The number of elements to take.\n\t     * @param- {Object} [guard] Enables use as an iteratee for functions like `_.map`.\n\t     * @returns {Array} Returns the slice of `array`.\n\t     * @example\n\t     *\n\t     * _.takeRight([1, 2, 3]);\n\t     * // => [3]\n\t     *\n\t     * _.takeRight([1, 2, 3], 2);\n\t     * // => [2, 3]\n\t     *\n\t     * _.takeRight([1, 2, 3], 5);\n\t     * // => [1, 2, 3]\n\t     *\n\t     * _.takeRight([1, 2, 3], 0);\n\t     * // => []\n\t     */\n\t    function takeRight(array, n, guard) {\n\t      var length = array ? array.length : 0;\n\t      if (!length) {\n\t        return [];\n\t      }\n\t      n = (guard || n === undefined) ? 1 : toInteger(n);\n\t      n = length - n;\n\t      return baseSlice(array, n < 0 ? 0 : n, length);\n\t    }\n\t\n\t    /**\n\t     * Creates a slice of `array` with elements taken from the end. Elements are\n\t     * taken until `predicate` returns falsey. The predicate is invoked with three\n\t     * arguments: (value, index, array).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {Array} array The array to query.\n\t     * @param {Function|Object|string} [predicate=_.identity] The function invoked per iteration.\n\t     * @returns {Array} Returns the slice of `array`.\n\t     * @example\n\t     *\n\t     * var users = [\n\t     *   { 'user': 'barney',  'active': true },\n\t     *   { 'user': 'fred',    'active': false },\n\t     *   { 'user': 'pebbles', 'active': false }\n\t     * ];\n\t     *\n\t     * _.takeRightWhile(users, function(o) { return !o.active; });\n\t     * // => objects for ['fred', 'pebbles']\n\t     *\n\t     * // using the `_.matches` iteratee shorthand\n\t     * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });\n\t     * // => objects for ['pebbles']\n\t     *\n\t     * // using the `_.matchesProperty` iteratee shorthand\n\t     * _.takeRightWhile(users, ['active', false]);\n\t     * // => objects for ['fred', 'pebbles']\n\t     *\n\t     * // using the `_.property` iteratee shorthand\n\t     * _.takeRightWhile(users, 'active');\n\t     * // => []\n\t     */\n\t    function takeRightWhile(array, predicate) {\n\t      return (array && array.length)\n\t        ? baseWhile(array, getIteratee(predicate, 3), false, true)\n\t        : [];\n\t    }\n\t\n\t    /**\n\t     * Creates a slice of `array` with elements taken from the beginning. Elements\n\t     * are taken until `predicate` returns falsey. The predicate is invoked with\n\t     * three arguments: (value, index, array).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {Array} array The array to query.\n\t     * @param {Function|Object|string} [predicate=_.identity] The function invoked per iteration.\n\t     * @returns {Array} Returns the slice of `array`.\n\t     * @example\n\t     *\n\t     * var users = [\n\t     *   { 'user': 'barney',  'active': false },\n\t     *   { 'user': 'fred',    'active': false},\n\t     *   { 'user': 'pebbles', 'active': true }\n\t     * ];\n\t     *\n\t     * _.takeWhile(users, function(o) { return !o.active; });\n\t     * // => objects for ['barney', 'fred']\n\t     *\n\t     * // using the `_.matches` iteratee shorthand\n\t     * _.takeWhile(users, { 'user': 'barney', 'active': false });\n\t     * // => objects for ['barney']\n\t     *\n\t     * // using the `_.matchesProperty` iteratee shorthand\n\t     * _.takeWhile(users, ['active', false]);\n\t     * // => objects for ['barney', 'fred']\n\t     *\n\t     * // using the `_.property` iteratee shorthand\n\t     * _.takeWhile(users, 'active');\n\t     * // => []\n\t     */\n\t    function takeWhile(array, predicate) {\n\t      return (array && array.length)\n\t        ? baseWhile(array, getIteratee(predicate, 3))\n\t        : [];\n\t    }\n\t\n\t    /**\n\t     * Creates an array of unique values, in order, from all of the provided arrays\n\t     * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)\n\t     * for equality comparisons.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {...Array} [arrays] The arrays to inspect.\n\t     * @returns {Array} Returns the new array of combined values.\n\t     * @example\n\t     *\n\t     * _.union([2, 1], [4, 2], [1, 2]);\n\t     * // => [2, 1, 4]\n\t     */\n\t    var union = rest(function(arrays) {\n\t      return baseUniq(baseFlatten(arrays, false, true));\n\t    });\n\t\n\t    /**\n\t     * This method is like `_.union` except that it accepts `iteratee` which is\n\t     * invoked for each element of each `arrays` to generate the criterion by which\n\t     * uniqueness is computed. The iteratee is invoked with one argument: (value).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {...Array} [arrays] The arrays to inspect.\n\t     * @param {Function|Object|string} [iteratee=_.identity] The iteratee invoked per element.\n\t     * @returns {Array} Returns the new array of combined values.\n\t     * @example\n\t     *\n\t     * _.unionBy([2.1, 1.2], [4.3, 2.4], Math.floor);\n\t     * // => [2.1, 1.2, 4.3]\n\t     *\n\t     * // using the `_.property` iteratee shorthand\n\t     * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');\n\t     * // => [{ 'x': 1 }, { 'x': 2 }]\n\t     */\n\t    var unionBy = rest(function(arrays) {\n\t      var iteratee = last(arrays);\n\t      if (isArrayLikeObject(iteratee)) {\n\t        iteratee = undefined;\n\t      }\n\t      return baseUniq(baseFlatten(arrays, false, true), getIteratee(iteratee));\n\t    });\n\t\n\t    /**\n\t     * This method is like `_.union` except that it accepts `comparator` which\n\t     * is invoked to compare elements of `arrays`. The comparator is invoked\n\t     * with two arguments: (arrVal, othVal).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {...Array} [arrays] The arrays to inspect.\n\t     * @param {Function} [comparator] The comparator invoked per element.\n\t     * @returns {Array} Returns the new array of combined values.\n\t     * @example\n\t     *\n\t     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\n\t     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];\n\t     *\n\t     * _.unionWith(objects, others, _.isEqual);\n\t     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]\n\t     */\n\t    var unionWith = rest(function(arrays) {\n\t      var comparator = last(arrays);\n\t      if (isArrayLikeObject(comparator)) {\n\t        comparator = undefined;\n\t      }\n\t      return baseUniq(baseFlatten(arrays, false, true), undefined, comparator);\n\t    });\n\t\n\t    /**\n\t     * Creates a duplicate-free version of an array, using\n\t     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)\n\t     * for equality comparisons, in which only the first occurrence of each element\n\t     * is kept.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {Array} array The array to inspect.\n\t     * @returns {Array} Returns the new duplicate free array.\n\t     * @example\n\t     *\n\t     * _.uniq([2, 1, 2]);\n\t     * // => [2, 1]\n\t     */\n\t    function uniq(array) {\n\t      return (array && array.length)\n\t        ? baseUniq(array)\n\t        : [];\n\t    }\n\t\n\t    /**\n\t     * This method is like `_.uniq` except that it accepts `iteratee` which is\n\t     * invoked for each element in `array` to generate the criterion by which\n\t     * uniqueness is computed. The iteratee is invoked with one argument: (value).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {Array} array The array to inspect.\n\t     * @param {Function|Object|string} [iteratee=_.identity] The iteratee invoked per element.\n\t     * @returns {Array} Returns the new duplicate free array.\n\t     * @example\n\t     *\n\t     * _.uniqBy([2.1, 1.2, 2.3], Math.floor);\n\t     * // => [2.1, 1.2]\n\t     *\n\t     * // using the `_.property` iteratee shorthand\n\t     * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');\n\t     * // => [{ 'x': 1 }, { 'x': 2 }]\n\t     */\n\t    function uniqBy(array, iteratee) {\n\t      return (array && array.length)\n\t        ? baseUniq(array, getIteratee(iteratee))\n\t        : [];\n\t    }\n\t\n\t    /**\n\t     * This method is like `_.uniq` except that it accepts `comparator` which\n\t     * is invoked to compare elements of `array`. The comparator is invoked with\n\t     * two arguments: (arrVal, othVal).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {Array} array The array to inspect.\n\t     * @param {Function} [comparator] The comparator invoked per element.\n\t     * @returns {Array} Returns the new duplicate free array.\n\t     * @example\n\t     *\n\t     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 },  { 'x': 1, 'y': 2 }];\n\t     *\n\t     * _.uniqWith(objects, _.isEqual);\n\t     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]\n\t     */\n\t    function uniqWith(array, comparator) {\n\t      return (array && array.length)\n\t        ? baseUniq(array, undefined, comparator)\n\t        : [];\n\t    }\n\t\n\t    /**\n\t     * This method is like `_.zip` except that it accepts an array of grouped\n\t     * elements and creates an array regrouping the elements to their pre-zip\n\t     * configuration.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {Array} array The array of grouped elements to process.\n\t     * @returns {Array} Returns the new array of regrouped elements.\n\t     * @example\n\t     *\n\t     * var zipped = _.zip(['fred', 'barney'], [30, 40], [true, false]);\n\t     * // => [['fred', 30, true], ['barney', 40, false]]\n\t     *\n\t     * _.unzip(zipped);\n\t     * // => [['fred', 'barney'], [30, 40], [true, false]]\n\t     */\n\t    function unzip(array) {\n\t      if (!(array && array.length)) {\n\t        return [];\n\t      }\n\t      var length = 0;\n\t      array = arrayFilter(array, function(group) {\n\t        if (isArrayLikeObject(group)) {\n\t          length = nativeMax(group.length, length);\n\t          return true;\n\t        }\n\t      });\n\t      return baseTimes(length, function(index) {\n\t        return arrayMap(array, baseProperty(index));\n\t      });\n\t    }\n\t\n\t    /**\n\t     * This method is like `_.unzip` except that it accepts `iteratee` to specify\n\t     * how regrouped values should be combined. The iteratee is invoked with the\n\t     * elements of each group: (...group).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {Array} array The array of grouped elements to process.\n\t     * @param {Function} [iteratee=_.identity] The function to combine regrouped values.\n\t     * @returns {Array} Returns the new array of regrouped elements.\n\t     * @example\n\t     *\n\t     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);\n\t     * // => [[1, 10, 100], [2, 20, 200]]\n\t     *\n\t     * _.unzipWith(zipped, _.add);\n\t     * // => [3, 30, 300]\n\t     */\n\t    function unzipWith(array, iteratee) {\n\t      if (!(array && array.length)) {\n\t        return [];\n\t      }\n\t      var result = unzip(array);\n\t      if (iteratee == null) {\n\t        return result;\n\t      }\n\t      return arrayMap(result, function(group) {\n\t        return apply(iteratee, undefined, group);\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Creates an array excluding all provided values using\n\t     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)\n\t     * for equality comparisons.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {Array} array The array to filter.\n\t     * @param {...*} [values] The values to exclude.\n\t     * @returns {Array} Returns the new array of filtered values.\n\t     * @example\n\t     *\n\t     * _.without([1, 2, 1, 3], 1, 2);\n\t     * // => [3]\n\t     */\n\t    var without = rest(function(array, values) {\n\t      return isArrayLikeObject(array)\n\t        ? baseDifference(array, values)\n\t        : [];\n\t    });\n\t\n\t    /**\n\t     * Creates an array of unique values that is the [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)\n\t     * of the provided arrays.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {...Array} [arrays] The arrays to inspect.\n\t     * @returns {Array} Returns the new array of values.\n\t     * @example\n\t     *\n\t     * _.xor([2, 1], [4, 2]);\n\t     * // => [1, 4]\n\t     */\n\t    var xor = rest(function(arrays) {\n\t      return baseXor(arrayFilter(arrays, isArrayLikeObject));\n\t    });\n\t\n\t    /**\n\t     * This method is like `_.xor` except that it accepts `iteratee` which is\n\t     * invoked for each element of each `arrays` to generate the criterion by which\n\t     * uniqueness is computed. The iteratee is invoked with one argument: (value).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {...Array} [arrays] The arrays to inspect.\n\t     * @param {Function|Object|string} [iteratee=_.identity] The iteratee invoked per element.\n\t     * @returns {Array} Returns the new array of values.\n\t     * @example\n\t     *\n\t     * _.xorBy([2.1, 1.2], [4.3, 2.4], Math.floor);\n\t     * // => [1.2, 4.3]\n\t     *\n\t     * // using the `_.property` iteratee shorthand\n\t     * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');\n\t     * // => [{ 'x': 2 }]\n\t     */\n\t    var xorBy = rest(function(arrays) {\n\t      var iteratee = last(arrays);\n\t      if (isArrayLikeObject(iteratee)) {\n\t        iteratee = undefined;\n\t      }\n\t      return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee));\n\t    });\n\t\n\t    /**\n\t     * This method is like `_.xor` except that it accepts `comparator` which is\n\t     * invoked to compare elements of `arrays`. The comparator is invoked with\n\t     * two arguments: (arrVal, othVal).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {...Array} [arrays] The arrays to inspect.\n\t     * @param {Function} [comparator] The comparator invoked per element.\n\t     * @returns {Array} Returns the new array of values.\n\t     * @example\n\t     *\n\t     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\n\t     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];\n\t     *\n\t     * _.xorWith(objects, others, _.isEqual);\n\t     * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]\n\t     */\n\t    var xorWith = rest(function(arrays) {\n\t      var comparator = last(arrays);\n\t      if (isArrayLikeObject(comparator)) {\n\t        comparator = undefined;\n\t      }\n\t      return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator);\n\t    });\n\t\n\t    /**\n\t     * Creates an array of grouped elements, the first of which contains the first\n\t     * elements of the given arrays, the second of which contains the second elements\n\t     * of the given arrays, and so on.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {...Array} [arrays] The arrays to process.\n\t     * @returns {Array} Returns the new array of grouped elements.\n\t     * @example\n\t     *\n\t     * _.zip(['fred', 'barney'], [30, 40], [true, false]);\n\t     * // => [['fred', 30, true], ['barney', 40, false]]\n\t     */\n\t    var zip = rest(unzip);\n\t\n\t    /**\n\t     * This method is like `_.fromPairs` except that it accepts two arrays,\n\t     * one of property names and one of corresponding values.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {Array} [props=[]] The property names.\n\t     * @param {Array} [values=[]] The property values.\n\t     * @returns {Object} Returns the new object.\n\t     * @example\n\t     *\n\t     * _.zipObject(['fred', 'barney'], [30, 40]);\n\t     * // => { 'fred': 30, 'barney': 40 }\n\t     */\n\t    function zipObject(props, values) {\n\t      var index = -1,\n\t          length = props ? props.length : 0,\n\t          valsLength = values ? values.length : 0,\n\t          result = {};\n\t\n\t      while (++index < length) {\n\t        baseSet(result, props[index], index < valsLength ? values[index] : undefined);\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * This method is like `_.zip` except that it accepts `iteratee` to specify\n\t     * how grouped values should be combined. The iteratee is invoked with the\n\t     * elements of each group: (...group).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Array\n\t     * @param {...Array} [arrays] The arrays to process.\n\t     * @param {Function} [iteratee=_.identity] The function to combine grouped values.\n\t     * @returns {Array} Returns the new array of grouped elements.\n\t     * @example\n\t     *\n\t     * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {\n\t     *   return a + b + c;\n\t     * });\n\t     * // => [111, 222]\n\t     */\n\t    var zipWith = rest(function(arrays) {\n\t      var length = arrays.length,\n\t          iteratee = length > 1 ? arrays[length - 1] : undefined;\n\t\n\t      iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined;\n\t      return unzipWith(arrays, iteratee);\n\t    });\n\t\n\t    /*------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * Creates a `lodash` object that wraps `value` with explicit method chaining enabled.\n\t     * The result of such method chaining must be unwrapped with `_#value`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Seq\n\t     * @param {*} value The value to wrap.\n\t     * @returns {Object} Returns the new `lodash` wrapper instance.\n\t     * @example\n\t     *\n\t     * var users = [\n\t     *   { 'user': 'barney',  'age': 36 },\n\t     *   { 'user': 'fred',    'age': 40 },\n\t     *   { 'user': 'pebbles', 'age': 1 }\n\t     * ];\n\t     *\n\t     * var youngest = _\n\t     *   .chain(users)\n\t     *   .sortBy('age')\n\t     *   .map(function(o) {\n\t     *     return o.user + ' is ' + o.age;\n\t     *   })\n\t     *   .head()\n\t     *   .value();\n\t     * // => 'pebbles is 1'\n\t     */\n\t    function chain(value) {\n\t      var result = lodash(value);\n\t      result.__chain__ = true;\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * This method invokes `interceptor` and returns `value`. The interceptor is\n\t     * invoked with one argument; (value). The purpose of this method is to \"tap into\"\n\t     * a method chain in order to perform operations on intermediate results within\n\t     * the chain.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Seq\n\t     * @param {*} value The value to provide to `interceptor`.\n\t     * @param {Function} interceptor The function to invoke.\n\t     * @returns {*} Returns `value`.\n\t     * @example\n\t     *\n\t     * _([1, 2, 3])\n\t     *  .tap(function(array) {\n\t     *    array.pop();\n\t     *  })\n\t     *  .reverse()\n\t     *  .value();\n\t     * // => [2, 1]\n\t     */\n\t    function tap(value, interceptor) {\n\t      interceptor(value);\n\t      return value;\n\t    }\n\t\n\t    /**\n\t     * This method is like `_.tap` except that it returns the result of `interceptor`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Seq\n\t     * @param {*} value The value to provide to `interceptor`.\n\t     * @param {Function} interceptor The function to invoke.\n\t     * @returns {*} Returns the result of `interceptor`.\n\t     * @example\n\t     *\n\t     * _('  abc  ')\n\t     *  .chain()\n\t     *  .trim()\n\t     *  .thru(function(value) {\n\t     *    return [value];\n\t     *  })\n\t     *  .value();\n\t     * // => ['abc']\n\t     */\n\t    function thru(value, interceptor) {\n\t      return interceptor(value);\n\t    }\n\t\n\t    /**\n\t     * This method is the wrapper version of `_.at`.\n\t     *\n\t     * @name at\n\t     * @memberOf _\n\t     * @category Seq\n\t     * @param {...(string|string[])} [paths] The property paths of elements to pick,\n\t     *  specified individually or in arrays.\n\t     * @returns {Object} Returns the new `lodash` wrapper instance.\n\t     * @example\n\t     *\n\t     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };\n\t     *\n\t     * _(object).at(['a[0].b.c', 'a[1]']).value();\n\t     * // => [3, 4]\n\t     *\n\t     * _(['a', 'b', 'c']).at(0, 2).value();\n\t     * // => ['a', 'c']\n\t     */\n\t    var wrapperAt = rest(function(paths) {\n\t      paths = baseFlatten(paths);\n\t      var length = paths.length,\n\t          start = length ? paths[0] : 0,\n\t          value = this.__wrapped__,\n\t          interceptor = function(object) { return baseAt(object, paths); };\n\t\n\t      if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {\n\t        return this.thru(interceptor);\n\t      }\n\t      value = value.slice(start, +start + (length ? 1 : 0));\n\t      value.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined });\n\t      return new LodashWrapper(value, this.__chain__).thru(function(array) {\n\t        if (length && !array.length) {\n\t          array.push(undefined);\n\t        }\n\t        return array;\n\t      });\n\t    });\n\t\n\t    /**\n\t     * Enables explicit method chaining on the wrapper object.\n\t     *\n\t     * @name chain\n\t     * @memberOf _\n\t     * @category Seq\n\t     * @returns {Object} Returns the new `lodash` wrapper instance.\n\t     * @example\n\t     *\n\t     * var users = [\n\t     *   { 'user': 'barney', 'age': 36 },\n\t     *   { 'user': 'fred',   'age': 40 }\n\t     * ];\n\t     *\n\t     * // without explicit chaining\n\t     * _(users).head();\n\t     * // => { 'user': 'barney', 'age': 36 }\n\t     *\n\t     * // with explicit chaining\n\t     * _(users)\n\t     *   .chain()\n\t     *   .head()\n\t     *   .pick('user')\n\t     *   .value();\n\t     * // => { 'user': 'barney' }\n\t     */\n\t    function wrapperChain() {\n\t      return chain(this);\n\t    }\n\t\n\t    /**\n\t     * Executes the chained sequence and returns the wrapped result.\n\t     *\n\t     * @name commit\n\t     * @memberOf _\n\t     * @category Seq\n\t     * @returns {Object} Returns the new `lodash` wrapper instance.\n\t     * @example\n\t     *\n\t     * var array = [1, 2];\n\t     * var wrapped = _(array).push(3);\n\t     *\n\t     * console.log(array);\n\t     * // => [1, 2]\n\t     *\n\t     * wrapped = wrapped.commit();\n\t     * console.log(array);\n\t     * // => [1, 2, 3]\n\t     *\n\t     * wrapped.last();\n\t     * // => 3\n\t     *\n\t     * console.log(array);\n\t     * // => [1, 2, 3]\n\t     */\n\t    function wrapperCommit() {\n\t      return new LodashWrapper(this.value(), this.__chain__);\n\t    }\n\t\n\t    /**\n\t     * This method is the wrapper version of `_.flatMap`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Seq\n\t     * @param {Function|Object|string} [iteratee=_.identity] The function invoked per iteration.\n\t     * @returns {Object} Returns the new `lodash` wrapper instance.\n\t     * @example\n\t     *\n\t     * function duplicate(n) {\n\t     *   return [n, n];\n\t     * }\n\t     *\n\t     * _([1, 2]).flatMap(duplicate).value();\n\t     * // => [1, 1, 2, 2]\n\t     */\n\t    function wrapperFlatMap(iteratee) {\n\t      return this.map(iteratee).flatten();\n\t    }\n\t\n\t    /**\n\t     * Gets the next value on a wrapped object following the\n\t     * [iterator protocol](https://mdn.io/iteration_protocols#iterator).\n\t     *\n\t     * @name next\n\t     * @memberOf _\n\t     * @category Seq\n\t     * @returns {Object} Returns the next iterator value.\n\t     * @example\n\t     *\n\t     * var wrapped = _([1, 2]);\n\t     *\n\t     * wrapped.next();\n\t     * // => { 'done': false, 'value': 1 }\n\t     *\n\t     * wrapped.next();\n\t     * // => { 'done': false, 'value': 2 }\n\t     *\n\t     * wrapped.next();\n\t     * // => { 'done': true, 'value': undefined }\n\t     */\n\t    function wrapperNext() {\n\t      if (this.__values__ === undefined) {\n\t        this.__values__ = toArray(this.value());\n\t      }\n\t      var done = this.__index__ >= this.__values__.length,\n\t          value = done ? undefined : this.__values__[this.__index__++];\n\t\n\t      return { 'done': done, 'value': value };\n\t    }\n\t\n\t    /**\n\t     * Enables the wrapper to be iterable.\n\t     *\n\t     * @name Symbol.iterator\n\t     * @memberOf _\n\t     * @category Seq\n\t     * @returns {Object} Returns the wrapper object.\n\t     * @example\n\t     *\n\t     * var wrapped = _([1, 2]);\n\t     *\n\t     * wrapped[Symbol.iterator]() === wrapped;\n\t     * // => true\n\t     *\n\t     * Array.from(wrapped);\n\t     * // => [1, 2]\n\t     */\n\t    function wrapperToIterator() {\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * Creates a clone of the chained sequence planting `value` as the wrapped value.\n\t     *\n\t     * @name plant\n\t     * @memberOf _\n\t     * @category Seq\n\t     * @param {*} value The value to plant.\n\t     * @returns {Object} Returns the new `lodash` wrapper instance.\n\t     * @example\n\t     *\n\t     * function square(n) {\n\t     *   return n * n;\n\t     * }\n\t     *\n\t     * var wrapped = _([1, 2]).map(square);\n\t     * var other = wrapped.plant([3, 4]);\n\t     *\n\t     * other.value();\n\t     * // => [9, 16]\n\t     *\n\t     * wrapped.value();\n\t     * // => [1, 4]\n\t     */\n\t    function wrapperPlant(value) {\n\t      var result,\n\t          parent = this;\n\t\n\t      while (parent instanceof baseLodash) {\n\t        var clone = wrapperClone(parent);\n\t        clone.__index__ = 0;\n\t        clone.__values__ = undefined;\n\t        if (result) {\n\t          previous.__wrapped__ = clone;\n\t        } else {\n\t          result = clone;\n\t        }\n\t        var previous = clone;\n\t        parent = parent.__wrapped__;\n\t      }\n\t      previous.__wrapped__ = value;\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * This method is the wrapper version of `_.reverse`.\n\t     *\n\t     * **Note:** This method mutates the wrapped array.\n\t     *\n\t     * @name reverse\n\t     * @memberOf _\n\t     * @category Seq\n\t     * @returns {Object} Returns the new `lodash` wrapper instance.\n\t     * @example\n\t     *\n\t     * var array = [1, 2, 3];\n\t     *\n\t     * _(array).reverse().value()\n\t     * // => [3, 2, 1]\n\t     *\n\t     * console.log(array);\n\t     * // => [3, 2, 1]\n\t     */\n\t    function wrapperReverse() {\n\t      var value = this.__wrapped__;\n\t      if (value instanceof LazyWrapper) {\n\t        var wrapped = value;\n\t        if (this.__actions__.length) {\n\t          wrapped = new LazyWrapper(this);\n\t        }\n\t        wrapped = wrapped.reverse();\n\t        wrapped.__actions__.push({ 'func': thru, 'args': [reverse], 'thisArg': undefined });\n\t        return new LodashWrapper(wrapped, this.__chain__);\n\t      }\n\t      return this.thru(reverse);\n\t    }\n\t\n\t    /**\n\t     * Executes the chained sequence to extract the unwrapped value.\n\t     *\n\t     * @name value\n\t     * @memberOf _\n\t     * @alias run, toJSON, valueOf\n\t     * @category Seq\n\t     * @returns {*} Returns the resolved unwrapped value.\n\t     * @example\n\t     *\n\t     * _([1, 2, 3]).value();\n\t     * // => [1, 2, 3]\n\t     */\n\t    function wrapperValue() {\n\t      return baseWrapperValue(this.__wrapped__, this.__actions__);\n\t    }\n\t\n\t    /*------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * Creates an object composed of keys generated from the results of running\n\t     * each element of `collection` through `iteratee`. The corresponding value\n\t     * of each key is the number of times the key was returned by `iteratee`.\n\t     * The iteratee is invoked with one argument: (value).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Collection\n\t     * @param {Array|Object} collection The collection to iterate over.\n\t     * @param {Function|Object|string} [iteratee=_.identity] The iteratee invoked per element.\n\t     * @returns {Object} Returns the composed aggregate object.\n\t     * @example\n\t     *\n\t     * _.countBy([6.1, 4.2, 6.3], Math.floor);\n\t     * // => { '4': 1, '6': 2 }\n\t     *\n\t     * _.countBy(['one', 'two', 'three'], 'length');\n\t     * // => { '3': 2, '5': 1 }\n\t     */\n\t    var countBy = createAggregator(function(result, value, key) {\n\t      hasOwnProperty.call(result, key) ? ++result[key] : (result[key] = 1);\n\t    });\n\t\n\t    /**\n\t     * Checks if `predicate` returns truthy for **all** elements of `collection`.\n\t     * Iteration is stopped once `predicate` returns falsey. The predicate is\n\t     * invoked with three arguments: (value, index|key, collection).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Collection\n\t     * @param {Array|Object} collection The collection to iterate over.\n\t     * @param {Function|Object|string} [predicate=_.identity] The function invoked per iteration.\n\t     * @param- {Object} [guard] Enables use as an iteratee for functions like `_.map`.\n\t     * @returns {boolean} Returns `true` if all elements pass the predicate check, else `false`.\n\t     * @example\n\t     *\n\t     * _.every([true, 1, null, 'yes'], Boolean);\n\t     * // => false\n\t     *\n\t     * var users = [\n\t     *   { 'user': 'barney', 'active': false },\n\t     *   { 'user': 'fred',   'active': false }\n\t     * ];\n\t     *\n\t     * // using the `_.matches` iteratee shorthand\n\t     * _.every(users, { 'user': 'barney', 'active': false });\n\t     * // => false\n\t     *\n\t     * // using the `_.matchesProperty` iteratee shorthand\n\t     * _.every(users, ['active', false]);\n\t     * // => true\n\t     *\n\t     * // using the `_.property` iteratee shorthand\n\t     * _.every(users, 'active');\n\t     * // => false\n\t     */\n\t    function every(collection, predicate, guard) {\n\t      var func = isArray(collection) ? arrayEvery : baseEvery;\n\t      if (guard && isIterateeCall(collection, predicate, guard)) {\n\t        predicate = undefined;\n\t      }\n\t      return func(collection, getIteratee(predicate, 3));\n\t    }\n\t\n\t    /**\n\t     * Iterates over elements of `collection`, returning an array of all elements\n\t     * `predicate` returns truthy for. The predicate is invoked with three arguments:\n\t     * (value, index|key, collection).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Collection\n\t     * @param {Array|Object} collection The collection to iterate over.\n\t     * @param {Function|Object|string} [predicate=_.identity] The function invoked per iteration.\n\t     * @returns {Array} Returns the new filtered array.\n\t     * @example\n\t     *\n\t     * var users = [\n\t     *   { 'user': 'barney', 'age': 36, 'active': true },\n\t     *   { 'user': 'fred',   'age': 40, 'active': false }\n\t     * ];\n\t     *\n\t     * _.filter(users, function(o) { return !o.active; });\n\t     * // => objects for ['fred']\n\t     *\n\t     * // using the `_.matches` iteratee shorthand\n\t     * _.filter(users, { 'age': 36, 'active': true });\n\t     * // => objects for ['barney']\n\t     *\n\t     * // using the `_.matchesProperty` iteratee shorthand\n\t     * _.filter(users, ['active', false]);\n\t     * // => objects for ['fred']\n\t     *\n\t     * // using the `_.property` iteratee shorthand\n\t     * _.filter(users, 'active');\n\t     * // => objects for ['barney']\n\t     */\n\t    function filter(collection, predicate) {\n\t      var func = isArray(collection) ? arrayFilter : baseFilter;\n\t      return func(collection, getIteratee(predicate, 3));\n\t    }\n\t\n\t    /**\n\t     * Iterates over elements of `collection`, returning the first element\n\t     * `predicate` returns truthy for. The predicate is invoked with three arguments:\n\t     * (value, index|key, collection).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Collection\n\t     * @param {Array|Object} collection The collection to search.\n\t     * @param {Function|Object|string} [predicate=_.identity] The function invoked per iteration.\n\t     * @returns {*} Returns the matched element, else `undefined`.\n\t     * @example\n\t     *\n\t     * var users = [\n\t     *   { 'user': 'barney',  'age': 36, 'active': true },\n\t     *   { 'user': 'fred',    'age': 40, 'active': false },\n\t     *   { 'user': 'pebbles', 'age': 1,  'active': true }\n\t     * ];\n\t     *\n\t     * _.find(users, function(o) { return o.age < 40; });\n\t     * // => object for 'barney'\n\t     *\n\t     * // using the `_.matches` iteratee shorthand\n\t     * _.find(users, { 'age': 1, 'active': true });\n\t     * // => object for 'pebbles'\n\t     *\n\t     * // using the `_.matchesProperty` iteratee shorthand\n\t     * _.find(users, ['active', false]);\n\t     * // => object for 'fred'\n\t     *\n\t     * // using the `_.property` iteratee shorthand\n\t     * _.find(users, 'active');\n\t     * // => object for 'barney'\n\t     */\n\t    function find(collection, predicate) {\n\t      predicate = getIteratee(predicate, 3);\n\t      if (isArray(collection)) {\n\t        var index = baseFindIndex(collection, predicate);\n\t        return index > -1 ? collection[index] : undefined;\n\t      }\n\t      return baseFind(collection, predicate, baseEach);\n\t    }\n\t\n\t    /**\n\t     * This method is like `_.find` except that it iterates over elements of\n\t     * `collection` from right to left.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Collection\n\t     * @param {Array|Object} collection The collection to search.\n\t     * @param {Function|Object|string} [predicate=_.identity] The function invoked per iteration.\n\t     * @returns {*} Returns the matched element, else `undefined`.\n\t     * @example\n\t     *\n\t     * _.findLast([1, 2, 3, 4], function(n) {\n\t     *   return n % 2 == 1;\n\t     * });\n\t     * // => 3\n\t     */\n\t    function findLast(collection, predicate) {\n\t      predicate = getIteratee(predicate, 3);\n\t      if (isArray(collection)) {\n\t        var index = baseFindIndex(collection, predicate, true);\n\t        return index > -1 ? collection[index] : undefined;\n\t      }\n\t      return baseFind(collection, predicate, baseEachRight);\n\t    }\n\t\n\t    /**\n\t     * Iterates over elements of `collection` invoking `iteratee` for each element.\n\t     * The iteratee is invoked with three arguments: (value, index|key, collection).\n\t     * Iteratee functions may exit iteration early by explicitly returning `false`.\n\t     *\n\t     * **Note:** As with other \"Collections\" methods, objects with a \"length\" property\n\t     * are iterated like arrays. To avoid this behavior use `_.forIn` or `_.forOwn`\n\t     * for object iteration.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @alias each\n\t     * @category Collection\n\t     * @param {Array|Object} collection The collection to iterate over.\n\t     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n\t     * @returns {Array|Object} Returns `collection`.\n\t     * @example\n\t     *\n\t     * _([1, 2]).forEach(function(value) {\n\t     *   console.log(value);\n\t     * });\n\t     * // => logs `1` then `2`\n\t     *\n\t     * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {\n\t     *   console.log(key);\n\t     * });\n\t     * // => logs 'a' then 'b' (iteration order is not guaranteed)\n\t     */\n\t    function forEach(collection, iteratee) {\n\t      return (typeof iteratee == 'function' && isArray(collection))\n\t        ? arrayEach(collection, iteratee)\n\t        : baseEach(collection, toFunction(iteratee));\n\t    }\n\t\n\t    /**\n\t     * This method is like `_.forEach` except that it iterates over elements of\n\t     * `collection` from right to left.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @alias eachRight\n\t     * @category Collection\n\t     * @param {Array|Object} collection The collection to iterate over.\n\t     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n\t     * @returns {Array|Object} Returns `collection`.\n\t     * @example\n\t     *\n\t     * _.forEachRight([1, 2], function(value) {\n\t     *   console.log(value);\n\t     * });\n\t     * // => logs `2` then `1`\n\t     */\n\t    function forEachRight(collection, iteratee) {\n\t      return (typeof iteratee == 'function' && isArray(collection))\n\t        ? arrayEachRight(collection, iteratee)\n\t        : baseEachRight(collection, toFunction(iteratee));\n\t    }\n\t\n\t    /**\n\t     * Creates an object composed of keys generated from the results of running\n\t     * each element of `collection` through `iteratee`. The corresponding value\n\t     * of each key is an array of the elements responsible for generating the key.\n\t     * The iteratee is invoked with one argument: (value).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Collection\n\t     * @param {Array|Object} collection The collection to iterate over.\n\t     * @param {Function|Object|string} [iteratee=_.identity] The iteratee invoked per element.\n\t     * @returns {Object} Returns the composed aggregate object.\n\t     * @example\n\t     *\n\t     * _.groupBy([6.1, 4.2, 6.3], Math.floor);\n\t     * // => { '4': [4.2], '6': [6.1, 6.3] }\n\t     *\n\t     * // using the `_.property` iteratee shorthand\n\t     * _.groupBy(['one', 'two', 'three'], 'length');\n\t     * // => { '3': ['one', 'two'], '5': ['three'] }\n\t     */\n\t    var groupBy = createAggregator(function(result, value, key) {\n\t      if (hasOwnProperty.call(result, key)) {\n\t        result[key].push(value);\n\t      } else {\n\t        result[key] = [value];\n\t      }\n\t    });\n\t\n\t    /**\n\t     * Checks if `value` is in `collection`. If `collection` is a string it's checked\n\t     * for a substring of `value`, otherwise [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)\n\t     * is used for equality comparisons. If `fromIndex` is negative, it's used as\n\t     * the offset from the end of `collection`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Collection\n\t     * @param {Array|Object|string} collection The collection to search.\n\t     * @param {*} value The value to search for.\n\t     * @param {number} [fromIndex=0] The index to search from.\n\t     * @param- {Object} [guard] Enables use as an iteratee for functions like `_.reduce`.\n\t     * @returns {boolean} Returns `true` if `value` is found, else `false`.\n\t     * @example\n\t     *\n\t     * _.includes([1, 2, 3], 1);\n\t     * // => true\n\t     *\n\t     * _.includes([1, 2, 3], 1, 2);\n\t     * // => false\n\t     *\n\t     * _.includes({ 'user': 'fred', 'age': 40 }, 'fred');\n\t     * // => true\n\t     *\n\t     * _.includes('pebbles', 'eb');\n\t     * // => true\n\t     */\n\t    function includes(collection, value, fromIndex, guard) {\n\t      collection = isArrayLike(collection) ? collection : values(collection);\n\t      fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;\n\t\n\t      var length = collection.length;\n\t      if (fromIndex < 0) {\n\t        fromIndex = nativeMax(length + fromIndex, 0);\n\t      }\n\t      return isString(collection)\n\t        ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)\n\t        : (!!length && baseIndexOf(collection, value, fromIndex) > -1);\n\t    }\n\t\n\t    /**\n\t     * Invokes the method at `path` of each element in `collection`, returning\n\t     * an array of the results of each invoked method. Any additional arguments\n\t     * are provided to each invoked method. If `methodName` is a function it's\n\t     * invoked for, and `this` bound to, each element in `collection`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Collection\n\t     * @param {Array|Object} collection The collection to iterate over.\n\t     * @param {Array|Function|string} path The path of the method to invoke or\n\t     *  the function invoked per iteration.\n\t     * @param {...*} [args] The arguments to invoke each method with.\n\t     * @returns {Array} Returns the array of results.\n\t     * @example\n\t     *\n\t     * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');\n\t     * // => [[1, 5, 7], [1, 2, 3]]\n\t     *\n\t     * _.invokeMap([123, 456], String.prototype.split, '');\n\t     * // => [['1', '2', '3'], ['4', '5', '6']]\n\t     */\n\t    var invokeMap = rest(function(collection, path, args) {\n\t      var index = -1,\n\t          isFunc = typeof path == 'function',\n\t          isProp = isKey(path),\n\t          result = isArrayLike(collection) ? Array(collection.length) : [];\n\t\n\t      baseEach(collection, function(value) {\n\t        var func = isFunc ? path : ((isProp && value != null) ? value[path] : undefined);\n\t        result[++index] = func ? apply(func, value, args) : baseInvoke(value, path, args);\n\t      });\n\t      return result;\n\t    });\n\t\n\t    /**\n\t     * Creates an object composed of keys generated from the results of running\n\t     * each element of `collection` through `iteratee`. The corresponding value\n\t     * of each key is the last element responsible for generating the key. The\n\t     * iteratee is invoked with one argument: (value).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Collection\n\t     * @param {Array|Object} collection The collection to iterate over.\n\t     * @param {Function|Object|string} [iteratee=_.identity] The iteratee invoked per element.\n\t     * @returns {Object} Returns the composed aggregate object.\n\t     * @example\n\t     *\n\t     * var keyData = [\n\t     *   { 'dir': 'left', 'code': 97 },\n\t     *   { 'dir': 'right', 'code': 100 }\n\t     * ];\n\t     *\n\t     * _.keyBy(keyData, 'dir');\n\t     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }\n\t     *\n\t     * _.keyBy(keyData, function(o) {\n\t     *   return String.fromCharCode(o.code);\n\t     * });\n\t     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }\n\t     */\n\t    var keyBy = createAggregator(function(result, value, key) {\n\t      result[key] = value;\n\t    });\n\t\n\t    /**\n\t     * Creates an array of values by running each element in `collection` through\n\t     * `iteratee`. The iteratee is invoked with three arguments:\n\t     * (value, index|key, collection).\n\t     *\n\t     * Many lodash methods are guarded to work as iteratees for methods like\n\t     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.\n\t     *\n\t     * The guarded methods are:\n\t     * `ary`, `curry`, `curryRight`, `drop`, `dropRight`, `every`, `fill`,\n\t     * `invert`, `parseInt`, `random`, `range`, `rangeRight`, `slice`, `some`,\n\t     * `sortBy`, `take`, `takeRight`, `template`, `trim`, `trimEnd`, `trimStart`,\n\t     * and `words`\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Collection\n\t     * @param {Array|Object} collection The collection to iterate over.\n\t     * @param {Function|Object|string} [iteratee=_.identity] The function invoked per iteration.\n\t     * @returns {Array} Returns the new mapped array.\n\t     * @example\n\t     *\n\t     * function square(n) {\n\t     *   return n * n;\n\t     * }\n\t     *\n\t     * _.map([1, 2], square);\n\t     * // => [3, 6]\n\t     *\n\t     * _.map({ 'a': 1, 'b': 2 }, square);\n\t     * // => [3, 6] (iteration order is not guaranteed)\n\t     *\n\t     * var users = [\n\t     *   { 'user': 'barney' },\n\t     *   { 'user': 'fred' }\n\t     * ];\n\t     *\n\t     * // using the `_.property` iteratee shorthand\n\t     * _.map(users, 'user');\n\t     * // => ['barney', 'fred']\n\t     */\n\t    function map(collection, iteratee) {\n\t      var func = isArray(collection) ? arrayMap : baseMap;\n\t      return func(collection, getIteratee(iteratee, 3));\n\t    }\n\t\n\t    /**\n\t     * This method is like `_.sortBy` except that it allows specifying the sort\n\t     * orders of the iteratees to sort by. If `orders` is unspecified, all values\n\t     * are sorted in ascending order. Otherwise, specify an order of \"desc\" for\n\t     * descending or \"asc\" for ascending sort order of corresponding values.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Collection\n\t     * @param {Array|Object} collection The collection to iterate over.\n\t     * @param {Function[]|Object[]|string[]} [iteratees=[_.identity]] The iteratees to sort by.\n\t     * @param {string[]} [orders] The sort orders of `iteratees`.\n\t     * @param- {Object} [guard] Enables use as an iteratee for functions like `_.reduce`.\n\t     * @returns {Array} Returns the new sorted array.\n\t     * @example\n\t     *\n\t     * var users = [\n\t     *   { 'user': 'fred',   'age': 48 },\n\t     *   { 'user': 'barney', 'age': 34 },\n\t     *   { 'user': 'fred',   'age': 42 },\n\t     *   { 'user': 'barney', 'age': 36 }\n\t     * ];\n\t     *\n\t     * // sort by `user` in ascending order and by `age` in descending order\n\t     * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);\n\t     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 42]]\n\t     */\n\t    function orderBy(collection, iteratees, orders, guard) {\n\t      if (collection == null) {\n\t        return [];\n\t      }\n\t      if (!isArray(iteratees)) {\n\t        iteratees = iteratees == null ? [] : [iteratees];\n\t      }\n\t      orders = guard ? undefined : orders;\n\t      if (!isArray(orders)) {\n\t        orders = orders == null ? [] : [orders];\n\t      }\n\t      return baseOrderBy(collection, iteratees, orders);\n\t    }\n\t\n\t    /**\n\t     * Creates an array of elements split into two groups, the first of which\n\t     * contains elements `predicate` returns truthy for, while the second of which\n\t     * contains elements `predicate` returns falsey for. The predicate is invoked\n\t     * with three arguments: (value, index|key, collection).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Collection\n\t     * @param {Array|Object} collection The collection to iterate over.\n\t     * @param {Function|Object|string} [predicate=_.identity] The function invoked per iteration.\n\t     * @returns {Array} Returns the array of grouped elements.\n\t     * @example\n\t     *\n\t     * var users = [\n\t     *   { 'user': 'barney',  'age': 36, 'active': false },\n\t     *   { 'user': 'fred',    'age': 40, 'active': true },\n\t     *   { 'user': 'pebbles', 'age': 1,  'active': false }\n\t     * ];\n\t     *\n\t     * _.partition(users, function(o) { return o.active; });\n\t     * // => objects for [['fred'], ['barney', 'pebbles']]\n\t     *\n\t     * // using the `_.matches` iteratee shorthand\n\t     * _.partition(users, { 'age': 1, 'active': false });\n\t     * // => objects for [['pebbles'], ['barney', 'fred']]\n\t     *\n\t     * // using the `_.matchesProperty` iteratee shorthand\n\t     * _.partition(users, ['active', false]);\n\t     * // => objects for [['barney', 'pebbles'], ['fred']]\n\t     *\n\t     * // using the `_.property` iteratee shorthand\n\t     * _.partition(users, 'active');\n\t     * // => objects for [['fred'], ['barney', 'pebbles']]\n\t     */\n\t    var partition = createAggregator(function(result, value, key) {\n\t      result[key ? 0 : 1].push(value);\n\t    }, function() { return [[], []]; });\n\t\n\t    /**\n\t     * Reduces `collection` to a value which is the accumulated result of running\n\t     * each element in `collection` through `iteratee`, where each successive\n\t     * invocation is supplied the return value of the previous. If `accumulator`\n\t     * is not provided the first element of `collection` is used as the initial\n\t     * value. The iteratee is invoked with four arguments:\n\t     * (accumulator, value, index|key, collection).\n\t     *\n\t     * Many lodash methods are guarded to work as iteratees for methods like\n\t     * `_.reduce`, `_.reduceRight`, and `_.transform`.\n\t     *\n\t     * The guarded methods are:\n\t     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,\n\t     * and `sortBy`\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Collection\n\t     * @param {Array|Object} collection The collection to iterate over.\n\t     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n\t     * @param {*} [accumulator] The initial value.\n\t     * @returns {*} Returns the accumulated value.\n\t     * @example\n\t     *\n\t     * _.reduce([1, 2], function(sum, n) {\n\t     *   return sum + n;\n\t     * });\n\t     * // => 3\n\t     *\n\t     * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {\n\t     *   (result[value] || (result[value] = [])).push(key);\n\t     *   return result;\n\t     * }, {});\n\t     * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)\n\t     */\n\t    function reduce(collection, iteratee, accumulator) {\n\t      var func = isArray(collection) ? arrayReduce : baseReduce,\n\t          initFromCollection = arguments.length < 3;\n\t\n\t      return func(collection, getIteratee(iteratee, 4), accumulator, initFromCollection, baseEach);\n\t    }\n\t\n\t    /**\n\t     * This method is like `_.reduce` except that it iterates over elements of\n\t     * `collection` from right to left.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Collection\n\t     * @param {Array|Object} collection The collection to iterate over.\n\t     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n\t     * @param {*} [accumulator] The initial value.\n\t     * @returns {*} Returns the accumulated value.\n\t     * @example\n\t     *\n\t     * var array = [[0, 1], [2, 3], [4, 5]];\n\t     *\n\t     * _.reduceRight(array, function(flattened, other) {\n\t     *   return flattened.concat(other);\n\t     * }, []);\n\t     * // => [4, 5, 2, 3, 0, 1]\n\t     */\n\t    function reduceRight(collection, iteratee, accumulator) {\n\t      var func = isArray(collection) ? arrayReduceRight : baseReduce,\n\t          initFromCollection = arguments.length < 3;\n\t\n\t      return func(collection, getIteratee(iteratee, 4), accumulator, initFromCollection, baseEachRight);\n\t    }\n\t\n\t    /**\n\t     * The opposite of `_.filter`; this method returns the elements of `collection`\n\t     * that `predicate` does **not** return truthy for.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Collection\n\t     * @param {Array|Object} collection The collection to iterate over.\n\t     * @param {Function|Object|string} [predicate=_.identity] The function invoked per iteration.\n\t     * @returns {Array} Returns the new filtered array.\n\t     * @example\n\t     *\n\t     * var users = [\n\t     *   { 'user': 'barney', 'age': 36, 'active': false },\n\t     *   { 'user': 'fred',   'age': 40, 'active': true }\n\t     * ];\n\t     *\n\t     * _.reject(users, function(o) { return !o.active; });\n\t     * // => objects for ['fred']\n\t     *\n\t     * // using the `_.matches` iteratee shorthand\n\t     * _.reject(users, { 'age': 40, 'active': true });\n\t     * // => objects for ['barney']\n\t     *\n\t     * // using the `_.matchesProperty` iteratee shorthand\n\t     * _.reject(users, ['active', false]);\n\t     * // => objects for ['fred']\n\t     *\n\t     * // using the `_.property` iteratee shorthand\n\t     * _.reject(users, 'active');\n\t     * // => objects for ['barney']\n\t     */\n\t    function reject(collection, predicate) {\n\t      var func = isArray(collection) ? arrayFilter : baseFilter;\n\t      predicate = getIteratee(predicate, 3);\n\t      return func(collection, function(value, index, collection) {\n\t        return !predicate(value, index, collection);\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Gets a random element from `collection`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Collection\n\t     * @param {Array|Object} collection The collection to sample.\n\t     * @returns {*} Returns the random element.\n\t     * @example\n\t     *\n\t     * _.sample([1, 2, 3, 4]);\n\t     * // => 2\n\t     */\n\t    function sample(collection) {\n\t      var array = isArrayLike(collection) ? collection : values(collection),\n\t          length = array.length;\n\t\n\t      return length > 0 ? array[baseRandom(0, length - 1)] : undefined;\n\t    }\n\t\n\t    /**\n\t     * Gets `n` random elements from `collection`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Collection\n\t     * @param {Array|Object} collection The collection to sample.\n\t     * @param {number} [n=0] The number of elements to sample.\n\t     * @returns {Array} Returns the random elements.\n\t     * @example\n\t     *\n\t     * _.sampleSize([1, 2, 3, 4], 2);\n\t     * // => [3, 1]\n\t     */\n\t    function sampleSize(collection, n) {\n\t      var index = -1,\n\t          result = toArray(collection),\n\t          length = result.length,\n\t          lastIndex = length - 1;\n\t\n\t      n = baseClamp(toInteger(n), 0, length);\n\t      while (++index < n) {\n\t        var rand = baseRandom(index, lastIndex),\n\t            value = result[rand];\n\t\n\t        result[rand] = result[index];\n\t        result[index] = value;\n\t      }\n\t      result.length = n;\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * Creates an array of shuffled values, using a version of the\n\t     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Collection\n\t     * @param {Array|Object} collection The collection to shuffle.\n\t     * @returns {Array} Returns the new shuffled array.\n\t     * @example\n\t     *\n\t     * _.shuffle([1, 2, 3, 4]);\n\t     * // => [4, 1, 3, 2]\n\t     */\n\t    function shuffle(collection) {\n\t      return sampleSize(collection, MAX_ARRAY_LENGTH);\n\t    }\n\t\n\t    /**\n\t     * Gets the size of `collection` by returning its length for array-like\n\t     * values or the number of own enumerable properties for objects.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Collection\n\t     * @param {Array|Object} collection The collection to inspect.\n\t     * @returns {number} Returns the collection size.\n\t     * @example\n\t     *\n\t     * _.size([1, 2, 3]);\n\t     * // => 3\n\t     *\n\t     * _.size({ 'a': 1, 'b': 2 });\n\t     * // => 2\n\t     *\n\t     * _.size('pebbles');\n\t     * // => 7\n\t     */\n\t    function size(collection) {\n\t      if (collection == null) {\n\t        return 0;\n\t      }\n\t      if (isArrayLike(collection)) {\n\t        var result = collection.length;\n\t        return (result && isString(collection)) ? stringSize(collection) : result;\n\t      }\n\t      return keys(collection).length;\n\t    }\n\t\n\t    /**\n\t     * Checks if `predicate` returns truthy for **any** element of `collection`.\n\t     * Iteration is stopped once `predicate` returns truthy. The predicate is\n\t     * invoked with three arguments: (value, index|key, collection).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Collection\n\t     * @param {Array|Object} collection The collection to iterate over.\n\t     * @param {Function|Object|string} [predicate=_.identity] The function invoked per iteration.\n\t     * @param- {Object} [guard] Enables use as an iteratee for functions like `_.map`.\n\t     * @returns {boolean} Returns `true` if any element passes the predicate check, else `false`.\n\t     * @example\n\t     *\n\t     * _.some([null, 0, 'yes', false], Boolean);\n\t     * // => true\n\t     *\n\t     * var users = [\n\t     *   { 'user': 'barney', 'active': true },\n\t     *   { 'user': 'fred',   'active': false }\n\t     * ];\n\t     *\n\t     * // using the `_.matches` iteratee shorthand\n\t     * _.some(users, { 'user': 'barney', 'active': false });\n\t     * // => false\n\t     *\n\t     * // using the `_.matchesProperty` iteratee shorthand\n\t     * _.some(users, ['active', false]);\n\t     * // => true\n\t     *\n\t     * // using the `_.property` iteratee shorthand\n\t     * _.some(users, 'active');\n\t     * // => true\n\t     */\n\t    function some(collection, predicate, guard) {\n\t      var func = isArray(collection) ? arraySome : baseSome;\n\t      if (guard && isIterateeCall(collection, predicate, guard)) {\n\t        predicate = undefined;\n\t      }\n\t      return func(collection, getIteratee(predicate, 3));\n\t    }\n\t\n\t    /**\n\t     * Creates an array of elements, sorted in ascending order by the results of\n\t     * running each element in a collection through each iteratee. This method\n\t     * performs a stable sort, that is, it preserves the original sort order of\n\t     * equal elements. The iteratees are invoked with one argument: (value).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Collection\n\t     * @param {Array|Object} collection The collection to iterate over.\n\t     * @param {...(Function|Function[]|Object|Object[]|string|string[])} [iteratees=[_.identity]]\n\t     *  The iteratees to sort by, specified individually or in arrays.\n\t     * @returns {Array} Returns the new sorted array.\n\t     * @example\n\t     *\n\t     * var users = [\n\t     *   { 'user': 'fred',   'age': 48 },\n\t     *   { 'user': 'barney', 'age': 36 },\n\t     *   { 'user': 'fred',   'age': 42 },\n\t     *   { 'user': 'barney', 'age': 34 }\n\t     * ];\n\t     *\n\t     * _.sortBy(users, function(o) { return o.user; });\n\t     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 42]]\n\t     *\n\t     * _.sortBy(users, ['user', 'age']);\n\t     * // => objects for [['barney', 34], ['barney', 36], ['fred', 42], ['fred', 48]]\n\t     *\n\t     * _.sortBy(users, 'user', function(o) {\n\t     *   return Math.floor(o.age / 10);\n\t     * });\n\t     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 42]]\n\t     */\n\t    var sortBy = rest(function(collection, iteratees) {\n\t      if (collection == null) {\n\t        return [];\n\t      }\n\t      var length = iteratees.length;\n\t      if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {\n\t        iteratees = [];\n\t      } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {\n\t        iteratees.length = 1;\n\t      }\n\t      return baseOrderBy(collection, baseFlatten(iteratees), []);\n\t    });\n\t\n\t    /*------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * Gets the timestamp of the number of milliseconds that have elapsed since\n\t     * the Unix epoch (1 January 1970 00:00:00 UTC).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @type Function\n\t     * @category Date\n\t     * @returns {number} Returns the timestamp.\n\t     * @example\n\t     *\n\t     * _.defer(function(stamp) {\n\t     *   console.log(_.now() - stamp);\n\t     * }, _.now());\n\t     * // => logs the number of milliseconds it took for the deferred function to be invoked\n\t     */\n\t    var now = Date.now;\n\t\n\t    /*------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * The opposite of `_.before`; this method creates a function that invokes\n\t     * `func` once it's called `n` or more times.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Function\n\t     * @param {number} n The number of calls before `func` is invoked.\n\t     * @param {Function} func The function to restrict.\n\t     * @returns {Function} Returns the new restricted function.\n\t     * @example\n\t     *\n\t     * var saves = ['profile', 'settings'];\n\t     *\n\t     * var done = _.after(saves.length, function() {\n\t     *   console.log('done saving!');\n\t     * });\n\t     *\n\t     * _.forEach(saves, function(type) {\n\t     *   asyncSave({ 'type': type, 'complete': done });\n\t     * });\n\t     * // => logs 'done saving!' after the two async saves have completed\n\t     */\n\t    function after(n, func) {\n\t      if (typeof func != 'function') {\n\t        throw new TypeError(FUNC_ERROR_TEXT);\n\t      }\n\t      n = toInteger(n);\n\t      return function() {\n\t        if (--n < 1) {\n\t          return func.apply(this, arguments);\n\t        }\n\t      };\n\t    }\n\t\n\t    /**\n\t     * Creates a function that accepts up to `n` arguments, ignoring any\n\t     * additional arguments.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Function\n\t     * @param {Function} func The function to cap arguments for.\n\t     * @param {number} [n=func.length] The arity cap.\n\t     * @param- {Object} [guard] Enables use as an iteratee for functions like `_.map`.\n\t     * @returns {Function} Returns the new function.\n\t     * @example\n\t     *\n\t     * _.map(['6', '8', '10'], _.ary(parseInt, 1));\n\t     * // => [6, 8, 10]\n\t     */\n\t    function ary(func, n, guard) {\n\t      n = guard ? undefined : n;\n\t      n = (func && n == null) ? func.length : n;\n\t      return createWrapper(func, ARY_FLAG, undefined, undefined, undefined, undefined, n);\n\t    }\n\t\n\t    /**\n\t     * Creates a function that invokes `func`, with the `this` binding and arguments\n\t     * of the created function, while it's called less than `n` times. Subsequent\n\t     * calls to the created function return the result of the last `func` invocation.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Function\n\t     * @param {number} n The number of calls at which `func` is no longer invoked.\n\t     * @param {Function} func The function to restrict.\n\t     * @returns {Function} Returns the new restricted function.\n\t     * @example\n\t     *\n\t     * jQuery(element).on('click', _.before(5, addContactToList));\n\t     * // => allows adding up to 4 contacts to the list\n\t     */\n\t    function before(n, func) {\n\t      var result;\n\t      if (typeof func != 'function') {\n\t        throw new TypeError(FUNC_ERROR_TEXT);\n\t      }\n\t      n = toInteger(n);\n\t      return function() {\n\t        if (--n > 0) {\n\t          result = func.apply(this, arguments);\n\t        }\n\t        if (n <= 1) {\n\t          func = undefined;\n\t        }\n\t        return result;\n\t      };\n\t    }\n\t\n\t    /**\n\t     * Creates a function that invokes `func` with the `this` binding of `thisArg`\n\t     * and prepends any additional `_.bind` arguments to those provided to the\n\t     * bound function.\n\t     *\n\t     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,\n\t     * may be used as a placeholder for partially applied arguments.\n\t     *\n\t     * **Note:** Unlike native `Function#bind` this method doesn't set the \"length\"\n\t     * property of bound functions.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Function\n\t     * @param {Function} func The function to bind.\n\t     * @param {*} thisArg The `this` binding of `func`.\n\t     * @param {...*} [partials] The arguments to be partially applied.\n\t     * @returns {Function} Returns the new bound function.\n\t     * @example\n\t     *\n\t     * var greet = function(greeting, punctuation) {\n\t     *   return greeting + ' ' + this.user + punctuation;\n\t     * };\n\t     *\n\t     * var object = { 'user': 'fred' };\n\t     *\n\t     * var bound = _.bind(greet, object, 'hi');\n\t     * bound('!');\n\t     * // => 'hi fred!'\n\t     *\n\t     * // using placeholders\n\t     * var bound = _.bind(greet, object, _, '!');\n\t     * bound('hi');\n\t     * // => 'hi fred!'\n\t     */\n\t    var bind = rest(function(func, thisArg, partials) {\n\t      var bitmask = BIND_FLAG;\n\t      if (partials.length) {\n\t        var holders = replaceHolders(partials, bind.placeholder);\n\t        bitmask |= PARTIAL_FLAG;\n\t      }\n\t      return createWrapper(func, bitmask, thisArg, partials, holders);\n\t    });\n\t\n\t    /**\n\t     * Creates a function that invokes the method at `object[key]` and prepends\n\t     * any additional `_.bindKey` arguments to those provided to the bound function.\n\t     *\n\t     * This method differs from `_.bind` by allowing bound functions to reference\n\t     * methods that may be redefined or don't yet exist.\n\t     * See [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)\n\t     * for more details.\n\t     *\n\t     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic\n\t     * builds, may be used as a placeholder for partially applied arguments.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Function\n\t     * @param {Object} object The object to invoke the method on.\n\t     * @param {string} key The key of the method.\n\t     * @param {...*} [partials] The arguments to be partially applied.\n\t     * @returns {Function} Returns the new bound function.\n\t     * @example\n\t     *\n\t     * var object = {\n\t     *   'user': 'fred',\n\t     *   'greet': function(greeting, punctuation) {\n\t     *     return greeting + ' ' + this.user + punctuation;\n\t     *   }\n\t     * };\n\t     *\n\t     * var bound = _.bindKey(object, 'greet', 'hi');\n\t     * bound('!');\n\t     * // => 'hi fred!'\n\t     *\n\t     * object.greet = function(greeting, punctuation) {\n\t     *   return greeting + 'ya ' + this.user + punctuation;\n\t     * };\n\t     *\n\t     * bound('!');\n\t     * // => 'hiya fred!'\n\t     *\n\t     * // using placeholders\n\t     * var bound = _.bindKey(object, 'greet', _, '!');\n\t     * bound('hi');\n\t     * // => 'hiya fred!'\n\t     */\n\t    var bindKey = rest(function(object, key, partials) {\n\t      var bitmask = BIND_FLAG | BIND_KEY_FLAG;\n\t      if (partials.length) {\n\t        var holders = replaceHolders(partials, bindKey.placeholder);\n\t        bitmask |= PARTIAL_FLAG;\n\t      }\n\t      return createWrapper(key, bitmask, object, partials, holders);\n\t    });\n\t\n\t    /**\n\t     * Creates a function that accepts arguments of `func` and either invokes\n\t     * `func` returning its result, if at least `arity` number of arguments have\n\t     * been provided, or returns a function that accepts the remaining `func`\n\t     * arguments, and so on. The arity of `func` may be specified if `func.length`\n\t     * is not sufficient.\n\t     *\n\t     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,\n\t     * may be used as a placeholder for provided arguments.\n\t     *\n\t     * **Note:** This method doesn't set the \"length\" property of curried functions.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Function\n\t     * @param {Function} func The function to curry.\n\t     * @param {number} [arity=func.length] The arity of `func`.\n\t     * @param- {Object} [guard] Enables use as an iteratee for functions like `_.map`.\n\t     * @returns {Function} Returns the new curried function.\n\t     * @example\n\t     *\n\t     * var abc = function(a, b, c) {\n\t     *   return [a, b, c];\n\t     * };\n\t     *\n\t     * var curried = _.curry(abc);\n\t     *\n\t     * curried(1)(2)(3);\n\t     * // => [1, 2, 3]\n\t     *\n\t     * curried(1, 2)(3);\n\t     * // => [1, 2, 3]\n\t     *\n\t     * curried(1, 2, 3);\n\t     * // => [1, 2, 3]\n\t     *\n\t     * // using placeholders\n\t     * curried(1)(_, 3)(2);\n\t     * // => [1, 2, 3]\n\t     */\n\t    function curry(func, arity, guard) {\n\t      arity = guard ? undefined : arity;\n\t      var result = createWrapper(func, CURRY_FLAG, undefined, undefined, undefined, undefined, undefined, arity);\n\t      result.placeholder = curry.placeholder;\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * This method is like `_.curry` except that arguments are applied to `func`\n\t     * in the manner of `_.partialRight` instead of `_.partial`.\n\t     *\n\t     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic\n\t     * builds, may be used as a placeholder for provided arguments.\n\t     *\n\t     * **Note:** This method doesn't set the \"length\" property of curried functions.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Function\n\t     * @param {Function} func The function to curry.\n\t     * @param {number} [arity=func.length] The arity of `func`.\n\t     * @param- {Object} [guard] Enables use as an iteratee for functions like `_.map`.\n\t     * @returns {Function} Returns the new curried function.\n\t     * @example\n\t     *\n\t     * var abc = function(a, b, c) {\n\t     *   return [a, b, c];\n\t     * };\n\t     *\n\t     * var curried = _.curryRight(abc);\n\t     *\n\t     * curried(3)(2)(1);\n\t     * // => [1, 2, 3]\n\t     *\n\t     * curried(2, 3)(1);\n\t     * // => [1, 2, 3]\n\t     *\n\t     * curried(1, 2, 3);\n\t     * // => [1, 2, 3]\n\t     *\n\t     * // using placeholders\n\t     * curried(3)(1, _)(2);\n\t     * // => [1, 2, 3]\n\t     */\n\t    function curryRight(func, arity, guard) {\n\t      arity = guard ? undefined : arity;\n\t      var result = createWrapper(func, CURRY_RIGHT_FLAG, undefined, undefined, undefined, undefined, undefined, arity);\n\t      result.placeholder = curryRight.placeholder;\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * Creates a debounced function that delays invoking `func` until after `wait`\n\t     * milliseconds have elapsed since the last time the debounced function was\n\t     * invoked. The debounced function comes with a `cancel` method to cancel\n\t     * delayed `func` invocations and a `flush` method to immediately invoke them.\n\t     * Provide an options object to indicate whether `func` should be invoked on\n\t     * the leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n\t     * with the last arguments provided to the debounced function. Subsequent calls\n\t     * to the debounced function return the result of the last `func` invocation.\n\t     *\n\t     * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked\n\t     * on the trailing edge of the timeout only if the the debounced function is\n\t     * invoked more than once during the `wait` timeout.\n\t     *\n\t     * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)\n\t     * for details over the differences between `_.debounce` and `_.throttle`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Function\n\t     * @param {Function} func The function to debounce.\n\t     * @param {number} [wait=0] The number of milliseconds to delay.\n\t     * @param {Object} [options] The options object.\n\t     * @param {boolean} [options.leading=false] Specify invoking on the leading\n\t     *  edge of the timeout.\n\t     * @param {number} [options.maxWait] The maximum time `func` is allowed to be\n\t     *  delayed before it's invoked.\n\t     * @param {boolean} [options.trailing=true] Specify invoking on the trailing\n\t     *  edge of the timeout.\n\t     * @returns {Function} Returns the new debounced function.\n\t     * @example\n\t     *\n\t     * // avoid costly calculations while the window size is in flux\n\t     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n\t     *\n\t     * // invoke `sendMail` when clicked, debouncing subsequent calls\n\t     * jQuery(element).on('click', _.debounce(sendMail, 300, {\n\t     *   'leading': true,\n\t     *   'trailing': false\n\t     * }));\n\t     *\n\t     * // ensure `batchLog` is invoked once after 1 second of debounced calls\n\t     * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n\t     * var source = new EventSource('/stream');\n\t     * jQuery(source).on('message', debounced);\n\t     *\n\t     * // cancel a trailing debounced invocation\n\t     * jQuery(window).on('popstate', debounced.cancel);\n\t     */\n\t    function debounce(func, wait, options) {\n\t      var args,\n\t          maxTimeoutId,\n\t          result,\n\t          stamp,\n\t          thisArg,\n\t          timeoutId,\n\t          trailingCall,\n\t          lastCalled = 0,\n\t          leading = false,\n\t          maxWait = false,\n\t          trailing = true;\n\t\n\t      if (typeof func != 'function') {\n\t        throw new TypeError(FUNC_ERROR_TEXT);\n\t      }\n\t      wait = toNumber(wait) || 0;\n\t      if (isObject(options)) {\n\t        leading = !!options.leading;\n\t        maxWait = 'maxWait' in options && nativeMax(toNumber(options.maxWait) || 0, wait);\n\t        trailing = 'trailing' in options ? !!options.trailing : trailing;\n\t      }\n\t\n\t      function cancel() {\n\t        if (timeoutId) {\n\t          clearTimeout(timeoutId);\n\t        }\n\t        if (maxTimeoutId) {\n\t          clearTimeout(maxTimeoutId);\n\t        }\n\t        lastCalled = 0;\n\t        args = maxTimeoutId = thisArg = timeoutId = trailingCall = undefined;\n\t      }\n\t\n\t      function complete(isCalled, id) {\n\t        if (id) {\n\t          clearTimeout(id);\n\t        }\n\t        maxTimeoutId = timeoutId = trailingCall = undefined;\n\t        if (isCalled) {\n\t          lastCalled = now();\n\t          result = func.apply(thisArg, args);\n\t          if (!timeoutId && !maxTimeoutId) {\n\t            args = thisArg = undefined;\n\t          }\n\t        }\n\t      }\n\t\n\t      function delayed() {\n\t        var remaining = wait - (now() - stamp);\n\t        if (remaining <= 0 || remaining > wait) {\n\t          complete(trailingCall, maxTimeoutId);\n\t        } else {\n\t          timeoutId = setTimeout(delayed, remaining);\n\t        }\n\t      }\n\t\n\t      function flush() {\n\t        if ((timeoutId && trailingCall) || (maxTimeoutId && trailing)) {\n\t          result = func.apply(thisArg, args);\n\t        }\n\t        cancel();\n\t        return result;\n\t      }\n\t\n\t      function maxDelayed() {\n\t        complete(trailing, timeoutId);\n\t      }\n\t\n\t      function debounced() {\n\t        args = arguments;\n\t        stamp = now();\n\t        thisArg = this;\n\t        trailingCall = trailing && (timeoutId || !leading);\n\t\n\t        if (maxWait === false) {\n\t          var leadingCall = leading && !timeoutId;\n\t        } else {\n\t          if (!maxTimeoutId && !leading) {\n\t            lastCalled = stamp;\n\t          }\n\t          var remaining = maxWait - (stamp - lastCalled),\n\t              isCalled = remaining <= 0 || remaining > maxWait;\n\t\n\t          if (isCalled) {\n\t            if (maxTimeoutId) {\n\t              maxTimeoutId = clearTimeout(maxTimeoutId);\n\t            }\n\t            lastCalled = stamp;\n\t            result = func.apply(thisArg, args);\n\t          }\n\t          else if (!maxTimeoutId) {\n\t            maxTimeoutId = setTimeout(maxDelayed, remaining);\n\t          }\n\t        }\n\t        if (isCalled && timeoutId) {\n\t          timeoutId = clearTimeout(timeoutId);\n\t        }\n\t        else if (!timeoutId && wait !== maxWait) {\n\t          timeoutId = setTimeout(delayed, wait);\n\t        }\n\t        if (leadingCall) {\n\t          isCalled = true;\n\t          result = func.apply(thisArg, args);\n\t        }\n\t        if (isCalled && !timeoutId && !maxTimeoutId) {\n\t          args = thisArg = undefined;\n\t        }\n\t        return result;\n\t      }\n\t      debounced.cancel = cancel;\n\t      debounced.flush = flush;\n\t      return debounced;\n\t    }\n\t\n\t    /**\n\t     * Defers invoking the `func` until the current call stack has cleared. Any\n\t     * additional arguments are provided to `func` when it's invoked.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Function\n\t     * @param {Function} func The function to defer.\n\t     * @param {...*} [args] The arguments to invoke `func` with.\n\t     * @returns {number} Returns the timer id.\n\t     * @example\n\t     *\n\t     * _.defer(function(text) {\n\t     *   console.log(text);\n\t     * }, 'deferred');\n\t     * // logs 'deferred' after one or more milliseconds\n\t     */\n\t    var defer = rest(function(func, args) {\n\t      return baseDelay(func, 1, args);\n\t    });\n\t\n\t    /**\n\t     * Invokes `func` after `wait` milliseconds. Any additional arguments are\n\t     * provided to `func` when it's invoked.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Function\n\t     * @param {Function} func The function to delay.\n\t     * @param {number} wait The number of milliseconds to delay invocation.\n\t     * @param {...*} [args] The arguments to invoke `func` with.\n\t     * @returns {number} Returns the timer id.\n\t     * @example\n\t     *\n\t     * _.delay(function(text) {\n\t     *   console.log(text);\n\t     * }, 1000, 'later');\n\t     * // => logs 'later' after one second\n\t     */\n\t    var delay = rest(function(func, wait, args) {\n\t      return baseDelay(func, toNumber(wait) || 0, args);\n\t    });\n\t\n\t    /**\n\t     * Creates a function that invokes `func` with arguments reversed.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Function\n\t     * @param {Function} func The function to flip arguments for.\n\t     * @returns {Function} Returns the new function.\n\t     * @example\n\t     *\n\t     * var flipped = _.flip(function() {\n\t     *   return _.toArray(arguments);\n\t     * });\n\t     *\n\t     * flipped('a', 'b', 'c', 'd');\n\t     * // => ['d', 'c', 'b', 'a']\n\t     */\n\t    function flip(func) {\n\t      return createWrapper(func, FLIP_FLAG);\n\t    }\n\t\n\t    /**\n\t     * Creates a function that memoizes the result of `func`. If `resolver` is\n\t     * provided it determines the cache key for storing the result based on the\n\t     * arguments provided to the memoized function. By default, the first argument\n\t     * provided to the memoized function is used as the map cache key. The `func`\n\t     * is invoked with the `this` binding of the memoized function.\n\t     *\n\t     * **Note:** The cache is exposed as the `cache` property on the memoized\n\t     * function. Its creation may be customized by replacing the `_.memoize.Cache`\n\t     * constructor with one whose instances implement the [`Map`](http://ecma-international.org/ecma-262/6.0/#sec-properties-of-the-map-prototype-object)\n\t     * method interface of `delete`, `get`, `has`, and `set`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Function\n\t     * @param {Function} func The function to have its output memoized.\n\t     * @param {Function} [resolver] The function to resolve the cache key.\n\t     * @returns {Function} Returns the new memoizing function.\n\t     * @example\n\t     *\n\t     * var object = { 'a': 1, 'b': 2 };\n\t     * var other = { 'c': 3, 'd': 4 };\n\t     *\n\t     * var values = _.memoize(_.values);\n\t     * values(object);\n\t     * // => [1, 2]\n\t     *\n\t     * values(other);\n\t     * // => [3, 4]\n\t     *\n\t     * object.a = 2;\n\t     * values(object);\n\t     * // => [1, 2]\n\t     *\n\t     * // modifying the result cache\n\t     * values.cache.set(object, ['a', 'b']);\n\t     * values(object);\n\t     * // => ['a', 'b']\n\t     *\n\t     * // replacing `_.memoize.Cache`\n\t     * _.memoize.Cache = WeakMap;\n\t     */\n\t    function memoize(func, resolver) {\n\t      if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {\n\t        throw new TypeError(FUNC_ERROR_TEXT);\n\t      }\n\t      var memoized = function() {\n\t        var args = arguments,\n\t            key = resolver ? resolver.apply(this, args) : args[0],\n\t            cache = memoized.cache;\n\t\n\t        if (cache.has(key)) {\n\t          return cache.get(key);\n\t        }\n\t        var result = func.apply(this, args);\n\t        memoized.cache = cache.set(key, result);\n\t        return result;\n\t      };\n\t      memoized.cache = new memoize.Cache;\n\t      return memoized;\n\t    }\n\t\n\t    /**\n\t     * Creates a function that negates the result of the predicate `func`. The\n\t     * `func` predicate is invoked with the `this` binding and arguments of the\n\t     * created function.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Function\n\t     * @param {Function} predicate The predicate to negate.\n\t     * @returns {Function} Returns the new function.\n\t     * @example\n\t     *\n\t     * function isEven(n) {\n\t     *   return n % 2 == 0;\n\t     * }\n\t     *\n\t     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));\n\t     * // => [1, 3, 5]\n\t     */\n\t    function negate(predicate) {\n\t      if (typeof predicate != 'function') {\n\t        throw new TypeError(FUNC_ERROR_TEXT);\n\t      }\n\t      return function() {\n\t        return !predicate.apply(this, arguments);\n\t      };\n\t    }\n\t\n\t    /**\n\t     * Creates a function that is restricted to invoking `func` once. Repeat calls\n\t     * to the function return the value of the first invocation. The `func` is\n\t     * invoked with the `this` binding and arguments of the created function.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Function\n\t     * @param {Function} func The function to restrict.\n\t     * @returns {Function} Returns the new restricted function.\n\t     * @example\n\t     *\n\t     * var initialize = _.once(createApplication);\n\t     * initialize();\n\t     * initialize();\n\t     * // `initialize` invokes `createApplication` once\n\t     */\n\t    function once(func) {\n\t      return before(2, func);\n\t    }\n\t\n\t    /**\n\t     * Creates a function that invokes `func` with arguments transformed by\n\t     * corresponding `transforms`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Function\n\t     * @param {Function} func The function to wrap.\n\t     * @param {...(Function|Function[])} [transforms] The functions to transform\n\t     * arguments, specified individually or in arrays.\n\t     * @returns {Function} Returns the new function.\n\t     * @example\n\t     *\n\t     * function doubled(n) {\n\t     *   return n * 2;\n\t     * }\n\t     *\n\t     * function square(n) {\n\t     *   return n * n;\n\t     * }\n\t     *\n\t     * var func = _.overArgs(function(x, y) {\n\t     *   return [x, y];\n\t     * }, square, doubled);\n\t     *\n\t     * func(9, 3);\n\t     * // => [81, 6]\n\t     *\n\t     * func(10, 5);\n\t     * // => [100, 10]\n\t     */\n\t    var overArgs = rest(function(func, transforms) {\n\t      transforms = arrayMap(baseFlatten(transforms), getIteratee());\n\t\n\t      var funcsLength = transforms.length;\n\t      return rest(function(args) {\n\t        var index = -1,\n\t            length = nativeMin(args.length, funcsLength);\n\t\n\t        while (++index < length) {\n\t          args[index] = transforms[index].call(this, args[index]);\n\t        }\n\t        return apply(func, this, args);\n\t      });\n\t    });\n\t\n\t    /**\n\t     * Creates a function that invokes `func` with `partial` arguments prepended\n\t     * to those provided to the new function. This method is like `_.bind` except\n\t     * it does **not** alter the `this` binding.\n\t     *\n\t     * The `_.partial.placeholder` value, which defaults to `_` in monolithic\n\t     * builds, may be used as a placeholder for partially applied arguments.\n\t     *\n\t     * **Note:** This method doesn't set the \"length\" property of partially\n\t     * applied functions.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Function\n\t     * @param {Function} func The function to partially apply arguments to.\n\t     * @param {...*} [partials] The arguments to be partially applied.\n\t     * @returns {Function} Returns the new partially applied function.\n\t     * @example\n\t     *\n\t     * var greet = function(greeting, name) {\n\t     *   return greeting + ' ' + name;\n\t     * };\n\t     *\n\t     * var sayHelloTo = _.partial(greet, 'hello');\n\t     * sayHelloTo('fred');\n\t     * // => 'hello fred'\n\t     *\n\t     * // using placeholders\n\t     * var greetFred = _.partial(greet, _, 'fred');\n\t     * greetFred('hi');\n\t     * // => 'hi fred'\n\t     */\n\t    var partial = rest(function(func, partials) {\n\t      var holders = replaceHolders(partials, partial.placeholder);\n\t      return createWrapper(func, PARTIAL_FLAG, undefined, partials, holders);\n\t    });\n\t\n\t    /**\n\t     * This method is like `_.partial` except that partially applied arguments\n\t     * are appended to those provided to the new function.\n\t     *\n\t     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic\n\t     * builds, may be used as a placeholder for partially applied arguments.\n\t     *\n\t     * **Note:** This method doesn't set the \"length\" property of partially\n\t     * applied functions.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Function\n\t     * @param {Function} func The function to partially apply arguments to.\n\t     * @param {...*} [partials] The arguments to be partially applied.\n\t     * @returns {Function} Returns the new partially applied function.\n\t     * @example\n\t     *\n\t     * var greet = function(greeting, name) {\n\t     *   return greeting + ' ' + name;\n\t     * };\n\t     *\n\t     * var greetFred = _.partialRight(greet, 'fred');\n\t     * greetFred('hi');\n\t     * // => 'hi fred'\n\t     *\n\t     * // using placeholders\n\t     * var sayHelloTo = _.partialRight(greet, 'hello', _);\n\t     * sayHelloTo('fred');\n\t     * // => 'hello fred'\n\t     */\n\t    var partialRight = rest(function(func, partials) {\n\t      var holders = replaceHolders(partials, partialRight.placeholder);\n\t      return createWrapper(func, PARTIAL_RIGHT_FLAG, undefined, partials, holders);\n\t    });\n\t\n\t    /**\n\t     * Creates a function that invokes `func` with arguments arranged according\n\t     * to the specified indexes where the argument value at the first index is\n\t     * provided as the first argument, the argument value at the second index is\n\t     * provided as the second argument, and so on.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Function\n\t     * @param {Function} func The function to rearrange arguments for.\n\t     * @param {...(number|number[])} indexes The arranged argument indexes,\n\t     *  specified individually or in arrays.\n\t     * @returns {Function} Returns the new function.\n\t     * @example\n\t     *\n\t     * var rearged = _.rearg(function(a, b, c) {\n\t     *   return [a, b, c];\n\t     * }, 2, 0, 1);\n\t     *\n\t     * rearged('b', 'c', 'a')\n\t     * // => ['a', 'b', 'c']\n\t     */\n\t    var rearg = rest(function(func, indexes) {\n\t      return createWrapper(func, REARG_FLAG, undefined, undefined, undefined, baseFlatten(indexes));\n\t    });\n\t\n\t    /**\n\t     * Creates a function that invokes `func` with the `this` binding of the\n\t     * created function and arguments from `start` and beyond provided as an array.\n\t     *\n\t     * **Note:** This method is based on the [rest parameter](https://mdn.io/rest_parameters).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Function\n\t     * @param {Function} func The function to apply a rest parameter to.\n\t     * @param {number} [start=func.length-1] The start position of the rest parameter.\n\t     * @returns {Function} Returns the new function.\n\t     * @example\n\t     *\n\t     * var say = _.rest(function(what, names) {\n\t     *   return what + ' ' + _.initial(names).join(', ') +\n\t     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);\n\t     * });\n\t     *\n\t     * say('hello', 'fred', 'barney', 'pebbles');\n\t     * // => 'hello fred, barney, & pebbles'\n\t     */\n\t    function rest(func, start) {\n\t      if (typeof func != 'function') {\n\t        throw new TypeError(FUNC_ERROR_TEXT);\n\t      }\n\t      start = nativeMax(start === undefined ? (func.length - 1) : toInteger(start), 0);\n\t      return function() {\n\t        var args = arguments,\n\t            index = -1,\n\t            length = nativeMax(args.length - start, 0),\n\t            array = Array(length);\n\t\n\t        while (++index < length) {\n\t          array[index] = args[start + index];\n\t        }\n\t        switch (start) {\n\t          case 0: return func.call(this, array);\n\t          case 1: return func.call(this, args[0], array);\n\t          case 2: return func.call(this, args[0], args[1], array);\n\t        }\n\t        var otherArgs = Array(start + 1);\n\t        index = -1;\n\t        while (++index < start) {\n\t          otherArgs[index] = args[index];\n\t        }\n\t        otherArgs[start] = array;\n\t        return apply(func, this, otherArgs);\n\t      };\n\t    }\n\t\n\t    /**\n\t     * Creates a function that invokes `func` with the `this` binding of the created\n\t     * function and an array of arguments much like [`Function#apply`](https://es5.github.io/#x15.3.4.3).\n\t     *\n\t     * **Note:** This method is based on the [spread operator](https://mdn.io/spread_operator).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Function\n\t     * @param {Function} func The function to spread arguments over.\n\t     * @returns {Function} Returns the new function.\n\t     * @example\n\t     *\n\t     * var say = _.spread(function(who, what) {\n\t     *   return who + ' says ' + what;\n\t     * });\n\t     *\n\t     * say(['fred', 'hello']);\n\t     * // => 'fred says hello'\n\t     *\n\t     * // with a Promise\n\t     * var numbers = Promise.all([\n\t     *   Promise.resolve(40),\n\t     *   Promise.resolve(36)\n\t     * ]);\n\t     *\n\t     * numbers.then(_.spread(function(x, y) {\n\t     *   return x + y;\n\t     * }));\n\t     * // => a Promise of 76\n\t     */\n\t    function spread(func) {\n\t      if (typeof func != 'function') {\n\t        throw new TypeError(FUNC_ERROR_TEXT);\n\t      }\n\t      return function(array) {\n\t        return apply(func, this, array);\n\t      };\n\t    }\n\t\n\t    /**\n\t     * Creates a throttled function that only invokes `func` at most once per\n\t     * every `wait` milliseconds. The throttled function comes with a `cancel`\n\t     * method to cancel delayed `func` invocations and a `flush` method to\n\t     * immediately invoke them. Provide an options object to indicate whether\n\t     * `func` should be invoked on the leading and/or trailing edge of the `wait`\n\t     * timeout. The `func` is invoked with the last arguments provided to the\n\t     * throttled function. Subsequent calls to the throttled function return the\n\t     * result of the last `func` invocation.\n\t     *\n\t     * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked\n\t     * on the trailing edge of the timeout only if the the throttled function is\n\t     * invoked more than once during the `wait` timeout.\n\t     *\n\t     * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)\n\t     * for details over the differences between `_.throttle` and `_.debounce`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Function\n\t     * @param {Function} func The function to throttle.\n\t     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.\n\t     * @param {Object} [options] The options object.\n\t     * @param {boolean} [options.leading=true] Specify invoking on the leading\n\t     *  edge of the timeout.\n\t     * @param {boolean} [options.trailing=true] Specify invoking on the trailing\n\t     *  edge of the timeout.\n\t     * @returns {Function} Returns the new throttled function.\n\t     * @example\n\t     *\n\t     * // avoid excessively updating the position while scrolling\n\t     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));\n\t     *\n\t     * // invoke `renewToken` when the click event is fired, but not more than once every 5 minutes\n\t     * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });\n\t     * jQuery(element).on('click', throttled);\n\t     *\n\t     * // cancel a trailing throttled invocation\n\t     * jQuery(window).on('popstate', throttled.cancel);\n\t     */\n\t    function throttle(func, wait, options) {\n\t      var leading = true,\n\t          trailing = true;\n\t\n\t      if (typeof func != 'function') {\n\t        throw new TypeError(FUNC_ERROR_TEXT);\n\t      }\n\t      if (isObject(options)) {\n\t        leading = 'leading' in options ? !!options.leading : leading;\n\t        trailing = 'trailing' in options ? !!options.trailing : trailing;\n\t      }\n\t      return debounce(func, wait, { 'leading': leading, 'maxWait': wait, 'trailing': trailing });\n\t    }\n\t\n\t    /**\n\t     * Creates a function that accepts up to one argument, ignoring any\n\t     * additional arguments.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Function\n\t     * @param {Function} func The function to cap arguments for.\n\t     * @returns {Function} Returns the new function.\n\t     * @example\n\t     *\n\t     * _.map(['6', '8', '10'], _.unary(parseInt));\n\t     * // => [6, 8, 10]\n\t     */\n\t    function unary(func) {\n\t      return ary(func, 1);\n\t    }\n\t\n\t    /**\n\t     * Creates a function that provides `value` to the wrapper function as its\n\t     * first argument. Any additional arguments provided to the function are\n\t     * appended to those provided to the wrapper function. The wrapper is invoked\n\t     * with the `this` binding of the created function.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Function\n\t     * @param {*} value The value to wrap.\n\t     * @param {Function} wrapper The wrapper function.\n\t     * @returns {Function} Returns the new function.\n\t     * @example\n\t     *\n\t     * var p = _.wrap(_.escape, function(func, text) {\n\t     *   return '<p>' + func(text) + '</p>';\n\t     * });\n\t     *\n\t     * p('fred, barney, & pebbles');\n\t     * // => '<p>fred, barney, &amp; pebbles</p>'\n\t     */\n\t    function wrap(value, wrapper) {\n\t      wrapper = wrapper == null ? identity : wrapper;\n\t      return partial(wrapper, value);\n\t    }\n\t\n\t    /*------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * Creates a shallow clone of `value`.\n\t     *\n\t     * **Note:** This method is loosely based on the\n\t     * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)\n\t     * and supports cloning arrays, array buffers, booleans, date objects, maps,\n\t     * numbers, `Object` objects, regexes, sets, strings, symbols, and typed\n\t     * arrays. The own enumerable properties of `arguments` objects are cloned\n\t     * as plain objects. An empty object is returned for uncloneable values such\n\t     * as error objects, functions, DOM nodes, and WeakMaps.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Lang\n\t     * @param {*} value The value to clone.\n\t     * @returns {*} Returns the cloned value.\n\t     * @example\n\t     *\n\t     * var objects = [{ 'a': 1 }, { 'b': 2 }];\n\t     *\n\t     * var shallow = _.clone(objects);\n\t     * console.log(shallow[0] === objects[0]);\n\t     * // => true\n\t     */\n\t    function clone(value) {\n\t      return baseClone(value);\n\t    }\n\t\n\t    /**\n\t     * This method is like `_.clone` except that it accepts `customizer` which\n\t     * is invoked to produce the cloned value. If `customizer` returns `undefined`\n\t     * cloning is handled by the method instead. The `customizer` is invoked with\n\t     * up to five arguments; (value [, index|key, object, stack]).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Lang\n\t     * @param {*} value The value to clone.\n\t     * @param {Function} [customizer] The function to customize cloning.\n\t     * @returns {*} Returns the cloned value.\n\t     * @example\n\t     *\n\t     * function customizer(value) {\n\t     *   if (_.isElement(value)) {\n\t     *     return value.cloneNode(false);\n\t     *   }\n\t     * }\n\t     *\n\t     * var el = _.clone(document.body, customizer);\n\t     *\n\t     * console.log(el === document.body);\n\t     * // => false\n\t     * console.log(el.nodeName);\n\t     * // => 'BODY'\n\t     * console.log(el.childNodes.length);\n\t     * // => 0\n\t     */\n\t    function cloneWith(value, customizer) {\n\t      return baseClone(value, false, customizer);\n\t    }\n\t\n\t    /**\n\t     * This method is like `_.clone` except that it recursively clones `value`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Lang\n\t     * @param {*} value The value to recursively clone.\n\t     * @returns {*} Returns the deep cloned value.\n\t     * @example\n\t     *\n\t     * var objects = [{ 'a': 1 }, { 'b': 2 }];\n\t     *\n\t     * var deep = _.cloneDeep(objects);\n\t     * console.log(deep[0] === objects[0]);\n\t     * // => false\n\t     */\n\t    function cloneDeep(value) {\n\t      return baseClone(value, true);\n\t    }\n\t\n\t    /**\n\t     * This method is like `_.cloneWith` except that it recursively clones `value`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Lang\n\t     * @param {*} value The value to recursively clone.\n\t     * @param {Function} [customizer] The function to customize cloning.\n\t     * @returns {*} Returns the deep cloned value.\n\t     * @example\n\t     *\n\t     * function customizer(value) {\n\t     *   if (_.isElement(value)) {\n\t     *     return value.cloneNode(true);\n\t     *   }\n\t     * }\n\t     *\n\t     * var el = _.cloneDeep(document.body, customizer);\n\t     *\n\t     * console.log(el === document.body);\n\t     * // => false\n\t     * console.log(el.nodeName);\n\t     * // => 'BODY'\n\t     * console.log(el.childNodes.length);\n\t     * // => 20\n\t     */\n\t    function cloneDeepWith(value, customizer) {\n\t      return baseClone(value, true, customizer);\n\t    }\n\t\n\t    /**\n\t     * Performs a [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)\n\t     * comparison between two values to determine if they are equivalent.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Lang\n\t     * @param {*} value The value to compare.\n\t     * @param {*} other The other value to compare.\n\t     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n\t     * @example\n\t     *\n\t     * var object = { 'user': 'fred' };\n\t     * var other = { 'user': 'fred' };\n\t     *\n\t     * _.eq(object, object);\n\t     * // => true\n\t     *\n\t     * _.eq(object, other);\n\t     * // => false\n\t     *\n\t     * _.eq('a', 'a');\n\t     * // => true\n\t     *\n\t     * _.eq('a', Object('a'));\n\t     * // => false\n\t     *\n\t     * _.eq(NaN, NaN);\n\t     * // => true\n\t     */\n\t    function eq(value, other) {\n\t      return value === other || (value !== value && other !== other);\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is greater than `other`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Lang\n\t     * @param {*} value The value to compare.\n\t     * @param {*} other The other value to compare.\n\t     * @returns {boolean} Returns `true` if `value` is greater than `other`, else `false`.\n\t     * @example\n\t     *\n\t     * _.gt(3, 1);\n\t     * // => true\n\t     *\n\t     * _.gt(3, 3);\n\t     * // => false\n\t     *\n\t     * _.gt(1, 3);\n\t     * // => false\n\t     */\n\t    function gt(value, other) {\n\t      return value > other;\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is greater than or equal to `other`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Lang\n\t     * @param {*} value The value to compare.\n\t     * @param {*} other The other value to compare.\n\t     * @returns {boolean} Returns `true` if `value` is greater than or equal to `other`, else `false`.\n\t     * @example\n\t     *\n\t     * _.gte(3, 1);\n\t     * // => true\n\t     *\n\t     * _.gte(3, 3);\n\t     * // => true\n\t     *\n\t     * _.gte(1, 3);\n\t     * // => false\n\t     */\n\t    function gte(value, other) {\n\t      return value >= other;\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is likely an `arguments` object.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Lang\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n\t     * @example\n\t     *\n\t     * _.isArguments(function() { return arguments; }());\n\t     * // => true\n\t     *\n\t     * _.isArguments([1, 2, 3]);\n\t     * // => false\n\t     */\n\t    function isArguments(value) {\n\t      // Safari 8.1 incorrectly makes `arguments.callee` enumerable in strict mode.\n\t      return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&\n\t        (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is classified as an `Array` object.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @type Function\n\t     * @category Lang\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n\t     * @example\n\t     *\n\t     * _.isArray([1, 2, 3]);\n\t     * // => true\n\t     *\n\t     * _.isArray(document.body.children);\n\t     * // => false\n\t     *\n\t     * _.isArray('abc');\n\t     * // => false\n\t     *\n\t     * _.isArray(_.noop);\n\t     * // => false\n\t     */\n\t    var isArray = Array.isArray;\n\t\n\t    /**\n\t     * Checks if `value` is array-like. A value is considered array-like if it's\n\t     * not a function and has a `value.length` that's an integer greater than or\n\t     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @type Function\n\t     * @category Lang\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n\t     * @example\n\t     *\n\t     * _.isArrayLike([1, 2, 3]);\n\t     * // => true\n\t     *\n\t     * _.isArrayLike(document.body.children);\n\t     * // => true\n\t     *\n\t     * _.isArrayLike('abc');\n\t     * // => true\n\t     *\n\t     * _.isArrayLike(_.noop);\n\t     * // => false\n\t     */\n\t    function isArrayLike(value) {\n\t      return value != null &&\n\t        !(typeof value == 'function' && isFunction(value)) && isLength(getLength(value));\n\t    }\n\t\n\t    /**\n\t     * This method is like `_.isArrayLike` except that it also checks if `value`\n\t     * is an object.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @type Function\n\t     * @category Lang\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is an array-like object, else `false`.\n\t     * @example\n\t     *\n\t     * _.isArrayLikeObject([1, 2, 3]);\n\t     * // => true\n\t     *\n\t     * _.isArrayLikeObject(document.body.children);\n\t     * // => true\n\t     *\n\t     * _.isArrayLikeObject('abc');\n\t     * // => false\n\t     *\n\t     * _.isArrayLikeObject(_.noop);\n\t     * // => false\n\t     */\n\t    function isArrayLikeObject(value) {\n\t      return isObjectLike(value) && isArrayLike(value);\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is classified as a boolean primitive or object.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Lang\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n\t     * @example\n\t     *\n\t     * _.isBoolean(false);\n\t     * // => true\n\t     *\n\t     * _.isBoolean(null);\n\t     * // => false\n\t     */\n\t    function isBoolean(value) {\n\t      return value === true || value === false ||\n\t        (isObjectLike(value) && objectToString.call(value) == boolTag);\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is classified as a `Date` object.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Lang\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n\t     * @example\n\t     *\n\t     * _.isDate(new Date);\n\t     * // => true\n\t     *\n\t     * _.isDate('Mon April 23 2012');\n\t     * // => false\n\t     */\n\t    function isDate(value) {\n\t      return isObjectLike(value) && objectToString.call(value) == dateTag;\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is likely a DOM element.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Lang\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.\n\t     * @example\n\t     *\n\t     * _.isElement(document.body);\n\t     * // => true\n\t     *\n\t     * _.isElement('<body>');\n\t     * // => false\n\t     */\n\t    function isElement(value) {\n\t      return !!value && value.nodeType === 1 && isObjectLike(value) && !isPlainObject(value);\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is empty. A value is considered empty unless it's an\n\t     * `arguments` object, array, string, or jQuery-like collection with a length\n\t     * greater than `0` or an object with own enumerable properties.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Lang\n\t     * @param {Array|Object|string} value The value to inspect.\n\t     * @returns {boolean} Returns `true` if `value` is empty, else `false`.\n\t     * @example\n\t     *\n\t     * _.isEmpty(null);\n\t     * // => true\n\t     *\n\t     * _.isEmpty(true);\n\t     * // => true\n\t     *\n\t     * _.isEmpty(1);\n\t     * // => true\n\t     *\n\t     * _.isEmpty([1, 2, 3]);\n\t     * // => false\n\t     *\n\t     * _.isEmpty({ 'a': 1 });\n\t     * // => false\n\t     */\n\t    function isEmpty(value) {\n\t      return (!isObjectLike(value) || isFunction(value.splice))\n\t        ? !size(value)\n\t        : !keys(value).length;\n\t    }\n\t\n\t    /**\n\t     * Performs a deep comparison between two values to determine if they are\n\t     * equivalent.\n\t     *\n\t     * **Note:** This method supports comparing arrays, array buffers, booleans,\n\t     * date objects, error objects, maps, numbers, `Object` objects, regexes,\n\t     * sets, strings, symbols, and typed arrays. `Object` objects are compared\n\t     * by their own, not inherited, enumerable properties. Functions and DOM\n\t     * nodes are **not** supported.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Lang\n\t     * @param {*} value The value to compare.\n\t     * @param {*} other The other value to compare.\n\t     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n\t     * @example\n\t     *\n\t     * var object = { 'user': 'fred' };\n\t     * var other = { 'user': 'fred' };\n\t     *\n\t     * _.isEqual(object, other);\n\t     * // => true\n\t     *\n\t     * object === other;\n\t     * // => false\n\t     */\n\t    function isEqual(value, other) {\n\t      return baseIsEqual(value, other);\n\t    }\n\t\n\t    /**\n\t     * This method is like `_.isEqual` except that it accepts `customizer` which is\n\t     * invoked to compare values. If `customizer` returns `undefined` comparisons are\n\t     * handled by the method instead. The `customizer` is invoked with up to seven arguments:\n\t     * (objValue, othValue [, index|key, object, other, stack]).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Lang\n\t     * @param {*} value The value to compare.\n\t     * @param {*} other The other value to compare.\n\t     * @param {Function} [customizer] The function to customize comparisons.\n\t     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n\t     * @example\n\t     *\n\t     * function isGreeting(value) {\n\t     *   return /^h(?:i|ello)$/.test(value);\n\t     * }\n\t     *\n\t     * function customizer(objValue, othValue) {\n\t     *   if (isGreeting(objValue) && isGreeting(othValue)) {\n\t     *     return true;\n\t     *   }\n\t     * }\n\t     *\n\t     * var array = ['hello', 'goodbye'];\n\t     * var other = ['hi', 'goodbye'];\n\t     *\n\t     * _.isEqualWith(array, other, customizer);\n\t     * // => true\n\t     */\n\t    function isEqualWith(value, other, customizer) {\n\t      customizer = typeof customizer == 'function' ? customizer : undefined;\n\t      var result = customizer ? customizer(value, other) : undefined;\n\t      return result === undefined ? baseIsEqual(value, other, customizer) : !!result;\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,\n\t     * `SyntaxError`, `TypeError`, or `URIError` object.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Lang\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.\n\t     * @example\n\t     *\n\t     * _.isError(new Error);\n\t     * // => true\n\t     *\n\t     * _.isError(Error);\n\t     * // => false\n\t     */\n\t    function isError(value) {\n\t      return isObjectLike(value) &&\n\t        typeof value.message == 'string' && objectToString.call(value) == errorTag;\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is a finite primitive number.\n\t     *\n\t     * **Note:** This method is based on [`Number.isFinite`](https://mdn.io/Number/isFinite).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Lang\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.\n\t     * @example\n\t     *\n\t     * _.isFinite(3);\n\t     * // => true\n\t     *\n\t     * _.isFinite(Number.MAX_VALUE);\n\t     * // => true\n\t     *\n\t     * _.isFinite(3.14);\n\t     * // => true\n\t     *\n\t     * _.isFinite(Infinity);\n\t     * // => false\n\t     */\n\t    function isFinite(value) {\n\t      return typeof value == 'number' && nativeIsFinite(value);\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is classified as a `Function` object.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Lang\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n\t     * @example\n\t     *\n\t     * _.isFunction(_);\n\t     * // => true\n\t     *\n\t     * _.isFunction(/abc/);\n\t     * // => false\n\t     */\n\t    function isFunction(value) {\n\t      // The use of `Object#toString` avoids issues with the `typeof` operator\n\t      // in Safari 8 which returns 'object' for typed array constructors, and\n\t      // PhantomJS 1.9 which returns 'function' for `NodeList` instances.\n\t      var tag = isObject(value) ? objectToString.call(value) : '';\n\t      return tag == funcTag || tag == genTag;\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is an integer.\n\t     *\n\t     * **Note:** This method is based on [`Number.isInteger`](https://mdn.io/Number/isInteger).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Lang\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is an integer, else `false`.\n\t     * @example\n\t     *\n\t     * _.isInteger(3);\n\t     * // => true\n\t     *\n\t     * _.isInteger(Number.MIN_VALUE);\n\t     * // => false\n\t     *\n\t     * _.isInteger(Infinity);\n\t     * // => false\n\t     *\n\t     * _.isInteger('3');\n\t     * // => false\n\t     */\n\t    function isInteger(value) {\n\t      return typeof value == 'number' && value == toInteger(value);\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is a valid array-like length.\n\t     *\n\t     * **Note:** This function is loosely based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Lang\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n\t     * @example\n\t     *\n\t     * _.isLength(3);\n\t     * // => true\n\t     *\n\t     * _.isLength(Number.MIN_VALUE);\n\t     * // => false\n\t     *\n\t     * _.isLength(Infinity);\n\t     * // => false\n\t     *\n\t     * _.isLength('3');\n\t     * // => false\n\t     */\n\t    function isLength(value) {\n\t      return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.\n\t     * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Lang\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n\t     * @example\n\t     *\n\t     * _.isObject({});\n\t     * // => true\n\t     *\n\t     * _.isObject([1, 2, 3]);\n\t     * // => true\n\t     *\n\t     * _.isObject(_.noop);\n\t     * // => true\n\t     *\n\t     * _.isObject(null);\n\t     * // => false\n\t     */\n\t    function isObject(value) {\n\t      // Avoid a V8 JIT bug in Chrome 19-20.\n\t      // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n\t      var type = typeof value;\n\t      return !!value && (type == 'object' || type == 'function');\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is object-like. A value is object-like if it's not `null`\n\t     * and has a `typeof` result of \"object\".\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Lang\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n\t     * @example\n\t     *\n\t     * _.isObjectLike({});\n\t     * // => true\n\t     *\n\t     * _.isObjectLike([1, 2, 3]);\n\t     * // => true\n\t     *\n\t     * _.isObjectLike(_.noop);\n\t     * // => false\n\t     *\n\t     * _.isObjectLike(null);\n\t     * // => false\n\t     */\n\t    function isObjectLike(value) {\n\t      return !!value && typeof value == 'object';\n\t    }\n\t\n\t    /**\n\t     * Performs a deep comparison between `object` and `source` to determine if\n\t     * `object` contains equivalent property values.\n\t     *\n\t     * **Note:** This method supports comparing the same values as `_.isEqual`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Lang\n\t     * @param {Object} object The object to inspect.\n\t     * @param {Object} source The object of property values to match.\n\t     * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n\t     * @example\n\t     *\n\t     * var object = { 'user': 'fred', 'age': 40 };\n\t     *\n\t     * _.isMatch(object, { 'age': 40 });\n\t     * // => true\n\t     *\n\t     * _.isMatch(object, { 'age': 36 });\n\t     * // => false\n\t     */\n\t    function isMatch(object, source) {\n\t      return object === source || baseIsMatch(object, source, getMatchData(source));\n\t    }\n\t\n\t    /**\n\t     * This method is like `_.isMatch` except that it accepts `customizer` which\n\t     * is invoked to compare values. If `customizer` returns `undefined` comparisons\n\t     * are handled by the method instead. The `customizer` is invoked with three\n\t     * arguments: (objValue, srcValue, index|key, object, source).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Lang\n\t     * @param {Object} object The object to inspect.\n\t     * @param {Object} source The object of property values to match.\n\t     * @param {Function} [customizer] The function to customize comparisons.\n\t     * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n\t     * @example\n\t     *\n\t     * function isGreeting(value) {\n\t     *   return /^h(?:i|ello)$/.test(value);\n\t     * }\n\t     *\n\t     * function customizer(objValue, srcValue) {\n\t     *   if (isGreeting(objValue) && isGreeting(srcValue)) {\n\t     *     return true;\n\t     *   }\n\t     * }\n\t     *\n\t     * var object = { 'greeting': 'hello' };\n\t     * var source = { 'greeting': 'hi' };\n\t     *\n\t     * _.isMatchWith(object, source, customizer);\n\t     * // => true\n\t     */\n\t    function isMatchWith(object, source, customizer) {\n\t      customizer = typeof customizer == 'function' ? customizer : undefined;\n\t      return baseIsMatch(object, source, getMatchData(source), customizer);\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is `NaN`.\n\t     *\n\t     * **Note:** This method is not the same as [`isNaN`](https://es5.github.io/#x15.1.2.4)\n\t     * which returns `true` for `undefined` and other non-numeric values.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Lang\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.\n\t     * @example\n\t     *\n\t     * _.isNaN(NaN);\n\t     * // => true\n\t     *\n\t     * _.isNaN(new Number(NaN));\n\t     * // => true\n\t     *\n\t     * isNaN(undefined);\n\t     * // => true\n\t     *\n\t     * _.isNaN(undefined);\n\t     * // => false\n\t     */\n\t    function isNaN(value) {\n\t      // An `NaN` primitive is the only value that is not equal to itself.\n\t      // Perform the `toStringTag` check first to avoid errors with some ActiveX objects in IE.\n\t      return isNumber(value) && value != +value;\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is a native function.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Lang\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is a native function, else `false`.\n\t     * @example\n\t     *\n\t     * _.isNative(Array.prototype.push);\n\t     * // => true\n\t     *\n\t     * _.isNative(_);\n\t     * // => false\n\t     */\n\t    function isNative(value) {\n\t      if (value == null) {\n\t        return false;\n\t      }\n\t      if (isFunction(value)) {\n\t        return reIsNative.test(funcToString.call(value));\n\t      }\n\t      return isObjectLike(value) &&\n\t        (isHostObject(value) ? reIsNative : reIsHostCtor).test(value);\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is `null`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Lang\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.\n\t     * @example\n\t     *\n\t     * _.isNull(null);\n\t     * // => true\n\t     *\n\t     * _.isNull(void 0);\n\t     * // => false\n\t     */\n\t    function isNull(value) {\n\t      return value === null;\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is `null` or `undefined`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Lang\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is nullish, else `false`.\n\t     * @example\n\t     *\n\t     * _.isNil(null);\n\t     * // => true\n\t     *\n\t     * _.isNil(void 0);\n\t     * // => true\n\t     *\n\t     * _.isNil(NaN);\n\t     * // => false\n\t     */\n\t    function isNil(value) {\n\t      return value == null;\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is classified as a `Number` primitive or object.\n\t     *\n\t     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are classified\n\t     * as numbers, use the `_.isFinite` method.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Lang\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n\t     * @example\n\t     *\n\t     * _.isNumber(3);\n\t     * // => true\n\t     *\n\t     * _.isNumber(Number.MIN_VALUE);\n\t     * // => true\n\t     *\n\t     * _.isNumber(Infinity);\n\t     * // => true\n\t     *\n\t     * _.isNumber('3');\n\t     * // => false\n\t     */\n\t    function isNumber(value) {\n\t      return typeof value == 'number' ||\n\t        (isObjectLike(value) && objectToString.call(value) == numberTag);\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is a plain object, that is, an object created by the\n\t     * `Object` constructor or one with a `[[Prototype]]` of `null`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Lang\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n\t     * @example\n\t     *\n\t     * function Foo() {\n\t     *   this.a = 1;\n\t     * }\n\t     *\n\t     * _.isPlainObject(new Foo);\n\t     * // => false\n\t     *\n\t     * _.isPlainObject([1, 2, 3]);\n\t     * // => false\n\t     *\n\t     * _.isPlainObject({ 'x': 0, 'y': 0 });\n\t     * // => true\n\t     *\n\t     * _.isPlainObject(Object.create(null));\n\t     * // => true\n\t     */\n\t    function isPlainObject(value) {\n\t      if (!isObjectLike(value) || objectToString.call(value) != objectTag || isHostObject(value)) {\n\t        return false;\n\t      }\n\t      var proto = objectProto;\n\t      if (typeof value.constructor == 'function') {\n\t        proto = getPrototypeOf(value);\n\t      }\n\t      if (proto === null) {\n\t        return true;\n\t      }\n\t      var Ctor = proto.constructor;\n\t      return (typeof Ctor == 'function' &&\n\t        Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString);\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is classified as a `RegExp` object.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Lang\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n\t     * @example\n\t     *\n\t     * _.isRegExp(/abc/);\n\t     * // => true\n\t     *\n\t     * _.isRegExp('/abc/');\n\t     * // => false\n\t     */\n\t    function isRegExp(value) {\n\t      return isObject(value) && objectToString.call(value) == regexpTag;\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754\n\t     * double precision number which isn't the result of a rounded unsafe integer.\n\t     *\n\t     * **Note:** This method is based on [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Lang\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.\n\t     * @example\n\t     *\n\t     * _.isSafeInteger(3);\n\t     * // => true\n\t     *\n\t     * _.isSafeInteger(Number.MIN_VALUE);\n\t     * // => false\n\t     *\n\t     * _.isSafeInteger(Infinity);\n\t     * // => false\n\t     *\n\t     * _.isSafeInteger('3');\n\t     * // => false\n\t     */\n\t    function isSafeInteger(value) {\n\t      return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is classified as a `String` primitive or object.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Lang\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n\t     * @example\n\t     *\n\t     * _.isString('abc');\n\t     * // => true\n\t     *\n\t     * _.isString(1);\n\t     * // => false\n\t     */\n\t    function isString(value) {\n\t      return typeof value == 'string' ||\n\t        (!isArray(value) && isObjectLike(value) && objectToString.call(value) == stringTag);\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is classified as a `Symbol` primitive or object.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Lang\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n\t     * @example\n\t     *\n\t     * _.isSymbol(Symbol.iterator);\n\t     * // => true\n\t     *\n\t     * _.isSymbol('abc');\n\t     * // => false\n\t     */\n\t    function isSymbol(value) {\n\t      return typeof value == 'symbol' ||\n\t        (isObjectLike(value) && objectToString.call(value) == symbolTag);\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is classified as a typed array.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Lang\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n\t     * @example\n\t     *\n\t     * _.isTypedArray(new Uint8Array);\n\t     * // => true\n\t     *\n\t     * _.isTypedArray([]);\n\t     * // => false\n\t     */\n\t    function isTypedArray(value) {\n\t      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objectToString.call(value)];\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is `undefined`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Lang\n\t     * @param {*} value The value to check.\n\t     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.\n\t     * @example\n\t     *\n\t     * _.isUndefined(void 0);\n\t     * // => true\n\t     *\n\t     * _.isUndefined(null);\n\t     * // => false\n\t     */\n\t    function isUndefined(value) {\n\t      return value === undefined;\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is less than `other`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Lang\n\t     * @param {*} value The value to compare.\n\t     * @param {*} other The other value to compare.\n\t     * @returns {boolean} Returns `true` if `value` is less than `other`, else `false`.\n\t     * @example\n\t     *\n\t     * _.lt(1, 3);\n\t     * // => true\n\t     *\n\t     * _.lt(3, 3);\n\t     * // => false\n\t     *\n\t     * _.lt(3, 1);\n\t     * // => false\n\t     */\n\t    function lt(value, other) {\n\t      return value < other;\n\t    }\n\t\n\t    /**\n\t     * Checks if `value` is less than or equal to `other`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Lang\n\t     * @param {*} value The value to compare.\n\t     * @param {*} other The other value to compare.\n\t     * @returns {boolean} Returns `true` if `value` is less than or equal to `other`, else `false`.\n\t     * @example\n\t     *\n\t     * _.lte(1, 3);\n\t     * // => true\n\t     *\n\t     * _.lte(3, 3);\n\t     * // => true\n\t     *\n\t     * _.lte(3, 1);\n\t     * // => false\n\t     */\n\t    function lte(value, other) {\n\t      return value <= other;\n\t    }\n\t\n\t    /**\n\t     * Converts `value` to an array.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Lang\n\t     * @param {*} value The value to convert.\n\t     * @returns {Array} Returns the converted array.\n\t     * @example\n\t     *\n\t     * _.toArray({ 'a': 1, 'b': 2 });\n\t     * // => [1, 2]\n\t     *\n\t     * _.toArray('abc');\n\t     * // => ['a', 'b', 'c']\n\t     *\n\t     * _.toArray(1);\n\t     * // => []\n\t     *\n\t     * _.toArray(null);\n\t     * // => []\n\t     */\n\t    function toArray(value) {\n\t      if (!value) {\n\t        return [];\n\t      }\n\t      if (isArrayLike(value)) {\n\t        return isString(value) ? stringToArray(value) : copyArray(value);\n\t      }\n\t      if (iteratorSymbol && value[iteratorSymbol]) {\n\t        return iteratorToArray(value[iteratorSymbol]());\n\t      }\n\t      var tag = getTag(value),\n\t          func = tag == mapTag ? mapToArray : (tag == setTag ? setToArray : values);\n\t\n\t      return func(value);\n\t    }\n\t\n\t    /**\n\t     * Converts `value` to an integer.\n\t     *\n\t     * **Note:** This function is loosely based on [`ToInteger`](http://www.ecma-international.org/ecma-262/6.0/#sec-tointeger).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Lang\n\t     * @param {*} value The value to convert.\n\t     * @returns {number} Returns the converted integer.\n\t     * @example\n\t     *\n\t     * _.toInteger(3);\n\t     * // => 3\n\t     *\n\t     * _.toInteger(Number.MIN_VALUE);\n\t     * // => 0\n\t     *\n\t     * _.toInteger(Infinity);\n\t     * // => 1.7976931348623157e+308\n\t     *\n\t     * _.toInteger('3');\n\t     * // => 3\n\t     */\n\t    function toInteger(value) {\n\t      if (!value) {\n\t        return value === 0 ? value : 0;\n\t      }\n\t      value = toNumber(value);\n\t      if (value === INFINITY || value === -INFINITY) {\n\t        var sign = (value < 0 ? -1 : 1);\n\t        return sign * MAX_INTEGER;\n\t      }\n\t      var remainder = value % 1;\n\t      return value === value ? (remainder ? value - remainder : value) : 0;\n\t    }\n\t\n\t    /**\n\t     * Converts `value` to an integer suitable for use as the length of an\n\t     * array-like object.\n\t     *\n\t     * **Note:** This method is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Lang\n\t     * @param {*} value The value to convert.\n\t     * @return {number} Returns the converted integer.\n\t     * @example\n\t     *\n\t     * _.toLength(3);\n\t     * // => 3\n\t     *\n\t     * _.toLength(Number.MIN_VALUE);\n\t     * // => 0\n\t     *\n\t     * _.toLength(Infinity);\n\t     * // => 4294967295\n\t     *\n\t     * _.toLength('3');\n\t     * // => 3\n\t     */\n\t    function toLength(value) {\n\t      return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;\n\t    }\n\t\n\t    /**\n\t     * Converts `value` to a number.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Lang\n\t     * @param {*} value The value to process.\n\t     * @returns {number} Returns the number.\n\t     * @example\n\t     *\n\t     * _.toNumber(3);\n\t     * // => 3\n\t     *\n\t     * _.toNumber(Number.MIN_VALUE);\n\t     * // => 5e-324\n\t     *\n\t     * _.toNumber(Infinity);\n\t     * // => Infinity\n\t     *\n\t     * _.toNumber('3');\n\t     * // => 3\n\t     */\n\t    function toNumber(value) {\n\t      if (isObject(value)) {\n\t        var other = isFunction(value.valueOf) ? value.valueOf() : value;\n\t        value = isObject(other) ? (other + '') : other;\n\t      }\n\t      if (typeof value != 'string') {\n\t        return value === 0 ? value : +value;\n\t      }\n\t      value = value.replace(reTrim, '');\n\t      var isBinary = reIsBinary.test(value);\n\t      return (isBinary || reIsOctal.test(value))\n\t        ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n\t        : (reIsBadHex.test(value) ? NAN : +value);\n\t    }\n\t\n\t    /**\n\t     * Converts `value` to a plain object flattening inherited enumerable\n\t     * properties of `value` to own properties of the plain object.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Lang\n\t     * @param {*} value The value to convert.\n\t     * @returns {Object} Returns the converted plain object.\n\t     * @example\n\t     *\n\t     * function Foo() {\n\t     *   this.b = 2;\n\t     * }\n\t     *\n\t     * Foo.prototype.c = 3;\n\t     *\n\t     * _.assign({ 'a': 1 }, new Foo);\n\t     * // => { 'a': 1, 'b': 2 }\n\t     *\n\t     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));\n\t     * // => { 'a': 1, 'b': 2, 'c': 3 }\n\t     */\n\t    function toPlainObject(value) {\n\t      return copyObject(value, keysIn(value));\n\t    }\n\t\n\t    /**\n\t     * Converts `value` to a safe integer. A safe integer can be compared and\n\t     * represented correctly.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Lang\n\t     * @param {*} value The value to convert.\n\t     * @returns {number} Returns the converted integer.\n\t     * @example\n\t     *\n\t     * _.toSafeInteger(3);\n\t     * // => 3\n\t     *\n\t     * _.toSafeInteger(Number.MIN_VALUE);\n\t     * // => 0\n\t     *\n\t     * _.toSafeInteger(Infinity);\n\t     * // => 9007199254740991\n\t     *\n\t     * _.toSafeInteger('3');\n\t     * // => 3\n\t     */\n\t    function toSafeInteger(value) {\n\t      return baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);\n\t    }\n\t\n\t    /**\n\t     * Converts `value` to a string if it's not one. An empty string is returned\n\t     * for `null` and `undefined` values. The sign of `-0` is preserved.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Lang\n\t     * @param {*} value The value to process.\n\t     * @returns {string} Returns the string.\n\t     * @example\n\t     *\n\t     * _.toString(null);\n\t     * // => ''\n\t     *\n\t     * _.toString(-0);\n\t     * // => '-0'\n\t     *\n\t     * _.toString([1, 2, 3]);\n\t     * // => '1,2,3'\n\t     */\n\t    function toString(value) {\n\t      // Exit early for strings to avoid a performance hit in some environments.\n\t      if (typeof value == 'string') {\n\t        return value;\n\t      }\n\t      if (value == null) {\n\t        return '';\n\t      }\n\t      if (isSymbol(value)) {\n\t        return _Symbol ? symbolToString.call(value) : '';\n\t      }\n\t      var result = (value + '');\n\t      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n\t    }\n\t\n\t    /*------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * Assigns own enumerable properties of source objects to the destination\n\t     * object. Source objects are applied from left to right. Subsequent sources\n\t     * overwrite property assignments of previous sources.\n\t     *\n\t     * **Note:** This method mutates `object` and is loosely based on\n\t     * [`Object.assign`](https://mdn.io/Object/assign).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Object\n\t     * @param {Object} object The destination object.\n\t     * @param {...Object} [sources] The source objects.\n\t     * @returns {Object} Returns `object`.\n\t     * @example\n\t     *\n\t     * function Foo() {\n\t     *   this.c = 3;\n\t     * }\n\t     *\n\t     * function Bar() {\n\t     *   this.e = 5;\n\t     * }\n\t     *\n\t     * Foo.prototype.d = 4;\n\t     * Bar.prototype.f = 6;\n\t     *\n\t     * _.assign({ 'a': 1 }, new Foo, new Bar);\n\t     * // => { 'a': 1, 'c': 3, 'e': 5 }\n\t     */\n\t    var assign = createAssigner(function(object, source) {\n\t      copyObject(source, keys(source), object);\n\t    });\n\t\n\t    /**\n\t     * This method is like `_.assign` except that it iterates over own and\n\t     * inherited source properties.\n\t     *\n\t     * **Note:** This method mutates `object`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @alias extend\n\t     * @category Object\n\t     * @param {Object} object The destination object.\n\t     * @param {...Object} [sources] The source objects.\n\t     * @returns {Object} Returns `object`.\n\t     * @example\n\t     *\n\t     * function Foo() {\n\t     *   this.b = 2;\n\t     * }\n\t     *\n\t     * function Bar() {\n\t     *   this.d = 4;\n\t     * }\n\t     *\n\t     * Foo.prototype.c = 3;\n\t     * Bar.prototype.e = 5;\n\t     *\n\t     * _.assignIn({ 'a': 1 }, new Foo, new Bar);\n\t     * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5 }\n\t     */\n\t    var assignIn = createAssigner(function(object, source) {\n\t      copyObject(source, keysIn(source), object);\n\t    });\n\t\n\t    /**\n\t     * This method is like `_.assignIn` except that it accepts `customizer` which\n\t     * is invoked to produce the assigned values. If `customizer` returns `undefined`\n\t     * assignment is handled by the method instead. The `customizer` is invoked\n\t     * with five arguments: (objValue, srcValue, key, object, source).\n\t     *\n\t     * **Note:** This method mutates `object`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @alias extendWith\n\t     * @category Object\n\t     * @param {Object} object The destination object.\n\t     * @param {...Object} sources The source objects.\n\t     * @param {Function} [customizer] The function to customize assigned values.\n\t     * @returns {Object} Returns `object`.\n\t     * @example\n\t     *\n\t     * function customizer(objValue, srcValue) {\n\t     *   return _.isUndefined(objValue) ? srcValue : objValue;\n\t     * }\n\t     *\n\t     * var defaults = _.partialRight(_.assignInWith, customizer);\n\t     *\n\t     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });\n\t     * // => { 'a': 1, 'b': 2 }\n\t     */\n\t    var assignInWith = createAssigner(function(object, source, customizer) {\n\t      copyObjectWith(source, keysIn(source), object, customizer);\n\t    });\n\t\n\t    /**\n\t     * This method is like `_.assign` except that it accepts `customizer` which\n\t     * is invoked to produce the assigned values. If `customizer` returns `undefined`\n\t     * assignment is handled by the method instead. The `customizer` is invoked\n\t     * with five arguments: (objValue, srcValue, key, object, source).\n\t     *\n\t     * **Note:** This method mutates `object`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Object\n\t     * @param {Object} object The destination object.\n\t     * @param {...Object} sources The source objects.\n\t     * @param {Function} [customizer] The function to customize assigned values.\n\t     * @returns {Object} Returns `object`.\n\t     * @example\n\t     *\n\t     * function customizer(objValue, srcValue) {\n\t     *   return _.isUndefined(objValue) ? srcValue : objValue;\n\t     * }\n\t     *\n\t     * var defaults = _.partialRight(_.assignWith, customizer);\n\t     *\n\t     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });\n\t     * // => { 'a': 1, 'b': 2 }\n\t     */\n\t    var assignWith = createAssigner(function(object, source, customizer) {\n\t      copyObjectWith(source, keys(source), object, customizer);\n\t    });\n\t\n\t    /**\n\t     * Creates an array of values corresponding to `paths` of `object`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Object\n\t     * @param {Object} object The object to iterate over.\n\t     * @param {...(string|string[])} [paths] The property paths of elements to pick,\n\t     *  specified individually or in arrays.\n\t     * @returns {Array} Returns the new array of picked elements.\n\t     * @example\n\t     *\n\t     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };\n\t     *\n\t     * _.at(object, ['a[0].b.c', 'a[1]']);\n\t     * // => [3, 4]\n\t     *\n\t     * _.at(['a', 'b', 'c'], 0, 2);\n\t     * // => ['a', 'c']\n\t     */\n\t    var at = rest(function(object, paths) {\n\t      return baseAt(object, baseFlatten(paths));\n\t    });\n\t\n\t    /**\n\t     * Creates an object that inherits from the `prototype` object. If a `properties`\n\t     * object is provided its own enumerable properties are assigned to the created object.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Object\n\t     * @param {Object} prototype The object to inherit from.\n\t     * @param {Object} [properties] The properties to assign to the object.\n\t     * @returns {Object} Returns the new object.\n\t     * @example\n\t     *\n\t     * function Shape() {\n\t     *   this.x = 0;\n\t     *   this.y = 0;\n\t     * }\n\t     *\n\t     * function Circle() {\n\t     *   Shape.call(this);\n\t     * }\n\t     *\n\t     * Circle.prototype = _.create(Shape.prototype, {\n\t     *   'constructor': Circle\n\t     * });\n\t     *\n\t     * var circle = new Circle;\n\t     * circle instanceof Circle;\n\t     * // => true\n\t     *\n\t     * circle instanceof Shape;\n\t     * // => true\n\t     */\n\t    function create(prototype, properties) {\n\t      var result = baseCreate(prototype);\n\t      return properties ? baseAssign(result, properties) : result;\n\t    }\n\t\n\t    /**\n\t     * Assigns own and inherited enumerable properties of source objects to the\n\t     * destination object for all destination properties that resolve to `undefined`.\n\t     * Source objects are applied from left to right. Once a property is set,\n\t     * additional values of the same property are ignored.\n\t     *\n\t     * **Note:** This method mutates `object`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Object\n\t     * @param {Object} object The destination object.\n\t     * @param {...Object} [sources] The source objects.\n\t     * @returns {Object} Returns `object`.\n\t     * @example\n\t     *\n\t     * _.defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });\n\t     * // => { 'user': 'barney', 'age': 36 }\n\t     */\n\t    var defaults = rest(function(args) {\n\t      args.push(undefined, assignInDefaults);\n\t      return apply(assignInWith, undefined, args);\n\t    });\n\t\n\t    /**\n\t     * This method is like `_.defaults` except that it recursively assigns\n\t     * default properties.\n\t     *\n\t     * **Note:** This method mutates `object`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Object\n\t     * @param {Object} object The destination object.\n\t     * @param {...Object} [sources] The source objects.\n\t     * @returns {Object} Returns `object`.\n\t     * @example\n\t     *\n\t     * _.defaultsDeep({ 'user': { 'name': 'barney' } }, { 'user': { 'name': 'fred', 'age': 36 } });\n\t     * // => { 'user': { 'name': 'barney', 'age': 36 } }\n\t     *\n\t     */\n\t    var defaultsDeep = rest(function(args) {\n\t      args.push(undefined, mergeDefaults);\n\t      return apply(mergeWith, undefined, args);\n\t    });\n\t\n\t    /**\n\t     * This method is like `_.find` except that it returns the key of the first\n\t     * element `predicate` returns truthy for instead of the element itself.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Object\n\t     * @param {Object} object The object to search.\n\t     * @param {Function|Object|string} [predicate=_.identity] The function invoked per iteration.\n\t     * @returns {string|undefined} Returns the key of the matched element, else `undefined`.\n\t     * @example\n\t     *\n\t     * var users = {\n\t     *   'barney':  { 'age': 36, 'active': true },\n\t     *   'fred':    { 'age': 40, 'active': false },\n\t     *   'pebbles': { 'age': 1,  'active': true }\n\t     * };\n\t     *\n\t     * _.findKey(users, function(o) { return o.age < 40; });\n\t     * // => 'barney' (iteration order is not guaranteed)\n\t     *\n\t     * // using the `_.matches` iteratee shorthand\n\t     * _.findKey(users, { 'age': 1, 'active': true });\n\t     * // => 'pebbles'\n\t     *\n\t     * // using the `_.matchesProperty` iteratee shorthand\n\t     * _.findKey(users, ['active', false]);\n\t     * // => 'fred'\n\t     *\n\t     * // using the `_.property` iteratee shorthand\n\t     * _.findKey(users, 'active');\n\t     * // => 'barney'\n\t     */\n\t    function findKey(object, predicate) {\n\t      return baseFind(object, getIteratee(predicate, 3), baseForOwn, true);\n\t    }\n\t\n\t    /**\n\t     * This method is like `_.findKey` except that it iterates over elements of\n\t     * a collection in the opposite order.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Object\n\t     * @param {Object} object The object to search.\n\t     * @param {Function|Object|string} [predicate=_.identity] The function invoked per iteration.\n\t     * @returns {string|undefined} Returns the key of the matched element, else `undefined`.\n\t     * @example\n\t     *\n\t     * var users = {\n\t     *   'barney':  { 'age': 36, 'active': true },\n\t     *   'fred':    { 'age': 40, 'active': false },\n\t     *   'pebbles': { 'age': 1,  'active': true }\n\t     * };\n\t     *\n\t     * _.findLastKey(users, function(o) { return o.age < 40; });\n\t     * // => returns 'pebbles' assuming `_.findKey` returns 'barney'\n\t     *\n\t     * // using the `_.matches` iteratee shorthand\n\t     * _.findLastKey(users, { 'age': 36, 'active': true });\n\t     * // => 'barney'\n\t     *\n\t     * // using the `_.matchesProperty` iteratee shorthand\n\t     * _.findLastKey(users, ['active', false]);\n\t     * // => 'fred'\n\t     *\n\t     * // using the `_.property` iteratee shorthand\n\t     * _.findLastKey(users, 'active');\n\t     * // => 'pebbles'\n\t     */\n\t    function findLastKey(object, predicate) {\n\t      return baseFind(object, getIteratee(predicate, 3), baseForOwnRight, true);\n\t    }\n\t\n\t    /**\n\t     * Iterates over own and inherited enumerable properties of an object invoking\n\t     * `iteratee` for each property. The iteratee is invoked with three arguments:\n\t     * (value, key, object). Iteratee functions may exit iteration early by explicitly\n\t     * returning `false`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Object\n\t     * @param {Object} object The object to iterate over.\n\t     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n\t     * @returns {Object} Returns `object`.\n\t     * @example\n\t     *\n\t     * function Foo() {\n\t     *   this.a = 1;\n\t     *   this.b = 2;\n\t     * }\n\t     *\n\t     * Foo.prototype.c = 3;\n\t     *\n\t     * _.forIn(new Foo, function(value, key) {\n\t     *   console.log(key);\n\t     * });\n\t     * // => logs 'a', 'b', then 'c' (iteration order is not guaranteed)\n\t     */\n\t    function forIn(object, iteratee) {\n\t      return object == null ? object : baseFor(object, toFunction(iteratee), keysIn);\n\t    }\n\t\n\t    /**\n\t     * This method is like `_.forIn` except that it iterates over properties of\n\t     * `object` in the opposite order.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Object\n\t     * @param {Object} object The object to iterate over.\n\t     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n\t     * @returns {Object} Returns `object`.\n\t     * @example\n\t     *\n\t     * function Foo() {\n\t     *   this.a = 1;\n\t     *   this.b = 2;\n\t     * }\n\t     *\n\t     * Foo.prototype.c = 3;\n\t     *\n\t     * _.forInRight(new Foo, function(value, key) {\n\t     *   console.log(key);\n\t     * });\n\t     * // => logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'\n\t     */\n\t    function forInRight(object, iteratee) {\n\t      return object == null ? object : baseForRight(object, toFunction(iteratee), keysIn);\n\t    }\n\t\n\t    /**\n\t     * Iterates over own enumerable properties of an object invoking `iteratee`\n\t     * for each property. The iteratee is invoked with three arguments:\n\t     * (value, key, object). Iteratee functions may exit iteration early by\n\t     * explicitly returning `false`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Object\n\t     * @param {Object} object The object to iterate over.\n\t     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n\t     * @returns {Object} Returns `object`.\n\t     * @example\n\t     *\n\t     * function Foo() {\n\t     *   this.a = 1;\n\t     *   this.b = 2;\n\t     * }\n\t     *\n\t     * Foo.prototype.c = 3;\n\t     *\n\t     * _.forOwn(new Foo, function(value, key) {\n\t     *   console.log(key);\n\t     * });\n\t     * // => logs 'a' then 'b' (iteration order is not guaranteed)\n\t     */\n\t    function forOwn(object, iteratee) {\n\t      return object && baseForOwn(object, toFunction(iteratee));\n\t    }\n\t\n\t    /**\n\t     * This method is like `_.forOwn` except that it iterates over properties of\n\t     * `object` in the opposite order.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Object\n\t     * @param {Object} object The object to iterate over.\n\t     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n\t     * @returns {Object} Returns `object`.\n\t     * @example\n\t     *\n\t     * function Foo() {\n\t     *   this.a = 1;\n\t     *   this.b = 2;\n\t     * }\n\t     *\n\t     * Foo.prototype.c = 3;\n\t     *\n\t     * _.forOwnRight(new Foo, function(value, key) {\n\t     *   console.log(key);\n\t     * });\n\t     * // => logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'\n\t     */\n\t    function forOwnRight(object, iteratee) {\n\t      return object && baseForOwnRight(object, toFunction(iteratee));\n\t    }\n\t\n\t    /**\n\t     * Creates an array of function property names from own enumerable properties\n\t     * of `object`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Object\n\t     * @param {Object} object The object to inspect.\n\t     * @returns {Array} Returns the new array of property names.\n\t     * @example\n\t     *\n\t     * function Foo() {\n\t     *   this.a = _.constant('a');\n\t     *   this.b = _.constant('b');\n\t     * }\n\t     *\n\t     * Foo.prototype.c = _.constant('c');\n\t     *\n\t     * _.functions(new Foo);\n\t     * // => ['a', 'b']\n\t     */\n\t    function functions(object) {\n\t      return object == null ? [] : baseFunctions(object, keys(object));\n\t    }\n\t\n\t    /**\n\t     * Creates an array of function property names from own and inherited\n\t     * enumerable properties of `object`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Object\n\t     * @param {Object} object The object to inspect.\n\t     * @returns {Array} Returns the new array of property names.\n\t     * @example\n\t     *\n\t     * function Foo() {\n\t     *   this.a = _.constant('a');\n\t     *   this.b = _.constant('b');\n\t     * }\n\t     *\n\t     * Foo.prototype.c = _.constant('c');\n\t     *\n\t     * _.functionsIn(new Foo);\n\t     * // => ['a', 'b', 'c']\n\t     */\n\t    function functionsIn(object) {\n\t      return object == null ? [] : baseFunctions(object, keysIn(object));\n\t    }\n\t\n\t    /**\n\t     * Gets the value at `path` of `object`. If the resolved value is\n\t     * `undefined` the `defaultValue` is used in its place.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Object\n\t     * @param {Object} object The object to query.\n\t     * @param {Array|string} path The path of the property to get.\n\t     * @param {*} [defaultValue] The value returned if the resolved value is `undefined`.\n\t     * @returns {*} Returns the resolved value.\n\t     * @example\n\t     *\n\t     * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n\t     *\n\t     * _.get(object, 'a[0].b.c');\n\t     * // => 3\n\t     *\n\t     * _.get(object, ['a', '0', 'b', 'c']);\n\t     * // => 3\n\t     *\n\t     * _.get(object, 'a.b.c', 'default');\n\t     * // => 'default'\n\t     */\n\t    function get(object, path, defaultValue) {\n\t      var result = object == null ? undefined : baseGet(object, path);\n\t      return result === undefined ? defaultValue : result;\n\t    }\n\t\n\t    /**\n\t     * Checks if `path` is a direct property of `object`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Object\n\t     * @param {Object} object The object to query.\n\t     * @param {Array|string} path The path to check.\n\t     * @returns {boolean} Returns `true` if `path` exists, else `false`.\n\t     * @example\n\t     *\n\t     * var object = { 'a': { 'b': { 'c': 3 } } };\n\t     * var other = _.create({ 'a': _.create({ 'b': _.create({ 'c': 3 }) }) });\n\t     *\n\t     * _.has(object, 'a');\n\t     * // => true\n\t     *\n\t     * _.has(object, 'a.b.c');\n\t     * // => true\n\t     *\n\t     * _.has(object, ['a', 'b', 'c']);\n\t     * // => true\n\t     *\n\t     * _.has(other, 'a');\n\t     * // => false\n\t     */\n\t    function has(object, path) {\n\t      return hasPath(object, path, baseHas);\n\t    }\n\t\n\t    /**\n\t     * Checks if `path` is a direct or inherited property of `object`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Object\n\t     * @param {Object} object The object to query.\n\t     * @param {Array|string} path The path to check.\n\t     * @returns {boolean} Returns `true` if `path` exists, else `false`.\n\t     * @example\n\t     *\n\t     * var object = _.create({ 'a': _.create({ 'b': _.create({ 'c': 3 }) }) });\n\t     *\n\t     * _.hasIn(object, 'a');\n\t     * // => true\n\t     *\n\t     * _.hasIn(object, 'a.b.c');\n\t     * // => true\n\t     *\n\t     * _.hasIn(object, ['a', 'b', 'c']);\n\t     * // => true\n\t     *\n\t     * _.hasIn(object, 'b');\n\t     * // => false\n\t     */\n\t    function hasIn(object, path) {\n\t      return hasPath(object, path, baseHasIn);\n\t    }\n\t\n\t    /**\n\t     * Creates an object composed of the inverted keys and values of `object`.\n\t     * If `object` contains duplicate values, subsequent values overwrite property\n\t     * assignments of previous values unless `multiVal` is `true`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Object\n\t     * @param {Object} object The object to invert.\n\t     * @param {boolean} [multiVal] Allow multiple values per key.\n\t     * @param- {Object} [guard] Enables use as an iteratee for functions like `_.map`.\n\t     * @returns {Object} Returns the new inverted object.\n\t     * @example\n\t     *\n\t     * var object = { 'a': 1, 'b': 2, 'c': 1 };\n\t     *\n\t     * _.invert(object);\n\t     * // => { '1': 'c', '2': 'b' }\n\t     *\n\t     * // with `multiVal`\n\t     * _.invert(object, true);\n\t     * // => { '1': ['a', 'c'], '2': ['b'] }\n\t     */\n\t    function invert(object, multiVal, guard) {\n\t      return arrayReduce(keys(object), function(result, key) {\n\t        var value = object[key];\n\t        if (multiVal && !guard) {\n\t          if (hasOwnProperty.call(result, value)) {\n\t            result[value].push(key);\n\t          } else {\n\t            result[value] = [key];\n\t          }\n\t        }\n\t        else {\n\t          result[value] = key;\n\t        }\n\t        return result;\n\t      }, {});\n\t    }\n\t\n\t    /**\n\t     * Invokes the method at `path` of `object`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Object\n\t     * @param {Object} object The object to query.\n\t     * @param {Array|string} path The path of the method to invoke.\n\t     * @param {...*} [args] The arguments to invoke the method with.\n\t     * @returns {*} Returns the result of the invoked method.\n\t     * @example\n\t     *\n\t     * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };\n\t     *\n\t     * _.invoke(object, 'a[0].b.c.slice', 1, 3);\n\t     * // => [2, 3]\n\t     */\n\t    var invoke = rest(baseInvoke);\n\t\n\t    /**\n\t     * Creates an array of the own enumerable property names of `object`.\n\t     *\n\t     * **Note:** Non-object values are coerced to objects. See the\n\t     * [ES spec](http://ecma-international.org/ecma-262/6.0/#sec-object.keys)\n\t     * for more details.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Object\n\t     * @param {Object} object The object to query.\n\t     * @returns {Array} Returns the array of property names.\n\t     * @example\n\t     *\n\t     * function Foo() {\n\t     *   this.a = 1;\n\t     *   this.b = 2;\n\t     * }\n\t     *\n\t     * Foo.prototype.c = 3;\n\t     *\n\t     * _.keys(new Foo);\n\t     * // => ['a', 'b'] (iteration order is not guaranteed)\n\t     *\n\t     * _.keys('hi');\n\t     * // => ['0', '1']\n\t     */\n\t    function keys(object) {\n\t      var isProto = isPrototype(object);\n\t      if (!(isProto || isArrayLike(object))) {\n\t        return baseKeys(object);\n\t      }\n\t      var indexes = indexKeys(object),\n\t          skipIndexes = !!indexes,\n\t          result = indexes || [],\n\t          length = result.length;\n\t\n\t      for (var key in object) {\n\t        if (baseHas(object, key) &&\n\t            !(skipIndexes && (key == 'length' || isIndex(key, length))) &&\n\t            !(isProto && key == 'constructor')) {\n\t          result.push(key);\n\t        }\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * Creates an array of the own and inherited enumerable property names of `object`.\n\t     *\n\t     * **Note:** Non-object values are coerced to objects.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Object\n\t     * @param {Object} object The object to query.\n\t     * @returns {Array} Returns the array of property names.\n\t     * @example\n\t     *\n\t     * function Foo() {\n\t     *   this.a = 1;\n\t     *   this.b = 2;\n\t     * }\n\t     *\n\t     * Foo.prototype.c = 3;\n\t     *\n\t     * _.keysIn(new Foo);\n\t     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\n\t     */\n\t    function keysIn(object) {\n\t      var index = -1,\n\t          isProto = isPrototype(object),\n\t          props = baseKeysIn(object),\n\t          propsLength = props.length,\n\t          indexes = indexKeys(object),\n\t          skipIndexes = !!indexes,\n\t          result = indexes || [],\n\t          length = result.length;\n\t\n\t      while (++index < propsLength) {\n\t        var key = props[index];\n\t        if (!(skipIndexes && (key == 'length' || isIndex(key, length))) &&\n\t            !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {\n\t          result.push(key);\n\t        }\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * The opposite of `_.mapValues`; this method creates an object with the\n\t     * same values as `object` and keys generated by running each own enumerable\n\t     * property of `object` through `iteratee`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Object\n\t     * @param {Object} object The object to iterate over.\n\t     * @param {Function|Object|string} [iteratee=_.identity] The function invoked per iteration.\n\t     * @returns {Object} Returns the new mapped object.\n\t     * @example\n\t     *\n\t     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {\n\t     *   return key + value;\n\t     * });\n\t     * // => { 'a1': 1, 'b2': 2 }\n\t     */\n\t    function mapKeys(object, iteratee) {\n\t      var result = {};\n\t      iteratee = getIteratee(iteratee, 3);\n\t\n\t      baseForOwn(object, function(value, key, object) {\n\t        result[iteratee(value, key, object)] = value;\n\t      });\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * Creates an object with the same keys as `object` and values generated by\n\t     * running each own enumerable property of `object` through `iteratee`. The\n\t     * iteratee function is invoked with three arguments: (value, key, object).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Object\n\t     * @param {Object} object The object to iterate over.\n\t     * @param {Function|Object|string} [iteratee=_.identity] The function invoked per iteration.\n\t     * @returns {Object} Returns the new mapped object.\n\t     * @example\n\t     *\n\t     * var users = {\n\t     *   'fred':    { 'user': 'fred',    'age': 40 },\n\t     *   'pebbles': { 'user': 'pebbles', 'age': 1 }\n\t     * };\n\t     *\n\t     * _.mapValues(users, function(o) { return o.age; });\n\t     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)\n\t     *\n\t     * // using the `_.property` iteratee shorthand\n\t     * _.mapValues(users, 'age');\n\t     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)\n\t     */\n\t    function mapValues(object, iteratee) {\n\t      var result = {};\n\t      iteratee = getIteratee(iteratee, 3);\n\t\n\t      baseForOwn(object, function(value, key, object) {\n\t        result[key] = iteratee(value, key, object);\n\t      });\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * Recursively merges own and inherited enumerable properties of source\n\t     * objects into the destination object, skipping source properties that resolve\n\t     * to `undefined`. Array and plain object properties are merged recursively.\n\t     * Other objects and value types are overridden by assignment. Source objects\n\t     * are applied from left to right. Subsequent sources overwrite property\n\t     * assignments of previous sources.\n\t     *\n\t     * **Note:** This method mutates `object`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Object\n\t     * @param {Object} object The destination object.\n\t     * @param {...Object} [sources] The source objects.\n\t     * @returns {Object} Returns `object`.\n\t     * @example\n\t     *\n\t     * var users = {\n\t     *   'data': [{ 'user': 'barney' }, { 'user': 'fred' }]\n\t     * };\n\t     *\n\t     * var ages = {\n\t     *   'data': [{ 'age': 36 }, { 'age': 40 }]\n\t     * };\n\t     *\n\t     * _.merge(users, ages);\n\t     * // => { 'data': [{ 'user': 'barney', 'age': 36 }, { 'user': 'fred', 'age': 40 }] }\n\t     */\n\t    var merge = createAssigner(function(object, source) {\n\t      baseMerge(object, source);\n\t    });\n\t\n\t    /**\n\t     * This method is like `_.merge` except that it accepts `customizer` which\n\t     * is invoked to produce the merged values of the destination and source\n\t     * properties. If `customizer` returns `undefined` merging is handled by the\n\t     * method instead. The `customizer` is invoked with seven arguments:\n\t     * (objValue, srcValue, key, object, source, stack).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Object\n\t     * @param {Object} object The destination object.\n\t     * @param {...Object} sources The source objects.\n\t     * @param {Function} customizer The function to customize assigned values.\n\t     * @returns {Object} Returns `object`.\n\t     * @example\n\t     *\n\t     * function customizer(objValue, srcValue) {\n\t     *   if (_.isArray(objValue)) {\n\t     *     return objValue.concat(srcValue);\n\t     *   }\n\t     * }\n\t     *\n\t     * var object = {\n\t     *   'fruits': ['apple'],\n\t     *   'vegetables': ['beet']\n\t     * };\n\t     *\n\t     * var other = {\n\t     *   'fruits': ['banana'],\n\t     *   'vegetables': ['carrot']\n\t     * };\n\t     *\n\t     * _.mergeWith(object, other, customizer);\n\t     * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot'] }\n\t     */\n\t    var mergeWith = createAssigner(function(object, source, customizer) {\n\t      baseMerge(object, source, customizer);\n\t    });\n\t\n\t    /**\n\t     * The opposite of `_.pick`; this method creates an object composed of the\n\t     * own and inherited enumerable properties of `object` that are not omitted.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Object\n\t     * @param {Object} object The source object.\n\t     * @param {...(string|string[])} [props] The property names to omit, specified\n\t     *  individually or in arrays..\n\t     * @returns {Object} Returns the new object.\n\t     * @example\n\t     *\n\t     * var object = { 'a': 1, 'b': '2', 'c': 3 };\n\t     *\n\t     * _.omit(object, ['a', 'c']);\n\t     * // => { 'b': '2' }\n\t     */\n\t    var omit = rest(function(object, props) {\n\t      if (object == null) {\n\t        return {};\n\t      }\n\t      props = arrayMap(baseFlatten(props), String);\n\t      return basePick(object, baseDifference(keysIn(object), props));\n\t    });\n\t\n\t    /**\n\t     * The opposite of `_.pickBy`; this method creates an object composed of the\n\t     * own and inherited enumerable properties of `object` that `predicate`\n\t     * doesn't return truthy for.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Object\n\t     * @param {Object} object The source object.\n\t     * @param {Function|Object|string} [predicate=_.identity] The function invoked per property.\n\t     * @returns {Object} Returns the new object.\n\t     * @example\n\t     *\n\t     * var object = { 'a': 1, 'b': '2', 'c': 3 };\n\t     *\n\t     * _.omitBy(object, _.isNumber);\n\t     * // => { 'b': '2' }\n\t     */\n\t    function omitBy(object, predicate) {\n\t      predicate = getIteratee(predicate);\n\t      return basePickBy(object, function(value) {\n\t        return !predicate(value);\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Creates an object composed of the picked `object` properties.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Object\n\t     * @param {Object} object The source object.\n\t     * @param {...(string|string[])} [props] The property names to pick, specified\n\t     *  individually or in arrays.\n\t     * @returns {Object} Returns the new object.\n\t     * @example\n\t     *\n\t     * var object = { 'a': 1, 'b': '2', 'c': 3 };\n\t     *\n\t     * _.pick(object, ['a', 'c']);\n\t     * // => { 'a': 1, 'c': 3 }\n\t     */\n\t    var pick = rest(function(object, props) {\n\t      return object == null ? {} : basePick(object, baseFlatten(props));\n\t    });\n\t\n\t    /**\n\t     * Creates an object composed of the `object` properties `predicate` returns\n\t     * truthy for. The predicate is invoked with one argument: (value).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Object\n\t     * @param {Object} object The source object.\n\t     * @param {Function|Object|string} [predicate=_.identity] The function invoked per property.\n\t     * @returns {Object} Returns the new object.\n\t     * @example\n\t     *\n\t     * var object = { 'a': 1, 'b': '2', 'c': 3 };\n\t     *\n\t     * _.pickBy(object, _.isNumber);\n\t     * // => { 'a': 1, 'c': 3 }\n\t     */\n\t    function pickBy(object, predicate) {\n\t      return object == null ? {} : basePickBy(object, getIteratee(predicate));\n\t    }\n\t\n\t    /**\n\t     * This method is like `_.get` except that if the resolved value is a function\n\t     * it's invoked with the `this` binding of its parent object and its result\n\t     * is returned.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Object\n\t     * @param {Object} object The object to query.\n\t     * @param {Array|string} path The path of the property to resolve.\n\t     * @param {*} [defaultValue] The value returned if the resolved value is `undefined`.\n\t     * @returns {*} Returns the resolved value.\n\t     * @example\n\t     *\n\t     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };\n\t     *\n\t     * _.result(object, 'a[0].b.c1');\n\t     * // => 3\n\t     *\n\t     * _.result(object, 'a[0].b.c2');\n\t     * // => 4\n\t     *\n\t     * _.result(object, 'a[0].b.c3', 'default');\n\t     * // => 'default'\n\t     *\n\t     * _.result(object, 'a[0].b.c3', _.constant('default'));\n\t     * // => 'default'\n\t     */\n\t    function result(object, path, defaultValue) {\n\t      if (!isKey(path, object)) {\n\t        path = baseToPath(path);\n\t        var result = get(object, path);\n\t        object = parent(object, path);\n\t      } else {\n\t        result = object == null ? undefined : object[path];\n\t      }\n\t      if (result === undefined) {\n\t        result = defaultValue;\n\t      }\n\t      return isFunction(result) ? result.call(object) : result;\n\t    }\n\t\n\t    /**\n\t     * Sets the value at `path` of `object`. If a portion of `path` doesn't exist\n\t     * it's created. Arrays are created for missing index properties while objects\n\t     * are created for all other missing properties. Use `_.setWith` to customize\n\t     * `path` creation.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Object\n\t     * @param {Object} object The object to modify.\n\t     * @param {Array|string} path The path of the property to set.\n\t     * @param {*} value The value to set.\n\t     * @returns {Object} Returns `object`.\n\t     * @example\n\t     *\n\t     * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n\t     *\n\t     * _.set(object, 'a[0].b.c', 4);\n\t     * console.log(object.a[0].b.c);\n\t     * // => 4\n\t     *\n\t     * _.set(object, 'x[0].y.z', 5);\n\t     * console.log(object.x[0].y.z);\n\t     * // => 5\n\t     */\n\t    function set(object, path, value) {\n\t      return object == null ? object : baseSet(object, path, value);\n\t    }\n\t\n\t    /**\n\t     * This method is like `_.set` except that it accepts `customizer` which is\n\t     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`\n\t     * path creation is handled by the method instead. The `customizer` is invoked\n\t     * with three arguments: (nsValue, key, nsObject).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Object\n\t     * @param {Object} object The object to modify.\n\t     * @param {Array|string} path The path of the property to set.\n\t     * @param {*} value The value to set.\n\t     * @param {Function} [customizer] The function to customize assigned values.\n\t     * @returns {Object} Returns `object`.\n\t     * @example\n\t     *\n\t     * _.setWith({ '0': { 'length': 2 } }, '[0][1][2]', 3, Object);\n\t     * // => { '0': { '1': { '2': 3 }, 'length': 2 } }\n\t     */\n\t    function setWith(object, path, value, customizer) {\n\t      customizer = typeof customizer == 'function' ? customizer : undefined;\n\t      return object == null ? object : baseSet(object, path, value, customizer);\n\t    }\n\t\n\t    /**\n\t     * Creates an array of own enumerable key-value pairs for `object`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Object\n\t     * @param {Object} object The object to query.\n\t     * @returns {Array} Returns the new array of key-value pairs.\n\t     * @example\n\t     *\n\t     * function Foo() {\n\t     *   this.a = 1;\n\t     *   this.b = 2;\n\t     * }\n\t     *\n\t     * Foo.prototype.c = 3;\n\t     *\n\t     * _.toPairs(new Foo);\n\t     * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)\n\t     */\n\t    function toPairs(object) {\n\t      return baseToPairs(object, keys(object));\n\t    }\n\t\n\t    /**\n\t     * Creates an array of own and inherited enumerable key-value pairs for `object`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Object\n\t     * @param {Object} object The object to query.\n\t     * @returns {Array} Returns the new array of key-value pairs.\n\t     * @example\n\t     *\n\t     * function Foo() {\n\t     *   this.a = 1;\n\t     *   this.b = 2;\n\t     * }\n\t     *\n\t     * Foo.prototype.c = 3;\n\t     *\n\t     * _.toPairsIn(new Foo);\n\t     * // => [['a', 1], ['b', 2], ['c', 1]] (iteration order is not guaranteed)\n\t     */\n\t    function toPairsIn(object) {\n\t      return baseToPairs(object, keysIn(object));\n\t    }\n\t\n\t    /**\n\t     * An alternative to `_.reduce`; this method transforms `object` to a new\n\t     * `accumulator` object which is the result of running each of its own enumerable\n\t     * properties through `iteratee`, with each invocation potentially mutating\n\t     * the `accumulator` object. The iteratee is invoked with four arguments:\n\t     * (accumulator, value, key, object). Iteratee functions may exit iteration\n\t     * early by explicitly returning `false`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Object\n\t     * @param {Array|Object} object The object to iterate over.\n\t     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n\t     * @param {*} [accumulator] The custom accumulator value.\n\t     * @returns {*} Returns the accumulated value.\n\t     * @example\n\t     *\n\t     * _.transform([2, 3, 4], function(result, n) {\n\t     *   result.push(n *= n);\n\t     *   return n % 2 == 0;\n\t     * });\n\t     * // => [4, 9]\n\t     *\n\t     * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {\n\t     *   (result[value] || (result[value] = [])).push(key);\n\t     * });\n\t     * // => { '1': ['a', 'c'], '2': ['b'] }\n\t     */\n\t    function transform(object, iteratee, accumulator) {\n\t      var isArr = isArray(object) || isTypedArray(object);\n\t      iteratee = getIteratee(iteratee, 4);\n\t\n\t      if (accumulator == null) {\n\t        if (isArr || isObject(object)) {\n\t          var Ctor = object.constructor;\n\t          if (isArr) {\n\t            accumulator = isArray(object) ? new Ctor : [];\n\t          } else {\n\t            accumulator = baseCreate(isFunction(Ctor) ? Ctor.prototype : undefined);\n\t          }\n\t        } else {\n\t          accumulator = {};\n\t        }\n\t      }\n\t      (isArr ? arrayEach : baseForOwn)(object, function(value, index, object) {\n\t        return iteratee(accumulator, value, index, object);\n\t      });\n\t      return accumulator;\n\t    }\n\t\n\t    /**\n\t     * Removes the property at `path` of `object`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Object\n\t     * @param {Object} object The object to modify.\n\t     * @param {Array|string} path The path of the property to unset.\n\t     * @returns {boolean} Returns `true` if the property is deleted, else `false`.\n\t     * @example\n\t     *\n\t     * var object = { 'a': [{ 'b': { 'c': 7 } }] };\n\t     * _.unset(object, 'a[0].b.c');\n\t     * // => true\n\t     *\n\t     * console.log(object);\n\t     * // => { 'a': [{ 'b': {} }] };\n\t     *\n\t     * _.unset(object, 'a[0].b.c');\n\t     * // => true\n\t     *\n\t     * console.log(object);\n\t     * // => { 'a': [{ 'b': {} }] };\n\t     */\n\t    function unset(object, path) {\n\t      return object == null ? true : baseUnset(object, path);\n\t    }\n\t\n\t    /**\n\t     * Creates an array of the own enumerable property values of `object`.\n\t     *\n\t     * **Note:** Non-object values are coerced to objects.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Object\n\t     * @param {Object} object The object to query.\n\t     * @returns {Array} Returns the array of property values.\n\t     * @example\n\t     *\n\t     * function Foo() {\n\t     *   this.a = 1;\n\t     *   this.b = 2;\n\t     * }\n\t     *\n\t     * Foo.prototype.c = 3;\n\t     *\n\t     * _.values(new Foo);\n\t     * // => [1, 2] (iteration order is not guaranteed)\n\t     *\n\t     * _.values('hi');\n\t     * // => ['h', 'i']\n\t     */\n\t    function values(object) {\n\t      return object ? baseValues(object, keys(object)) : [];\n\t    }\n\t\n\t    /**\n\t     * Creates an array of the own and inherited enumerable property values of `object`.\n\t     *\n\t     * **Note:** Non-object values are coerced to objects.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Object\n\t     * @param {Object} object The object to query.\n\t     * @returns {Array} Returns the array of property values.\n\t     * @example\n\t     *\n\t     * function Foo() {\n\t     *   this.a = 1;\n\t     *   this.b = 2;\n\t     * }\n\t     *\n\t     * Foo.prototype.c = 3;\n\t     *\n\t     * _.valuesIn(new Foo);\n\t     * // => [1, 2, 3] (iteration order is not guaranteed)\n\t     */\n\t    function valuesIn(object) {\n\t      return object == null ? baseValues(object, keysIn(object)) : [];\n\t    }\n\t\n\t    /*------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * Clamps `number` within the inclusive `lower` and `upper` bounds.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Number\n\t     * @param {number} number The number to clamp.\n\t     * @param {number} [lower] The lower bound.\n\t     * @param {number} upper The upper bound.\n\t     * @returns {number} Returns the clamped number.\n\t     * @example\n\t     *\n\t     * _.clamp(-10, -5, 5);\n\t     * // => -5\n\t     *\n\t     * _.clamp(10, -5, 5);\n\t     * // => 5\n\t     */\n\t    function clamp(number, lower, upper) {\n\t      if (upper === undefined) {\n\t        upper = lower;\n\t        lower = undefined;\n\t      }\n\t      if (upper !== undefined) {\n\t        upper = toNumber(upper);\n\t        upper = upper === upper ? upper : 0;\n\t      }\n\t      if (lower !== undefined) {\n\t        lower = toNumber(lower);\n\t        lower = lower === lower ? lower : 0;\n\t      }\n\t      return baseClamp(toNumber(number), lower, upper);\n\t    }\n\t\n\t    /**\n\t     * Checks if `n` is between `start` and up to but not including, `end`. If\n\t     * `end` is not specified it's set to `start` with `start` then set to `0`.\n\t     * If `start` is greater than `end` the params are swapped to support\n\t     * negative ranges.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Number\n\t     * @param {number} number The number to check.\n\t     * @param {number} [start=0] The start of the range.\n\t     * @param {number} end The end of the range.\n\t     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.\n\t     * @example\n\t     *\n\t     * _.inRange(3, 2, 4);\n\t     * // => true\n\t     *\n\t     * _.inRange(4, 8);\n\t     * // => true\n\t     *\n\t     * _.inRange(4, 2);\n\t     * // => false\n\t     *\n\t     * _.inRange(2, 2);\n\t     * // => false\n\t     *\n\t     * _.inRange(1.2, 2);\n\t     * // => true\n\t     *\n\t     * _.inRange(5.2, 4);\n\t     * // => false\n\t     *\n\t     * _.inRange(-3, -2, -6);\n\t     * // => true\n\t     */\n\t    function inRange(number, start, end) {\n\t      start = toNumber(start) || 0;\n\t      if (end === undefined) {\n\t        end = start;\n\t        start = 0;\n\t      } else {\n\t        end = toNumber(end) || 0;\n\t      }\n\t      number = toNumber(number);\n\t      return baseInRange(number, start, end);\n\t    }\n\t\n\t    /**\n\t     * Produces a random number between the inclusive `lower` and `upper` bounds.\n\t     * If only one argument is provided a number between `0` and the given number\n\t     * is returned. If `floating` is `true`, or either `lower` or `upper` are floats,\n\t     * a floating-point number is returned instead of an integer.\n\t     *\n\t     * **Note:** JavaScript follows the IEEE-754 standard for resolving\n\t     * floating-point values which can produce unexpected results.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Number\n\t     * @param {number} [lower=0] The lower bound.\n\t     * @param {number} [upper=1] The upper bound.\n\t     * @param {boolean} [floating] Specify returning a floating-point number.\n\t     * @returns {number} Returns the random number.\n\t     * @example\n\t     *\n\t     * _.random(0, 5);\n\t     * // => an integer between 0 and 5\n\t     *\n\t     * _.random(5);\n\t     * // => also an integer between 0 and 5\n\t     *\n\t     * _.random(5, true);\n\t     * // => a floating-point number between 0 and 5\n\t     *\n\t     * _.random(1.2, 5.2);\n\t     * // => a floating-point number between 1.2 and 5.2\n\t     */\n\t    function random(lower, upper, floating) {\n\t      if (floating && typeof floating != 'boolean' && isIterateeCall(lower, upper, floating)) {\n\t        upper = floating = undefined;\n\t      }\n\t      if (floating === undefined) {\n\t        if (typeof upper == 'boolean') {\n\t          floating = upper;\n\t          upper = undefined;\n\t        }\n\t        else if (typeof lower == 'boolean') {\n\t          floating = lower;\n\t          lower = undefined;\n\t        }\n\t      }\n\t      if (lower === undefined && upper === undefined) {\n\t        lower = 0;\n\t        upper = 1;\n\t      }\n\t      else {\n\t        lower = toNumber(lower) || 0;\n\t        if (upper === undefined) {\n\t          upper = lower;\n\t          lower = 0;\n\t        } else {\n\t          upper = toNumber(upper) || 0;\n\t        }\n\t      }\n\t      if (lower > upper) {\n\t        var temp = lower;\n\t        lower = upper;\n\t        upper = temp;\n\t      }\n\t      if (floating || lower % 1 || upper % 1) {\n\t        var rand = nativeRandom();\n\t        return nativeMin(lower + (rand * (upper - lower + freeParseFloat('1e-' + ((rand + '').length - 1)))), upper);\n\t      }\n\t      return baseRandom(lower, upper);\n\t    }\n\t\n\t    /*------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category String\n\t     * @param {string} [string=''] The string to convert.\n\t     * @returns {string} Returns the camel cased string.\n\t     * @example\n\t     *\n\t     * _.camelCase('Foo Bar');\n\t     * // => 'fooBar'\n\t     *\n\t     * _.camelCase('--foo-bar');\n\t     * // => 'fooBar'\n\t     *\n\t     * _.camelCase('__foo_bar__');\n\t     * // => 'fooBar'\n\t     */\n\t    var camelCase = createCompounder(function(result, word, index) {\n\t      word = word.toLowerCase();\n\t      return result + (index ? capitalize(word) : word);\n\t    });\n\t\n\t    /**\n\t     * Converts the first character of `string` to upper case and the remaining\n\t     * to lower case.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category String\n\t     * @param {string} [string=''] The string to capitalize.\n\t     * @returns {string} Returns the capitalized string.\n\t     * @example\n\t     *\n\t     * _.capitalize('FRED');\n\t     * // => 'Fred'\n\t     */\n\t    function capitalize(string) {\n\t      return upperFirst(toString(string).toLowerCase());\n\t    }\n\t\n\t    /**\n\t     * Deburrs `string` by converting [latin-1 supplementary letters](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)\n\t     * to basic latin letters and removing [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category String\n\t     * @param {string} [string=''] The string to deburr.\n\t     * @returns {string} Returns the deburred string.\n\t     * @example\n\t     *\n\t     * _.deburr('déjà vu');\n\t     * // => 'deja vu'\n\t     */\n\t    function deburr(string) {\n\t      string = toString(string);\n\t      return string && string.replace(reLatin1, deburrLetter).replace(reComboMark, '');\n\t    }\n\t\n\t    /**\n\t     * Checks if `string` ends with the given target string.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category String\n\t     * @param {string} [string=''] The string to search.\n\t     * @param {string} [target] The string to search for.\n\t     * @param {number} [position=string.length] The position to search from.\n\t     * @returns {boolean} Returns `true` if `string` ends with `target`, else `false`.\n\t     * @example\n\t     *\n\t     * _.endsWith('abc', 'c');\n\t     * // => true\n\t     *\n\t     * _.endsWith('abc', 'b');\n\t     * // => false\n\t     *\n\t     * _.endsWith('abc', 'b', 2);\n\t     * // => true\n\t     */\n\t    function endsWith(string, target, position) {\n\t      string = toString(string);\n\t      target = typeof target == 'string' ? target : (target + '');\n\t\n\t      var length = string.length;\n\t      position = position === undefined\n\t        ? length\n\t        : baseClamp(toInteger(position), 0, length);\n\t\n\t      position -= target.length;\n\t      return position >= 0 && string.indexOf(target, position) == position;\n\t    }\n\t\n\t    /**\n\t     * Converts the characters \"&\", \"<\", \">\", '\"', \"'\", and \"\\`\" in `string` to\n\t     * their corresponding HTML entities.\n\t     *\n\t     * **Note:** No other characters are escaped. To escape additional\n\t     * characters use a third-party library like [_he_](https://mths.be/he).\n\t     *\n\t     * Though the \">\" character is escaped for symmetry, characters like\n\t     * \">\" and \"/\" don't need escaping in HTML and have no special meaning\n\t     * unless they're part of a tag or unquoted attribute value.\n\t     * See [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)\n\t     * (under \"semi-related fun fact\") for more details.\n\t     *\n\t     * Backticks are escaped because in IE < 9, they can break out of\n\t     * attribute values or HTML comments. See [#59](https://html5sec.org/#59),\n\t     * [#102](https://html5sec.org/#102), [#108](https://html5sec.org/#108), and\n\t     * [#133](https://html5sec.org/#133) of the [HTML5 Security Cheatsheet](https://html5sec.org/)\n\t     * for more details.\n\t     *\n\t     * When working with HTML you should always [quote attribute values](http://wonko.com/post/html-escaping)\n\t     * to reduce XSS vectors.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category String\n\t     * @param {string} [string=''] The string to escape.\n\t     * @returns {string} Returns the escaped string.\n\t     * @example\n\t     *\n\t     * _.escape('fred, barney, & pebbles');\n\t     * // => 'fred, barney, &amp; pebbles'\n\t     */\n\t    function escape(string) {\n\t      string = toString(string);\n\t      return (string && reHasUnescapedHtml.test(string))\n\t        ? string.replace(reUnescapedHtml, escapeHtmlChar)\n\t        : string;\n\t    }\n\t\n\t    /**\n\t     * Escapes the `RegExp` special characters \"^\", \"$\", \"\\\", \".\", \"*\", \"+\",\n\t     * \"?\", \"(\", \")\", \"[\", \"]\", \"{\", \"}\", and \"|\" in `string`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category String\n\t     * @param {string} [string=''] The string to escape.\n\t     * @returns {string} Returns the escaped string.\n\t     * @example\n\t     *\n\t     * _.escapeRegExp('[lodash](https://lodash.com/)');\n\t     * // => '\\[lodash\\]\\(https://lodash\\.com/\\)'\n\t     */\n\t    function escapeRegExp(string) {\n\t      string = toString(string);\n\t      return (string && reHasRegExpChar.test(string))\n\t        ? string.replace(reRegExpChar, '\\\\$&')\n\t        : string;\n\t    }\n\t\n\t    /**\n\t     * Converts `string` to [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category String\n\t     * @param {string} [string=''] The string to convert.\n\t     * @returns {string} Returns the kebab cased string.\n\t     * @example\n\t     *\n\t     * _.kebabCase('Foo Bar');\n\t     * // => 'foo-bar'\n\t     *\n\t     * _.kebabCase('fooBar');\n\t     * // => 'foo-bar'\n\t     *\n\t     * _.kebabCase('__foo_bar__');\n\t     * // => 'foo-bar'\n\t     */\n\t    var kebabCase = createCompounder(function(result, word, index) {\n\t      return result + (index ? '-' : '') + word.toLowerCase();\n\t    });\n\t\n\t    /**\n\t     * Converts `string`, as space separated words, to lower case.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category String\n\t     * @param {string} [string=''] The string to convert.\n\t     * @returns {string} Returns the lower cased string.\n\t     * @example\n\t     *\n\t     * _.lowerCase('--Foo-Bar');\n\t     * // => 'foo bar'\n\t     *\n\t     * _.lowerCase('fooBar');\n\t     * // => 'foo bar'\n\t     *\n\t     * _.lowerCase('__FOO_BAR__');\n\t     * // => 'foo bar'\n\t     */\n\t    var lowerCase = createCompounder(function(result, word, index) {\n\t      return result + (index ? ' ' : '') + word.toLowerCase();\n\t    });\n\t\n\t    /**\n\t     * Converts the first character of `string` to lower case.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category String\n\t     * @param {string} [string=''] The string to convert.\n\t     * @returns {string} Returns the converted string.\n\t     * @example\n\t     *\n\t     * _.lowerFirst('Fred');\n\t     * // => 'fred'\n\t     *\n\t     * _.lowerFirst('FRED');\n\t     * // => 'fRED'\n\t     */\n\t    var lowerFirst = createCaseFirst('toLowerCase');\n\t\n\t    /**\n\t     * Converts the first character of `string` to upper case.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category String\n\t     * @param {string} [string=''] The string to convert.\n\t     * @returns {string} Returns the converted string.\n\t     * @example\n\t     *\n\t     * _.upperFirst('fred');\n\t     * // => 'Fred'\n\t     *\n\t     * _.upperFirst('FRED');\n\t     * // => 'FRED'\n\t     */\n\t    var upperFirst = createCaseFirst('toUpperCase');\n\t\n\t    /**\n\t     * Pads `string` on the left and right sides if it's shorter than `length`.\n\t     * Padding characters are truncated if they can't be evenly divided by `length`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category String\n\t     * @param {string} [string=''] The string to pad.\n\t     * @param {number} [length=0] The padding length.\n\t     * @param {string} [chars=' '] The string used as padding.\n\t     * @returns {string} Returns the padded string.\n\t     * @example\n\t     *\n\t     * _.pad('abc', 8);\n\t     * // => '  abc   '\n\t     *\n\t     * _.pad('abc', 8, '_-');\n\t     * // => '_-abc_-_'\n\t     *\n\t     * _.pad('abc', 3);\n\t     * // => 'abc'\n\t     */\n\t    function pad(string, length, chars) {\n\t      string = toString(string);\n\t      length = toInteger(length);\n\t\n\t      var strLength = stringSize(string);\n\t      if (!length || strLength >= length) {\n\t        return string;\n\t      }\n\t      var mid = (length - strLength) / 2,\n\t          leftLength = nativeFloor(mid),\n\t          rightLength = nativeCeil(mid);\n\t\n\t      return createPadding('', leftLength, chars) + string + createPadding('', rightLength, chars);\n\t    }\n\t\n\t    /**\n\t     * Pads `string` on the right side if it's shorter than `length`. Padding\n\t     * characters are truncated if they exceed `length`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category String\n\t     * @param {string} [string=''] The string to pad.\n\t     * @param {number} [length=0] The padding length.\n\t     * @param {string} [chars=' '] The string used as padding.\n\t     * @returns {string} Returns the padded string.\n\t     * @example\n\t     *\n\t     * _.padEnd('abc', 6);\n\t     * // => 'abc   '\n\t     *\n\t     * _.padEnd('abc', 6, '_-');\n\t     * // => 'abc_-_'\n\t     *\n\t     * _.padEnd('abc', 3);\n\t     * // => 'abc'\n\t     */\n\t    function padEnd(string, length, chars) {\n\t      string = toString(string);\n\t      return string + createPadding(string, length, chars);\n\t    }\n\t\n\t    /**\n\t     * Pads `string` on the left side if it's shorter than `length`. Padding\n\t     * characters are truncated if they exceed `length`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category String\n\t     * @param {string} [string=''] The string to pad.\n\t     * @param {number} [length=0] The padding length.\n\t     * @param {string} [chars=' '] The string used as padding.\n\t     * @returns {string} Returns the padded string.\n\t     * @example\n\t     *\n\t     * _.padStart('abc', 6);\n\t     * // => '   abc'\n\t     *\n\t     * _.padStart('abc', 6, '_-');\n\t     * // => '_-_abc'\n\t     *\n\t     * _.padStart('abc', 3);\n\t     * // => 'abc'\n\t     */\n\t    function padStart(string, length, chars) {\n\t      string = toString(string);\n\t      return createPadding(string, length, chars) + string;\n\t    }\n\t\n\t    /**\n\t     * Converts `string` to an integer of the specified radix. If `radix` is\n\t     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a hexadecimal,\n\t     * in which case a `radix` of `16` is used.\n\t     *\n\t     * **Note:** This method aligns with the [ES5 implementation](https://es5.github.io/#E)\n\t     * of `parseInt`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category String\n\t     * @param {string} string The string to convert.\n\t     * @param {number} [radix] The radix to interpret `value` by.\n\t     * @param- {Object} [guard] Enables use as an iteratee for functions like `_.map`.\n\t     * @returns {number} Returns the converted integer.\n\t     * @example\n\t     *\n\t     * _.parseInt('08');\n\t     * // => 8\n\t     *\n\t     * _.map(['6', '08', '10'], _.parseInt);\n\t     * // => [6, 8, 10]\n\t     */\n\t    function parseInt(string, radix, guard) {\n\t      // Chrome fails to trim leading <BOM> whitespace characters.\n\t      // See https://code.google.com/p/v8/issues/detail?id=3109 for more details.\n\t      if (guard || radix == null) {\n\t        radix = 0;\n\t      } else if (radix) {\n\t        radix = +radix;\n\t      }\n\t      string = toString(string).replace(reTrim, '');\n\t      return nativeParseInt(string, radix || (reHasHexPrefix.test(string) ? 16 : 10));\n\t    }\n\t\n\t    /**\n\t     * Repeats the given string `n` times.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category String\n\t     * @param {string} [string=''] The string to repeat.\n\t     * @param {number} [n=0] The number of times to repeat the string.\n\t     * @returns {string} Returns the repeated string.\n\t     * @example\n\t     *\n\t     * _.repeat('*', 3);\n\t     * // => '***'\n\t     *\n\t     * _.repeat('abc', 2);\n\t     * // => 'abcabc'\n\t     *\n\t     * _.repeat('abc', 0);\n\t     * // => ''\n\t     */\n\t    function repeat(string, n) {\n\t      string = toString(string);\n\t      n = toInteger(n);\n\t\n\t      var result = '';\n\t      if (!string || n < 1 || n > MAX_SAFE_INTEGER) {\n\t        return result;\n\t      }\n\t      // Leverage the exponentiation by squaring algorithm for a faster repeat.\n\t      // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.\n\t      do {\n\t        if (n % 2) {\n\t          result += string;\n\t        }\n\t        n = nativeFloor(n / 2);\n\t        string += string;\n\t      } while (n);\n\t\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * Replaces matches for `pattern` in `string` with `replacement`.\n\t     *\n\t     * **Note:** This method is based on [`String#replace`](https://mdn.io/String/replace).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category String\n\t     * @param {string} [string=''] The string to modify.\n\t     * @param {RegExp|string} pattern The pattern to replace.\n\t     * @param {Function|string} replacement The match replacement.\n\t     * @returns {string} Returns the modified string.\n\t     * @example\n\t     *\n\t     * _.replace('Hi Fred', 'Fred', 'Barney');\n\t     * // => 'Hi Barney'\n\t     */\n\t    function replace() {\n\t      var args = arguments,\n\t          string = toString(args[0]);\n\t\n\t      return args.length < 3 ? string : string.replace(args[1], args[2]);\n\t    }\n\t\n\t    /**\n\t     * Converts `string` to [snake case](https://en.wikipedia.org/wiki/Snake_case).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category String\n\t     * @param {string} [string=''] The string to convert.\n\t     * @returns {string} Returns the snake cased string.\n\t     * @example\n\t     *\n\t     * _.snakeCase('Foo Bar');\n\t     * // => 'foo_bar'\n\t     *\n\t     * _.snakeCase('fooBar');\n\t     * // => 'foo_bar'\n\t     *\n\t     * _.snakeCase('--foo-bar');\n\t     * // => 'foo_bar'\n\t     */\n\t    var snakeCase = createCompounder(function(result, word, index) {\n\t      return result + (index ? '_' : '') + word.toLowerCase();\n\t    });\n\t\n\t    /**\n\t     * Splits `string` by `separator`.\n\t     *\n\t     * **Note:** This method is based on [`String#split`](https://mdn.io/String/split).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category String\n\t     * @param {string} [string=''] The string to split.\n\t     * @param {RegExp|string} separator The separator pattern to split by.\n\t     * @param {number} [limit] The length to truncate results to.\n\t     * @returns {Array} Returns the new array of string segments.\n\t     * @example\n\t     *\n\t     * _.split('a-b-c', '-', 2);\n\t     * // => ['a', 'b']\n\t     */\n\t    function split(string, separator, limit) {\n\t      return toString(string).split(separator, limit);\n\t    }\n\t\n\t    /**\n\t     * Converts `string` to [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category String\n\t     * @param {string} [string=''] The string to convert.\n\t     * @returns {string} Returns the start cased string.\n\t     * @example\n\t     *\n\t     * _.startCase('--foo-bar');\n\t     * // => 'Foo Bar'\n\t     *\n\t     * _.startCase('fooBar');\n\t     * // => 'Foo Bar'\n\t     *\n\t     * _.startCase('__foo_bar__');\n\t     * // => 'Foo Bar'\n\t     */\n\t    var startCase = createCompounder(function(result, word, index) {\n\t      return result + (index ? ' ' : '') + capitalize(word);\n\t    });\n\t\n\t    /**\n\t     * Checks if `string` starts with the given target string.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category String\n\t     * @param {string} [string=''] The string to search.\n\t     * @param {string} [target] The string to search for.\n\t     * @param {number} [position=0] The position to search from.\n\t     * @returns {boolean} Returns `true` if `string` starts with `target`, else `false`.\n\t     * @example\n\t     *\n\t     * _.startsWith('abc', 'a');\n\t     * // => true\n\t     *\n\t     * _.startsWith('abc', 'b');\n\t     * // => false\n\t     *\n\t     * _.startsWith('abc', 'b', 1);\n\t     * // => true\n\t     */\n\t    function startsWith(string, target, position) {\n\t      string = toString(string);\n\t      position = baseClamp(toInteger(position), 0, string.length);\n\t      return string.lastIndexOf(target, position) == position;\n\t    }\n\t\n\t    /**\n\t     * Creates a compiled template function that can interpolate data properties\n\t     * in \"interpolate\" delimiters, HTML-escape interpolated data properties in\n\t     * \"escape\" delimiters, and execute JavaScript in \"evaluate\" delimiters. Data\n\t     * properties may be accessed as free variables in the template. If a setting\n\t     * object is provided it takes precedence over `_.templateSettings` values.\n\t     *\n\t     * **Note:** In the development build `_.template` utilizes\n\t     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)\n\t     * for easier debugging.\n\t     *\n\t     * For more information on precompiling templates see\n\t     * [lodash's custom builds documentation](https://lodash.com/custom-builds).\n\t     *\n\t     * For more information on Chrome extension sandboxes see\n\t     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category String\n\t     * @param {string} [string=''] The template string.\n\t     * @param {Object} [options] The options object.\n\t     * @param {RegExp} [options.escape] The HTML \"escape\" delimiter.\n\t     * @param {RegExp} [options.evaluate] The \"evaluate\" delimiter.\n\t     * @param {Object} [options.imports] An object to import into the template as free variables.\n\t     * @param {RegExp} [options.interpolate] The \"interpolate\" delimiter.\n\t     * @param {string} [options.sourceURL] The sourceURL of the template's compiled source.\n\t     * @param {string} [options.variable] The data object variable name.\n\t     * @param- {Object} [guard] Enables use as an iteratee for functions like `_.map`.\n\t     * @returns {Function} Returns the compiled template function.\n\t     * @example\n\t     *\n\t     * // using the \"interpolate\" delimiter to create a compiled template\n\t     * var compiled = _.template('hello <%= user %>!');\n\t     * compiled({ 'user': 'fred' });\n\t     * // => 'hello fred!'\n\t     *\n\t     * // using the HTML \"escape\" delimiter to escape data property values\n\t     * var compiled = _.template('<b><%- value %></b>');\n\t     * compiled({ 'value': '<script>' });\n\t     * // => '<b>&lt;script&gt;</b>'\n\t     *\n\t     * // using the \"evaluate\" delimiter to execute JavaScript and generate HTML\n\t     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');\n\t     * compiled({ 'users': ['fred', 'barney'] });\n\t     * // => '<li>fred</li><li>barney</li>'\n\t     *\n\t     * // using the internal `print` function in \"evaluate\" delimiters\n\t     * var compiled = _.template('<% print(\"hello \" + user); %>!');\n\t     * compiled({ 'user': 'barney' });\n\t     * // => 'hello barney!'\n\t     *\n\t     * // using the ES delimiter as an alternative to the default \"interpolate\" delimiter\n\t     * var compiled = _.template('hello ${ user }!');\n\t     * compiled({ 'user': 'pebbles' });\n\t     * // => 'hello pebbles!'\n\t     *\n\t     * // using custom template delimiters\n\t     * _.templateSettings.interpolate = /{{([\\s\\S]+?)}}/g;\n\t     * var compiled = _.template('hello {{ user }}!');\n\t     * compiled({ 'user': 'mustache' });\n\t     * // => 'hello mustache!'\n\t     *\n\t     * // using backslashes to treat delimiters as plain text\n\t     * var compiled = _.template('<%= \"\\\\<%- value %\\\\>\" %>');\n\t     * compiled({ 'value': 'ignored' });\n\t     * // => '<%- value %>'\n\t     *\n\t     * // using the `imports` option to import `jQuery` as `jq`\n\t     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';\n\t     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });\n\t     * compiled({ 'users': ['fred', 'barney'] });\n\t     * // => '<li>fred</li><li>barney</li>'\n\t     *\n\t     * // using the `sourceURL` option to specify a custom sourceURL for the template\n\t     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });\n\t     * compiled(data);\n\t     * // => find the source of \"greeting.jst\" under the Sources tab or Resources panel of the web inspector\n\t     *\n\t     * // using the `variable` option to ensure a with-statement isn't used in the compiled template\n\t     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });\n\t     * compiled.source;\n\t     * // => function(data) {\n\t     * //   var __t, __p = '';\n\t     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';\n\t     * //   return __p;\n\t     * // }\n\t     *\n\t     * // using the `source` property to inline compiled templates for meaningful\n\t     * // line numbers in error messages and a stack trace\n\t     * fs.writeFileSync(path.join(cwd, 'jst.js'), '\\\n\t     *   var JST = {\\\n\t     *     \"main\": ' + _.template(mainText).source + '\\\n\t     *   };\\\n\t     * ');\n\t     */\n\t    function template(string, options, guard) {\n\t      // Based on John Resig's `tmpl` implementation (http://ejohn.org/blog/javascript-micro-templating/)\n\t      // and Laura Doktorova's doT.js (https://github.com/olado/doT).\n\t      var settings = lodash.templateSettings;\n\t\n\t      if (guard && isIterateeCall(string, options, guard)) {\n\t        options = undefined;\n\t      }\n\t      string = toString(string);\n\t      options = assignInWith({}, options, settings, assignInDefaults);\n\t\n\t      var imports = assignInWith({}, options.imports, settings.imports, assignInDefaults),\n\t          importsKeys = keys(imports),\n\t          importsValues = baseValues(imports, importsKeys);\n\t\n\t      var isEscaping,\n\t          isEvaluating,\n\t          index = 0,\n\t          interpolate = options.interpolate || reNoMatch,\n\t          source = \"__p += '\";\n\t\n\t      // Compile the regexp to match each delimiter.\n\t      var reDelimiters = RegExp(\n\t        (options.escape || reNoMatch).source + '|' +\n\t        interpolate.source + '|' +\n\t        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +\n\t        (options.evaluate || reNoMatch).source + '|$'\n\t      , 'g');\n\t\n\t      // Use a sourceURL for easier debugging.\n\t      var sourceURL = '//# sourceURL=' +\n\t        ('sourceURL' in options\n\t          ? options.sourceURL\n\t          : ('lodash.templateSources[' + (++templateCounter) + ']')\n\t        ) + '\\n';\n\t\n\t      string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {\n\t        interpolateValue || (interpolateValue = esTemplateValue);\n\t\n\t        // Escape characters that can't be included in string literals.\n\t        source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);\n\t\n\t        // Replace delimiters with snippets.\n\t        if (escapeValue) {\n\t          isEscaping = true;\n\t          source += \"' +\\n__e(\" + escapeValue + \") +\\n'\";\n\t        }\n\t        if (evaluateValue) {\n\t          isEvaluating = true;\n\t          source += \"';\\n\" + evaluateValue + \";\\n__p += '\";\n\t        }\n\t        if (interpolateValue) {\n\t          source += \"' +\\n((__t = (\" + interpolateValue + \")) == null ? '' : __t) +\\n'\";\n\t        }\n\t        index = offset + match.length;\n\t\n\t        // The JS engine embedded in Adobe products needs `match` returned in\n\t        // order to produce the correct `offset` value.\n\t        return match;\n\t      });\n\t\n\t      source += \"';\\n\";\n\t\n\t      // If `variable` is not specified wrap a with-statement around the generated\n\t      // code to add the data object to the top of the scope chain.\n\t      var variable = options.variable;\n\t      if (!variable) {\n\t        source = 'with (obj) {\\n' + source + '\\n}\\n';\n\t      }\n\t      // Cleanup code by stripping empty strings.\n\t      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)\n\t        .replace(reEmptyStringMiddle, '$1')\n\t        .replace(reEmptyStringTrailing, '$1;');\n\t\n\t      // Frame code as the function body.\n\t      source = 'function(' + (variable || 'obj') + ') {\\n' +\n\t        (variable\n\t          ? ''\n\t          : 'obj || (obj = {});\\n'\n\t        ) +\n\t        \"var __t, __p = ''\" +\n\t        (isEscaping\n\t           ? ', __e = _.escape'\n\t           : ''\n\t        ) +\n\t        (isEvaluating\n\t          ? ', __j = Array.prototype.join;\\n' +\n\t            \"function print() { __p += __j.call(arguments, '') }\\n\"\n\t          : ';\\n'\n\t        ) +\n\t        source +\n\t        'return __p\\n}';\n\t\n\t      var result = attempt(function() {\n\t        return Function(importsKeys, sourceURL + 'return ' + source).apply(undefined, importsValues);\n\t      });\n\t\n\t      // Provide the compiled function's source by its `toString` method or\n\t      // the `source` property as a convenience for inlining compiled templates.\n\t      result.source = source;\n\t      if (isError(result)) {\n\t        throw result;\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * Converts `string`, as a whole, to lower case.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category String\n\t     * @param {string} [string=''] The string to convert.\n\t     * @returns {string} Returns the lower cased string.\n\t     * @example\n\t     *\n\t     * _.toLower('--Foo-Bar');\n\t     * // => '--foo-bar'\n\t     *\n\t     * _.toLower('fooBar');\n\t     * // => 'foobar'\n\t     *\n\t     * _.toLower('__FOO_BAR__');\n\t     * // => '__foo_bar__'\n\t     */\n\t    function toLower(value) {\n\t      return toString(value).toLowerCase();\n\t    }\n\t\n\t    /**\n\t     * Converts `string`, as a whole, to upper case.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category String\n\t     * @param {string} [string=''] The string to convert.\n\t     * @returns {string} Returns the upper cased string.\n\t     * @example\n\t     *\n\t     * _.toUpper('--foo-bar');\n\t     * // => '--FOO-BAR'\n\t     *\n\t     * _.toUpper('fooBar');\n\t     * // => 'FOOBAR'\n\t     *\n\t     * _.toUpper('__foo_bar__');\n\t     * // => '__FOO_BAR__'\n\t     */\n\t    function toUpper(value) {\n\t      return toString(value).toUpperCase();\n\t    }\n\t\n\t    /**\n\t     * Removes leading and trailing whitespace or specified characters from `string`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category String\n\t     * @param {string} [string=''] The string to trim.\n\t     * @param {string} [chars=whitespace] The characters to trim.\n\t     * @param- {Object} [guard] Enables use as an iteratee for functions like `_.map`.\n\t     * @returns {string} Returns the trimmed string.\n\t     * @example\n\t     *\n\t     * _.trim('  abc  ');\n\t     * // => 'abc'\n\t     *\n\t     * _.trim('-_-abc-_-', '_-');\n\t     * // => 'abc'\n\t     *\n\t     * _.map(['  foo  ', '  bar  '], _.trim);\n\t     * // => ['foo', 'bar']\n\t     */\n\t    function trim(string, chars, guard) {\n\t      string = toString(string);\n\t      if (!string) {\n\t        return string;\n\t      }\n\t      if (guard || chars === undefined) {\n\t        return string.replace(reTrim, '');\n\t      }\n\t      chars = (chars + '');\n\t      if (!chars) {\n\t        return string;\n\t      }\n\t      var strSymbols = stringToArray(string),\n\t          chrSymbols = stringToArray(chars);\n\t\n\t      return strSymbols.slice(charsStartIndex(strSymbols, chrSymbols), charsEndIndex(strSymbols, chrSymbols) + 1).join('');\n\t    }\n\t\n\t    /**\n\t     * Removes trailing whitespace or specified characters from `string`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category String\n\t     * @param {string} [string=''] The string to trim.\n\t     * @param {string} [chars=whitespace] The characters to trim.\n\t     * @param- {Object} [guard] Enables use as an iteratee for functions like `_.map`.\n\t     * @returns {string} Returns the trimmed string.\n\t     * @example\n\t     *\n\t     * _.trimEnd('  abc  ');\n\t     * // => '  abc'\n\t     *\n\t     * _.trimEnd('-_-abc-_-', '_-');\n\t     * // => '-_-abc'\n\t     */\n\t    function trimEnd(string, chars, guard) {\n\t      string = toString(string);\n\t      if (!string) {\n\t        return string;\n\t      }\n\t      if (guard || chars === undefined) {\n\t        return string.replace(reTrimEnd, '');\n\t      }\n\t      chars = (chars + '');\n\t      if (!chars) {\n\t        return string;\n\t      }\n\t      var strSymbols = stringToArray(string);\n\t      return strSymbols.slice(0, charsEndIndex(strSymbols, stringToArray(chars)) + 1).join('');\n\t    }\n\t\n\t    /**\n\t     * Removes leading whitespace or specified characters from `string`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category String\n\t     * @param {string} [string=''] The string to trim.\n\t     * @param {string} [chars=whitespace] The characters to trim.\n\t     * @param- {Object} [guard] Enables use as an iteratee for functions like `_.map`.\n\t     * @returns {string} Returns the trimmed string.\n\t     * @example\n\t     *\n\t     * _.trimStart('  abc  ');\n\t     * // => 'abc  '\n\t     *\n\t     * _.trimStart('-_-abc-_-', '_-');\n\t     * // => 'abc-_-'\n\t     */\n\t    function trimStart(string, chars, guard) {\n\t      string = toString(string);\n\t      if (!string) {\n\t        return string;\n\t      }\n\t      if (guard || chars === undefined) {\n\t        return string.replace(reTrimStart, '');\n\t      }\n\t      chars = (chars + '');\n\t      if (!chars) {\n\t        return string;\n\t      }\n\t      var strSymbols = stringToArray(string);\n\t      return strSymbols.slice(charsStartIndex(strSymbols, stringToArray(chars))).join('');\n\t    }\n\t\n\t    /**\n\t     * Truncates `string` if it's longer than the given maximum string length.\n\t     * The last characters of the truncated string are replaced with the omission\n\t     * string which defaults to \"...\".\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category String\n\t     * @param {string} [string=''] The string to truncate.\n\t     * @param {Object} [options] The options object.\n\t     * @param {number} [options.length=30] The maximum string length.\n\t     * @param {string} [options.omission='...'] The string to indicate text is omitted.\n\t     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.\n\t     * @returns {string} Returns the truncated string.\n\t     * @example\n\t     *\n\t     * _.truncate('hi-diddly-ho there, neighborino');\n\t     * // => 'hi-diddly-ho there, neighbo...'\n\t     *\n\t     * _.truncate('hi-diddly-ho there, neighborino', {\n\t     *   'length': 24,\n\t     *   'separator': ' '\n\t     * });\n\t     * // => 'hi-diddly-ho there,...'\n\t     *\n\t     * _.truncate('hi-diddly-ho there, neighborino', {\n\t     *   'length': 24,\n\t     *   'separator': /,? +/\n\t     * });\n\t     * // => 'hi-diddly-ho there...'\n\t     *\n\t     * _.truncate('hi-diddly-ho there, neighborino', {\n\t     *   'omission': ' [...]'\n\t     * });\n\t     * // => 'hi-diddly-ho there, neig [...]'\n\t     */\n\t    function truncate(string, options) {\n\t      var length = DEFAULT_TRUNC_LENGTH,\n\t          omission = DEFAULT_TRUNC_OMISSION;\n\t\n\t      if (isObject(options)) {\n\t        var separator = 'separator' in options ? options.separator : separator;\n\t        length = 'length' in options ? toInteger(options.length) : length;\n\t        omission = 'omission' in options ? toString(options.omission) : omission;\n\t      }\n\t      string = toString(string);\n\t\n\t      var strLength = string.length;\n\t      if (reHasComplexSymbol.test(string)) {\n\t        var strSymbols = stringToArray(string);\n\t        strLength = strSymbols.length;\n\t      }\n\t      if (length >= strLength) {\n\t        return string;\n\t      }\n\t      var end = length - stringSize(omission);\n\t      if (end < 1) {\n\t        return omission;\n\t      }\n\t      var result = strSymbols\n\t        ? strSymbols.slice(0, end).join('')\n\t        : string.slice(0, end);\n\t\n\t      if (separator === undefined) {\n\t        return result + omission;\n\t      }\n\t      if (strSymbols) {\n\t        end += (result.length - end);\n\t      }\n\t      if (isRegExp(separator)) {\n\t        if (string.slice(end).search(separator)) {\n\t          var match,\n\t              substring = result;\n\t\n\t          if (!separator.global) {\n\t            separator = RegExp(separator.source, toString(reFlags.exec(separator)) + 'g');\n\t          }\n\t          separator.lastIndex = 0;\n\t          while ((match = separator.exec(substring))) {\n\t            var newEnd = match.index;\n\t          }\n\t          result = result.slice(0, newEnd === undefined ? end : newEnd);\n\t        }\n\t      } else if (string.indexOf(separator, end) != end) {\n\t        var index = result.lastIndexOf(separator);\n\t        if (index > -1) {\n\t          result = result.slice(0, index);\n\t        }\n\t      }\n\t      return result + omission;\n\t    }\n\t\n\t    /**\n\t     * The inverse of `_.escape`; this method converts the HTML entities\n\t     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, `&#39;`, and `&#96;` in `string` to their\n\t     * corresponding characters.\n\t     *\n\t     * **Note:** No other HTML entities are unescaped. To unescape additional HTML\n\t     * entities use a third-party library like [_he_](https://mths.be/he).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category String\n\t     * @param {string} [string=''] The string to unescape.\n\t     * @returns {string} Returns the unescaped string.\n\t     * @example\n\t     *\n\t     * _.unescape('fred, barney, &amp; pebbles');\n\t     * // => 'fred, barney, & pebbles'\n\t     */\n\t    function unescape(string) {\n\t      string = toString(string);\n\t      return (string && reHasEscapedHtml.test(string))\n\t        ? string.replace(reEscapedHtml, unescapeHtmlChar)\n\t        : string;\n\t    }\n\t\n\t    /**\n\t     * Converts `string`, as space separated words, to upper case.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category String\n\t     * @param {string} [string=''] The string to convert.\n\t     * @returns {string} Returns the upper cased string.\n\t     * @example\n\t     *\n\t     * _.upperCase('--foo-bar');\n\t     * // => 'FOO BAR'\n\t     *\n\t     * _.upperCase('fooBar');\n\t     * // => 'FOO BAR'\n\t     *\n\t     * _.upperCase('__foo_bar__');\n\t     * // => 'FOO BAR'\n\t     */\n\t    var upperCase = createCompounder(function(result, word, index) {\n\t      return result + (index ? ' ' : '') + word.toUpperCase();\n\t    });\n\t\n\t    /**\n\t     * Splits `string` into an array of its words.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category String\n\t     * @param {string} [string=''] The string to inspect.\n\t     * @param {RegExp|string} [pattern] The pattern to match words.\n\t     * @param- {Object} [guard] Enables use as an iteratee for functions like `_.map`.\n\t     * @returns {Array} Returns the words of `string`.\n\t     * @example\n\t     *\n\t     * _.words('fred, barney, & pebbles');\n\t     * // => ['fred', 'barney', 'pebbles']\n\t     *\n\t     * _.words('fred, barney, & pebbles', /[^, ]+/g);\n\t     * // => ['fred', 'barney', '&', 'pebbles']\n\t     */\n\t    function words(string, pattern, guard) {\n\t      string = toString(string);\n\t      pattern = guard ? undefined : pattern;\n\t\n\t      if (pattern === undefined) {\n\t        pattern = reHasComplexWord.test(string) ? reComplexWord : reBasicWord;\n\t      }\n\t      return string.match(pattern) || [];\n\t    }\n\t\n\t    /*------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * Attempts to invoke `func`, returning either the result or the caught error\n\t     * object. Any additional arguments are provided to `func` when it's invoked.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Util\n\t     * @param {Function} func The function to attempt.\n\t     * @returns {*} Returns the `func` result or error object.\n\t     * @example\n\t     *\n\t     * // avoid throwing errors for invalid selectors\n\t     * var elements = _.attempt(function(selector) {\n\t     *   return document.querySelectorAll(selector);\n\t     * }, '>_>');\n\t     *\n\t     * if (_.isError(elements)) {\n\t     *   elements = [];\n\t     * }\n\t     */\n\t    var attempt = rest(function(func, args) {\n\t      try {\n\t        return apply(func, undefined, args);\n\t      } catch (e) {\n\t        return isError(e) ? e : new Error(e);\n\t      }\n\t    });\n\t\n\t    /**\n\t     * Binds methods of an object to the object itself, overwriting the existing\n\t     * method.\n\t     *\n\t     * **Note:** This method doesn't set the \"length\" property of bound functions.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Util\n\t     * @param {Object} object The object to bind and assign the bound methods to.\n\t     * @param {...(string|string[])} methodNames The object method names to bind,\n\t     *  specified individually or in arrays.\n\t     * @returns {Object} Returns `object`.\n\t     * @example\n\t     *\n\t     * var view = {\n\t     *   'label': 'docs',\n\t     *   'onClick': function() {\n\t     *     console.log('clicked ' + this.label);\n\t     *   }\n\t     * };\n\t     *\n\t     * _.bindAll(view, 'onClick');\n\t     * jQuery(element).on('click', view.onClick);\n\t     * // => logs 'clicked docs' when clicked\n\t     */\n\t    var bindAll = rest(function(object, methodNames) {\n\t      arrayEach(baseFlatten(methodNames), function(key) {\n\t        object[key] = bind(object[key], object);\n\t      });\n\t      return object;\n\t    });\n\t\n\t    /**\n\t     * Creates a function that iterates over `pairs` invoking the corresponding\n\t     * function of the first predicate to return truthy. The predicate-function\n\t     * pairs are invoked with the `this` binding and arguments of the created\n\t     * function.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Util\n\t     * @param {Array} pairs The predicate-function pairs.\n\t     * @returns {Function} Returns the new function.\n\t     * @example\n\t     *\n\t     * var func = _.cond([\n\t     *   [_.matches({ 'a': 1 }),           _.constant('matches A')],\n\t     *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],\n\t     *   [_.constant(true),                _.constant('no match')]\n\t     * ])\n\t     *\n\t     * func({ 'a': 1, 'b': 2 });\n\t     * // => 'matches A'\n\t     *\n\t     * func({ 'a': 0, 'b': 1 });\n\t     * // => 'matches B'\n\t     *\n\t     * func({ 'a': '1', 'b': '2' });\n\t     * // => 'no match'\n\t     */\n\t    function cond(pairs) {\n\t      var length = pairs ? pairs.length : 0,\n\t          toIteratee = getIteratee();\n\t\n\t      pairs = !length ? [] : arrayMap(pairs, function(pair) {\n\t        if (typeof pair[1] != 'function') {\n\t          throw new TypeError(FUNC_ERROR_TEXT);\n\t        }\n\t        return [toIteratee(pair[0]), pair[1]];\n\t      });\n\t\n\t      return rest(function(args) {\n\t        var index = -1;\n\t        while (++index < length) {\n\t          var pair = pairs[index];\n\t          if (apply(pair[0], this, args)) {\n\t            return apply(pair[1], this, args);\n\t          }\n\t        }\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Creates a function that invokes the predicate properties of `source` with\n\t     * the corresponding property values of a given object, returning `true` if\n\t     * all predicates return truthy, else `false`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Util\n\t     * @param {Object} source The object of property predicates to conform to.\n\t     * @returns {Function} Returns the new function.\n\t     * @example\n\t     *\n\t     * var users = [\n\t     *   { 'user': 'barney', 'age': 36 },\n\t     *   { 'user': 'fred',   'age': 40 }\n\t     * ];\n\t     *\n\t     * _.filter(users, _.conforms({ 'age': _.partial(_.gt, _, 38) }));\n\t     * // => [{ 'user': 'fred', 'age': 40 }]\n\t     */\n\t    function conforms(source) {\n\t      return baseConforms(baseClone(source, true));\n\t    }\n\t\n\t    /**\n\t     * Creates a function that returns `value`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Util\n\t     * @param {*} value The value to return from the new function.\n\t     * @returns {Function} Returns the new function.\n\t     * @example\n\t     *\n\t     * var object = { 'user': 'fred' };\n\t     * var getter = _.constant(object);\n\t     *\n\t     * getter() === object;\n\t     * // => true\n\t     */\n\t    function constant(value) {\n\t      return function() {\n\t        return value;\n\t      };\n\t    }\n\t\n\t    /**\n\t     * Creates a function that returns the result of invoking the provided\n\t     * functions with the `this` binding of the created function, where each\n\t     * successive invocation is supplied the return value of the previous.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Util\n\t     * @param {...(Function|Function[])} [funcs] Functions to invoke.\n\t     * @returns {Function} Returns the new function.\n\t     * @example\n\t     *\n\t     * function square(n) {\n\t     *   return n * n;\n\t     * }\n\t     *\n\t     * var addSquare = _.flow(_.add, square);\n\t     * addSquare(1, 2);\n\t     * // => 9\n\t     */\n\t    var flow = createFlow();\n\t\n\t    /**\n\t     * This method is like `_.flow` except that it creates a function that\n\t     * invokes the provided functions from right to left.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Util\n\t     * @param {...(Function|Function[])} [funcs] Functions to invoke.\n\t     * @returns {Function} Returns the new function.\n\t     * @example\n\t     *\n\t     * function square(n) {\n\t     *   return n * n;\n\t     * }\n\t     *\n\t     * var addSquare = _.flowRight(square, _.add);\n\t     * addSquare(1, 2);\n\t     * // => 9\n\t     */\n\t    var flowRight = createFlow(true);\n\t\n\t    /**\n\t     * This method returns the first argument provided to it.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Util\n\t     * @param {*} value Any value.\n\t     * @returns {*} Returns `value`.\n\t     * @example\n\t     *\n\t     * var object = { 'user': 'fred' };\n\t     *\n\t     * _.identity(object) === object;\n\t     * // => true\n\t     */\n\t    function identity(value) {\n\t      return value;\n\t    }\n\t\n\t    /**\n\t     * Creates a function that invokes `func` with the arguments of the created\n\t     * function. If `func` is a property name the created callback returns the\n\t     * property value for a given element. If `func` is an object the created\n\t     * callback returns `true` for elements that contain the equivalent object properties, otherwise it returns `false`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Util\n\t     * @param {*} [func=_.identity] The value to convert to a callback.\n\t     * @returns {Function} Returns the callback.\n\t     * @example\n\t     *\n\t     * var users = [\n\t     *   { 'user': 'barney', 'age': 36 },\n\t     *   { 'user': 'fred',   'age': 40 }\n\t     * ];\n\t     *\n\t     * // create custom iteratee shorthands\n\t     * _.iteratee = _.wrap(_.iteratee, function(callback, func) {\n\t     *   var p = /^(\\S+)\\s*([<>])\\s*(\\S+)$/.exec(func);\n\t     *   return !p ? callback(func) : function(object) {\n\t     *     return (p[2] == '>' ? object[p[1]] > p[3] : object[p[1]] < p[3]);\n\t     *   };\n\t     * });\n\t     *\n\t     * _.filter(users, 'age > 36');\n\t     * // => [{ 'user': 'fred', 'age': 40 }]\n\t     */\n\t    function iteratee(func) {\n\t      return (isObjectLike(func) && !isArray(func))\n\t        ? matches(func)\n\t        : baseIteratee(func);\n\t    }\n\t\n\t    /**\n\t     * Creates a function that performs a deep partial comparison between a given\n\t     * object and `source`, returning `true` if the given object has equivalent\n\t     * property values, else `false`.\n\t     *\n\t     * **Note:** This method supports comparing the same values as `_.isEqual`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Util\n\t     * @param {Object} source The object of property values to match.\n\t     * @returns {Function} Returns the new function.\n\t     * @example\n\t     *\n\t     * var users = [\n\t     *   { 'user': 'barney', 'age': 36, 'active': true },\n\t     *   { 'user': 'fred',   'age': 40, 'active': false }\n\t     * ];\n\t     *\n\t     * _.filter(users, _.matches({ 'age': 40, 'active': false }));\n\t     * // => [{ 'user': 'fred', 'age': 40, 'active': false }]\n\t     */\n\t    function matches(source) {\n\t      return baseMatches(baseClone(source, true));\n\t    }\n\t\n\t    /**\n\t     * Creates a function that performs a deep partial comparison between the\n\t     * value at `path` of a given object to `srcValue`, returning `true` if the\n\t     * object value is equivalent, else `false`.\n\t     *\n\t     * **Note:** This method supports comparing the same values as `_.isEqual`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Util\n\t     * @param {Array|string} path The path of the property to get.\n\t     * @param {*} srcValue The value to match.\n\t     * @returns {Function} Returns the new function.\n\t     * @example\n\t     *\n\t     * var users = [\n\t     *   { 'user': 'barney' },\n\t     *   { 'user': 'fred' }\n\t     * ];\n\t     *\n\t     * _.find(users, _.matchesProperty('user', 'fred'));\n\t     * // => { 'user': 'fred' }\n\t     */\n\t    function matchesProperty(path, srcValue) {\n\t      return baseMatchesProperty(path, baseClone(srcValue, true));\n\t    }\n\t\n\t    /**\n\t     * Creates a function that invokes the method at `path` of a given object.\n\t     * Any additional arguments are provided to the invoked method.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Util\n\t     * @param {Array|string} path The path of the method to invoke.\n\t     * @param {...*} [args] The arguments to invoke the method with.\n\t     * @returns {Function} Returns the new function.\n\t     * @example\n\t     *\n\t     * var objects = [\n\t     *   { 'a': { 'b': { 'c': _.constant(2) } } },\n\t     *   { 'a': { 'b': { 'c': _.constant(1) } } }\n\t     * ];\n\t     *\n\t     * _.map(objects, _.method('a.b.c'));\n\t     * // => [2, 1]\n\t     *\n\t     * _.invokeMap(_.sortBy(objects, _.method(['a', 'b', 'c'])), 'a.b.c');\n\t     * // => [1, 2]\n\t     */\n\t    var method = rest(function(path, args) {\n\t      return function(object) {\n\t        return baseInvoke(object, path, args);\n\t      };\n\t    });\n\t\n\t    /**\n\t     * The opposite of `_.method`; this method creates a function that invokes\n\t     * the method at a given path of `object`. Any additional arguments are\n\t     * provided to the invoked method.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Util\n\t     * @param {Object} object The object to query.\n\t     * @param {...*} [args] The arguments to invoke the method with.\n\t     * @returns {Function} Returns the new function.\n\t     * @example\n\t     *\n\t     * var array = _.times(3, _.constant),\n\t     *     object = { 'a': array, 'b': array, 'c': array };\n\t     *\n\t     * _.map(['a[2]', 'c[0]'], _.methodOf(object));\n\t     * // => [2, 0]\n\t     *\n\t     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));\n\t     * // => [2, 0]\n\t     */\n\t    var methodOf = rest(function(object, args) {\n\t      return function(path) {\n\t        return baseInvoke(object, path, args);\n\t      };\n\t    });\n\t\n\t    /**\n\t     * Adds all own enumerable function properties of a source object to the\n\t     * destination object. If `object` is a function then methods are added to\n\t     * its prototype as well.\n\t     *\n\t     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to\n\t     * avoid conflicts caused by modifying the original.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Util\n\t     * @param {Function|Object} [object=lodash] The destination object.\n\t     * @param {Object} source The object of functions to add.\n\t     * @param {Object} [options] The options object.\n\t     * @param {boolean} [options.chain=true] Specify whether the functions added\n\t     *  are chainable.\n\t     * @returns {Function|Object} Returns `object`.\n\t     * @example\n\t     *\n\t     * function vowels(string) {\n\t     *   return _.filter(string, function(v) {\n\t     *     return /[aeiou]/i.test(v);\n\t     *   });\n\t     * }\n\t     *\n\t     * _.mixin({ 'vowels': vowels });\n\t     * _.vowels('fred');\n\t     * // => ['e']\n\t     *\n\t     * _('fred').vowels().value();\n\t     * // => ['e']\n\t     *\n\t     * _.mixin({ 'vowels': vowels }, { 'chain': false });\n\t     * _('fred').vowels();\n\t     * // => ['e']\n\t     */\n\t    function mixin(object, source, options) {\n\t      var props = keys(source),\n\t          methodNames = baseFunctions(source, props);\n\t\n\t      if (options == null &&\n\t          !(isObject(source) && (methodNames.length || !props.length))) {\n\t        options = source;\n\t        source = object;\n\t        object = this;\n\t        methodNames = baseFunctions(source, keys(source));\n\t      }\n\t      var chain = (isObject(options) && 'chain' in options) ? options.chain : true,\n\t          isFunc = isFunction(object);\n\t\n\t      arrayEach(methodNames, function(methodName) {\n\t        var func = source[methodName];\n\t        object[methodName] = func;\n\t        if (isFunc) {\n\t          object.prototype[methodName] = function() {\n\t            var chainAll = this.__chain__;\n\t            if (chain || chainAll) {\n\t              var result = object(this.__wrapped__),\n\t                  actions = result.__actions__ = copyArray(this.__actions__);\n\t\n\t              actions.push({ 'func': func, 'args': arguments, 'thisArg': object });\n\t              result.__chain__ = chainAll;\n\t              return result;\n\t            }\n\t            return func.apply(object, arrayPush([this.value()], arguments));\n\t          };\n\t        }\n\t      });\n\t\n\t      return object;\n\t    }\n\t\n\t    /**\n\t     * Reverts the `_` variable to its previous value and returns a reference to\n\t     * the `lodash` function.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Util\n\t     * @returns {Function} Returns the `lodash` function.\n\t     * @example\n\t     *\n\t     * var lodash = _.noConflict();\n\t     */\n\t    function noConflict() {\n\t      root._ = oldDash;\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * A no-operation function that returns `undefined` regardless of the\n\t     * arguments it receives.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Util\n\t     * @example\n\t     *\n\t     * var object = { 'user': 'fred' };\n\t     *\n\t     * _.noop(object) === undefined;\n\t     * // => true\n\t     */\n\t    function noop() {\n\t      // No operation performed.\n\t    }\n\t\n\t    /**\n\t     * Creates a function that returns its nth argument.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Util\n\t     * @param {number} [n=0] The index of the argument to return.\n\t     * @returns {Function} Returns the new function.\n\t     * @example\n\t     *\n\t     * var func = _.nthArg(1);\n\t     *\n\t     * func('a', 'b', 'c');\n\t     * // => 'b'\n\t     */\n\t    function nthArg(n) {\n\t      n = toInteger(n);\n\t      return function() {\n\t        return arguments[n];\n\t      };\n\t    }\n\t\n\t    /**\n\t     * Creates a function that invokes `iteratees` with the arguments provided\n\t     * to the created function and returns their results.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Util\n\t     * @param {...(Function|Function[])} iteratees The iteratees to invoke.\n\t     * @returns {Function} Returns the new function.\n\t     * @example\n\t     *\n\t     * var func = _.over(Math.max, Math.min);\n\t     *\n\t     * func(1, 2, 3, 4);\n\t     * // => [4, 1]\n\t     */\n\t    var over = createOver(arrayMap);\n\t\n\t    /**\n\t     * Creates a function that checks if **all** of the `predicates` return\n\t     * truthy when invoked with the arguments provided to the created function.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Util\n\t     * @param {...(Function|Function[])} predicates The predicates to check.\n\t     * @returns {Function} Returns the new function.\n\t     * @example\n\t     *\n\t     * var func = _.overEvery(Boolean, isFinite);\n\t     *\n\t     * func('1');\n\t     * // => true\n\t     *\n\t     * func(null);\n\t     * // => false\n\t     *\n\t     * func(NaN);\n\t     * // => false\n\t     */\n\t    var overEvery = createOver(arrayEvery);\n\t\n\t    /**\n\t     * Creates a function that checks if **any** of the `predicates` return\n\t     * truthy when invoked with the arguments provided to the created function.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Util\n\t     * @param {...(Function|Function[])} predicates The predicates to check.\n\t     * @returns {Function} Returns the new function.\n\t     * @example\n\t     *\n\t     * var func = _.overSome(Boolean, isFinite);\n\t     *\n\t     * func('1');\n\t     * // => true\n\t     *\n\t     * func(null);\n\t     * // => true\n\t     *\n\t     * func(NaN);\n\t     * // => false\n\t     */\n\t    var overSome = createOver(arraySome);\n\t\n\t    /**\n\t     * Creates a function that returns the value at `path` of a given object.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Util\n\t     * @param {Array|string} path The path of the property to get.\n\t     * @returns {Function} Returns the new function.\n\t     * @example\n\t     *\n\t     * var objects = [\n\t     *   { 'a': { 'b': { 'c': 2 } } },\n\t     *   { 'a': { 'b': { 'c': 1 } } }\n\t     * ];\n\t     *\n\t     * _.map(objects, _.property('a.b.c'));\n\t     * // => [2, 1]\n\t     *\n\t     * _.map(_.sortBy(objects, _.property(['a', 'b', 'c'])), 'a.b.c');\n\t     * // => [1, 2]\n\t     */\n\t    function property(path) {\n\t      return isKey(path) ? baseProperty(path) : basePropertyDeep(path);\n\t    }\n\t\n\t    /**\n\t     * The opposite of `_.property`; this method creates a function that returns\n\t     * the value at a given path of `object`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Util\n\t     * @param {Object} object The object to query.\n\t     * @returns {Function} Returns the new function.\n\t     * @example\n\t     *\n\t     * var array = [0, 1, 2],\n\t     *     object = { 'a': array, 'b': array, 'c': array };\n\t     *\n\t     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));\n\t     * // => [2, 0]\n\t     *\n\t     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));\n\t     * // => [2, 0]\n\t     */\n\t    function propertyOf(object) {\n\t      return function(path) {\n\t        return object == null ? undefined : baseGet(object, path);\n\t      };\n\t    }\n\t\n\t    /**\n\t     * Creates an array of numbers (positive and/or negative) progressing from\n\t     * `start` up to, but not including, `end`. A step of `-1` is used if a negative\n\t     * `start` is specified without an `end` or `step`. If `end` is not specified\n\t     * it's set to `start` with `start` then set to `0`.  If `end` is less than\n\t     * `start` a zero-length range is created unless a negative `step` is specified.\n\t     *\n\t     * **Note:** JavaScript follows the IEEE-754 standard for resolving\n\t     * floating-point values which can produce unexpected results.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Util\n\t     * @param {number} [start=0] The start of the range.\n\t     * @param {number} end The end of the range.\n\t     * @param {number} [step=1] The value to increment or decrement by.\n\t     * @returns {Array} Returns the new array of numbers.\n\t     * @example\n\t     *\n\t     * _.range(4);\n\t     * // => [0, 1, 2, 3]\n\t     *\n\t     * _.range(-4);\n\t     * // => [0, -1, -2, -3]\n\t     *\n\t     * _.range(1, 5);\n\t     * // => [1, 2, 3, 4]\n\t     *\n\t     * _.range(0, 20, 5);\n\t     * // => [0, 5, 10, 15]\n\t     *\n\t     * _.range(0, -4, -1);\n\t     * // => [0, -1, -2, -3]\n\t     *\n\t     * _.range(1, 4, 0);\n\t     * // => [1, 1, 1]\n\t     *\n\t     * _.range(0);\n\t     * // => []\n\t     */\n\t    var range = createRange();\n\t\n\t    /**\n\t     * This method is like `_.range` except that it populates values in\n\t     * descending order.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Util\n\t     * @param {number} [start=0] The start of the range.\n\t     * @param {number} end The end of the range.\n\t     * @param {number} [step=1] The value to increment or decrement by.\n\t     * @returns {Array} Returns the new array of numbers.\n\t     * @example\n\t     *\n\t     * _.rangeRight(4);\n\t     * // => [3, 2, 1, 0]\n\t     *\n\t     * _.rangeRight(-4);\n\t     * // => [-3, -2, -1, 0]\n\t     *\n\t     * _.rangeRight(1, 5);\n\t     * // => [4, 3, 2, 1]\n\t     *\n\t     * _.rangeRight(0, 20, 5);\n\t     * // => [15, 10, 5, 0]\n\t     *\n\t     * _.rangeRight(0, -4, -1);\n\t     * // => [-3, -2, -1, 0]\n\t     *\n\t     * _.rangeRight(1, 4, 0);\n\t     * // => [1, 1, 1]\n\t     *\n\t     * _.rangeRight(0);\n\t     * // => []\n\t     */\n\t    var rangeRight = createRange(true);\n\t\n\t    /**\n\t     * Invokes the iteratee function `n` times, returning an array of the results\n\t     * of each invocation. The iteratee is invoked with one argument; (index).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Util\n\t     * @param {number} n The number of times to invoke `iteratee`.\n\t     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n\t     * @returns {Array} Returns the array of results.\n\t     * @example\n\t     *\n\t     * _.times(3, String);\n\t     * // => ['0', '1', '2']\n\t     *\n\t     *  _.times(4, _.constant(true));\n\t     * // => [true, true, true, true]\n\t     */\n\t    function times(n, iteratee) {\n\t      n = toInteger(n);\n\t      if (n < 1 || n > MAX_SAFE_INTEGER) {\n\t        return [];\n\t      }\n\t      var index = MAX_ARRAY_LENGTH,\n\t          length = nativeMin(n, MAX_ARRAY_LENGTH);\n\t\n\t      iteratee = toFunction(iteratee);\n\t      n -= MAX_ARRAY_LENGTH;\n\t\n\t      var result = baseTimes(length, iteratee);\n\t      while (++index < n) {\n\t        iteratee(index);\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * Converts `value` to a property path array.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Util\n\t     * @param {*} value The value to convert.\n\t     * @returns {Array} Returns the new property path array.\n\t     * @example\n\t     *\n\t     * _.toPath('a.b.c');\n\t     * // => ['a', 'b', 'c']\n\t     *\n\t     * _.toPath('a[0].b.c');\n\t     * // => ['a', '0', 'b', 'c']\n\t     *\n\t     * var path = ['a', 'b', 'c'],\n\t     *     newPath = _.toPath(path);\n\t     *\n\t     * console.log(newPath);\n\t     * // => ['a', 'b', 'c']\n\t     *\n\t     * console.log(path === newPath);\n\t     * // => false\n\t     */\n\t    function toPath(value) {\n\t      return isArray(value) ? arrayMap(value, String) : stringToPath(value);\n\t    }\n\t\n\t    /**\n\t     * Generates a unique ID. If `prefix` is provided the ID is appended to it.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Util\n\t     * @param {string} [prefix] The value to prefix the ID with.\n\t     * @returns {string} Returns the unique ID.\n\t     * @example\n\t     *\n\t     * _.uniqueId('contact_');\n\t     * // => 'contact_104'\n\t     *\n\t     * _.uniqueId();\n\t     * // => '105'\n\t     */\n\t    function uniqueId(prefix) {\n\t      var id = ++idCounter;\n\t      return toString(prefix) + id;\n\t    }\n\t\n\t    /*------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * Adds two numbers.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Math\n\t     * @param {number} augend The first number in an addition.\n\t     * @param {number} addend The second number in an addition.\n\t     * @returns {number} Returns the total.\n\t     * @example\n\t     *\n\t     * _.add(6, 4);\n\t     * // => 10\n\t     */\n\t    function add(augend, addend) {\n\t      var result;\n\t      if (augend !== undefined) {\n\t        result = augend;\n\t      }\n\t      if (addend !== undefined) {\n\t        result = result === undefined ? addend : (result + addend);\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * Computes `number` rounded up to `precision`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Math\n\t     * @param {number} number The number to round up.\n\t     * @param {number} [precision=0] The precision to round up to.\n\t     * @returns {number} Returns the rounded up number.\n\t     * @example\n\t     *\n\t     * _.ceil(4.006);\n\t     * // => 5\n\t     *\n\t     * _.ceil(6.004, 2);\n\t     * // => 6.01\n\t     *\n\t     * _.ceil(6040, -2);\n\t     * // => 6100\n\t     */\n\t    var ceil = createRound('ceil');\n\t\n\t    /**\n\t     * Computes `number` rounded down to `precision`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Math\n\t     * @param {number} number The number to round down.\n\t     * @param {number} [precision=0] The precision to round down to.\n\t     * @returns {number} Returns the rounded down number.\n\t     * @example\n\t     *\n\t     * _.floor(4.006);\n\t     * // => 4\n\t     *\n\t     * _.floor(0.046, 2);\n\t     * // => 0.04\n\t     *\n\t     * _.floor(4060, -2);\n\t     * // => 4000\n\t     */\n\t    var floor = createRound('floor');\n\t\n\t    /**\n\t     * Computes the maximum value of `array`. If `array` is empty or falsey\n\t     * `undefined` is returned.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Math\n\t     * @param {Array} array The array to iterate over.\n\t     * @returns {*} Returns the maximum value.\n\t     * @example\n\t     *\n\t     * _.max([4, 2, 8, 6]);\n\t     * // => 8\n\t     *\n\t     * _.max([]);\n\t     * // => undefined\n\t     */\n\t    function max(array) {\n\t      return (array && array.length)\n\t        ? baseExtremum(array, identity, gt)\n\t        : undefined;\n\t    }\n\t\n\t    /**\n\t     * This method is like `_.max` except that it accepts `iteratee` which is\n\t     * invoked for each element in `array` to generate the criterion by which\n\t     * the value is ranked. The iteratee is invoked with one argument: (value).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Math\n\t     * @param {Array} array The array to iterate over.\n\t     * @param {Function|Object|string} [iteratee=_.identity] The iteratee invoked per element.\n\t     * @returns {*} Returns the maximum value.\n\t     * @example\n\t     *\n\t     * var objects = [{ 'n': 1 }, { 'n': 2 }];\n\t     *\n\t     * _.maxBy(objects, function(o) { return o.a; });\n\t     * // => { 'n': 2 }\n\t     *\n\t     * // using the `_.property` iteratee shorthand\n\t     * _.maxBy(objects, 'n');\n\t     * // => { 'n': 2 }\n\t     */\n\t    function maxBy(array, iteratee) {\n\t      return (array && array.length)\n\t        ? baseExtremum(array, getIteratee(iteratee), gt)\n\t        : undefined;\n\t    }\n\t\n\t    /**\n\t     * Computes the mean of the values in `array`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Math\n\t     * @param {Array} array The array to iterate over.\n\t     * @returns {number} Returns the mean.\n\t     * @example\n\t     *\n\t     * _.mean([4, 2, 8, 6]);\n\t     * // => 5\n\t     */\n\t    function mean(array) {\n\t      return sum(array) / (array ? array.length : 0);\n\t    }\n\t\n\t    /**\n\t     * Computes the minimum value of `array`. If `array` is empty or falsey\n\t     * `undefined` is returned.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Math\n\t     * @param {Array} array The array to iterate over.\n\t     * @returns {*} Returns the minimum value.\n\t     * @example\n\t     *\n\t     * _.min([4, 2, 8, 6]);\n\t     * // => 2\n\t     *\n\t     * _.min([]);\n\t     * // => undefined\n\t     */\n\t    function min(array) {\n\t      return (array && array.length)\n\t        ? baseExtremum(array, identity, lt)\n\t        : undefined;\n\t    }\n\t\n\t    /**\n\t     * This method is like `_.min` except that it accepts `iteratee` which is\n\t     * invoked for each element in `array` to generate the criterion by which\n\t     * the value is ranked. The iteratee is invoked with one argument: (value).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Math\n\t     * @param {Array} array The array to iterate over.\n\t     * @param {Function|Object|string} [iteratee=_.identity] The iteratee invoked per element.\n\t     * @returns {*} Returns the minimum value.\n\t     * @example\n\t     *\n\t     * var objects = [{ 'n': 1 }, { 'n': 2 }];\n\t     *\n\t     * _.minBy(objects, function(o) { return o.a; });\n\t     * // => { 'n': 1 }\n\t     *\n\t     * // using the `_.property` iteratee shorthand\n\t     * _.minBy(objects, 'n');\n\t     * // => { 'n': 1 }\n\t     */\n\t    function minBy(array, iteratee) {\n\t      return (array && array.length)\n\t        ? baseExtremum(array, getIteratee(iteratee), lt)\n\t        : undefined;\n\t    }\n\t\n\t    /**\n\t     * Computes `number` rounded to `precision`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Math\n\t     * @param {number} number The number to round.\n\t     * @param {number} [precision=0] The precision to round to.\n\t     * @returns {number} Returns the rounded number.\n\t     * @example\n\t     *\n\t     * _.round(4.006);\n\t     * // => 4\n\t     *\n\t     * _.round(4.006, 2);\n\t     * // => 4.01\n\t     *\n\t     * _.round(4060, -2);\n\t     * // => 4100\n\t     */\n\t    var round = createRound('round');\n\t\n\t    /**\n\t     * Subtract two numbers.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Math\n\t     * @param {number} minuend The first number in a subtraction.\n\t     * @param {number} subtrahend The second number in a subtraction.\n\t     * @returns {number} Returns the difference.\n\t     * @example\n\t     *\n\t     * _.subtract(6, 4);\n\t     * // => 2\n\t     */\n\t    function subtract(minuend, subtrahend) {\n\t      var result;\n\t      if (minuend !== undefined) {\n\t        result = minuend;\n\t      }\n\t      if (subtrahend !== undefined) {\n\t        result = result === undefined ? subtrahend : (result - subtrahend);\n\t      }\n\t      return result;\n\t    }\n\t\n\t    /**\n\t     * Computes the sum of the values in `array`.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Math\n\t     * @param {Array} array The array to iterate over.\n\t     * @returns {number} Returns the sum.\n\t     * @example\n\t     *\n\t     * _.sum([4, 2, 8, 6]);\n\t     * // => 20\n\t     */\n\t    function sum(array) {\n\t      return (array && array.length)\n\t        ? baseSum(array, identity)\n\t        : undefined;\n\t    }\n\t\n\t    /**\n\t     * This method is like `_.sum` except that it accepts `iteratee` which is\n\t     * invoked for each element in `array` to generate the value to be summed.\n\t     * The iteratee is invoked with one argument: (value).\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @category Math\n\t     * @param {Array} array The array to iterate over.\n\t     * @param {Function|Object|string} [iteratee=_.identity] The iteratee invoked per element.\n\t     * @returns {number} Returns the sum.\n\t     * @example\n\t     *\n\t     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];\n\t     *\n\t     * _.sumBy(objects, function(o) { return o.n; });\n\t     * // => 20\n\t     *\n\t     * // using the `_.property` iteratee shorthand\n\t     * _.sumBy(objects, 'n');\n\t     * // => 20\n\t     */\n\t    function sumBy(array, iteratee) {\n\t      return (array && array.length)\n\t        ? baseSum(array, getIteratee(iteratee))\n\t        : undefined;\n\t    }\n\t\n\t    /*------------------------------------------------------------------------*/\n\t\n\t    // Ensure wrappers are instances of `baseLodash`.\n\t    lodash.prototype = baseLodash.prototype;\n\t\n\t    LodashWrapper.prototype = baseCreate(baseLodash.prototype);\n\t    LodashWrapper.prototype.constructor = LodashWrapper;\n\t\n\t    LazyWrapper.prototype = baseCreate(baseLodash.prototype);\n\t    LazyWrapper.prototype.constructor = LazyWrapper;\n\t\n\t    // Avoid inheriting from `Object.prototype` when possible.\n\t    Hash.prototype = nativeCreate ? nativeCreate(null) : objectProto;\n\t\n\t    // Add functions to the `MapCache`.\n\t    MapCache.prototype.clear = mapClear;\n\t    MapCache.prototype['delete'] = mapDelete;\n\t    MapCache.prototype.get = mapGet;\n\t    MapCache.prototype.has = mapHas;\n\t    MapCache.prototype.set = mapSet;\n\t\n\t    // Add functions to the `SetCache`.\n\t    SetCache.prototype.push = cachePush;\n\t\n\t    // Add functions to the `Stack` cache.\n\t    Stack.prototype.clear = stackClear;\n\t    Stack.prototype['delete'] = stackDelete;\n\t    Stack.prototype.get = stackGet;\n\t    Stack.prototype.has = stackHas;\n\t    Stack.prototype.set = stackSet;\n\t\n\t    // Assign cache to `_.memoize`.\n\t    memoize.Cache = MapCache;\n\t\n\t    // Add functions that return wrapped values when chaining.\n\t    lodash.after = after;\n\t    lodash.ary = ary;\n\t    lodash.assign = assign;\n\t    lodash.assignIn = assignIn;\n\t    lodash.assignInWith = assignInWith;\n\t    lodash.assignWith = assignWith;\n\t    lodash.at = at;\n\t    lodash.before = before;\n\t    lodash.bind = bind;\n\t    lodash.bindAll = bindAll;\n\t    lodash.bindKey = bindKey;\n\t    lodash.chain = chain;\n\t    lodash.chunk = chunk;\n\t    lodash.compact = compact;\n\t    lodash.concat = concat;\n\t    lodash.cond = cond;\n\t    lodash.conforms = conforms;\n\t    lodash.constant = constant;\n\t    lodash.countBy = countBy;\n\t    lodash.create = create;\n\t    lodash.curry = curry;\n\t    lodash.curryRight = curryRight;\n\t    lodash.debounce = debounce;\n\t    lodash.defaults = defaults;\n\t    lodash.defaultsDeep = defaultsDeep;\n\t    lodash.defer = defer;\n\t    lodash.delay = delay;\n\t    lodash.difference = difference;\n\t    lodash.differenceBy = differenceBy;\n\t    lodash.differenceWith = differenceWith;\n\t    lodash.drop = drop;\n\t    lodash.dropRight = dropRight;\n\t    lodash.dropRightWhile = dropRightWhile;\n\t    lodash.dropWhile = dropWhile;\n\t    lodash.fill = fill;\n\t    lodash.filter = filter;\n\t    lodash.flatMap = flatMap;\n\t    lodash.flatten = flatten;\n\t    lodash.flattenDeep = flattenDeep;\n\t    lodash.flip = flip;\n\t    lodash.flow = flow;\n\t    lodash.flowRight = flowRight;\n\t    lodash.fromPairs = fromPairs;\n\t    lodash.functions = functions;\n\t    lodash.functionsIn = functionsIn;\n\t    lodash.groupBy = groupBy;\n\t    lodash.initial = initial;\n\t    lodash.intersection = intersection;\n\t    lodash.intersectionBy = intersectionBy;\n\t    lodash.intersectionWith = intersectionWith;\n\t    lodash.invert = invert;\n\t    lodash.invokeMap = invokeMap;\n\t    lodash.iteratee = iteratee;\n\t    lodash.keyBy = keyBy;\n\t    lodash.keys = keys;\n\t    lodash.keysIn = keysIn;\n\t    lodash.map = map;\n\t    lodash.mapKeys = mapKeys;\n\t    lodash.mapValues = mapValues;\n\t    lodash.matches = matches;\n\t    lodash.matchesProperty = matchesProperty;\n\t    lodash.memoize = memoize;\n\t    lodash.merge = merge;\n\t    lodash.mergeWith = mergeWith;\n\t    lodash.method = method;\n\t    lodash.methodOf = methodOf;\n\t    lodash.mixin = mixin;\n\t    lodash.negate = negate;\n\t    lodash.nthArg = nthArg;\n\t    lodash.omit = omit;\n\t    lodash.omitBy = omitBy;\n\t    lodash.once = once;\n\t    lodash.orderBy = orderBy;\n\t    lodash.over = over;\n\t    lodash.overArgs = overArgs;\n\t    lodash.overEvery = overEvery;\n\t    lodash.overSome = overSome;\n\t    lodash.partial = partial;\n\t    lodash.partialRight = partialRight;\n\t    lodash.partition = partition;\n\t    lodash.pick = pick;\n\t    lodash.pickBy = pickBy;\n\t    lodash.property = property;\n\t    lodash.propertyOf = propertyOf;\n\t    lodash.pull = pull;\n\t    lodash.pullAll = pullAll;\n\t    lodash.pullAllBy = pullAllBy;\n\t    lodash.pullAt = pullAt;\n\t    lodash.range = range;\n\t    lodash.rangeRight = rangeRight;\n\t    lodash.rearg = rearg;\n\t    lodash.reject = reject;\n\t    lodash.remove = remove;\n\t    lodash.rest = rest;\n\t    lodash.reverse = reverse;\n\t    lodash.sampleSize = sampleSize;\n\t    lodash.set = set;\n\t    lodash.setWith = setWith;\n\t    lodash.shuffle = shuffle;\n\t    lodash.slice = slice;\n\t    lodash.sortBy = sortBy;\n\t    lodash.sortedUniq = sortedUniq;\n\t    lodash.sortedUniqBy = sortedUniqBy;\n\t    lodash.split = split;\n\t    lodash.spread = spread;\n\t    lodash.tail = tail;\n\t    lodash.take = take;\n\t    lodash.takeRight = takeRight;\n\t    lodash.takeRightWhile = takeRightWhile;\n\t    lodash.takeWhile = takeWhile;\n\t    lodash.tap = tap;\n\t    lodash.throttle = throttle;\n\t    lodash.thru = thru;\n\t    lodash.toArray = toArray;\n\t    lodash.toPairs = toPairs;\n\t    lodash.toPairsIn = toPairsIn;\n\t    lodash.toPath = toPath;\n\t    lodash.toPlainObject = toPlainObject;\n\t    lodash.transform = transform;\n\t    lodash.unary = unary;\n\t    lodash.union = union;\n\t    lodash.unionBy = unionBy;\n\t    lodash.unionWith = unionWith;\n\t    lodash.uniq = uniq;\n\t    lodash.uniqBy = uniqBy;\n\t    lodash.uniqWith = uniqWith;\n\t    lodash.unset = unset;\n\t    lodash.unzip = unzip;\n\t    lodash.unzipWith = unzipWith;\n\t    lodash.values = values;\n\t    lodash.valuesIn = valuesIn;\n\t    lodash.without = without;\n\t    lodash.words = words;\n\t    lodash.wrap = wrap;\n\t    lodash.xor = xor;\n\t    lodash.xorBy = xorBy;\n\t    lodash.xorWith = xorWith;\n\t    lodash.zip = zip;\n\t    lodash.zipObject = zipObject;\n\t    lodash.zipWith = zipWith;\n\t\n\t    // Add aliases.\n\t    lodash.each = forEach;\n\t    lodash.eachRight = forEachRight;\n\t    lodash.extend = assignIn;\n\t    lodash.extendWith = assignInWith;\n\t\n\t    // Add functions to `lodash.prototype`.\n\t    mixin(lodash, lodash);\n\t\n\t    /*------------------------------------------------------------------------*/\n\t\n\t    // Add functions that return unwrapped values when chaining.\n\t    lodash.add = add;\n\t    lodash.attempt = attempt;\n\t    lodash.camelCase = camelCase;\n\t    lodash.capitalize = capitalize;\n\t    lodash.ceil = ceil;\n\t    lodash.clamp = clamp;\n\t    lodash.clone = clone;\n\t    lodash.cloneDeep = cloneDeep;\n\t    lodash.cloneDeepWith = cloneDeepWith;\n\t    lodash.cloneWith = cloneWith;\n\t    lodash.deburr = deburr;\n\t    lodash.endsWith = endsWith;\n\t    lodash.eq = eq;\n\t    lodash.escape = escape;\n\t    lodash.escapeRegExp = escapeRegExp;\n\t    lodash.every = every;\n\t    lodash.find = find;\n\t    lodash.findIndex = findIndex;\n\t    lodash.findKey = findKey;\n\t    lodash.findLast = findLast;\n\t    lodash.findLastIndex = findLastIndex;\n\t    lodash.findLastKey = findLastKey;\n\t    lodash.floor = floor;\n\t    lodash.forEach = forEach;\n\t    lodash.forEachRight = forEachRight;\n\t    lodash.forIn = forIn;\n\t    lodash.forInRight = forInRight;\n\t    lodash.forOwn = forOwn;\n\t    lodash.forOwnRight = forOwnRight;\n\t    lodash.get = get;\n\t    lodash.gt = gt;\n\t    lodash.gte = gte;\n\t    lodash.has = has;\n\t    lodash.hasIn = hasIn;\n\t    lodash.head = head;\n\t    lodash.identity = identity;\n\t    lodash.includes = includes;\n\t    lodash.indexOf = indexOf;\n\t    lodash.inRange = inRange;\n\t    lodash.invoke = invoke;\n\t    lodash.isArguments = isArguments;\n\t    lodash.isArray = isArray;\n\t    lodash.isArrayLike = isArrayLike;\n\t    lodash.isArrayLikeObject = isArrayLikeObject;\n\t    lodash.isBoolean = isBoolean;\n\t    lodash.isDate = isDate;\n\t    lodash.isElement = isElement;\n\t    lodash.isEmpty = isEmpty;\n\t    lodash.isEqual = isEqual;\n\t    lodash.isEqualWith = isEqualWith;\n\t    lodash.isError = isError;\n\t    lodash.isFinite = isFinite;\n\t    lodash.isFunction = isFunction;\n\t    lodash.isInteger = isInteger;\n\t    lodash.isLength = isLength;\n\t    lodash.isMatch = isMatch;\n\t    lodash.isMatchWith = isMatchWith;\n\t    lodash.isNaN = isNaN;\n\t    lodash.isNative = isNative;\n\t    lodash.isNil = isNil;\n\t    lodash.isNull = isNull;\n\t    lodash.isNumber = isNumber;\n\t    lodash.isObject = isObject;\n\t    lodash.isObjectLike = isObjectLike;\n\t    lodash.isPlainObject = isPlainObject;\n\t    lodash.isRegExp = isRegExp;\n\t    lodash.isSafeInteger = isSafeInteger;\n\t    lodash.isString = isString;\n\t    lodash.isSymbol = isSymbol;\n\t    lodash.isTypedArray = isTypedArray;\n\t    lodash.isUndefined = isUndefined;\n\t    lodash.join = join;\n\t    lodash.kebabCase = kebabCase;\n\t    lodash.last = last;\n\t    lodash.lastIndexOf = lastIndexOf;\n\t    lodash.lowerCase = lowerCase;\n\t    lodash.lowerFirst = lowerFirst;\n\t    lodash.lt = lt;\n\t    lodash.lte = lte;\n\t    lodash.max = max;\n\t    lodash.maxBy = maxBy;\n\t    lodash.mean = mean;\n\t    lodash.min = min;\n\t    lodash.minBy = minBy;\n\t    lodash.noConflict = noConflict;\n\t    lodash.noop = noop;\n\t    lodash.now = now;\n\t    lodash.pad = pad;\n\t    lodash.padEnd = padEnd;\n\t    lodash.padStart = padStart;\n\t    lodash.parseInt = parseInt;\n\t    lodash.random = random;\n\t    lodash.reduce = reduce;\n\t    lodash.reduceRight = reduceRight;\n\t    lodash.repeat = repeat;\n\t    lodash.replace = replace;\n\t    lodash.result = result;\n\t    lodash.round = round;\n\t    lodash.runInContext = runInContext;\n\t    lodash.sample = sample;\n\t    lodash.size = size;\n\t    lodash.snakeCase = snakeCase;\n\t    lodash.some = some;\n\t    lodash.sortedIndex = sortedIndex;\n\t    lodash.sortedIndexBy = sortedIndexBy;\n\t    lodash.sortedIndexOf = sortedIndexOf;\n\t    lodash.sortedLastIndex = sortedLastIndex;\n\t    lodash.sortedLastIndexBy = sortedLastIndexBy;\n\t    lodash.sortedLastIndexOf = sortedLastIndexOf;\n\t    lodash.startCase = startCase;\n\t    lodash.startsWith = startsWith;\n\t    lodash.subtract = subtract;\n\t    lodash.sum = sum;\n\t    lodash.sumBy = sumBy;\n\t    lodash.template = template;\n\t    lodash.times = times;\n\t    lodash.toInteger = toInteger;\n\t    lodash.toLength = toLength;\n\t    lodash.toLower = toLower;\n\t    lodash.toNumber = toNumber;\n\t    lodash.toSafeInteger = toSafeInteger;\n\t    lodash.toString = toString;\n\t    lodash.toUpper = toUpper;\n\t    lodash.trim = trim;\n\t    lodash.trimEnd = trimEnd;\n\t    lodash.trimStart = trimStart;\n\t    lodash.truncate = truncate;\n\t    lodash.unescape = unescape;\n\t    lodash.uniqueId = uniqueId;\n\t    lodash.upperCase = upperCase;\n\t    lodash.upperFirst = upperFirst;\n\t\n\t    // Add aliases.\n\t    lodash.first = head;\n\t\n\t    mixin(lodash, (function() {\n\t      var source = {};\n\t      baseForOwn(lodash, function(func, methodName) {\n\t        if (!hasOwnProperty.call(lodash.prototype, methodName)) {\n\t          source[methodName] = func;\n\t        }\n\t      });\n\t      return source;\n\t    }()), { 'chain': false });\n\t\n\t    /*------------------------------------------------------------------------*/\n\t\n\t    /**\n\t     * The semantic version number.\n\t     *\n\t     * @static\n\t     * @memberOf _\n\t     * @type string\n\t     */\n\t    lodash.VERSION = VERSION;\n\t\n\t    // Assign default placeholders.\n\t    arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {\n\t      lodash[methodName].placeholder = lodash;\n\t    });\n\t\n\t    // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.\n\t    arrayEach(['drop', 'take'], function(methodName, index) {\n\t      LazyWrapper.prototype[methodName] = function(n) {\n\t        var filtered = this.__filtered__;\n\t        if (filtered && !index) {\n\t          return new LazyWrapper(this);\n\t        }\n\t        n = n === undefined ? 1 : nativeMax(toInteger(n), 0);\n\t\n\t        var result = this.clone();\n\t        if (filtered) {\n\t          result.__takeCount__ = nativeMin(n, result.__takeCount__);\n\t        } else {\n\t          result.__views__.push({ 'size': nativeMin(n, MAX_ARRAY_LENGTH), 'type': methodName + (result.__dir__ < 0 ? 'Right' : '') });\n\t        }\n\t        return result;\n\t      };\n\t\n\t      LazyWrapper.prototype[methodName + 'Right'] = function(n) {\n\t        return this.reverse()[methodName](n).reverse();\n\t      };\n\t    });\n\t\n\t    // Add `LazyWrapper` methods that accept an `iteratee` value.\n\t    arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {\n\t      var type = index + 1,\n\t          isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;\n\t\n\t      LazyWrapper.prototype[methodName] = function(iteratee) {\n\t        var result = this.clone();\n\t        result.__iteratees__.push({ 'iteratee': getIteratee(iteratee, 3), 'type': type });\n\t        result.__filtered__ = result.__filtered__ || isFilter;\n\t        return result;\n\t      };\n\t    });\n\t\n\t    // Add `LazyWrapper` methods for `_.head` and `_.last`.\n\t    arrayEach(['head', 'last'], function(methodName, index) {\n\t      var takeName = 'take' + (index ? 'Right' : '');\n\t\n\t      LazyWrapper.prototype[methodName] = function() {\n\t        return this[takeName](1).value()[0];\n\t      };\n\t    });\n\t\n\t    // Add `LazyWrapper` methods for `_.initial` and `_.tail`.\n\t    arrayEach(['initial', 'tail'], function(methodName, index) {\n\t      var dropName = 'drop' + (index ? '' : 'Right');\n\t\n\t      LazyWrapper.prototype[methodName] = function() {\n\t        return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);\n\t      };\n\t    });\n\t\n\t    LazyWrapper.prototype.compact = function() {\n\t      return this.filter(identity);\n\t    };\n\t\n\t    LazyWrapper.prototype.find = function(predicate) {\n\t      return this.filter(predicate).head();\n\t    };\n\t\n\t    LazyWrapper.prototype.findLast = function(predicate) {\n\t      return this.reverse().find(predicate);\n\t    };\n\t\n\t    LazyWrapper.prototype.invokeMap = rest(function(path, args) {\n\t      if (typeof path == 'function') {\n\t        return new LazyWrapper(this);\n\t      }\n\t      return this.map(function(value) {\n\t        return baseInvoke(value, path, args);\n\t      });\n\t    });\n\t\n\t    LazyWrapper.prototype.reject = function(predicate) {\n\t      predicate = getIteratee(predicate, 3);\n\t      return this.filter(function(value) {\n\t        return !predicate(value);\n\t      });\n\t    };\n\t\n\t    LazyWrapper.prototype.slice = function(start, end) {\n\t      start = toInteger(start);\n\t\n\t      var result = this;\n\t      if (result.__filtered__ && (start > 0 || end < 0)) {\n\t        return new LazyWrapper(result);\n\t      }\n\t      if (start < 0) {\n\t        result = result.takeRight(-start);\n\t      } else if (start) {\n\t        result = result.drop(start);\n\t      }\n\t      if (end !== undefined) {\n\t        end = toInteger(end);\n\t        result = end < 0 ? result.dropRight(-end) : result.take(end - start);\n\t      }\n\t      return result;\n\t    };\n\t\n\t    LazyWrapper.prototype.takeRightWhile = function(predicate) {\n\t      return this.reverse().takeWhile(predicate).reverse();\n\t    };\n\t\n\t    LazyWrapper.prototype.toArray = function() {\n\t      return this.take(MAX_ARRAY_LENGTH);\n\t    };\n\t\n\t    // Add `LazyWrapper` methods to `lodash.prototype`.\n\t    baseForOwn(LazyWrapper.prototype, function(func, methodName) {\n\t      var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName),\n\t          isTaker = /^(?:head|last)$/.test(methodName),\n\t          lodashFunc = lodash[isTaker ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName],\n\t          retUnwrapped = isTaker || /^find/.test(methodName);\n\t\n\t      if (!lodashFunc) {\n\t        return;\n\t      }\n\t      lodash.prototype[methodName] = function() {\n\t        var value = this.__wrapped__,\n\t            args = isTaker ? [1] : arguments,\n\t            isLazy = value instanceof LazyWrapper,\n\t            iteratee = args[0],\n\t            useLazy = isLazy || isArray(value);\n\t\n\t        var interceptor = function(value) {\n\t          var result = lodashFunc.apply(lodash, arrayPush([value], args));\n\t          return (isTaker && chainAll) ? result[0] : result;\n\t        };\n\t\n\t        if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {\n\t          // Avoid lazy use if the iteratee has a \"length\" value other than `1`.\n\t          isLazy = useLazy = false;\n\t        }\n\t        var chainAll = this.__chain__,\n\t            isHybrid = !!this.__actions__.length,\n\t            isUnwrapped = retUnwrapped && !chainAll,\n\t            onlyLazy = isLazy && !isHybrid;\n\t\n\t        if (!retUnwrapped && useLazy) {\n\t          value = onlyLazy ? value : new LazyWrapper(this);\n\t          var result = func.apply(value, args);\n\t          result.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined });\n\t          return new LodashWrapper(result, chainAll);\n\t        }\n\t        if (isUnwrapped && onlyLazy) {\n\t          return func.apply(this, args);\n\t        }\n\t        result = this.thru(interceptor);\n\t        return isUnwrapped ? (isTaker ? result.value()[0] : result.value()) : result;\n\t      };\n\t    });\n\t\n\t    // Add `Array` and `String` methods to `lodash.prototype`.\n\t    arrayEach(['pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function(methodName) {\n\t      var func = arrayProto[methodName],\n\t          chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',\n\t          retUnwrapped = /^(?:pop|shift)$/.test(methodName);\n\t\n\t      lodash.prototype[methodName] = function() {\n\t        var args = arguments;\n\t        if (retUnwrapped && !this.__chain__) {\n\t          return func.apply(this.value(), args);\n\t        }\n\t        return this[chainName](function(value) {\n\t          return func.apply(value, args);\n\t        });\n\t      };\n\t    });\n\t\n\t    // Map minified function names to their real names.\n\t    baseForOwn(LazyWrapper.prototype, function(func, methodName) {\n\t      var lodashFunc = lodash[methodName];\n\t      if (lodashFunc) {\n\t        var key = (lodashFunc.name + ''),\n\t            names = realNames[key] || (realNames[key] = []);\n\t\n\t        names.push({ 'name': methodName, 'func': lodashFunc });\n\t      }\n\t    });\n\t\n\t    realNames[createHybridWrapper(undefined, BIND_KEY_FLAG).name] = [{ 'name': 'wrapper', 'func': undefined }];\n\t\n\t    // Add functions to the lazy wrapper.\n\t    LazyWrapper.prototype.clone = lazyClone;\n\t    LazyWrapper.prototype.reverse = lazyReverse;\n\t    LazyWrapper.prototype.value = lazyValue;\n\t\n\t    // Add chaining functions to the `lodash` wrapper.\n\t    lodash.prototype.at = wrapperAt;\n\t    lodash.prototype.chain = wrapperChain;\n\t    lodash.prototype.commit = wrapperCommit;\n\t    lodash.prototype.flatMap = wrapperFlatMap;\n\t    lodash.prototype.next = wrapperNext;\n\t    lodash.prototype.plant = wrapperPlant;\n\t    lodash.prototype.reverse = wrapperReverse;\n\t    lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;\n\t\n\t    if (iteratorSymbol) {\n\t      lodash.prototype[iteratorSymbol] = wrapperToIterator;\n\t    }\n\t    return lodash;\n\t  }\n\t\n\t  /*--------------------------------------------------------------------------*/\n\t\n\t  // Export lodash.\n\t  var _ = runInContext();\n\t\n\t  // Expose lodash on the free variable `window` or `self` when available. This\n\t  // prevents errors in cases where lodash is loaded by a script tag in the presence\n\t  // of an AMD loader. See http://requirejs.org/docs/errors.html#mismatch for more details.\n\t  (freeWindow || freeSelf || {})._ = _;\n\t\n\t  // Some AMD build optimizers like r.js check for condition patterns like the following:\n\t  if (true) {\n\t    // Define as an anonymous module so, through path mapping, it can be\n\t    // referenced as the \"underscore\" module.\n\t    !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {\n\t      return _;\n\t    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t  }\n\t  // Check for `exports` after `define` in case a build optimizer adds an `exports` object.\n\t  else if (freeExports && freeModule) {\n\t    // Export for Node.js.\n\t    if (moduleExports) {\n\t      (freeModule.exports = _)._ = _;\n\t    }\n\t    // Export for CommonJS support.\n\t    freeExports._ = _;\n\t  }\n\t  else {\n\t    // Export to the global object.\n\t    root._ = _;\n\t  }\n\t}.call(this));\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(50)(module), (function() { return this; }())))\n\n/***/ },\n/* 103 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _slicedToArray2 = __webpack_require__(3);\n\t\n\tvar _slicedToArray3 = _interopRequireDefault(_slicedToArray2);\n\t\n\tvar _classCallCheck2 = __webpack_require__(45);\n\t\n\tvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\t\n\tvar _createClass2 = __webpack_require__(46);\n\t\n\tvar _createClass3 = _interopRequireDefault(_createClass2);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar h = __webpack_require__(78);\n\t\n\tvar TodoItem = function () {\n\t  function TodoItem(emit, eventBus) {\n\t    (0, _classCallCheck3.default)(this, TodoItem);\n\t\n\t    this.emit = emit;\n\t    this.eventBus = eventBus;\n\t  }\n\t\n\t  (0, _createClass3.default)(TodoItem, [{\n\t    key: 'cssClass',\n\t    value: function cssClass(item) {\n\t      if (item.completed === true) {\n\t        return 'completed';\n\t      } else if (item.editing === true) {\n\t        return 'editing';\n\t      } else {\n\t        return '';\n\t      }\n\t    }\n\t  }, {\n\t    key: 'render',\n\t    value: function render(_ref) {\n\t      var _this = this;\n\t\n\t      var _ref2 = (0, _slicedToArray3.default)(_ref, 2);\n\t\n\t      var id = _ref2[0];\n\t      var item = _ref2[1];\n\t\n\t      var cssClass = this.cssClass(item),\n\t          save = function save(ev) {\n\t        if (ev.keyCode == 13) {\n\t          _this.emit({\n\t            id: id,\n\t            action: 'save',\n\t            text: ev.target.value\n\t          });\n\t        }\n\t      },\n\t          emit = function emit(action) {\n\t        return function (ev) {\n\t          _this.emit({ action: action, id: id });\n\t        };\n\t      };\n\t      return h('li', { class: cssClass }, [h('div', { class: \"view\" }, [h('input', { class: \"toggle\",\n\t        type: \"checkbox\",\n\t        'ev-click': emit(item.completed ? 'uncomplete' : 'complete'),\n\t        checked: item.completed ? true : undefined }), h('label', { 'ev-dblclick': emit('edit') }, [item.text]), h('button', { class: \"destroy\", 'ev-click': emit('destroy') })]), h('input', { class: \"edit\",\n\t        value: item.text,\n\t        'ev-keyup': save,\n\t        'ev-blur': emit('unedit'),\n\t        autofocus: item.editing ? true : undefined })]);\n\t    }\n\t  }]);\n\t  return TodoItem;\n\t}();\n\t\n\tmodule.exports = TodoItem;\n\n/***/ },\n/* 104 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tmodule.exports = function () {\n\t  return Math.random().toString(36).substring(7);\n\t};\n\n/***/ },\n/* 105 */\n/***/ function(module, exports) {\n\n\t// removed by extract-text-webpack-plugin\n\n/***/ }\n/******/ ]);\n\n\n/** WEBPACK FOOTER **\n ** todo-mvc-rx-virtual-dom.bundle.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 3460af023be0bd1c8da3\n **/","require('expose?Todo!./src/app.js');\n\n\n\n/** WEBPACK FOOTER **\n ** ./entry.js\n **/","module.exports = global[\"Todo\"] = require(\"-!/Users/james/projects/todo-mvc-rx-virtual-dom/node_modules/babel-loader/index.js?presets[]=es2015,plugins[]=transform-runtime!/Users/james/projects/todo-mvc-rx-virtual-dom/src/app.js\");\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/expose-loader?Todo!./src/app.js\n ** module id = 1\n ** module chunks = 0\n **/","var Rx = require('rx'),\n    Immutable = require('seamless-immutable'),\n    RxWidget = require('./rx-widget'),\n    TodoList = require('./todo-list'),\n    genId = require('./gen-id');\n\nrequire('todomvc-app-css/index.css');\n\nclass Todo {\n  constructor(container) {\n    this.container = container;\n    this.eventBus = new Rx.Subject();\n    this.recording = null;\n    this.state = null;\n    this.stateSnapshot = null;\n  }\n\n  startRecording() {\n    let start = new Date();\n    this.eventBus.takeWhile((event) => {\n      return event.action !== 'stopRecording';\n    }).map((event) => {\n      return event.set('_recordingDelay', new Date() - start);\n    }).toArray().subscribe(\n      (recording) => { this.recording = Immutable(recording).asMutable({deep: true}); },\n      (error) => { console.error('[Recording]', error); },\n      () => { console.debug('[Recording] done'); }\n    );\n  }\n\n  stopRecording() {\n    this.emit({ action: 'stopRecording' });\n    return this.recording;\n  }\n\n  playRecording(recording0, options0) {\n    let options = _.merge({realTime: true, speed: 1}, options0),\n        recording;\n\n    if(options.realTime) {\n      recording = Rx.Observable.from(recording0).flatMap((event) => {\n        return Rx.Observable.just(Immutable(event).without('_recordingDelay'))\n          .delay(event._recordingDelay / options.speed);\n      });\n    } else {\n      recording = Rx.Observable.from(recording0);\n    }\n\n    recording.subscribe(\n      (event) => { this.eventBus.onNext(event); },\n      (error) => { console.error('[Playback]', error); },\n      () => { console.debug('[Playback] done'); }\n    );\n  }\n\n  currentState() {\n    this.emit({action: 'stateSnapshot'});\n    return this.stateSnapshot.asMutable();\n  }\n\n  replaceState(state) {\n    this.emit({action: 'replaceState', state: state});\n  }\n\n  emit(event) {\n    return this.eventBus.onNext(Immutable(event));\n  }\n\n  init() {\n    let initial = Immutable({\n          show: 'all',\n          todos: {}\n        });\n\n    this.state = this.eventBus.scan((acc, event) => {\n      switch(event.action) {\n      case 'create':\n        return acc.setIn(['todos', genId()], {\n          text: event.text,\n          editing: false,\n          completed: false\n        });\n      case 'edit':\n        return acc.setIn(['todos', event.id, 'editing'], true);\n      case 'unedit':\n        return acc.setIn(['todos', event.id, 'editing'], false);\n      case 'save':\n        return acc.setIn(['todos', event.id, 'editing'], false)\n          .setIn(['todos', event.id, 'text'], event.text);\n      case 'uncomplete':\n        return acc.setIn(['todos', event.id, 'completed'], false);\n      case 'complete':\n        return acc.setIn(['todos', event.id, 'completed'], true);\n      case 'destroy':\n        return acc.setIn(['todos'], acc.todos.without([event.id]));\n      case 'clearCompleted':\n        let removeIds = _.flatMap(_.toPairs(acc.todos), ([id, todo]) => {\n          if(todo.completed) {\n            return [id];\n          } else {\n            return [];\n          }\n        });\n        return acc.setIn(['todos'], acc.todos.without(removeIds));\n      case 'toggelAll':\n        return acc.setIn(['todos'], Immutable(_.toPairs(acc.todos)).map(([id, todo]) => {\n          return [id, todo.set('completed', event.completed)];\n        }).asObject());\n      case 'show':\n        return acc.setIn(['show'], event.show);\n      case 'stateSnapshot':\n        this.stateSnapshot = acc;\n        return acc;\n      case 'replaceState':\n        return event.state;\n      default:\n        return acc;\n      }\n    }, initial);\n\n    // if debug\n    this.eventBus.subscribe((e) => { console.debug('[Commands]', e); },\n                            (e) => { console.error('[Commands]', e); },\n                            () => { console.debug('[Commands]', 'Completed'); });\n\n    this.state.subscribe((e) => { console.debug('[View]', e); },\n                              (e) => { console.error('[View]', e); },\n                              () => { console.debug('[View]', 'Completed'); });\n\n    let root = new TodoList((e) => { return this.emit(e); }, this.state),\n        widget = new RxWidget(this.state, (opts) => { return root.render(opts); }, initial);\n\n    this.container.appendChild(widget.init());\n  }\n}\n\nmodule.exports = Todo;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/app.js\n **/","\"use strict\";\n\nexports.__esModule = true;\n\nvar _isIterable2 = require(\"../core-js/is-iterable\");\n\nvar _isIterable3 = _interopRequireDefault(_isIterable2);\n\nvar _getIterator2 = require(\"../core-js/get-iterator\");\n\nvar _getIterator3 = _interopRequireDefault(_getIterator2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = (function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = (0, _getIterator3.default)(arr), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if ((0, _isIterable3.default)(Object(arr))) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n})();\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/helpers/slicedToArray.js\n ** module id = 3\n ** module chunks = 0\n **/","module.exports = { \"default\": require(\"core-js/library/fn/is-iterable\"), __esModule: true };\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/core-js/is-iterable.js\n ** module id = 4\n ** module chunks = 0\n **/","require('../modules/web.dom.iterable');\nrequire('../modules/es6.string.iterator');\nmodule.exports = require('../modules/core.is-iterable');\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/fn/is-iterable.js\n ** module id = 5\n ** module chunks = 0\n **/","require('./es6.array.iterator');\nvar Iterators = require('./$.iterators');\nIterators.NodeList = Iterators.HTMLCollection = Iterators.Array;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/web.dom.iterable.js\n ** module id = 6\n ** module chunks = 0\n **/","'use strict';\nvar addToUnscopables = require('./$.add-to-unscopables')\n  , step             = require('./$.iter-step')\n  , Iterators        = require('./$.iterators')\n  , toIObject        = require('./$.to-iobject');\n\n// 22.1.3.4 Array.prototype.entries()\n// 22.1.3.13 Array.prototype.keys()\n// 22.1.3.29 Array.prototype.values()\n// 22.1.3.30 Array.prototype[@@iterator]()\nmodule.exports = require('./$.iter-define')(Array, 'Array', function(iterated, kind){\n  this._t = toIObject(iterated); // target\n  this._i = 0;                   // next index\n  this._k = kind;                // kind\n// 22.1.5.2.1 %ArrayIteratorPrototype%.next()\n}, function(){\n  var O     = this._t\n    , kind  = this._k\n    , index = this._i++;\n  if(!O || index >= O.length){\n    this._t = undefined;\n    return step(1);\n  }\n  if(kind == 'keys'  )return step(0, index);\n  if(kind == 'values')return step(0, O[index]);\n  return step(0, [index, O[index]]);\n}, 'values');\n\n// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)\nIterators.Arguments = Iterators.Array;\n\naddToUnscopables('keys');\naddToUnscopables('values');\naddToUnscopables('entries');\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/es6.array.iterator.js\n ** module id = 7\n ** module chunks = 0\n **/","module.exports = function(){ /* empty */ };\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/$.add-to-unscopables.js\n ** module id = 8\n ** module chunks = 0\n **/","module.exports = function(done, value){\n  return {value: value, done: !!done};\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/$.iter-step.js\n ** module id = 9\n ** module chunks = 0\n **/","module.exports = {};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/$.iterators.js\n ** module id = 10\n ** module chunks = 0\n **/","// to indexed object, toObject with fallback for non-array-like ES3 strings\nvar IObject = require('./$.iobject')\n  , defined = require('./$.defined');\nmodule.exports = function(it){\n  return IObject(defined(it));\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/$.to-iobject.js\n ** module id = 11\n ** module chunks = 0\n **/","// fallback for non-array-like ES3 and non-enumerable old V8 strings\nvar cof = require('./$.cof');\nmodule.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){\n  return cof(it) == 'String' ? it.split('') : Object(it);\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/$.iobject.js\n ** module id = 12\n ** module chunks = 0\n **/","var toString = {}.toString;\n\nmodule.exports = function(it){\n  return toString.call(it).slice(8, -1);\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/$.cof.js\n ** module id = 13\n ** module chunks = 0\n **/","// 7.2.1 RequireObjectCoercible(argument)\nmodule.exports = function(it){\n  if(it == undefined)throw TypeError(\"Can't call method on  \" + it);\n  return it;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/$.defined.js\n ** module id = 14\n ** module chunks = 0\n **/","'use strict';\nvar LIBRARY        = require('./$.library')\n  , $export        = require('./$.export')\n  , redefine       = require('./$.redefine')\n  , hide           = require('./$.hide')\n  , has            = require('./$.has')\n  , Iterators      = require('./$.iterators')\n  , $iterCreate    = require('./$.iter-create')\n  , setToStringTag = require('./$.set-to-string-tag')\n  , getProto       = require('./$').getProto\n  , ITERATOR       = require('./$.wks')('iterator')\n  , BUGGY          = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`\n  , FF_ITERATOR    = '@@iterator'\n  , KEYS           = 'keys'\n  , VALUES         = 'values';\n\nvar returnThis = function(){ return this; };\n\nmodule.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){\n  $iterCreate(Constructor, NAME, next);\n  var getMethod = function(kind){\n    if(!BUGGY && kind in proto)return proto[kind];\n    switch(kind){\n      case KEYS: return function keys(){ return new Constructor(this, kind); };\n      case VALUES: return function values(){ return new Constructor(this, kind); };\n    } return function entries(){ return new Constructor(this, kind); };\n  };\n  var TAG        = NAME + ' Iterator'\n    , DEF_VALUES = DEFAULT == VALUES\n    , VALUES_BUG = false\n    , proto      = Base.prototype\n    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]\n    , $default   = $native || getMethod(DEFAULT)\n    , methods, key;\n  // Fix native\n  if($native){\n    var IteratorPrototype = getProto($default.call(new Base));\n    // Set @@toStringTag to native iterators\n    setToStringTag(IteratorPrototype, TAG, true);\n    // FF fix\n    if(!LIBRARY && has(proto, FF_ITERATOR))hide(IteratorPrototype, ITERATOR, returnThis);\n    // fix Array#{values, @@iterator}.name in V8 / FF\n    if(DEF_VALUES && $native.name !== VALUES){\n      VALUES_BUG = true;\n      $default = function values(){ return $native.call(this); };\n    }\n  }\n  // Define iterator\n  if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){\n    hide(proto, ITERATOR, $default);\n  }\n  // Plug for library\n  Iterators[NAME] = $default;\n  Iterators[TAG]  = returnThis;\n  if(DEFAULT){\n    methods = {\n      values:  DEF_VALUES  ? $default : getMethod(VALUES),\n      keys:    IS_SET      ? $default : getMethod(KEYS),\n      entries: !DEF_VALUES ? $default : getMethod('entries')\n    };\n    if(FORCED)for(key in methods){\n      if(!(key in proto))redefine(proto, key, methods[key]);\n    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);\n  }\n  return methods;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/$.iter-define.js\n ** module id = 15\n ** module chunks = 0\n **/","module.exports = true;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/$.library.js\n ** module id = 16\n ** module chunks = 0\n **/","var global    = require('./$.global')\n  , core      = require('./$.core')\n  , ctx       = require('./$.ctx')\n  , PROTOTYPE = 'prototype';\n\nvar $export = function(type, name, source){\n  var IS_FORCED = type & $export.F\n    , IS_GLOBAL = type & $export.G\n    , IS_STATIC = type & $export.S\n    , IS_PROTO  = type & $export.P\n    , IS_BIND   = type & $export.B\n    , IS_WRAP   = type & $export.W\n    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})\n    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]\n    , key, own, out;\n  if(IS_GLOBAL)source = name;\n  for(key in source){\n    // contains in native\n    own = !IS_FORCED && target && key in target;\n    if(own && key in exports)continue;\n    // export native or passed\n    out = own ? target[key] : source[key];\n    // prevent global pollution for namespaces\n    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]\n    // bind timers to global for call from export context\n    : IS_BIND && own ? ctx(out, global)\n    // wrap global constructors for prevent change them in library\n    : IS_WRAP && target[key] == out ? (function(C){\n      var F = function(param){\n        return this instanceof C ? new C(param) : C(param);\n      };\n      F[PROTOTYPE] = C[PROTOTYPE];\n      return F;\n    // make static versions for prototype methods\n    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;\n    if(IS_PROTO)(exports[PROTOTYPE] || (exports[PROTOTYPE] = {}))[key] = out;\n  }\n};\n// type bitmap\n$export.F = 1;  // forced\n$export.G = 2;  // global\n$export.S = 4;  // static\n$export.P = 8;  // proto\n$export.B = 16; // bind\n$export.W = 32; // wrap\nmodule.exports = $export;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/$.export.js\n ** module id = 17\n ** module chunks = 0\n **/","// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nvar global = module.exports = typeof window != 'undefined' && window.Math == Math\n  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();\nif(typeof __g == 'number')__g = global; // eslint-disable-line no-undef\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/$.global.js\n ** module id = 18\n ** module chunks = 0\n **/","var core = module.exports = {version: '1.2.6'};\nif(typeof __e == 'number')__e = core; // eslint-disable-line no-undef\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/$.core.js\n ** module id = 19\n ** module chunks = 0\n **/","// optional / simple context binding\nvar aFunction = require('./$.a-function');\nmodule.exports = function(fn, that, length){\n  aFunction(fn);\n  if(that === undefined)return fn;\n  switch(length){\n    case 1: return function(a){\n      return fn.call(that, a);\n    };\n    case 2: return function(a, b){\n      return fn.call(that, a, b);\n    };\n    case 3: return function(a, b, c){\n      return fn.call(that, a, b, c);\n    };\n  }\n  return function(/* ...args */){\n    return fn.apply(that, arguments);\n  };\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/$.ctx.js\n ** module id = 20\n ** module chunks = 0\n **/","module.exports = function(it){\n  if(typeof it != 'function')throw TypeError(it + ' is not a function!');\n  return it;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/$.a-function.js\n ** module id = 21\n ** module chunks = 0\n **/","module.exports = require('./$.hide');\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/$.redefine.js\n ** module id = 22\n ** module chunks = 0\n **/","var $          = require('./$')\n  , createDesc = require('./$.property-desc');\nmodule.exports = require('./$.descriptors') ? function(object, key, value){\n  return $.setDesc(object, key, createDesc(1, value));\n} : function(object, key, value){\n  object[key] = value;\n  return object;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/$.hide.js\n ** module id = 23\n ** module chunks = 0\n **/","var $Object = Object;\nmodule.exports = {\n  create:     $Object.create,\n  getProto:   $Object.getPrototypeOf,\n  isEnum:     {}.propertyIsEnumerable,\n  getDesc:    $Object.getOwnPropertyDescriptor,\n  setDesc:    $Object.defineProperty,\n  setDescs:   $Object.defineProperties,\n  getKeys:    $Object.keys,\n  getNames:   $Object.getOwnPropertyNames,\n  getSymbols: $Object.getOwnPropertySymbols,\n  each:       [].forEach\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/$.js\n ** module id = 24\n ** module chunks = 0\n **/","module.exports = function(bitmap, value){\n  return {\n    enumerable  : !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable    : !(bitmap & 4),\n    value       : value\n  };\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/$.property-desc.js\n ** module id = 25\n ** module chunks = 0\n **/","// Thank's IE8 for his funny defineProperty\nmodule.exports = !require('./$.fails')(function(){\n  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;\n});\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/$.descriptors.js\n ** module id = 26\n ** module chunks = 0\n **/","module.exports = function(exec){\n  try {\n    return !!exec();\n  } catch(e){\n    return true;\n  }\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/$.fails.js\n ** module id = 27\n ** module chunks = 0\n **/","var hasOwnProperty = {}.hasOwnProperty;\nmodule.exports = function(it, key){\n  return hasOwnProperty.call(it, key);\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/$.has.js\n ** module id = 28\n ** module chunks = 0\n **/","'use strict';\nvar $              = require('./$')\n  , descriptor     = require('./$.property-desc')\n  , setToStringTag = require('./$.set-to-string-tag')\n  , IteratorPrototype = {};\n\n// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()\nrequire('./$.hide')(IteratorPrototype, require('./$.wks')('iterator'), function(){ return this; });\n\nmodule.exports = function(Constructor, NAME, next){\n  Constructor.prototype = $.create(IteratorPrototype, {next: descriptor(1, next)});\n  setToStringTag(Constructor, NAME + ' Iterator');\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/$.iter-create.js\n ** module id = 29\n ** module chunks = 0\n **/","var def = require('./$').setDesc\n  , has = require('./$.has')\n  , TAG = require('./$.wks')('toStringTag');\n\nmodule.exports = function(it, tag, stat){\n  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/$.set-to-string-tag.js\n ** module id = 30\n ** module chunks = 0\n **/","var store  = require('./$.shared')('wks')\n  , uid    = require('./$.uid')\n  , Symbol = require('./$.global').Symbol;\nmodule.exports = function(name){\n  return store[name] || (store[name] =\n    Symbol && Symbol[name] || (Symbol || uid)('Symbol.' + name));\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/$.wks.js\n ** module id = 31\n ** module chunks = 0\n **/","var global = require('./$.global')\n  , SHARED = '__core-js_shared__'\n  , store  = global[SHARED] || (global[SHARED] = {});\nmodule.exports = function(key){\n  return store[key] || (store[key] = {});\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/$.shared.js\n ** module id = 32\n ** module chunks = 0\n **/","var id = 0\n  , px = Math.random();\nmodule.exports = function(key){\n  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/$.uid.js\n ** module id = 33\n ** module chunks = 0\n **/","'use strict';\nvar $at  = require('./$.string-at')(true);\n\n// 21.1.3.27 String.prototype[@@iterator]()\nrequire('./$.iter-define')(String, 'String', function(iterated){\n  this._t = String(iterated); // target\n  this._i = 0;                // next index\n// 21.1.5.2.1 %StringIteratorPrototype%.next()\n}, function(){\n  var O     = this._t\n    , index = this._i\n    , point;\n  if(index >= O.length)return {value: undefined, done: true};\n  point = $at(O, index);\n  this._i += point.length;\n  return {value: point, done: false};\n});\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/es6.string.iterator.js\n ** module id = 34\n ** module chunks = 0\n **/","var toInteger = require('./$.to-integer')\n  , defined   = require('./$.defined');\n// true  -> String#at\n// false -> String#codePointAt\nmodule.exports = function(TO_STRING){\n  return function(that, pos){\n    var s = String(defined(that))\n      , i = toInteger(pos)\n      , l = s.length\n      , a, b;\n    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;\n    a = s.charCodeAt(i);\n    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff\n      ? TO_STRING ? s.charAt(i) : a\n      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;\n  };\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/$.string-at.js\n ** module id = 35\n ** module chunks = 0\n **/","// 7.1.4 ToInteger\nvar ceil  = Math.ceil\n  , floor = Math.floor;\nmodule.exports = function(it){\n  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/$.to-integer.js\n ** module id = 36\n ** module chunks = 0\n **/","var classof   = require('./$.classof')\n  , ITERATOR  = require('./$.wks')('iterator')\n  , Iterators = require('./$.iterators');\nmodule.exports = require('./$.core').isIterable = function(it){\n  var O = Object(it);\n  return O[ITERATOR] !== undefined\n    || '@@iterator' in O\n    || Iterators.hasOwnProperty(classof(O));\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/core.is-iterable.js\n ** module id = 37\n ** module chunks = 0\n **/","// getting tag from 19.1.3.6 Object.prototype.toString()\nvar cof = require('./$.cof')\n  , TAG = require('./$.wks')('toStringTag')\n  // ES3 wrong here\n  , ARG = cof(function(){ return arguments; }()) == 'Arguments';\n\nmodule.exports = function(it){\n  var O, T, B;\n  return it === undefined ? 'Undefined' : it === null ? 'Null'\n    // @@toStringTag case\n    : typeof (T = (O = Object(it))[TAG]) == 'string' ? T\n    // builtinTag case\n    : ARG ? cof(O)\n    // ES3 arguments fallback\n    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/$.classof.js\n ** module id = 38\n ** module chunks = 0\n **/","module.exports = { \"default\": require(\"core-js/library/fn/get-iterator\"), __esModule: true };\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/core-js/get-iterator.js\n ** module id = 39\n ** module chunks = 0\n **/","require('../modules/web.dom.iterable');\nrequire('../modules/es6.string.iterator');\nmodule.exports = require('../modules/core.get-iterator');\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/fn/get-iterator.js\n ** module id = 40\n ** module chunks = 0\n **/","var anObject = require('./$.an-object')\n  , get      = require('./core.get-iterator-method');\nmodule.exports = require('./$.core').getIterator = function(it){\n  var iterFn = get(it);\n  if(typeof iterFn != 'function')throw TypeError(it + ' is not iterable!');\n  return anObject(iterFn.call(it));\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/core.get-iterator.js\n ** module id = 41\n ** module chunks = 0\n **/","var isObject = require('./$.is-object');\nmodule.exports = function(it){\n  if(!isObject(it))throw TypeError(it + ' is not an object!');\n  return it;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/$.an-object.js\n ** module id = 42\n ** module chunks = 0\n **/","module.exports = function(it){\n  return typeof it === 'object' ? it !== null : typeof it === 'function';\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/$.is-object.js\n ** module id = 43\n ** module chunks = 0\n **/","var classof   = require('./$.classof')\n  , ITERATOR  = require('./$.wks')('iterator')\n  , Iterators = require('./$.iterators');\nmodule.exports = require('./$.core').getIteratorMethod = function(it){\n  if(it != undefined)return it[ITERATOR]\n    || it['@@iterator']\n    || Iterators[classof(it)];\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/core.get-iterator-method.js\n ** module id = 44\n ** module chunks = 0\n **/","\"use strict\";\n\nexports.__esModule = true;\n\nexports.default = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/helpers/classCallCheck.js\n ** module id = 45\n ** module chunks = 0\n **/","\"use strict\";\n\nexports.__esModule = true;\n\nvar _defineProperty = require(\"../core-js/object/define-property\");\n\nvar _defineProperty2 = _interopRequireDefault(_defineProperty);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = (function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      (0, _defineProperty2.default)(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n})();\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/helpers/createClass.js\n ** module id = 46\n ** module chunks = 0\n **/","module.exports = { \"default\": require(\"core-js/library/fn/object/define-property\"), __esModule: true };\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/core-js/object/define-property.js\n ** module id = 47\n ** module chunks = 0\n **/","var $ = require('../../modules/$');\nmodule.exports = function defineProperty(it, key, desc){\n  return $.setDesc(it, key, desc);\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/fn/object/define-property.js\n ** module id = 48\n ** module chunks = 0\n **/","// Copyright (c) Microsoft, All rights reserved. See License.txt in the project root for license information.\n\n;(function (undefined) {\n\n  var objectTypes = {\n    'function': true,\n    'object': true\n  };\n\n  function checkGlobal(value) {\n    return (value && value.Object === Object) ? value : null;\n  }\n\n  var freeExports = (objectTypes[typeof exports] && exports && !exports.nodeType) ? exports : null;\n  var freeModule = (objectTypes[typeof module] && module && !module.nodeType) ? module : null;\n  var freeGlobal = checkGlobal(freeExports && freeModule && typeof global === 'object' && global);\n  var freeSelf = checkGlobal(objectTypes[typeof self] && self);\n  var freeWindow = checkGlobal(objectTypes[typeof window] && window);\n  var moduleExports = (freeModule && freeModule.exports === freeExports) ? freeExports : null;\n  var thisGlobal = checkGlobal(objectTypes[typeof this] && this);\n  var root = freeGlobal || ((freeWindow !== (thisGlobal && thisGlobal.window)) && freeWindow) || freeSelf || thisGlobal || Function('return this')();\n\n  var Rx = {\n    internals: {},\n    config: {\n      Promise: root.Promise\n    },\n    helpers: { }\n  };\n\n  // Defaults\n  var noop = Rx.helpers.noop = function () { },\n    identity = Rx.helpers.identity = function (x) { return x; },\n    defaultNow = Rx.helpers.defaultNow = Date.now,\n    defaultComparer = Rx.helpers.defaultComparer = function (x, y) { return isEqual(x, y); },\n    defaultSubComparer = Rx.helpers.defaultSubComparer = function (x, y) { return x > y ? 1 : (x < y ? -1 : 0); },\n    defaultKeySerializer = Rx.helpers.defaultKeySerializer = function (x) { return x.toString(); },\n    defaultError = Rx.helpers.defaultError = function (err) { throw err; },\n    isPromise = Rx.helpers.isPromise = function (p) { return !!p && typeof p.subscribe !== 'function' && typeof p.then === 'function'; },\n    isFunction = Rx.helpers.isFunction = (function () {\n\n      var isFn = function (value) {\n        return typeof value == 'function' || false;\n      };\n\n      // fallback for older versions of Chrome and Safari\n      if (isFn(/x/)) {\n        isFn = function(value) {\n          return typeof value == 'function' && toString.call(value) == '[object Function]';\n        };\n      }\n\n      return isFn;\n    }());\n\n  function cloneArray(arr) { for(var a = [], i = 0, len = arr.length; i < len; i++) { a.push(arr[i]); } return a;}\n\n  var errorObj = {e: {}};\n  \n  function tryCatcherGen(tryCatchTarget) {\n    return function tryCatcher() {\n      try {\n        return tryCatchTarget.apply(this, arguments);\n      } catch (e) {\n        errorObj.e = e;\n        return errorObj;\n      }\n    };\n  }\n\n  var tryCatch = Rx.internals.tryCatch = function tryCatch(fn) {\n    if (!isFunction(fn)) { throw new TypeError('fn must be a function'); }\n    return tryCatcherGen(fn);\n  };\n\n  function thrower(e) {\n    throw e;\n  }\n\n  Rx.config.longStackSupport = false;\n  var hasStacks = false, stacks = tryCatch(function () { throw new Error(); })();\n  hasStacks = !!stacks.e && !!stacks.e.stack;\n\n  // All code after this point will be filtered from stack traces reported by RxJS\n  var rStartingLine = captureLine(), rFileName;\n\n  var STACK_JUMP_SEPARATOR = 'From previous event:';\n\n  function makeStackTraceLong(error, observable) {\n    // If possible, transform the error stack trace by removing Node and RxJS\n    // cruft, then concatenating with the stack trace of `observable`.\n    if (hasStacks &&\n        observable.stack &&\n        typeof error === 'object' &&\n        error !== null &&\n        error.stack &&\n        error.stack.indexOf(STACK_JUMP_SEPARATOR) === -1\n    ) {\n      var stacks = [];\n      for (var o = observable; !!o; o = o.source) {\n        if (o.stack) {\n          stacks.unshift(o.stack);\n        }\n      }\n      stacks.unshift(error.stack);\n\n      var concatedStacks = stacks.join('\\n' + STACK_JUMP_SEPARATOR + '\\n');\n      error.stack = filterStackString(concatedStacks);\n    }\n  }\n\n  function filterStackString(stackString) {\n    var lines = stackString.split('\\n'), desiredLines = [];\n    for (var i = 0, len = lines.length; i < len; i++) {\n      var line = lines[i];\n\n      if (!isInternalFrame(line) && !isNodeFrame(line) && line) {\n        desiredLines.push(line);\n      }\n    }\n    return desiredLines.join('\\n');\n  }\n\n  function isInternalFrame(stackLine) {\n    var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);\n    if (!fileNameAndLineNumber) {\n      return false;\n    }\n    var fileName = fileNameAndLineNumber[0], lineNumber = fileNameAndLineNumber[1];\n\n    return fileName === rFileName &&\n      lineNumber >= rStartingLine &&\n      lineNumber <= rEndingLine;\n  }\n\n  function isNodeFrame(stackLine) {\n    return stackLine.indexOf('(module.js:') !== -1 ||\n      stackLine.indexOf('(node.js:') !== -1;\n  }\n\n  function captureLine() {\n    if (!hasStacks) { return; }\n\n    try {\n      throw new Error();\n    } catch (e) {\n      var lines = e.stack.split('\\n');\n      var firstLine = lines[0].indexOf('@') > 0 ? lines[1] : lines[2];\n      var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);\n      if (!fileNameAndLineNumber) { return; }\n\n      rFileName = fileNameAndLineNumber[0];\n      return fileNameAndLineNumber[1];\n    }\n  }\n\n  function getFileNameAndLineNumber(stackLine) {\n    // Named functions: 'at functionName (filename:lineNumber:columnNumber)'\n    var attempt1 = /at .+ \\((.+):(\\d+):(?:\\d+)\\)$/.exec(stackLine);\n    if (attempt1) { return [attempt1[1], Number(attempt1[2])]; }\n\n    // Anonymous functions: 'at filename:lineNumber:columnNumber'\n    var attempt2 = /at ([^ ]+):(\\d+):(?:\\d+)$/.exec(stackLine);\n    if (attempt2) { return [attempt2[1], Number(attempt2[2])]; }\n\n    // Firefox style: 'function@filename:lineNumber or @filename:lineNumber'\n    var attempt3 = /.*@(.+):(\\d+)$/.exec(stackLine);\n    if (attempt3) { return [attempt3[1], Number(attempt3[2])]; }\n  }\n\n  var EmptyError = Rx.EmptyError = function() {\n    this.message = 'Sequence contains no elements.';\n    Error.call(this);\n  };\n  EmptyError.prototype = Object.create(Error.prototype);\n  EmptyError.prototype.name = 'EmptyError';\n\n  var ObjectDisposedError = Rx.ObjectDisposedError = function() {\n    this.message = 'Object has been disposed';\n    Error.call(this);\n  };\n  ObjectDisposedError.prototype = Object.create(Error.prototype);\n  ObjectDisposedError.prototype.name = 'ObjectDisposedError';\n\n  var ArgumentOutOfRangeError = Rx.ArgumentOutOfRangeError = function () {\n    this.message = 'Argument out of range';\n    Error.call(this);\n  };\n  ArgumentOutOfRangeError.prototype = Object.create(Error.prototype);\n  ArgumentOutOfRangeError.prototype.name = 'ArgumentOutOfRangeError';\n\n  var NotSupportedError = Rx.NotSupportedError = function (message) {\n    this.message = message || 'This operation is not supported';\n    Error.call(this);\n  };\n  NotSupportedError.prototype = Object.create(Error.prototype);\n  NotSupportedError.prototype.name = 'NotSupportedError';\n\n  var NotImplementedError = Rx.NotImplementedError = function (message) {\n    this.message = message || 'This operation is not implemented';\n    Error.call(this);\n  };\n  NotImplementedError.prototype = Object.create(Error.prototype);\n  NotImplementedError.prototype.name = 'NotImplementedError';\n\n  var notImplemented = Rx.helpers.notImplemented = function () {\n    throw new NotImplementedError();\n  };\n\n  var notSupported = Rx.helpers.notSupported = function () {\n    throw new NotSupportedError();\n  };\n\n  // Shim in iterator support\n  var $iterator$ = (typeof Symbol === 'function' && Symbol.iterator) ||\n    '_es6shim_iterator_';\n  // Bug for mozilla version\n  if (root.Set && typeof new root.Set()['@@iterator'] === 'function') {\n    $iterator$ = '@@iterator';\n  }\n\n  var doneEnumerator = Rx.doneEnumerator = { done: true, value: undefined };\n\n  var isIterable = Rx.helpers.isIterable = function (o) {\n    return o && o[$iterator$] !== undefined;\n  };\n\n  var isArrayLike = Rx.helpers.isArrayLike = function (o) {\n    return o && o.length !== undefined;\n  };\n\n  Rx.helpers.iterator = $iterator$;\n\n  var bindCallback = Rx.internals.bindCallback = function (func, thisArg, argCount) {\n    if (typeof thisArg === 'undefined') { return func; }\n    switch(argCount) {\n      case 0:\n        return function() {\n          return func.call(thisArg)\n        };\n      case 1:\n        return function(arg) {\n          return func.call(thisArg, arg);\n        };\n      case 2:\n        return function(value, index) {\n          return func.call(thisArg, value, index);\n        };\n      case 3:\n        return function(value, index, collection) {\n          return func.call(thisArg, value, index, collection);\n        };\n    }\n\n    return function() {\n      return func.apply(thisArg, arguments);\n    };\n  };\n\n  /** Used to determine if values are of the language type Object */\n  var dontEnums = ['toString',\n    'toLocaleString',\n    'valueOf',\n    'hasOwnProperty',\n    'isPrototypeOf',\n    'propertyIsEnumerable',\n    'constructor'],\n  dontEnumsLength = dontEnums.length;\n\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    objectTag = '[object Object]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\ntypedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] =\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\ntypedArrayTags[dateTag] = typedArrayTags[errorTag] =\ntypedArrayTags[funcTag] = typedArrayTags[mapTag] =\ntypedArrayTags[numberTag] = typedArrayTags[objectTag] =\ntypedArrayTags[regexpTag] = typedArrayTags[setTag] =\ntypedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;\n\nvar objectProto = Object.prototype,\n    hasOwnProperty = objectProto.hasOwnProperty,\n    objToString = objectProto.toString,\n    MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;\n\nvar keys = Object.keys || (function() {\n    var hasOwnProperty = Object.prototype.hasOwnProperty,\n        hasDontEnumBug = !({ toString: null }).propertyIsEnumerable('toString'),\n        dontEnums = [\n          'toString',\n          'toLocaleString',\n          'valueOf',\n          'hasOwnProperty',\n          'isPrototypeOf',\n          'propertyIsEnumerable',\n          'constructor'\n        ],\n        dontEnumsLength = dontEnums.length;\n\n    return function(obj) {\n      if (typeof obj !== 'object' && (typeof obj !== 'function' || obj === null)) {\n        throw new TypeError('Object.keys called on non-object');\n      }\n\n      var result = [], prop, i;\n\n      for (prop in obj) {\n        if (hasOwnProperty.call(obj, prop)) {\n          result.push(prop);\n        }\n      }\n\n      if (hasDontEnumBug) {\n        for (i = 0; i < dontEnumsLength; i++) {\n          if (hasOwnProperty.call(obj, dontEnums[i])) {\n            result.push(dontEnums[i]);\n          }\n        }\n      }\n      return result;\n    };\n  }());\n\nfunction equalObjects(object, other, equalFunc, isLoose, stackA, stackB) {\n  var objProps = keys(object),\n      objLength = objProps.length,\n      othProps = keys(other),\n      othLength = othProps.length;\n\n  if (objLength !== othLength && !isLoose) {\n    return false;\n  }\n  var index = objLength, key;\n  while (index--) {\n    key = objProps[index];\n    if (!(isLoose ? key in other : hasOwnProperty.call(other, key))) {\n      return false;\n    }\n  }\n  var skipCtor = isLoose;\n  while (++index < objLength) {\n    key = objProps[index];\n    var objValue = object[key],\n        othValue = other[key],\n        result;\n\n    if (!(result === undefined ? equalFunc(objValue, othValue, isLoose, stackA, stackB) : result)) {\n      return false;\n    }\n    skipCtor || (skipCtor = key === 'constructor');\n  }\n  if (!skipCtor) {\n    var objCtor = object.constructor,\n        othCtor = other.constructor;\n\n    if (objCtor !== othCtor &&\n        ('constructor' in object && 'constructor' in other) &&\n        !(typeof objCtor === 'function' && objCtor instanceof objCtor &&\n          typeof othCtor === 'function' && othCtor instanceof othCtor)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction equalByTag(object, other, tag) {\n  switch (tag) {\n    case boolTag:\n    case dateTag:\n      return +object === +other;\n\n    case errorTag:\n      return object.name === other.name && object.message === other.message;\n\n    case numberTag:\n      return (object !== +object) ?\n        other !== +other :\n        object === +other;\n\n    case regexpTag:\n    case stringTag:\n      return object === (other + '');\n  }\n  return false;\n}\n\nvar isObject = Rx.internals.isObject = function(value) {\n  var type = typeof value;\n  return !!value && (type === 'object' || type === 'function');\n};\n\nfunction isObjectLike(value) {\n  return !!value && typeof value === 'object';\n}\n\nfunction isLength(value) {\n  return typeof value === 'number' && value > -1 && value % 1 === 0 && value <= MAX_SAFE_INTEGER;\n}\n\nvar isHostObject = (function() {\n  try {\n    Object({ 'toString': 0 } + '');\n  } catch(e) {\n    return function() { return false; };\n  }\n  return function(value) {\n    return typeof value.toString !== 'function' && typeof (value + '') === 'string';\n  };\n}());\n\nfunction isTypedArray(value) {\n  return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objToString.call(value)];\n}\n\nvar isArray = Array.isArray || function(value) {\n  return isObjectLike(value) && isLength(value.length) && objToString.call(value) === arrayTag;\n};\n\nfunction arraySome (array, predicate) {\n  var index = -1,\n      length = array.length;\n\n  while (++index < length) {\n    if (predicate(array[index], index, array)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction equalArrays(array, other, equalFunc, isLoose, stackA, stackB) {\n  var index = -1,\n      arrLength = array.length,\n      othLength = other.length;\n\n  if (arrLength !== othLength && !(isLoose && othLength > arrLength)) {\n    return false;\n  }\n  // Ignore non-index properties.\n  while (++index < arrLength) {\n    var arrValue = array[index],\n        othValue = other[index],\n        result;\n\n    if (result !== undefined) {\n      if (result) {\n        continue;\n      }\n      return false;\n    }\n    // Recursively compare arrays (susceptible to call stack limits).\n    if (isLoose) {\n      if (!arraySome(other, function(othValue) {\n            return arrValue === othValue || equalFunc(arrValue, othValue, isLoose, stackA, stackB);\n          })) {\n        return false;\n      }\n    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, isLoose, stackA, stackB))) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction baseIsEqualDeep(object, other, equalFunc, isLoose, stackA, stackB) {\n  var objIsArr = isArray(object),\n      othIsArr = isArray(other),\n      objTag = arrayTag,\n      othTag = arrayTag;\n\n  if (!objIsArr) {\n    objTag = objToString.call(object);\n    if (objTag === argsTag) {\n      objTag = objectTag;\n    } else if (objTag !== objectTag) {\n      objIsArr = isTypedArray(object);\n    }\n  }\n  if (!othIsArr) {\n    othTag = objToString.call(other);\n    if (othTag === argsTag) {\n      othTag = objectTag;\n    }\n  }\n  var objIsObj = objTag === objectTag && !isHostObject(object),\n      othIsObj = othTag === objectTag && !isHostObject(other),\n      isSameTag = objTag === othTag;\n\n  if (isSameTag && !(objIsArr || objIsObj)) {\n    return equalByTag(object, other, objTag);\n  }\n  if (!isLoose) {\n    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\n        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\n    if (objIsWrapped || othIsWrapped) {\n      return equalFunc(objIsWrapped ? object.value() : object, othIsWrapped ? other.value() : other, isLoose, stackA, stackB);\n    }\n  }\n  if (!isSameTag) {\n    return false;\n  }\n  // Assume cyclic values are equal.\n  // For more information on detecting circular references see https://es5.github.io/#JO.\n  stackA || (stackA = []);\n  stackB || (stackB = []);\n\n  var length = stackA.length;\n  while (length--) {\n    if (stackA[length] === object) {\n      return stackB[length] === other;\n    }\n  }\n  // Add `object` and `other` to the stack of traversed objects.\n  stackA.push(object);\n  stackB.push(other);\n\n  var result = (objIsArr ? equalArrays : equalObjects)(object, other, equalFunc, isLoose, stackA, stackB);\n\n  stackA.pop();\n  stackB.pop();\n\n  return result;\n}\n\nfunction baseIsEqual(value, other, isLoose, stackA, stackB) {\n  if (value === other) {\n    return true;\n  }\n  if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {\n    return value !== value && other !== other;\n  }\n  return baseIsEqualDeep(value, other, baseIsEqual, isLoose, stackA, stackB);\n}\n\nvar isEqual = Rx.internals.isEqual = function (value, other) {\n  return baseIsEqual(value, other);\n};\n\n  var hasProp = {}.hasOwnProperty,\n      slice = Array.prototype.slice;\n\n  var inherits = Rx.internals.inherits = function (child, parent) {\n    function __() { this.constructor = child; }\n    __.prototype = parent.prototype;\n    child.prototype = new __();\n  };\n\n  var addProperties = Rx.internals.addProperties = function (obj) {\n    for(var sources = [], i = 1, len = arguments.length; i < len; i++) { sources.push(arguments[i]); }\n    for (var idx = 0, ln = sources.length; idx < ln; idx++) {\n      var source = sources[idx];\n      for (var prop in source) {\n        obj[prop] = source[prop];\n      }\n    }\n  };\n\n  // Rx Utils\n  var addRef = Rx.internals.addRef = function (xs, r) {\n    return new AnonymousObservable(function (observer) {\n      return new BinaryDisposable(r.getDisposable(), xs.subscribe(observer));\n    });\n  };\n\n  function arrayInitialize(count, factory) {\n    var a = new Array(count);\n    for (var i = 0; i < count; i++) {\n      a[i] = factory();\n    }\n    return a;\n  }\n\n  function IndexedItem(id, value) {\n    this.id = id;\n    this.value = value;\n  }\n\n  IndexedItem.prototype.compareTo = function (other) {\n    var c = this.value.compareTo(other.value);\n    c === 0 && (c = this.id - other.id);\n    return c;\n  };\n\n  var PriorityQueue = Rx.internals.PriorityQueue = function (capacity) {\n    this.items = new Array(capacity);\n    this.length = 0;\n  };\n\n  var priorityProto = PriorityQueue.prototype;\n  priorityProto.isHigherPriority = function (left, right) {\n    return this.items[left].compareTo(this.items[right]) < 0;\n  };\n\n  priorityProto.percolate = function (index) {\n    if (index >= this.length || index < 0) { return; }\n    var parent = index - 1 >> 1;\n    if (parent < 0 || parent === index) { return; }\n    if (this.isHigherPriority(index, parent)) {\n      var temp = this.items[index];\n      this.items[index] = this.items[parent];\n      this.items[parent] = temp;\n      this.percolate(parent);\n    }\n  };\n\n  priorityProto.heapify = function (index) {\n    +index || (index = 0);\n    if (index >= this.length || index < 0) { return; }\n    var left = 2 * index + 1,\n        right = 2 * index + 2,\n        first = index;\n    if (left < this.length && this.isHigherPriority(left, first)) {\n      first = left;\n    }\n    if (right < this.length && this.isHigherPriority(right, first)) {\n      first = right;\n    }\n    if (first !== index) {\n      var temp = this.items[index];\n      this.items[index] = this.items[first];\n      this.items[first] = temp;\n      this.heapify(first);\n    }\n  };\n\n  priorityProto.peek = function () { return this.items[0].value; };\n\n  priorityProto.removeAt = function (index) {\n    this.items[index] = this.items[--this.length];\n    this.items[this.length] = undefined;\n    this.heapify();\n  };\n\n  priorityProto.dequeue = function () {\n    var result = this.peek();\n    this.removeAt(0);\n    return result;\n  };\n\n  priorityProto.enqueue = function (item) {\n    var index = this.length++;\n    this.items[index] = new IndexedItem(PriorityQueue.count++, item);\n    this.percolate(index);\n  };\n\n  priorityProto.remove = function (item) {\n    for (var i = 0; i < this.length; i++) {\n      if (this.items[i].value === item) {\n        this.removeAt(i);\n        return true;\n      }\n    }\n    return false;\n  };\n  PriorityQueue.count = 0;\n\n  /**\n   * Represents a group of disposable resources that are disposed together.\n   * @constructor\n   */\n  var CompositeDisposable = Rx.CompositeDisposable = function () {\n    var args = [], i, len;\n    if (Array.isArray(arguments[0])) {\n      args = arguments[0];\n    } else {\n      len = arguments.length;\n      args = new Array(len);\n      for(i = 0; i < len; i++) { args[i] = arguments[i]; }\n    }\n    this.disposables = args;\n    this.isDisposed = false;\n    this.length = args.length;\n  };\n\n  var CompositeDisposablePrototype = CompositeDisposable.prototype;\n\n  /**\n   * Adds a disposable to the CompositeDisposable or disposes the disposable if the CompositeDisposable is disposed.\n   * @param {Mixed} item Disposable to add.\n   */\n  CompositeDisposablePrototype.add = function (item) {\n    if (this.isDisposed) {\n      item.dispose();\n    } else {\n      this.disposables.push(item);\n      this.length++;\n    }\n  };\n\n  /**\n   * Removes and disposes the first occurrence of a disposable from the CompositeDisposable.\n   * @param {Mixed} item Disposable to remove.\n   * @returns {Boolean} true if found; false otherwise.\n   */\n  CompositeDisposablePrototype.remove = function (item) {\n    var shouldDispose = false;\n    if (!this.isDisposed) {\n      var idx = this.disposables.indexOf(item);\n      if (idx !== -1) {\n        shouldDispose = true;\n        this.disposables.splice(idx, 1);\n        this.length--;\n        item.dispose();\n      }\n    }\n    return shouldDispose;\n  };\n\n  /**\n   *  Disposes all disposables in the group and removes them from the group.\n   */\n  CompositeDisposablePrototype.dispose = function () {\n    if (!this.isDisposed) {\n      this.isDisposed = true;\n      var len = this.disposables.length, currentDisposables = new Array(len);\n      for(var i = 0; i < len; i++) { currentDisposables[i] = this.disposables[i]; }\n      this.disposables = [];\n      this.length = 0;\n\n      for (i = 0; i < len; i++) {\n        currentDisposables[i].dispose();\n      }\n    }\n  };\n\n  /**\n   * Provides a set of static methods for creating Disposables.\n   * @param {Function} dispose Action to run during the first call to dispose. The action is guaranteed to be run at most once.\n   */\n  var Disposable = Rx.Disposable = function (action) {\n    this.isDisposed = false;\n    this.action = action || noop;\n  };\n\n  /** Performs the task of cleaning up resources. */\n  Disposable.prototype.dispose = function () {\n    if (!this.isDisposed) {\n      this.action();\n      this.isDisposed = true;\n    }\n  };\n\n  /**\n   * Creates a disposable object that invokes the specified action when disposed.\n   * @param {Function} dispose Action to run during the first call to dispose. The action is guaranteed to be run at most once.\n   * @return {Disposable} The disposable object that runs the given action upon disposal.\n   */\n  var disposableCreate = Disposable.create = function (action) { return new Disposable(action); };\n\n  /**\n   * Gets the disposable that does nothing when disposed.\n   */\n  var disposableEmpty = Disposable.empty = { dispose: noop };\n\n  /**\n   * Validates whether the given object is a disposable\n   * @param {Object} Object to test whether it has a dispose method\n   * @returns {Boolean} true if a disposable object, else false.\n   */\n  var isDisposable = Disposable.isDisposable = function (d) {\n    return d && isFunction(d.dispose);\n  };\n\n  var checkDisposed = Disposable.checkDisposed = function (disposable) {\n    if (disposable.isDisposed) { throw new ObjectDisposedError(); }\n  };\n\n  var disposableFixup = Disposable._fixup = function (result) {\n    return isDisposable(result) ? result : disposableEmpty;\n  };\n\n  // Single assignment\n  var SingleAssignmentDisposable = Rx.SingleAssignmentDisposable = function () {\n    this.isDisposed = false;\n    this.current = null;\n  };\n  SingleAssignmentDisposable.prototype.getDisposable = function () {\n    return this.current;\n  };\n  SingleAssignmentDisposable.prototype.setDisposable = function (value) {\n    if (this.current) { throw new Error('Disposable has already been assigned'); }\n    var shouldDispose = this.isDisposed;\n    !shouldDispose && (this.current = value);\n    shouldDispose && value && value.dispose();\n  };\n  SingleAssignmentDisposable.prototype.dispose = function () {\n    if (!this.isDisposed) {\n      this.isDisposed = true;\n      var old = this.current;\n      this.current = null;\n      old && old.dispose();\n    }\n  };\n\n  // Multiple assignment disposable\n  var SerialDisposable = Rx.SerialDisposable = function () {\n    this.isDisposed = false;\n    this.current = null;\n  };\n  SerialDisposable.prototype.getDisposable = function () {\n    return this.current;\n  };\n  SerialDisposable.prototype.setDisposable = function (value) {\n    var shouldDispose = this.isDisposed;\n    if (!shouldDispose) {\n      var old = this.current;\n      this.current = value;\n    }\n    old && old.dispose();\n    shouldDispose && value && value.dispose();\n  };\n  SerialDisposable.prototype.dispose = function () {\n    if (!this.isDisposed) {\n      this.isDisposed = true;\n      var old = this.current;\n      this.current = null;\n    }\n    old && old.dispose();\n  };\n\n  var BinaryDisposable = Rx.BinaryDisposable = function (first, second) {\n    this._first = first;\n    this._second = second;\n    this.isDisposed = false;\n  };\n\n  BinaryDisposable.prototype.dispose = function () {\n    if (!this.isDisposed) {\n      this.isDisposed = true;\n      var old1 = this._first;\n      this._first = null;\n      old1 && old1.dispose();\n      var old2 = this._second;\n      this._second = null;\n      old2 && old2.dispose();\n    }\n  };\n\n  var NAryDisposable = Rx.NAryDisposable = function (disposables) {\n    this._disposables = disposables;\n    this.isDisposed = false;\n  };\n\n  NAryDisposable.prototype.dispose = function () {\n    if (!this.isDisposed) {\n      this.isDisposed = true;\n      for (var i = 0, len = this._disposables.length; i < len; i++) {\n        this._disposables[i].dispose();\n      }\n      this._disposables.length = 0;\n    }\n  };\n\n  /**\n   * Represents a disposable resource that only disposes its underlying disposable resource when all dependent disposable objects have been disposed.\n   */\n  var RefCountDisposable = Rx.RefCountDisposable = (function () {\n\n    function InnerDisposable(disposable) {\n      this.disposable = disposable;\n      this.disposable.count++;\n      this.isInnerDisposed = false;\n    }\n\n    InnerDisposable.prototype.dispose = function () {\n      if (!this.disposable.isDisposed && !this.isInnerDisposed) {\n        this.isInnerDisposed = true;\n        this.disposable.count--;\n        if (this.disposable.count === 0 && this.disposable.isPrimaryDisposed) {\n          this.disposable.isDisposed = true;\n          this.disposable.underlyingDisposable.dispose();\n        }\n      }\n    };\n\n    /**\n     * Initializes a new instance of the RefCountDisposable with the specified disposable.\n     * @constructor\n     * @param {Disposable} disposable Underlying disposable.\n      */\n    function RefCountDisposable(disposable) {\n      this.underlyingDisposable = disposable;\n      this.isDisposed = false;\n      this.isPrimaryDisposed = false;\n      this.count = 0;\n    }\n\n    /**\n     * Disposes the underlying disposable only when all dependent disposables have been disposed\n     */\n    RefCountDisposable.prototype.dispose = function () {\n      if (!this.isDisposed && !this.isPrimaryDisposed) {\n        this.isPrimaryDisposed = true;\n        if (this.count === 0) {\n          this.isDisposed = true;\n          this.underlyingDisposable.dispose();\n        }\n      }\n    };\n\n    /**\n     * Returns a dependent disposable that when disposed decreases the refcount on the underlying disposable.\n     * @returns {Disposable} A dependent disposable contributing to the reference count that manages the underlying disposable's lifetime.\n     */\n    RefCountDisposable.prototype.getDisposable = function () {\n      return this.isDisposed ? disposableEmpty : new InnerDisposable(this);\n    };\n\n    return RefCountDisposable;\n  })();\n\n  function ScheduledDisposable(scheduler, disposable) {\n    this.scheduler = scheduler;\n    this.disposable = disposable;\n    this.isDisposed = false;\n  }\n\n  function scheduleItem(s, self) {\n    if (!self.isDisposed) {\n      self.isDisposed = true;\n      self.disposable.dispose();\n    }\n  }\n\n  ScheduledDisposable.prototype.dispose = function () {\n    this.scheduler.schedule(this, scheduleItem);\n  };\n\n  var ScheduledItem = Rx.internals.ScheduledItem = function (scheduler, state, action, dueTime, comparer) {\n    this.scheduler = scheduler;\n    this.state = state;\n    this.action = action;\n    this.dueTime = dueTime;\n    this.comparer = comparer || defaultSubComparer;\n    this.disposable = new SingleAssignmentDisposable();\n  };\n\n  ScheduledItem.prototype.invoke = function () {\n    this.disposable.setDisposable(this.invokeCore());\n  };\n\n  ScheduledItem.prototype.compareTo = function (other) {\n    return this.comparer(this.dueTime, other.dueTime);\n  };\n\n  ScheduledItem.prototype.isCancelled = function () {\n    return this.disposable.isDisposed;\n  };\n\n  ScheduledItem.prototype.invokeCore = function () {\n    return disposableFixup(this.action(this.scheduler, this.state));\n  };\n\n  /** Provides a set of static properties to access commonly used schedulers. */\n  var Scheduler = Rx.Scheduler = (function () {\n\n    function Scheduler() { }\n\n    /** Determines whether the given object is a scheduler */\n    Scheduler.isScheduler = function (s) {\n      return s instanceof Scheduler;\n    };\n\n    var schedulerProto = Scheduler.prototype;\n\n    /**\n   * Schedules an action to be executed.\n   * @param state State passed to the action to be executed.\n   * @param {Function} action Action to be executed.\n   * @returns {Disposable} The disposable object used to cancel the scheduled action (best effort).\n   */\n    schedulerProto.schedule = function (state, action) {\n      throw new NotImplementedError();\n    };\n\n  /**\n   * Schedules an action to be executed after dueTime.\n   * @param state State passed to the action to be executed.\n   * @param {Function} action Action to be executed.\n   * @param {Number} dueTime Relative time after which to execute the action.\n   * @returns {Disposable} The disposable object used to cancel the scheduled action (best effort).\n   */\n    schedulerProto.scheduleFuture = function (state, dueTime, action) {\n      var dt = dueTime;\n      dt instanceof Date && (dt = dt - this.now());\n      dt = Scheduler.normalize(dt);\n\n      if (dt === 0) { return this.schedule(state, action); }\n\n      return this._scheduleFuture(state, dt, action);\n    };\n\n    schedulerProto._scheduleFuture = function (state, dueTime, action) {\n      throw new NotImplementedError();\n    };\n\n    /** Gets the current time according to the local machine's system clock. */\n    Scheduler.now = defaultNow;\n\n    /** Gets the current time according to the local machine's system clock. */\n    Scheduler.prototype.now = defaultNow;\n\n    /**\n     * Normalizes the specified TimeSpan value to a positive value.\n     * @param {Number} timeSpan The time span value to normalize.\n     * @returns {Number} The specified TimeSpan value if it is zero or positive; otherwise, 0\n     */\n    Scheduler.normalize = function (timeSpan) {\n      timeSpan < 0 && (timeSpan = 0);\n      return timeSpan;\n    };\n\n    return Scheduler;\n  }());\n\n  var normalizeTime = Scheduler.normalize, isScheduler = Scheduler.isScheduler;\n\n  (function (schedulerProto) {\n\n    function invokeRecImmediate(scheduler, pair) {\n      var state = pair[0], action = pair[1], group = new CompositeDisposable();\n      action(state, innerAction);\n      return group;\n\n      function innerAction(state2) {\n        var isAdded = false, isDone = false;\n\n        var d = scheduler.schedule(state2, scheduleWork);\n        if (!isDone) {\n          group.add(d);\n          isAdded = true;\n        }\n\n        function scheduleWork(_, state3) {\n          if (isAdded) {\n            group.remove(d);\n          } else {\n            isDone = true;\n          }\n          action(state3, innerAction);\n          return disposableEmpty;\n        }\n      }\n    }\n\n    function invokeRecDate(scheduler, pair) {\n      var state = pair[0], action = pair[1], group = new CompositeDisposable();\n      action(state, innerAction);\n      return group;\n\n      function innerAction(state2, dueTime1) {\n        var isAdded = false, isDone = false;\n\n        var d = scheduler.scheduleFuture(state2, dueTime1, scheduleWork);\n        if (!isDone) {\n          group.add(d);\n          isAdded = true;\n        }\n\n        function scheduleWork(_, state3) {\n          if (isAdded) {\n            group.remove(d);\n          } else {\n            isDone = true;\n          }\n          action(state3, innerAction);\n          return disposableEmpty;\n        }\n      }\n    }\n\n    /**\n     * Schedules an action to be executed recursively.\n     * @param {Mixed} state State passed to the action to be executed.\n     * @param {Function} action Action to execute recursively. The last parameter passed to the action is used to trigger recursive scheduling of the action, passing in recursive invocation state.\n     * @returns {Disposable} The disposable object used to cancel the scheduled action (best effort).\n     */\n    schedulerProto.scheduleRecursive = function (state, action) {\n      return this.schedule([state, action], invokeRecImmediate);\n    };\n\n    /**\n     * Schedules an action to be executed recursively after a specified relative or absolute due time.\n     * @param {Mixed} state State passed to the action to be executed.\n     * @param {Function} action Action to execute recursively. The last parameter passed to the action is used to trigger recursive scheduling of the action, passing in the recursive due time and invocation state.\n     * @param {Number | Date} dueTime Relative or absolute time after which to execute the action for the first time.\n     * @returns {Disposable} The disposable object used to cancel the scheduled action (best effort).\n     */\n    schedulerProto.scheduleRecursiveFuture = function (state, dueTime, action) {\n      return this.scheduleFuture([state, action], dueTime, invokeRecDate);\n    };\n\n  }(Scheduler.prototype));\n\n  (function (schedulerProto) {\n\n    /**\n     * Schedules a periodic piece of work by dynamically discovering the scheduler's capabilities. The periodic task will be scheduled using window.setInterval for the base implementation.\n     * @param {Mixed} state Initial state passed to the action upon the first iteration.\n     * @param {Number} period Period for running the work periodically.\n     * @param {Function} action Action to be executed, potentially updating the state.\n     * @returns {Disposable} The disposable object used to cancel the scheduled recurring action (best effort).\n     */\n    schedulerProto.schedulePeriodic = function(state, period, action) {\n      if (typeof root.setInterval === 'undefined') { throw new NotSupportedError(); }\n      period = normalizeTime(period);\n      var s = state, id = root.setInterval(function () { s = action(s); }, period);\n      return disposableCreate(function () { root.clearInterval(id); });\n    };\n\n  }(Scheduler.prototype));\n\n  (function (schedulerProto) {\n    /**\n     * Returns a scheduler that wraps the original scheduler, adding exception handling for scheduled actions.\n     * @param {Function} handler Handler that's run if an exception is caught. The exception will be rethrown if the handler returns false.\n     * @returns {Scheduler} Wrapper around the original scheduler, enforcing exception handling.\n     */\n    schedulerProto.catchError = schedulerProto['catch'] = function (handler) {\n      return new CatchScheduler(this, handler);\n    };\n  }(Scheduler.prototype));\n\n  var SchedulePeriodicRecursive = Rx.internals.SchedulePeriodicRecursive = (function () {\n    function createTick(self) {\n      return function tick(command, recurse) {\n        recurse(0, self._period);\n        var state = tryCatch(self._action)(self._state);\n        if (state === errorObj) {\n          self._cancel.dispose();\n          thrower(state.e);\n        }\n        self._state = state;\n      };\n    }\n\n    function SchedulePeriodicRecursive(scheduler, state, period, action) {\n      this._scheduler = scheduler;\n      this._state = state;\n      this._period = period;\n      this._action = action;\n    }\n\n    SchedulePeriodicRecursive.prototype.start = function () {\n      var d = new SingleAssignmentDisposable();\n      this._cancel = d;\n      d.setDisposable(this._scheduler.scheduleRecursiveFuture(0, this._period, createTick(this)));\n\n      return d;\n    };\n\n    return SchedulePeriodicRecursive;\n  }());\n\n  /** Gets a scheduler that schedules work immediately on the current thread. */\n   var ImmediateScheduler = (function (__super__) {\n    inherits(ImmediateScheduler, __super__);\n    function ImmediateScheduler() {\n      __super__.call(this);\n    }\n\n    ImmediateScheduler.prototype.schedule = function (state, action) {\n      return disposableFixup(action(this, state));\n    };\n\n    return ImmediateScheduler;\n  }(Scheduler));\n\n  var immediateScheduler = Scheduler.immediate = new ImmediateScheduler();\n\n  /**\n   * Gets a scheduler that schedules work as soon as possible on the current thread.\n   */\n  var CurrentThreadScheduler = (function (__super__) {\n    var queue;\n\n    function runTrampoline () {\n      while (queue.length > 0) {\n        var item = queue.dequeue();\n        !item.isCancelled() && item.invoke();\n      }\n    }\n\n    inherits(CurrentThreadScheduler, __super__);\n    function CurrentThreadScheduler() {\n      __super__.call(this);\n    }\n\n    CurrentThreadScheduler.prototype.schedule = function (state, action) {\n      var si = new ScheduledItem(this, state, action, this.now());\n\n      if (!queue) {\n        queue = new PriorityQueue(4);\n        queue.enqueue(si);\n\n        var result = tryCatch(runTrampoline)();\n        queue = null;\n        if (result === errorObj) { thrower(result.e); }\n      } else {\n        queue.enqueue(si);\n      }\n      return si.disposable;\n    };\n\n    CurrentThreadScheduler.prototype.scheduleRequired = function () { return !queue; };\n\n    return CurrentThreadScheduler;\n  }(Scheduler));\n\n  var currentThreadScheduler = Scheduler.currentThread = new CurrentThreadScheduler();\n\n  var scheduleMethod, clearMethod;\n\n  var localTimer = (function () {\n    var localSetTimeout, localClearTimeout = noop;\n    if (!!root.setTimeout) {\n      localSetTimeout = root.setTimeout;\n      localClearTimeout = root.clearTimeout;\n    } else if (!!root.WScript) {\n      localSetTimeout = function (fn, time) {\n        root.WScript.Sleep(time);\n        fn();\n      };\n    } else {\n      throw new NotSupportedError();\n    }\n\n    return {\n      setTimeout: localSetTimeout,\n      clearTimeout: localClearTimeout\n    };\n  }());\n  var localSetTimeout = localTimer.setTimeout,\n    localClearTimeout = localTimer.clearTimeout;\n\n  (function () {\n\n    var nextHandle = 1, tasksByHandle = {}, currentlyRunning = false;\n\n    clearMethod = function (handle) {\n      delete tasksByHandle[handle];\n    };\n\n    function runTask(handle) {\n      if (currentlyRunning) {\n        localSetTimeout(function () { runTask(handle); }, 0);\n      } else {\n        var task = tasksByHandle[handle];\n        if (task) {\n          currentlyRunning = true;\n          var result = tryCatch(task)();\n          clearMethod(handle);\n          currentlyRunning = false;\n          if (result === errorObj) { thrower(result.e); }\n        }\n      }\n    }\n\n    var reNative = new RegExp('^' +\n      String(toString)\n        .replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')\n        .replace(/toString| for [^\\]]+/g, '.*?') + '$'\n    );\n\n    var setImmediate = typeof (setImmediate = freeGlobal && moduleExports && freeGlobal.setImmediate) == 'function' &&\n      !reNative.test(setImmediate) && setImmediate;\n\n    function postMessageSupported () {\n      // Ensure not in a worker\n      if (!root.postMessage || root.importScripts) { return false; }\n      var isAsync = false, oldHandler = root.onmessage;\n      // Test for async\n      root.onmessage = function () { isAsync = true; };\n      root.postMessage('', '*');\n      root.onmessage = oldHandler;\n\n      return isAsync;\n    }\n\n    // Use in order, setImmediate, nextTick, postMessage, MessageChannel, script readystatechanged, setTimeout\n    if (isFunction(setImmediate)) {\n      scheduleMethod = function (action) {\n        var id = nextHandle++;\n        tasksByHandle[id] = action;\n        setImmediate(function () { runTask(id); });\n\n        return id;\n      };\n    } else if (typeof process !== 'undefined' && {}.toString.call(process) === '[object process]') {\n      scheduleMethod = function (action) {\n        var id = nextHandle++;\n        tasksByHandle[id] = action;\n        process.nextTick(function () { runTask(id); });\n\n        return id;\n      };\n    } else if (postMessageSupported()) {\n      var MSG_PREFIX = 'ms.rx.schedule' + Math.random();\n\n      var onGlobalPostMessage = function (event) {\n        // Only if we're a match to avoid any other global events\n        if (typeof event.data === 'string' && event.data.substring(0, MSG_PREFIX.length) === MSG_PREFIX) {\n          runTask(event.data.substring(MSG_PREFIX.length));\n        }\n      };\n\n      root.addEventListener('message', onGlobalPostMessage, false);\n\n      scheduleMethod = function (action) {\n        var id = nextHandle++;\n        tasksByHandle[id] = action;\n        root.postMessage(MSG_PREFIX + currentId, '*');\n        return id;\n      };\n    } else if (!!root.MessageChannel) {\n      var channel = new root.MessageChannel();\n\n      channel.port1.onmessage = function (e) { runTask(e.data); };\n\n      scheduleMethod = function (action) {\n        var id = nextHandle++;\n        tasksByHandle[id] = action;\n        channel.port2.postMessage(id);\n        return id;\n      };\n    } else if ('document' in root && 'onreadystatechange' in root.document.createElement('script')) {\n\n      scheduleMethod = function (action) {\n        var scriptElement = root.document.createElement('script');\n        var id = nextHandle++;\n        tasksByHandle[id] = action;\n\n        scriptElement.onreadystatechange = function () {\n          runTask(id);\n          scriptElement.onreadystatechange = null;\n          scriptElement.parentNode.removeChild(scriptElement);\n          scriptElement = null;\n        };\n        root.document.documentElement.appendChild(scriptElement);\n        return id;\n      };\n\n    } else {\n      scheduleMethod = function (action) {\n        var id = nextHandle++;\n        tasksByHandle[id] = action;\n        localSetTimeout(function () {\n          runTask(id);\n        }, 0);\n\n        return id;\n      };\n    }\n  }());\n\n  /**\n   * Gets a scheduler that schedules work via a timed callback based upon platform.\n   */\n   var DefaultScheduler = (function (__super__) {\n     inherits(DefaultScheduler, __super__);\n     function DefaultScheduler() {\n       __super__.call(this);\n     }\n\n     function scheduleAction(disposable, action, scheduler, state) {\n       return function schedule() {\n         disposable.setDisposable(Disposable._fixup(action(scheduler, state)));\n       };\n     }\n\n     function ClearDisposable(id) {\n       this._id = id;\n       this.isDisposed = false;\n     }\n\n     ClearDisposable.prototype.dispose = function () {\n       if (!this.isDisposed) {\n         this.isDisposed = true;\n         clearMethod(this._id);\n       }\n     };\n\n     function LocalClearDisposable(id) {\n       this._id = id;\n       this.isDisposed = false;\n     }\n\n     LocalClearDisposable.prototype.dispose = function () {\n       if (!this.isDisposed) {\n         this.isDisposed = true;\n         localClearTimeout(this._id);\n       }\n     };\n\n    DefaultScheduler.prototype.schedule = function (state, action) {\n      var disposable = new SingleAssignmentDisposable(),\n          id = scheduleMethod(scheduleAction(disposable, action, this, state));\n      return new BinaryDisposable(disposable, new ClearDisposable(id));\n    };\n\n    DefaultScheduler.prototype._scheduleFuture = function (state, dueTime, action) {\n      if (dueTime === 0) { return this.schedule(state, action); }\n      var disposable = new SingleAssignmentDisposable(),\n          id = localSetTimeout(scheduleAction(disposable, action, this, state), dueTime);\n      return new BinaryDisposable(disposable, new LocalClearDisposable(id));\n    };\n\n    return DefaultScheduler;\n  }(Scheduler));\n\n  var defaultScheduler = Scheduler['default'] = Scheduler.async = new DefaultScheduler();\n\n  var CatchScheduler = (function (__super__) {\n    inherits(CatchScheduler, __super__);\n\n    function CatchScheduler(scheduler, handler) {\n      this._scheduler = scheduler;\n      this._handler = handler;\n      this._recursiveOriginal = null;\n      this._recursiveWrapper = null;\n      __super__.call(this);\n    }\n\n    CatchScheduler.prototype.schedule = function (state, action) {\n      return this._scheduler.schedule(state, this._wrap(action));\n    };\n\n    CatchScheduler.prototype._scheduleFuture = function (state, dueTime, action) {\n      return this._scheduler.schedule(state, dueTime, this._wrap(action));\n    };\n\n    CatchScheduler.prototype.now = function () { return this._scheduler.now(); };\n\n    CatchScheduler.prototype._clone = function (scheduler) {\n        return new CatchScheduler(scheduler, this._handler);\n    };\n\n    CatchScheduler.prototype._wrap = function (action) {\n      var parent = this;\n      return function (self, state) {\n        var res = tryCatch(action)(parent._getRecursiveWrapper(self), state);\n        if (res === errorObj) {\n          if (!parent._handler(res.e)) { thrower(res.e); }\n          return disposableEmpty;\n        }\n        return disposableFixup(res);\n      };\n    };\n\n    CatchScheduler.prototype._getRecursiveWrapper = function (scheduler) {\n      if (this._recursiveOriginal !== scheduler) {\n        this._recursiveOriginal = scheduler;\n        var wrapper = this._clone(scheduler);\n        wrapper._recursiveOriginal = scheduler;\n        wrapper._recursiveWrapper = wrapper;\n        this._recursiveWrapper = wrapper;\n      }\n      return this._recursiveWrapper;\n    };\n\n    CatchScheduler.prototype.schedulePeriodic = function (state, period, action) {\n      var self = this, failed = false, d = new SingleAssignmentDisposable();\n\n      d.setDisposable(this._scheduler.schedulePeriodic(state, period, function (state1) {\n        if (failed) { return null; }\n        var res = tryCatch(action)(state1);\n        if (res === errorObj) {\n          failed = true;\n          if (!self._handler(res.e)) { thrower(res.e); }\n          d.dispose();\n          return null;\n        }\n        return res;\n      }));\n\n      return d;\n    };\n\n    return CatchScheduler;\n  }(Scheduler));\n\n  /**\n   *  Represents a notification to an observer.\n   */\n  var Notification = Rx.Notification = (function () {\n    function Notification() {\n\n    }\n\n    Notification.prototype._accept = function (onNext, onError, onCompleted) {\n      throw new NotImplementedError();\n    };\n\n    Notification.prototype._acceptObserver = function (onNext, onError, onCompleted) {\n      throw new NotImplementedError();\n    };\n\n    /**\n     * Invokes the delegate corresponding to the notification or the observer's method corresponding to the notification and returns the produced result.\n     * @param {Function | Observer} observerOrOnNext Function to invoke for an OnNext notification or Observer to invoke the notification on..\n     * @param {Function} onError Function to invoke for an OnError notification.\n     * @param {Function} onCompleted Function to invoke for an OnCompleted notification.\n     * @returns {Any} Result produced by the observation.\n     */\n    Notification.prototype.accept = function (observerOrOnNext, onError, onCompleted) {\n      return observerOrOnNext && typeof observerOrOnNext === 'object' ?\n        this._acceptObserver(observerOrOnNext) :\n        this._accept(observerOrOnNext, onError, onCompleted);\n    };\n\n    /**\n     * Returns an observable sequence with a single notification.\n     *\n     * @memberOf Notifications\n     * @param {Scheduler} [scheduler] Scheduler to send out the notification calls on.\n     * @returns {Observable} The observable sequence that surfaces the behavior of the notification upon subscription.\n     */\n    Notification.prototype.toObservable = function (scheduler) {\n      var self = this;\n      isScheduler(scheduler) || (scheduler = immediateScheduler);\n      return new AnonymousObservable(function (o) {\n        return scheduler.schedule(self, function (_, notification) {\n          notification._acceptObserver(o);\n          notification.kind === 'N' && o.onCompleted();\n        });\n      });\n    };\n\n    return Notification;\n  })();\n\n  var OnNextNotification = (function (__super__) {\n    inherits(OnNextNotification, __super__);\n    function OnNextNotification(value) {\n      this.value = value;\n      this.kind = 'N';\n    }\n\n    OnNextNotification.prototype._accept = function (onNext) {\n      return onNext(this.value);\n    };\n\n    OnNextNotification.prototype._acceptObserver = function (o) {\n      return o.onNext(this.value);\n    };\n\n    OnNextNotification.prototype.toString = function () {\n      return 'OnNext(' + this.value + ')';\n    };\n\n    return OnNextNotification;\n  }(Notification));\n\n  var OnErrorNotification = (function (__super__) {\n    inherits(OnErrorNotification, __super__);\n    function OnErrorNotification(error) {\n      this.error = error;\n      this.kind = 'E';\n    }\n\n    OnErrorNotification.prototype._accept = function (onNext, onError) {\n      return onError(this.error);\n    };\n\n    OnErrorNotification.prototype._acceptObserver = function (o) {\n      return o.onError(this.error);\n    };\n\n    OnErrorNotification.prototype.toString = function () {\n      return 'OnError(' + this.error + ')';\n    };\n\n    return OnErrorNotification;\n  }(Notification));\n\n  var OnCompletedNotification = (function (__super__) {\n    inherits(OnCompletedNotification, __super__);\n    function OnCompletedNotification() {\n      this.kind = 'C';\n    }\n\n    OnCompletedNotification.prototype._accept = function (onNext, onError, onCompleted) {\n      return onCompleted();\n    };\n\n    OnCompletedNotification.prototype._acceptObserver = function (o) {\n      return o.onCompleted();\n    };\n\n    OnCompletedNotification.prototype.toString = function () {\n      return 'OnCompleted()';\n    };\n\n    return OnCompletedNotification;\n  }(Notification));\n\n  /**\n   * Creates an object that represents an OnNext notification to an observer.\n   * @param {Any} value The value contained in the notification.\n   * @returns {Notification} The OnNext notification containing the value.\n   */\n  var notificationCreateOnNext = Notification.createOnNext = function (value) {\n    return new OnNextNotification(value);\n  };\n\n  /**\n   * Creates an object that represents an OnError notification to an observer.\n   * @param {Any} error The exception contained in the notification.\n   * @returns {Notification} The OnError notification containing the exception.\n   */\n  var notificationCreateOnError = Notification.createOnError = function (error) {\n    return new OnErrorNotification(error);\n  };\n\n  /**\n   * Creates an object that represents an OnCompleted notification to an observer.\n   * @returns {Notification} The OnCompleted notification.\n   */\n  var notificationCreateOnCompleted = Notification.createOnCompleted = function () {\n    return new OnCompletedNotification();\n  };\n\n  /**\n   * Supports push-style iteration over an observable sequence.\n   */\n  var Observer = Rx.Observer = function () { };\n\n  /**\n   *  Creates a notification callback from an observer.\n   * @returns The action that forwards its input notification to the underlying observer.\n   */\n  Observer.prototype.toNotifier = function () {\n    var observer = this;\n    return function (n) { return n.accept(observer); };\n  };\n\n  /**\n   *  Hides the identity of an observer.\n   * @returns An observer that hides the identity of the specified observer.\n   */\n  Observer.prototype.asObserver = function () {\n    var self = this;\n    return new AnonymousObserver(\n      function (x) { self.onNext(x); },\n      function (err) { self.onError(err); },\n      function () { self.onCompleted(); });\n  };\n\n  /**\n   *  Checks access to the observer for grammar violations. This includes checking for multiple OnError or OnCompleted calls, as well as reentrancy in any of the observer methods.\n   *  If a violation is detected, an Error is thrown from the offending observer method call.\n   * @returns An observer that checks callbacks invocations against the observer grammar and, if the checks pass, forwards those to the specified observer.\n   */\n  Observer.prototype.checked = function () { return new CheckedObserver(this); };\n\n  /**\n   *  Creates an observer from the specified OnNext, along with optional OnError, and OnCompleted actions.\n   * @param {Function} [onNext] Observer's OnNext action implementation.\n   * @param {Function} [onError] Observer's OnError action implementation.\n   * @param {Function} [onCompleted] Observer's OnCompleted action implementation.\n   * @returns {Observer} The observer object implemented using the given actions.\n   */\n  var observerCreate = Observer.create = function (onNext, onError, onCompleted) {\n    onNext || (onNext = noop);\n    onError || (onError = defaultError);\n    onCompleted || (onCompleted = noop);\n    return new AnonymousObserver(onNext, onError, onCompleted);\n  };\n\n  /**\n   *  Creates an observer from a notification callback.\n   * @param {Function} handler Action that handles a notification.\n   * @returns The observer object that invokes the specified handler using a notification corresponding to each message it receives.\n   */\n  Observer.fromNotifier = function (handler, thisArg) {\n    var cb = bindCallback(handler, thisArg, 1);\n    return new AnonymousObserver(function (x) {\n      return cb(notificationCreateOnNext(x));\n    }, function (e) {\n      return cb(notificationCreateOnError(e));\n    }, function () {\n      return cb(notificationCreateOnCompleted());\n    });\n  };\n\n  /**\n   * Schedules the invocation of observer methods on the given scheduler.\n   * @param {Scheduler} scheduler Scheduler to schedule observer messages on.\n   * @returns {Observer} Observer whose messages are scheduled on the given scheduler.\n   */\n  Observer.prototype.notifyOn = function (scheduler) {\n    return new ObserveOnObserver(scheduler, this);\n  };\n\n  Observer.prototype.makeSafe = function(disposable) {\n    return new AnonymousSafeObserver(this._onNext, this._onError, this._onCompleted, disposable);\n  };\n\n  /**\n   * Abstract base class for implementations of the Observer class.\n   * This base class enforces the grammar of observers where OnError and OnCompleted are terminal messages.\n   */\n  var AbstractObserver = Rx.internals.AbstractObserver = (function (__super__) {\n    inherits(AbstractObserver, __super__);\n\n    /**\n     * Creates a new observer in a non-stopped state.\n     */\n    function AbstractObserver() {\n      this.isStopped = false;\n    }\n\n    // Must be implemented by other observers\n    AbstractObserver.prototype.next = notImplemented;\n    AbstractObserver.prototype.error = notImplemented;\n    AbstractObserver.prototype.completed = notImplemented;\n\n    /**\n     * Notifies the observer of a new element in the sequence.\n     * @param {Any} value Next element in the sequence.\n     */\n    AbstractObserver.prototype.onNext = function (value) {\n      !this.isStopped && this.next(value);\n    };\n\n    /**\n     * Notifies the observer that an exception has occurred.\n     * @param {Any} error The error that has occurred.\n     */\n    AbstractObserver.prototype.onError = function (error) {\n      if (!this.isStopped) {\n        this.isStopped = true;\n        this.error(error);\n      }\n    };\n\n    /**\n     * Notifies the observer of the end of the sequence.\n     */\n    AbstractObserver.prototype.onCompleted = function () {\n      if (!this.isStopped) {\n        this.isStopped = true;\n        this.completed();\n      }\n    };\n\n    /**\n     * Disposes the observer, causing it to transition to the stopped state.\n     */\n    AbstractObserver.prototype.dispose = function () { this.isStopped = true; };\n\n    AbstractObserver.prototype.fail = function (e) {\n      if (!this.isStopped) {\n        this.isStopped = true;\n        this.error(e);\n        return true;\n      }\n\n      return false;\n    };\n\n    return AbstractObserver;\n  }(Observer));\n\n  /**\n   * Class to create an Observer instance from delegate-based implementations of the on* methods.\n   */\n  var AnonymousObserver = Rx.AnonymousObserver = (function (__super__) {\n    inherits(AnonymousObserver, __super__);\n\n    /**\n     * Creates an observer from the specified OnNext, OnError, and OnCompleted actions.\n     * @param {Any} onNext Observer's OnNext action implementation.\n     * @param {Any} onError Observer's OnError action implementation.\n     * @param {Any} onCompleted Observer's OnCompleted action implementation.\n     */\n    function AnonymousObserver(onNext, onError, onCompleted) {\n      __super__.call(this);\n      this._onNext = onNext;\n      this._onError = onError;\n      this._onCompleted = onCompleted;\n    }\n\n    /**\n     * Calls the onNext action.\n     * @param {Any} value Next element in the sequence.\n     */\n    AnonymousObserver.prototype.next = function (value) {\n      this._onNext(value);\n    };\n\n    /**\n     * Calls the onError action.\n     * @param {Any} error The error that has occurred.\n     */\n    AnonymousObserver.prototype.error = function (error) {\n      this._onError(error);\n    };\n\n    /**\n     *  Calls the onCompleted action.\n     */\n    AnonymousObserver.prototype.completed = function () {\n      this._onCompleted();\n    };\n\n    return AnonymousObserver;\n  }(AbstractObserver));\n\n  var CheckedObserver = (function (__super__) {\n    inherits(CheckedObserver, __super__);\n\n    function CheckedObserver(observer) {\n      __super__.call(this);\n      this._observer = observer;\n      this._state = 0; // 0 - idle, 1 - busy, 2 - done\n    }\n\n    var CheckedObserverPrototype = CheckedObserver.prototype;\n\n    CheckedObserverPrototype.onNext = function (value) {\n      this.checkAccess();\n      var res = tryCatch(this._observer.onNext).call(this._observer, value);\n      this._state = 0;\n      res === errorObj && thrower(res.e);\n    };\n\n    CheckedObserverPrototype.onError = function (err) {\n      this.checkAccess();\n      var res = tryCatch(this._observer.onError).call(this._observer, err);\n      this._state = 2;\n      res === errorObj && thrower(res.e);\n    };\n\n    CheckedObserverPrototype.onCompleted = function () {\n      this.checkAccess();\n      var res = tryCatch(this._observer.onCompleted).call(this._observer);\n      this._state = 2;\n      res === errorObj && thrower(res.e);\n    };\n\n    CheckedObserverPrototype.checkAccess = function () {\n      if (this._state === 1) { throw new Error('Re-entrancy detected'); }\n      if (this._state === 2) { throw new Error('Observer completed'); }\n      if (this._state === 0) { this._state = 1; }\n    };\n\n    return CheckedObserver;\n  }(Observer));\n\n  var ScheduledObserver = Rx.internals.ScheduledObserver = (function (__super__) {\n    inherits(ScheduledObserver, __super__);\n\n    function ScheduledObserver(scheduler, observer) {\n      __super__.call(this);\n      this.scheduler = scheduler;\n      this.observer = observer;\n      this.isAcquired = false;\n      this.hasFaulted = false;\n      this.queue = [];\n      this.disposable = new SerialDisposable();\n    }\n\n    function enqueueNext(observer, x) { return function () { observer.onNext(x); }; }\n    function enqueueError(observer, e) { return function () { observer.onError(e); }; }\n    function enqueueCompleted(observer) { return function () { observer.onCompleted(); }; }\n\n    ScheduledObserver.prototype.next = function (x) {\n      this.queue.push(enqueueNext(this.observer, x));\n    };\n\n    ScheduledObserver.prototype.error = function (e) {\n      this.queue.push(enqueueError(this.observer, e));\n    };\n\n    ScheduledObserver.prototype.completed = function () {\n      this.queue.push(enqueueCompleted(this.observer));\n    };\n\n\n    function scheduleMethod(state, recurse) {\n      var work;\n      if (state.queue.length > 0) {\n        work = state.queue.shift();\n      } else {\n        state.isAcquired = false;\n        return;\n      }\n      var res = tryCatch(work)();\n      if (res === errorObj) {\n        state.queue = [];\n        state.hasFaulted = true;\n        return thrower(res.e);\n      }\n      recurse(state);\n    }\n\n    ScheduledObserver.prototype.ensureActive = function () {\n      var isOwner = false;\n      if (!this.hasFaulted && this.queue.length > 0) {\n        isOwner = !this.isAcquired;\n        this.isAcquired = true;\n      }\n      isOwner &&\n        this.disposable.setDisposable(this.scheduler.scheduleRecursive(this, scheduleMethod));\n    };\n\n    ScheduledObserver.prototype.dispose = function () {\n      __super__.prototype.dispose.call(this);\n      this.disposable.dispose();\n    };\n\n    return ScheduledObserver;\n  }(AbstractObserver));\n\n  var ObserveOnObserver = (function (__super__) {\n    inherits(ObserveOnObserver, __super__);\n\n    function ObserveOnObserver(scheduler, observer, cancel) {\n      __super__.call(this, scheduler, observer);\n      this._cancel = cancel;\n    }\n\n    ObserveOnObserver.prototype.next = function (value) {\n      __super__.prototype.next.call(this, value);\n      this.ensureActive();\n    };\n\n    ObserveOnObserver.prototype.error = function (e) {\n      __super__.prototype.error.call(this, e);\n      this.ensureActive();\n    };\n\n    ObserveOnObserver.prototype.completed = function () {\n      __super__.prototype.completed.call(this);\n      this.ensureActive();\n    };\n\n    ObserveOnObserver.prototype.dispose = function () {\n      __super__.prototype.dispose.call(this);\n      this._cancel && this._cancel.dispose();\n      this._cancel = null;\n    };\n\n    return ObserveOnObserver;\n  })(ScheduledObserver);\n\n  var observableProto;\n\n  /**\n   * Represents a push-style collection.\n   */\n  var Observable = Rx.Observable = (function () {\n\n    function makeSubscribe(self, subscribe) {\n      return function (o) {\n        var oldOnError = o.onError;\n        o.onError = function (e) {\n          makeStackTraceLong(e, self);\n          oldOnError.call(o, e);\n        };\n\n        return subscribe.call(self, o);\n      };\n    }\n\n    function Observable() {\n      if (Rx.config.longStackSupport && hasStacks) {\n        var oldSubscribe = this._subscribe;\n        var e = tryCatch(thrower)(new Error()).e;\n        this.stack = e.stack.substring(e.stack.indexOf('\\n') + 1);\n        this._subscribe = makeSubscribe(this, oldSubscribe);\n      }\n    }\n\n    observableProto = Observable.prototype;\n\n    /**\n    * Determines whether the given object is an Observable\n    * @param {Any} An object to determine whether it is an Observable\n    * @returns {Boolean} true if an Observable, else false.\n    */\n    Observable.isObservable = function (o) {\n      return o && isFunction(o.subscribe);\n    };\n\n    /**\n     *  Subscribes an o to the observable sequence.\n     *  @param {Mixed} [oOrOnNext] The object that is to receive notifications or an action to invoke for each element in the observable sequence.\n     *  @param {Function} [onError] Action to invoke upon exceptional termination of the observable sequence.\n     *  @param {Function} [onCompleted] Action to invoke upon graceful termination of the observable sequence.\n     *  @returns {Diposable} A disposable handling the subscriptions and unsubscriptions.\n     */\n    observableProto.subscribe = observableProto.forEach = function (oOrOnNext, onError, onCompleted) {\n      return this._subscribe(typeof oOrOnNext === 'object' ?\n        oOrOnNext :\n        observerCreate(oOrOnNext, onError, onCompleted));\n    };\n\n    /**\n     * Subscribes to the next value in the sequence with an optional \"this\" argument.\n     * @param {Function} onNext The function to invoke on each element in the observable sequence.\n     * @param {Any} [thisArg] Object to use as this when executing callback.\n     * @returns {Disposable} A disposable handling the subscriptions and unsubscriptions.\n     */\n    observableProto.subscribeOnNext = function (onNext, thisArg) {\n      return this._subscribe(observerCreate(typeof thisArg !== 'undefined' ? function(x) { onNext.call(thisArg, x); } : onNext));\n    };\n\n    /**\n     * Subscribes to an exceptional condition in the sequence with an optional \"this\" argument.\n     * @param {Function} onError The function to invoke upon exceptional termination of the observable sequence.\n     * @param {Any} [thisArg] Object to use as this when executing callback.\n     * @returns {Disposable} A disposable handling the subscriptions and unsubscriptions.\n     */\n    observableProto.subscribeOnError = function (onError, thisArg) {\n      return this._subscribe(observerCreate(null, typeof thisArg !== 'undefined' ? function(e) { onError.call(thisArg, e); } : onError));\n    };\n\n    /**\n     * Subscribes to the next value in the sequence with an optional \"this\" argument.\n     * @param {Function} onCompleted The function to invoke upon graceful termination of the observable sequence.\n     * @param {Any} [thisArg] Object to use as this when executing callback.\n     * @returns {Disposable} A disposable handling the subscriptions and unsubscriptions.\n     */\n    observableProto.subscribeOnCompleted = function (onCompleted, thisArg) {\n      return this._subscribe(observerCreate(null, null, typeof thisArg !== 'undefined' ? function() { onCompleted.call(thisArg); } : onCompleted));\n    };\n\n    return Observable;\n  })();\n\n  var ObservableBase = Rx.ObservableBase = (function (__super__) {\n    inherits(ObservableBase, __super__);\n\n    function fixSubscriber(subscriber) {\n      return subscriber && isFunction(subscriber.dispose) ? subscriber :\n        isFunction(subscriber) ? disposableCreate(subscriber) : disposableEmpty;\n    }\n\n    function setDisposable(s, state) {\n      var ado = state[0], self = state[1];\n      var sub = tryCatch(self.subscribeCore).call(self, ado);\n      if (sub === errorObj && !ado.fail(errorObj.e)) { thrower(errorObj.e); }\n      ado.setDisposable(fixSubscriber(sub));\n    }\n\n    function ObservableBase() {\n      __super__.call(this);\n    }\n\n    ObservableBase.prototype._subscribe = function (o) {\n      var ado = new AutoDetachObserver(o), state = [ado, this];\n\n      if (currentThreadScheduler.scheduleRequired()) {\n        currentThreadScheduler.schedule(state, setDisposable);\n      } else {\n        setDisposable(null, state);\n      }\n      return ado;\n    };\n\n    ObservableBase.prototype.subscribeCore = notImplemented;\n\n    return ObservableBase;\n  }(Observable));\n\nvar FlatMapObservable = Rx.FlatMapObservable = (function(__super__) {\n\n    inherits(FlatMapObservable, __super__);\n\n    function FlatMapObservable(source, selector, resultSelector, thisArg) {\n      this.resultSelector = isFunction(resultSelector) ? resultSelector : null;\n      this.selector = bindCallback(isFunction(selector) ? selector : function() { return selector; }, thisArg, 3);\n      this.source = source;\n      __super__.call(this);\n    }\n\n    FlatMapObservable.prototype.subscribeCore = function(o) {\n      return this.source.subscribe(new InnerObserver(o, this.selector, this.resultSelector, this));\n    };\n\n    inherits(InnerObserver, AbstractObserver);\n    function InnerObserver(observer, selector, resultSelector, source) {\n      this.i = 0;\n      this.selector = selector;\n      this.resultSelector = resultSelector;\n      this.source = source;\n      this.o = observer;\n      AbstractObserver.call(this);\n    }\n\n    InnerObserver.prototype._wrapResult = function(result, x, i) {\n      return this.resultSelector ?\n        result.map(function(y, i2) { return this.resultSelector(x, y, i, i2); }, this) :\n        result;\n    };\n\n    InnerObserver.prototype.next = function(x) {\n      var i = this.i++;\n      var result = tryCatch(this.selector)(x, i, this.source);\n      if (result === errorObj) { return this.o.onError(result.e); }\n\n      isPromise(result) && (result = observableFromPromise(result));\n      (isArrayLike(result) || isIterable(result)) && (result = Observable.from(result));\n      this.o.onNext(this._wrapResult(result, x, i));\n    };\n\n    InnerObserver.prototype.error = function(e) { this.o.onError(e); };\n\n    InnerObserver.prototype.completed = function() { this.o.onCompleted(); };\n\n    return FlatMapObservable;\n\n}(ObservableBase));\n\n  var Enumerable = Rx.internals.Enumerable = function () { };\n\n  function IsDisposedDisposable(state) {\n    this._s = state;\n    this.isDisposed = false;\n  }\n\n  IsDisposedDisposable.prototype.dispose = function () {\n    if (!this.isDisposed) {\n      this.isDisposed = true;\n      this._s.isDisposed = true;\n    }\n  };\n\n  var ConcatEnumerableObservable = (function(__super__) {\n    inherits(ConcatEnumerableObservable, __super__);\n    function ConcatEnumerableObservable(sources) {\n      this.sources = sources;\n      __super__.call(this);\n    }\n\n    function scheduleMethod(state, recurse) {\n      if (state.isDisposed) { return; }\n      var currentItem = tryCatch(state.e.next).call(state.e);\n      if (currentItem === errorObj) { return state.o.onError(currentItem.e); }\n      if (currentItem.done) { return state.o.onCompleted(); }\n\n      // Check if promise\n      var currentValue = currentItem.value;\n      isPromise(currentValue) && (currentValue = observableFromPromise(currentValue));\n\n      var d = new SingleAssignmentDisposable();\n      state.subscription.setDisposable(d);\n      d.setDisposable(currentValue.subscribe(new InnerObserver(state, recurse)));\n    }\n\n    ConcatEnumerableObservable.prototype.subscribeCore = function (o) {\n      var subscription = new SerialDisposable();\n      var state = {\n        isDisposed: false,\n        o: o,\n        subscription: subscription,\n        e: this.sources[$iterator$]()\n      };\n\n      var cancelable = currentThreadScheduler.scheduleRecursive(state, scheduleMethod);\n      return new NAryDisposable([subscription, cancelable, new IsDisposedDisposable(state)]);\n    };\n\n    function InnerObserver(state, recurse) {\n      this._state = state;\n      this._recurse = recurse;\n      AbstractObserver.call(this);\n    }\n\n    inherits(InnerObserver, AbstractObserver);\n\n    InnerObserver.prototype.next = function (x) { this._state.o.onNext(x); };\n    InnerObserver.prototype.error = function (e) { this._state.o.onError(e); };\n    InnerObserver.prototype.completed = function () { this._recurse(this._state); };\n\n    return ConcatEnumerableObservable;\n  }(ObservableBase));\n\n  Enumerable.prototype.concat = function () {\n    return new ConcatEnumerableObservable(this);\n  };\n\n  var CatchErrorObservable = (function(__super__) {\n    function CatchErrorObservable(sources) {\n      this.sources = sources;\n      __super__.call(this);\n    }\n\n    inherits(CatchErrorObservable, __super__);\n\n    function scheduleMethod(state, recurse) {\n      if (state.isDisposed) { return; }\n      var currentItem = tryCatch(state.e.next).call(state.e);\n      if (currentItem === errorObj) { return state.o.onError(currentItem.e); }\n      if (currentItem.done) { return state.lastError !== null ? state.o.onError(state.lastError) : state.o.onCompleted(); }\n\n      var currentValue = currentItem.value;\n      isPromise(currentValue) && (currentValue = observableFromPromise(currentValue));\n\n      var d = new SingleAssignmentDisposable();\n      state.subscription.setDisposable(d);\n      d.setDisposable(currentValue.subscribe(new InnerObserver(state, recurse)));\n    }\n\n    CatchErrorObservable.prototype.subscribeCore = function (o) {\n      var subscription = new SerialDisposable();\n      var state = {\n        isDisposed: false,\n        e: this.sources[$iterator$](),\n        subscription: subscription,\n        lastError: null,\n        o: o\n      };\n\n      var cancelable = currentThreadScheduler.scheduleRecursive(state, scheduleMethod);\n      return new NAryDisposable([subscription, cancelable, new IsDisposedDisposable(state)]);\n    };\n\n    function InnerObserver(state, recurse) {\n      this._state = state;\n      this._recurse = recurse;\n      AbstractObserver.call(this);\n    }\n\n    inherits(InnerObserver, AbstractObserver);\n\n    InnerObserver.prototype.next = function (x) { this._state.o.onNext(x); };\n    InnerObserver.prototype.error = function (e) { this._state.lastError = e; this._recurse(this._state); };\n    InnerObserver.prototype.completed = function () { this._state.o.onCompleted(); };\n\n    return CatchErrorObservable;\n  }(ObservableBase));\n\n  Enumerable.prototype.catchError = function () {\n    return new CatchErrorObservable(this);\n  };\n\n  Enumerable.prototype.catchErrorWhen = function (notificationHandler) {\n    var sources = this;\n    return new AnonymousObservable(function (o) {\n      var exceptions = new Subject(),\n        notifier = new Subject(),\n        handled = notificationHandler(exceptions),\n        notificationDisposable = handled.subscribe(notifier);\n\n      var e = sources[$iterator$]();\n\n      var state = { isDisposed: false },\n        lastError,\n        subscription = new SerialDisposable();\n      var cancelable = currentThreadScheduler.scheduleRecursive(null, function (_, self) {\n        if (state.isDisposed) { return; }\n        var currentItem = tryCatch(e.next).call(e);\n        if (currentItem === errorObj) { return o.onError(currentItem.e); }\n\n        if (currentItem.done) {\n          if (lastError) {\n            o.onError(lastError);\n          } else {\n            o.onCompleted();\n          }\n          return;\n        }\n\n        // Check if promise\n        var currentValue = currentItem.value;\n        isPromise(currentValue) && (currentValue = observableFromPromise(currentValue));\n\n        var outer = new SingleAssignmentDisposable();\n        var inner = new SingleAssignmentDisposable();\n        subscription.setDisposable(new BinaryDisposable(inner, outer));\n        outer.setDisposable(currentValue.subscribe(\n          function(x) { o.onNext(x); },\n          function (exn) {\n            inner.setDisposable(notifier.subscribe(self, function(ex) {\n              o.onError(ex);\n            }, function() {\n              o.onCompleted();\n            }));\n\n            exceptions.onNext(exn);\n          },\n          function() { o.onCompleted(); }));\n      });\n\n      return new NAryDisposable([notificationDisposable, subscription, cancelable, new IsDisposedDisposable(state)]);\n    });\n  };\n\n  var RepeatEnumerable = (function (__super__) {\n    inherits(RepeatEnumerable, __super__);\n    function RepeatEnumerable(v, c) {\n      this.v = v;\n      this.c = c == null ? -1 : c;\n    }\n\n    RepeatEnumerable.prototype[$iterator$] = function () {\n      return new RepeatEnumerator(this);\n    };\n\n    function RepeatEnumerator(p) {\n      this.v = p.v;\n      this.l = p.c;\n    }\n\n    RepeatEnumerator.prototype.next = function () {\n      if (this.l === 0) { return doneEnumerator; }\n      if (this.l > 0) { this.l--; }\n      return { done: false, value: this.v };\n    };\n\n    return RepeatEnumerable;\n  }(Enumerable));\n\n  var enumerableRepeat = Enumerable.repeat = function (value, repeatCount) {\n    return new RepeatEnumerable(value, repeatCount);\n  };\n\n  var OfEnumerable = (function(__super__) {\n    inherits(OfEnumerable, __super__);\n    function OfEnumerable(s, fn, thisArg) {\n      this.s = s;\n      this.fn = fn ? bindCallback(fn, thisArg, 3) : null;\n    }\n    OfEnumerable.prototype[$iterator$] = function () {\n      return new OfEnumerator(this);\n    };\n\n    function OfEnumerator(p) {\n      this.i = -1;\n      this.s = p.s;\n      this.l = this.s.length;\n      this.fn = p.fn;\n    }\n\n    OfEnumerator.prototype.next = function () {\n     return ++this.i < this.l ?\n       { done: false, value: !this.fn ? this.s[this.i] : this.fn(this.s[this.i], this.i, this.s) } :\n       doneEnumerator;\n    };\n\n    return OfEnumerable;\n  }(Enumerable));\n\n  var enumerableOf = Enumerable.of = function (source, selector, thisArg) {\n    return new OfEnumerable(source, selector, thisArg);\n  };\n\nvar ObserveOnObservable = (function (__super__) {\n  inherits(ObserveOnObservable, __super__);\n  function ObserveOnObservable(source, s) {\n    this.source = source;\n    this._s = s;\n    __super__.call(this);\n  }\n\n  ObserveOnObservable.prototype.subscribeCore = function (o) {\n    return this.source.subscribe(new ObserveOnObserver(this._s, o));\n  };\n\n  return ObserveOnObservable;\n}(ObservableBase));\n\n   /**\n   *  Wraps the source sequence in order to run its observer callbacks on the specified scheduler.\n   *\n   *  This only invokes observer callbacks on a scheduler. In case the subscription and/or unsubscription actions have side-effects\n   *  that require to be run on a scheduler, use subscribeOn.\n   *\n   *  @param {Scheduler} scheduler Scheduler to notify observers on.\n   *  @returns {Observable} The source sequence whose observations happen on the specified scheduler.\n   */\n  observableProto.observeOn = function (scheduler) {\n    return new ObserveOnObservable(this, scheduler);\n  };\n\n  var SubscribeOnObservable = (function (__super__) {\n    inherits(SubscribeOnObservable, __super__);\n    function SubscribeOnObservable(source, s) {\n      this.source = source;\n      this._s = s;\n      __super__.call(this);\n    }\n\n    function scheduleMethod(scheduler, state) {\n      var source = state[0], d = state[1], o = state[2];\n      d.setDisposable(new ScheduledDisposable(scheduler, source.subscribe(o)));\n    }\n\n    SubscribeOnObservable.prototype.subscribeCore = function (o) {\n      var m = new SingleAssignmentDisposable(), d = new SerialDisposable();\n      d.setDisposable(m);\n      m.setDisposable(this._s.schedule([this.source, d, o], scheduleMethod));\n      return d;\n    };\n\n    return SubscribeOnObservable;\n  }(ObservableBase));\n\n   /**\n   *  Wraps the source sequence in order to run its subscription and unsubscription logic on the specified scheduler. This operation is not commonly used;\n   *  see the remarks section for more information on the distinction between subscribeOn and observeOn.\n\n   *  This only performs the side-effects of subscription and unsubscription on the specified scheduler. In order to invoke observer\n   *  callbacks on a scheduler, use observeOn.\n\n   *  @param {Scheduler} scheduler Scheduler to perform subscription and unsubscription actions on.\n   *  @returns {Observable} The source sequence whose subscriptions and unsubscriptions happen on the specified scheduler.\n   */\n  observableProto.subscribeOn = function (scheduler) {\n    return new SubscribeOnObservable(this, scheduler);\n  };\n\n  var FromPromiseObservable = (function(__super__) {\n    inherits(FromPromiseObservable, __super__);\n    function FromPromiseObservable(p, s) {\n      this._p = p;\n      this._s = s;\n      __super__.call(this);\n    }\n\n    function scheduleNext(s, state) {\n      var o = state[0], data = state[1];\n      o.onNext(data);\n      o.onCompleted();\n    }\n\n    function scheduleError(s, state) {\n      var o = state[0], err = state[1];\n      o.onError(err);\n    }\n\n    FromPromiseObservable.prototype.subscribeCore = function(o) {\n      var sad = new SingleAssignmentDisposable(), self = this;\n\n      this._p\n        .then(function (data) {\n          sad.setDisposable(self._s.schedule([o, data], scheduleNext));\n        }, function (err) {\n          sad.setDisposable(self._s.schedule([o, err], scheduleError));\n        });\n\n      return sad;\n    };\n\n    return FromPromiseObservable;\n  }(ObservableBase));\n\n  /**\n  * Converts a Promise to an Observable sequence\n  * @param {Promise} An ES6 Compliant promise.\n  * @returns {Observable} An Observable sequence which wraps the existing promise success and failure.\n  */\n  var observableFromPromise = Observable.fromPromise = function (promise, scheduler) {\n    scheduler || (scheduler = defaultScheduler);\n    return new FromPromiseObservable(promise, scheduler);\n  };\n\n  /*\n   * Converts an existing observable sequence to an ES6 Compatible Promise\n   * @example\n   * var promise = Rx.Observable.return(42).toPromise(RSVP.Promise);\n   *\n   * // With config\n   * Rx.config.Promise = RSVP.Promise;\n   * var promise = Rx.Observable.return(42).toPromise();\n   * @param {Function} [promiseCtor] The constructor of the promise. If not provided, it looks for it in Rx.config.Promise.\n   * @returns {Promise} An ES6 compatible promise with the last value from the observable sequence.\n   */\n  observableProto.toPromise = function (promiseCtor) {\n    promiseCtor || (promiseCtor = Rx.config.Promise);\n    if (!promiseCtor) { throw new NotSupportedError('Promise type not provided nor in Rx.config.Promise'); }\n    var source = this;\n    return new promiseCtor(function (resolve, reject) {\n      // No cancellation can be done\n      var value;\n      source.subscribe(function (v) {\n        value = v;\n      }, reject, function () {\n        resolve(value);\n      });\n    });\n  };\n\n  var ToArrayObservable = (function(__super__) {\n    inherits(ToArrayObservable, __super__);\n    function ToArrayObservable(source) {\n      this.source = source;\n      __super__.call(this);\n    }\n\n    ToArrayObservable.prototype.subscribeCore = function(o) {\n      return this.source.subscribe(new InnerObserver(o));\n    };\n\n    inherits(InnerObserver, AbstractObserver);\n    function InnerObserver(o) {\n      this.o = o;\n      this.a = [];\n      AbstractObserver.call(this);\n    }\n    \n    InnerObserver.prototype.next = function (x) { this.a.push(x); };\n    InnerObserver.prototype.error = function (e) { this.o.onError(e);  };\n    InnerObserver.prototype.completed = function () { this.o.onNext(this.a); this.o.onCompleted(); };\n\n    return ToArrayObservable;\n  }(ObservableBase));\n\n  /**\n  * Creates an array from an observable sequence.\n  * @returns {Observable} An observable sequence containing a single element with a list containing all the elements of the source sequence.\n  */\n  observableProto.toArray = function () {\n    return new ToArrayObservable(this);\n  };\n\n  /**\n   *  Creates an observable sequence from a specified subscribe method implementation.\n   * @example\n   *  var res = Rx.Observable.create(function (observer) { return function () { } );\n   *  var res = Rx.Observable.create(function (observer) { return Rx.Disposable.empty; } );\n   *  var res = Rx.Observable.create(function (observer) { } );\n   * @param {Function} subscribe Implementation of the resulting observable sequence's subscribe method, returning a function that will be wrapped in a Disposable.\n   * @returns {Observable} The observable sequence with the specified implementation for the Subscribe method.\n   */\n  Observable.create = function (subscribe, parent) {\n    return new AnonymousObservable(subscribe, parent);\n  };\n\n  var Defer = (function(__super__) {\n    inherits(Defer, __super__);\n    function Defer(factory) {\n      this._f = factory;\n      __super__.call(this);\n    }\n\n    Defer.prototype.subscribeCore = function (o) {\n      var result = tryCatch(this._f)();\n      if (result === errorObj) { return observableThrow(result.e).subscribe(o);}\n      isPromise(result) && (result = observableFromPromise(result));\n      return result.subscribe(o);\n    };\n\n    return Defer;\n  }(ObservableBase));\n\n  /**\n   *  Returns an observable sequence that invokes the specified factory function whenever a new observer subscribes.\n   *\n   * @example\n   *  var res = Rx.Observable.defer(function () { return Rx.Observable.fromArray([1,2,3]); });\n   * @param {Function} observableFactory Observable factory function to invoke for each observer that subscribes to the resulting sequence or Promise.\n   * @returns {Observable} An observable sequence whose observers trigger an invocation of the given observable factory function.\n   */\n  var observableDefer = Observable.defer = function (observableFactory) {\n    return new Defer(observableFactory);\n  };\n\n  var EmptyObservable = (function(__super__) {\n    inherits(EmptyObservable, __super__);\n    function EmptyObservable(scheduler) {\n      this.scheduler = scheduler;\n      __super__.call(this);\n    }\n\n    EmptyObservable.prototype.subscribeCore = function (observer) {\n      var sink = new EmptySink(observer, this.scheduler);\n      return sink.run();\n    };\n\n    function EmptySink(observer, scheduler) {\n      this.observer = observer;\n      this.scheduler = scheduler;\n    }\n\n    function scheduleItem(s, state) {\n      state.onCompleted();\n      return disposableEmpty;\n    }\n\n    EmptySink.prototype.run = function () {\n      var state = this.observer;\n      return this.scheduler === immediateScheduler ?\n        scheduleItem(null, state) :\n        this.scheduler.schedule(state, scheduleItem);\n    };\n\n    return EmptyObservable;\n  }(ObservableBase));\n\n  var EMPTY_OBSERVABLE = new EmptyObservable(immediateScheduler);\n\n  /**\n   *  Returns an empty observable sequence, using the specified scheduler to send out the single OnCompleted message.\n   *\n   * @example\n   *  var res = Rx.Observable.empty();\n   *  var res = Rx.Observable.empty(Rx.Scheduler.timeout);\n   * @param {Scheduler} [scheduler] Scheduler to send the termination call on.\n   * @returns {Observable} An observable sequence with no elements.\n   */\n  var observableEmpty = Observable.empty = function (scheduler) {\n    isScheduler(scheduler) || (scheduler = immediateScheduler);\n    return scheduler === immediateScheduler ? EMPTY_OBSERVABLE : new EmptyObservable(scheduler);\n  };\n\n  var FromObservable = (function(__super__) {\n    inherits(FromObservable, __super__);\n    function FromObservable(iterable, fn, scheduler) {\n      this._iterable = iterable;\n      this._fn = fn;\n      this._scheduler = scheduler;\n      __super__.call(this);\n    }\n\n    function createScheduleMethod(o, it, fn) {\n      return function loopRecursive(i, recurse) {\n        var next = tryCatch(it.next).call(it);\n        if (next === errorObj) { return o.onError(next.e); }\n        if (next.done) { return o.onCompleted(); }\n\n        var result = next.value;\n\n        if (isFunction(fn)) {\n          result = tryCatch(fn)(result, i);\n          if (result === errorObj) { return o.onError(result.e); }\n        }\n\n        o.onNext(result);\n        recurse(i + 1);\n      };\n    }\n\n    FromObservable.prototype.subscribeCore = function (o) {\n      var list = Object(this._iterable),\n          it = getIterable(list);\n\n      return this._scheduler.scheduleRecursive(0, createScheduleMethod(o, it, this._fn));\n    };\n\n    return FromObservable;\n  }(ObservableBase));\n\n  var maxSafeInteger = Math.pow(2, 53) - 1;\n\n  function StringIterable(s) {\n    this._s = s;\n  }\n\n  StringIterable.prototype[$iterator$] = function () {\n    return new StringIterator(this._s);\n  };\n\n  function StringIterator(s) {\n    this._s = s;\n    this._l = s.length;\n    this._i = 0;\n  }\n\n  StringIterator.prototype[$iterator$] = function () {\n    return this;\n  };\n\n  StringIterator.prototype.next = function () {\n    return this._i < this._l ? { done: false, value: this._s.charAt(this._i++) } : doneEnumerator;\n  };\n\n  function ArrayIterable(a) {\n    this._a = a;\n  }\n\n  ArrayIterable.prototype[$iterator$] = function () {\n    return new ArrayIterator(this._a);\n  };\n\n  function ArrayIterator(a) {\n    this._a = a;\n    this._l = toLength(a);\n    this._i = 0;\n  }\n\n  ArrayIterator.prototype[$iterator$] = function () {\n    return this;\n  };\n\n  ArrayIterator.prototype.next = function () {\n    return this._i < this._l ? { done: false, value: this._a[this._i++] } : doneEnumerator;\n  };\n\n  function numberIsFinite(value) {\n    return typeof value === 'number' && root.isFinite(value);\n  }\n\n  function isNan(n) {\n    return n !== n;\n  }\n\n  function getIterable(o) {\n    var i = o[$iterator$], it;\n    if (!i && typeof o === 'string') {\n      it = new StringIterable(o);\n      return it[$iterator$]();\n    }\n    if (!i && o.length !== undefined) {\n      it = new ArrayIterable(o);\n      return it[$iterator$]();\n    }\n    if (!i) { throw new TypeError('Object is not iterable'); }\n    return o[$iterator$]();\n  }\n\n  function sign(value) {\n    var number = +value;\n    if (number === 0) { return number; }\n    if (isNaN(number)) { return number; }\n    return number < 0 ? -1 : 1;\n  }\n\n  function toLength(o) {\n    var len = +o.length;\n    if (isNaN(len)) { return 0; }\n    if (len === 0 || !numberIsFinite(len)) { return len; }\n    len = sign(len) * Math.floor(Math.abs(len));\n    if (len <= 0) { return 0; }\n    if (len > maxSafeInteger) { return maxSafeInteger; }\n    return len;\n  }\n\n  /**\n  * This method creates a new Observable sequence from an array-like or iterable object.\n  * @param {Any} arrayLike An array-like or iterable object to convert to an Observable sequence.\n  * @param {Function} [mapFn] Map function to call on every element of the array.\n  * @param {Any} [thisArg] The context to use calling the mapFn if provided.\n  * @param {Scheduler} [scheduler] Optional scheduler to use for scheduling.  If not provided, defaults to Scheduler.currentThread.\n  */\n  var observableFrom = Observable.from = function (iterable, mapFn, thisArg, scheduler) {\n    if (iterable == null) {\n      throw new Error('iterable cannot be null.')\n    }\n    if (mapFn && !isFunction(mapFn)) {\n      throw new Error('mapFn when provided must be a function');\n    }\n    if (mapFn) {\n      var mapper = bindCallback(mapFn, thisArg, 2);\n    }\n    isScheduler(scheduler) || (scheduler = currentThreadScheduler);\n    return new FromObservable(iterable, mapper, scheduler);\n  }\n\n  var FromArrayObservable = (function(__super__) {\n    inherits(FromArrayObservable, __super__);\n    function FromArrayObservable(args, scheduler) {\n      this._args = args;\n      this._scheduler = scheduler;\n      __super__.call(this);\n    }\n\n    function scheduleMethod(o, args) {\n      var len = args.length;\n      return function loopRecursive (i, recurse) {\n        if (i < len) {\n          o.onNext(args[i]);\n          recurse(i + 1);\n        } else {\n          o.onCompleted();\n        }\n      };\n    }\n\n    FromArrayObservable.prototype.subscribeCore = function (o) {\n      return this._scheduler.scheduleRecursive(0, scheduleMethod(o, this._args));\n    };\n\n    return FromArrayObservable;\n  }(ObservableBase));\n\n  /**\n  *  Converts an array to an observable sequence, using an optional scheduler to enumerate the array.\n  * @deprecated use Observable.from or Observable.of\n  * @param {Scheduler} [scheduler] Scheduler to run the enumeration of the input sequence on.\n  * @returns {Observable} The observable sequence whose elements are pulled from the given enumerable sequence.\n  */\n  var observableFromArray = Observable.fromArray = function (array, scheduler) {\n    isScheduler(scheduler) || (scheduler = currentThreadScheduler);\n    return new FromArrayObservable(array, scheduler)\n  };\n\n  var GenerateObservable = (function (__super__) {\n    inherits(GenerateObservable, __super__);\n    function GenerateObservable(state, cndFn, itrFn, resFn, s) {\n      this._state = state;\n      this._cndFn = cndFn;\n      this._itrFn = itrFn;\n      this._resFn = resFn;\n      this._s = s;\n      this._first = true;\n      __super__.call(this);\n    }\n\n    function scheduleRecursive(self, recurse) {\n      if (self._first) {\n        self._first = false;\n      } else {\n        self._state = tryCatch(self._itrFn)(self._state);\n        if (self._state === errorObj) { return self._o.onError(self._state.e); }\n      }\n      var hasResult = tryCatch(self._cndFn)(self._state);\n      if (hasResult === errorObj) { return self._o.onError(hasResult.e); }\n      if (hasResult) {\n        var result = tryCatch(self._resFn)(self._state);\n        if (result === errorObj) { return self._o.onError(result.e); }\n        self._o.onNext(result);\n        recurse(self);\n      } else {\n        self._o.onCompleted();\n      }\n    }\n\n    GenerateObservable.prototype.subscribeCore = function (o) {\n      this._o = o;\n      return this._s.scheduleRecursive(this, scheduleRecursive);\n    };\n\n    return GenerateObservable;\n  }(ObservableBase));\n\n  /**\n   *  Generates an observable sequence by running a state-driven loop producing the sequence's elements, using the specified scheduler to send out observer messages.\n   *\n   * @example\n   *  var res = Rx.Observable.generate(0, function (x) { return x < 10; }, function (x) { return x + 1; }, function (x) { return x; });\n   *  var res = Rx.Observable.generate(0, function (x) { return x < 10; }, function (x) { return x + 1; }, function (x) { return x; }, Rx.Scheduler.timeout);\n   * @param {Mixed} initialState Initial state.\n   * @param {Function} condition Condition to terminate generation (upon returning false).\n   * @param {Function} iterate Iteration step function.\n   * @param {Function} resultSelector Selector function for results produced in the sequence.\n   * @param {Scheduler} [scheduler] Scheduler on which to run the generator loop. If not provided, defaults to Scheduler.currentThread.\n   * @returns {Observable} The generated sequence.\n   */\n  Observable.generate = function (initialState, condition, iterate, resultSelector, scheduler) {\n    isScheduler(scheduler) || (scheduler = currentThreadScheduler);\n    return new GenerateObservable(initialState, condition, iterate, resultSelector, scheduler);\n  };\n\n  function observableOf (scheduler, array) {\n    isScheduler(scheduler) || (scheduler = currentThreadScheduler);\n    return new FromArrayObservable(array, scheduler);\n  }\n\n  /**\n  *  This method creates a new Observable instance with a variable number of arguments, regardless of number or type of the arguments.\n  * @returns {Observable} The observable sequence whose elements are pulled from the given arguments.\n  */\n  Observable.of = function () {\n    var len = arguments.length, args = new Array(len);\n    for(var i = 0; i < len; i++) { args[i] = arguments[i]; }\n    return new FromArrayObservable(args, currentThreadScheduler);\n  };\n\n  /**\n  *  This method creates a new Observable instance with a variable number of arguments, regardless of number or type of the arguments.\n  * @param {Scheduler} scheduler A scheduler to use for scheduling the arguments.\n  * @returns {Observable} The observable sequence whose elements are pulled from the given arguments.\n  */\n  Observable.ofWithScheduler = function (scheduler) {\n    var len = arguments.length, args = new Array(len - 1);\n    for(var i = 1; i < len; i++) { args[i - 1] = arguments[i]; }\n    return new FromArrayObservable(args, scheduler);\n  };\n\n  /**\n   * Creates an Observable sequence from changes to an array using Array.observe.\n   * @param {Array} array An array to observe changes.\n   * @returns {Observable} An observable sequence containing changes to an array from Array.observe.\n   */\n  Observable.ofArrayChanges = function(array) {\n    if (!Array.isArray(array)) { throw new TypeError('Array.observe only accepts arrays.'); }\n    if (typeof Array.observe !== 'function' && typeof Array.unobserve !== 'function') { throw new TypeError('Array.observe is not supported on your platform') }\n    return new AnonymousObservable(function(observer) {\n      function observerFn(changes) {\n        for(var i = 0, len = changes.length; i < len; i++) {\n          observer.onNext(changes[i]);\n        }\n      }\n      \n      Array.observe(array, observerFn);\n\n      return function () {\n        Array.unobserve(array, observerFn);\n      };\n    });\n  };\n\n  /**\n   * Creates an Observable sequence from changes to an object using Object.observe.\n   * @param {Object} obj An object to observe changes.\n   * @returns {Observable} An observable sequence containing changes to an object from Object.observe.\n   */\n  Observable.ofObjectChanges = function(obj) {\n    if (obj == null) { throw new TypeError('object must not be null or undefined.'); }\n    if (typeof Object.observe !== 'function' && typeof Object.unobserve !== 'function') { throw new TypeError('Object.observe is not supported on your platform') }\n    return new AnonymousObservable(function(observer) {\n      function observerFn(changes) {\n        for(var i = 0, len = changes.length; i < len; i++) {\n          observer.onNext(changes[i]);\n        }\n      }\n\n      Object.observe(obj, observerFn);\n\n      return function () {\n        Object.unobserve(obj, observerFn);\n      };\n    });\n  };\n\n  var NeverObservable = (function(__super__) {\n    inherits(NeverObservable, __super__);\n    function NeverObservable() {\n      __super__.call(this);\n    }\n\n    NeverObservable.prototype.subscribeCore = function (observer) {\n      return disposableEmpty;\n    };\n\n    return NeverObservable;\n  }(ObservableBase));\n\n  var NEVER_OBSERVABLE = new NeverObservable();\n\n  /**\n   * Returns a non-terminating observable sequence, which can be used to denote an infinite duration (e.g. when using reactive joins).\n   * @returns {Observable} An observable sequence whose observers will never get called.\n   */\n  var observableNever = Observable.never = function () {\n    return NEVER_OBSERVABLE;\n  };\n\n  var PairsObservable = (function(__super__) {\n    inherits(PairsObservable, __super__);\n    function PairsObservable(o, scheduler) {\n      this._o = o;\n      this._keys = Object.keys(o);\n      this._scheduler = scheduler;\n      __super__.call(this);\n    }\n\n    function scheduleMethod(o, obj, keys) {\n      return function loopRecursive(i, recurse) {\n        if (i < keys.length) {\n          var key = keys[i];\n          o.onNext([key, obj[key]]);\n          recurse(i + 1);\n        } else {\n          o.onCompleted();\n        }\n      };\n    }\n\n    PairsObservable.prototype.subscribeCore = function (o) {\n      return this._scheduler.scheduleRecursive(0, scheduleMethod(o, this._o, this._keys));\n    };\n\n    return PairsObservable;\n  }(ObservableBase));\n\n  /**\n   * Convert an object into an observable sequence of [key, value] pairs.\n   * @param {Object} obj The object to inspect.\n   * @param {Scheduler} [scheduler] Scheduler to run the enumeration of the input sequence on.\n   * @returns {Observable} An observable sequence of [key, value] pairs from the object.\n   */\n  Observable.pairs = function (obj, scheduler) {\n    scheduler || (scheduler = currentThreadScheduler);\n    return new PairsObservable(obj, scheduler);\n  };\n\n    var RangeObservable = (function(__super__) {\n    inherits(RangeObservable, __super__);\n    function RangeObservable(start, count, scheduler) {\n      this.start = start;\n      this.rangeCount = count;\n      this.scheduler = scheduler;\n      __super__.call(this);\n    }\n\n    function loopRecursive(start, count, o) {\n      return function loop (i, recurse) {\n        if (i < count) {\n          o.onNext(start + i);\n          recurse(i + 1);\n        } else {\n          o.onCompleted();\n        }\n      };\n    }\n\n    RangeObservable.prototype.subscribeCore = function (o) {\n      return this.scheduler.scheduleRecursive(\n        0,\n        loopRecursive(this.start, this.rangeCount, o)\n      );\n    };\n\n    return RangeObservable;\n  }(ObservableBase));\n\n  /**\n  *  Generates an observable sequence of integral numbers within a specified range, using the specified scheduler to send out observer messages.\n  * @param {Number} start The value of the first integer in the sequence.\n  * @param {Number} count The number of sequential integers to generate.\n  * @param {Scheduler} [scheduler] Scheduler to run the generator loop on. If not specified, defaults to Scheduler.currentThread.\n  * @returns {Observable} An observable sequence that contains a range of sequential integral numbers.\n  */\n  Observable.range = function (start, count, scheduler) {\n    isScheduler(scheduler) || (scheduler = currentThreadScheduler);\n    return new RangeObservable(start, count, scheduler);\n  };\n\n  var RepeatObservable = (function(__super__) {\n    inherits(RepeatObservable, __super__);\n    function RepeatObservable(value, repeatCount, scheduler) {\n      this.value = value;\n      this.repeatCount = repeatCount == null ? -1 : repeatCount;\n      this.scheduler = scheduler;\n      __super__.call(this);\n    }\n\n    RepeatObservable.prototype.subscribeCore = function (observer) {\n      var sink = new RepeatSink(observer, this);\n      return sink.run();\n    };\n\n    return RepeatObservable;\n  }(ObservableBase));\n\n  function RepeatSink(observer, parent) {\n    this.observer = observer;\n    this.parent = parent;\n  }\n\n  RepeatSink.prototype.run = function () {\n    var observer = this.observer, value = this.parent.value;\n    function loopRecursive(i, recurse) {\n      if (i === -1 || i > 0) {\n        observer.onNext(value);\n        i > 0 && i--;\n      }\n      if (i === 0) { return observer.onCompleted(); }\n      recurse(i);\n    }\n\n    return this.parent.scheduler.scheduleRecursive(this.parent.repeatCount, loopRecursive);\n  };\n\n  /**\n   *  Generates an observable sequence that repeats the given element the specified number of times, using the specified scheduler to send out observer messages.\n   * @param {Mixed} value Element to repeat.\n   * @param {Number} repeatCount [Optiona] Number of times to repeat the element. If not specified, repeats indefinitely.\n   * @param {Scheduler} scheduler Scheduler to run the producer loop on. If not specified, defaults to Scheduler.immediate.\n   * @returns {Observable} An observable sequence that repeats the given element the specified number of times.\n   */\n  Observable.repeat = function (value, repeatCount, scheduler) {\n    isScheduler(scheduler) || (scheduler = currentThreadScheduler);\n    return new RepeatObservable(value, repeatCount, scheduler);\n  };\n\n  var JustObservable = (function(__super__) {\n    inherits(JustObservable, __super__);\n    function JustObservable(value, scheduler) {\n      this._value = value;\n      this._scheduler = scheduler;\n      __super__.call(this);\n    }\n\n    JustObservable.prototype.subscribeCore = function (o) {\n      var state = [this._value, o];\n      return this._scheduler === immediateScheduler ?\n        scheduleItem(null, state) :\n        this._scheduler.schedule(state, scheduleItem);\n    };\n\n    function scheduleItem(s, state) {\n      var value = state[0], observer = state[1];\n      observer.onNext(value);\n      observer.onCompleted();\n      return disposableEmpty;\n    }\n\n    return JustObservable;\n  }(ObservableBase));\n\n  /**\n   *  Returns an observable sequence that contains a single element, using the specified scheduler to send out observer messages.\n   *  There is an alias called 'just' or browsers <IE9.\n   * @param {Mixed} value Single element in the resulting observable sequence.\n   * @param {Scheduler} scheduler Scheduler to send the single element on. If not specified, defaults to Scheduler.immediate.\n   * @returns {Observable} An observable sequence containing the single specified element.\n   */\n  var observableReturn = Observable['return'] = Observable.just = function (value, scheduler) {\n    isScheduler(scheduler) || (scheduler = immediateScheduler);\n    return new JustObservable(value, scheduler);\n  };\n\n  var ThrowObservable = (function(__super__) {\n    inherits(ThrowObservable, __super__);\n    function ThrowObservable(error, scheduler) {\n      this._error = error;\n      this._scheduler = scheduler;\n      __super__.call(this);\n    }\n\n    ThrowObservable.prototype.subscribeCore = function (o) {\n      var state = [this._error, o];\n      return this._scheduler === immediateScheduler ?\n        scheduleItem(null, state) :\n        this._scheduler.schedule(state, scheduleItem);\n    };\n\n    function scheduleItem(s, state) {\n      var e = state[0], o = state[1];\n      o.onError(e);\n      return disposableEmpty;\n    }\n\n    return ThrowObservable;\n  }(ObservableBase));\n\n  /**\n   *  Returns an observable sequence that terminates with an exception, using the specified scheduler to send out the single onError message.\n   *  There is an alias to this method called 'throwError' for browsers <IE9.\n   * @param {Mixed} error An object used for the sequence's termination.\n   * @param {Scheduler} scheduler Scheduler to send the exceptional termination call on. If not specified, defaults to Scheduler.immediate.\n   * @returns {Observable} The observable sequence that terminates exceptionally with the specified exception object.\n   */\n  var observableThrow = Observable['throw'] = function (error, scheduler) {\n    isScheduler(scheduler) || (scheduler = immediateScheduler);\n    return new ThrowObservable(error, scheduler);\n  };\n\n  var UsingObservable = (function (__super__) {\n    inherits(UsingObservable, __super__);\n    function UsingObservable(resFn, obsFn) {\n      this._resFn = resFn;\n      this._obsFn = obsFn;\n      __super__.call(this);\n    }\n\n    UsingObservable.prototype.subscribeCore = function (o) {\n      var disposable = disposableEmpty;\n      var resource = tryCatch(this._resFn)();\n      if (resource === errorObj) {\n        return new BinaryDisposable(observableThrow(resource.e).subscribe(o), disposable);\n      }\n      resource && (disposable = resource);\n      var source = tryCatch(this._obsFn)(resource);\n      if (source === errorObj) {\n        return new BinaryDisposable(observableThrow(source.e).subscribe(o), disposable);\n      }\n      return new BinaryDisposable(source.subscribe(o), disposable);\n    };\n\n    return UsingObservable;\n  }(ObservableBase));\n\n  /**\n   * Constructs an observable sequence that depends on a resource object, whose lifetime is tied to the resulting observable sequence's lifetime.\n   * @param {Function} resourceFactory Factory function to obtain a resource object.\n   * @param {Function} observableFactory Factory function to obtain an observable sequence that depends on the obtained resource.\n   * @returns {Observable} An observable sequence whose lifetime controls the lifetime of the dependent resource object.\n   */\n  Observable.using = function (resourceFactory, observableFactory) {\n    return new UsingObservable(resourceFactory, observableFactory);\n  };\n\n  /**\n   * Propagates the observable sequence or Promise that reacts first.\n   * @param {Observable} rightSource Second observable sequence or Promise.\n   * @returns {Observable} {Observable} An observable sequence that surfaces either of the given sequences, whichever reacted first.\n   */\n  observableProto.amb = function (rightSource) {\n    var leftSource = this;\n    return new AnonymousObservable(function (observer) {\n      var choice,\n        leftChoice = 'L', rightChoice = 'R',\n        leftSubscription = new SingleAssignmentDisposable(),\n        rightSubscription = new SingleAssignmentDisposable();\n\n      isPromise(rightSource) && (rightSource = observableFromPromise(rightSource));\n\n      function choiceL() {\n        if (!choice) {\n          choice = leftChoice;\n          rightSubscription.dispose();\n        }\n      }\n\n      function choiceR() {\n        if (!choice) {\n          choice = rightChoice;\n          leftSubscription.dispose();\n        }\n      }\n\n      var leftSubscribe = observerCreate(\n        function (left) {\n          choiceL();\n          choice === leftChoice && observer.onNext(left);\n        },\n        function (e) {\n          choiceL();\n          choice === leftChoice && observer.onError(e);\n        },\n        function () {\n          choiceL();\n          choice === leftChoice && observer.onCompleted();\n        }\n      );\n      var rightSubscribe = observerCreate(\n        function (right) {\n          choiceR();\n          choice === rightChoice && observer.onNext(right);\n        },\n        function (e) {\n          choiceR();\n          choice === rightChoice && observer.onError(e);\n        },\n        function () {\n          choiceR();\n          choice === rightChoice && observer.onCompleted();\n        }\n      );\n\n      leftSubscription.setDisposable(leftSource.subscribe(leftSubscribe));\n      rightSubscription.setDisposable(rightSource.subscribe(rightSubscribe));\n\n      return new BinaryDisposable(leftSubscription, rightSubscription);\n    });\n  };\n\n  function amb(p, c) { return p.amb(c); }\n\n  /**\n   * Propagates the observable sequence or Promise that reacts first.\n   * @returns {Observable} An observable sequence that surfaces any of the given sequences, whichever reacted first.\n   */\n  Observable.amb = function () {\n    var acc = observableNever(), items;\n    if (Array.isArray(arguments[0])) {\n      items = arguments[0];\n    } else {\n      var len = arguments.length;\n      items = new Array(items);\n      for(var i = 0; i < len; i++) { items[i] = arguments[i]; }\n    }\n    for (var i = 0, len = items.length; i < len; i++) {\n      acc = amb(acc, items[i]);\n    }\n    return acc;\n  };\n\n  var CatchObservable = (function (__super__) {\n    inherits(CatchObservable, __super__);\n    function CatchObservable(source, fn) {\n      this.source = source;\n      this._fn = fn;\n      __super__.call(this);\n    }\n\n    CatchObservable.prototype.subscribeCore = function (o) {\n      var d1 = new SingleAssignmentDisposable(), subscription = new SerialDisposable();\n      subscription.setDisposable(d1);\n      d1.setDisposable(this.source.subscribe(new CatchObserver(o, subscription, this._fn)));\n      return subscription;\n    };\n\n    return CatchObservable;\n  }(ObservableBase));\n\n  var CatchObserver = (function(__super__) {\n    inherits(CatchObserver, __super__);\n    function CatchObserver(o, s, fn) {\n      this._o = o;\n      this._s = s;\n      this._fn = fn;\n      __super__.call(this);\n    }\n\n    CatchObserver.prototype.next = function (x) { this._o.onNext(x); };\n    CatchObserver.prototype.completed = function () { return this._o.onCompleted(); };\n    CatchObserver.prototype.error = function (e) {\n      var result = tryCatch(this._fn)(e);\n      if (result === errorObj) { return this._o.onError(result.e); }\n      isPromise(result) && (result = observableFromPromise(result));\n\n      var d = new SingleAssignmentDisposable();\n      this._s.setDisposable(d);\n      d.setDisposable(result.subscribe(this._o));\n    };\n\n    return CatchObserver;\n  }(AbstractObserver));\n\n  /**\n   * Continues an observable sequence that is terminated by an exception with the next observable sequence.\n   * @param {Mixed} handlerOrSecond Exception handler function that returns an observable sequence given the error that occurred in the first sequence, or a second observable sequence used to produce results when an error occurred in the first sequence.\n   * @returns {Observable} An observable sequence containing the first sequence's elements, followed by the elements of the handler sequence in case an exception occurred.\n   */\n  observableProto['catch'] = function (handlerOrSecond) {\n    return isFunction(handlerOrSecond) ? new CatchObservable(this, handlerOrSecond) : observableCatch([this, handlerOrSecond]);\n  };\n\n  /**\n   * Continues an observable sequence that is terminated by an exception with the next observable sequence.\n   * @param {Array | Arguments} args Arguments or an array to use as the next sequence if an error occurs.\n   * @returns {Observable} An observable sequence containing elements from consecutive source sequences until a source sequence terminates successfully.\n   */\n  var observableCatch = Observable['catch'] = function () {\n    var items;\n    if (Array.isArray(arguments[0])) {\n      items = arguments[0];\n    } else {\n      var len = arguments.length;\n      items = new Array(len);\n      for(var i = 0; i < len; i++) { items[i] = arguments[i]; }\n    }\n    return enumerableOf(items).catchError();\n  };\n\n  /**\n   * Merges the specified observable sequences into one observable sequence by using the selector function whenever any of the observable sequences or Promises produces an element.\n   * This can be in the form of an argument list of observables or an array.\n   *\n   * @example\n   * 1 - obs = observable.combineLatest(obs1, obs2, obs3, function (o1, o2, o3) { return o1 + o2 + o3; });\n   * 2 - obs = observable.combineLatest([obs1, obs2, obs3], function (o1, o2, o3) { return o1 + o2 + o3; });\n   * @returns {Observable} An observable sequence containing the result of combining elements of the sources using the specified result selector function.\n   */\n  observableProto.combineLatest = function () {\n    var len = arguments.length, args = new Array(len);\n    for(var i = 0; i < len; i++) { args[i] = arguments[i]; }\n    if (Array.isArray(args[0])) {\n      args[0].unshift(this);\n    } else {\n      args.unshift(this);\n    }\n    return combineLatest.apply(this, args);\n  };\n\n  function falseFactory() { return false; }\n  function argumentsToArray() {\n    var len = arguments.length, args = new Array(len);\n    for(var i = 0; i < len; i++) { args[i] = arguments[i]; }\n    return args;\n  }\n\n  var CombineLatestObservable = (function(__super__) {\n    inherits(CombineLatestObservable, __super__);\n    function CombineLatestObservable(params, cb) {\n      this._params = params;\n      this._cb = cb;\n      __super__.call(this);\n    }\n\n    CombineLatestObservable.prototype.subscribeCore = function(observer) {\n      var len = this._params.length,\n          subscriptions = new Array(len);\n\n      var state = {\n        hasValue: arrayInitialize(len, falseFactory),\n        hasValueAll: false,\n        isDone: arrayInitialize(len, falseFactory),\n        values: new Array(len)\n      };\n\n      for (var i = 0; i < len; i++) {\n        var source = this._params[i], sad = new SingleAssignmentDisposable();\n        subscriptions[i] = sad;\n        isPromise(source) && (source = observableFromPromise(source));\n        sad.setDisposable(source.subscribe(new CombineLatestObserver(observer, i, this._cb, state)));\n      }\n\n      return new NAryDisposable(subscriptions);\n    };\n\n    return CombineLatestObservable;\n  }(ObservableBase));\n\n  var CombineLatestObserver = (function (__super__) {\n    inherits(CombineLatestObserver, __super__);\n    function CombineLatestObserver(o, i, cb, state) {\n      this._o = o;\n      this._i = i;\n      this._cb = cb;\n      this._state = state;\n      __super__.call(this);\n    }\n\n    function notTheSame(i) {\n      return function (x, j) {\n        return j !== i;\n      };\n    }\n\n    CombineLatestObserver.prototype.next = function (x) {\n      this._state.values[this._i] = x;\n      this._state.hasValue[this._i] = true;\n      if (this._state.hasValueAll || (this._state.hasValueAll = this._state.hasValue.every(identity))) {\n        var res = tryCatch(this._cb).apply(null, this._state.values);\n        if (res === errorObj) { return this._o.onError(res.e); }\n        this._o.onNext(res);\n      } else if (this._state.isDone.filter(notTheSame(this._i)).every(identity)) {\n        this._o.onCompleted();\n      }\n    };\n\n    CombineLatestObserver.prototype.error = function (e) {\n      this._o.onError(e);\n    };\n\n    CombineLatestObserver.prototype.completed = function () {\n      this._state.isDone[this._i] = true;\n      this._state.isDone.every(identity) && this._o.onCompleted();\n    };\n\n    return CombineLatestObserver;\n  }(AbstractObserver));\n\n  /**\n  * Merges the specified observable sequences into one observable sequence by using the selector function whenever any of the observable sequences or Promises produces an element.\n  *\n  * @example\n  * 1 - obs = Rx.Observable.combineLatest(obs1, obs2, obs3, function (o1, o2, o3) { return o1 + o2 + o3; });\n  * 2 - obs = Rx.Observable.combineLatest([obs1, obs2, obs3], function (o1, o2, o3) { return o1 + o2 + o3; });\n  * @returns {Observable} An observable sequence containing the result of combining elements of the sources using the specified result selector function.\n  */\n  var combineLatest = Observable.combineLatest = function () {\n    var len = arguments.length, args = new Array(len);\n    for(var i = 0; i < len; i++) { args[i] = arguments[i]; }\n    var resultSelector = isFunction(args[len - 1]) ? args.pop() : argumentsToArray;\n    Array.isArray(args[0]) && (args = args[0]);\n    return new CombineLatestObservable(args, resultSelector);\n  };\n\n  /**\n   * Concatenates all the observable sequences.  This takes in either an array or variable arguments to concatenate.\n   * @returns {Observable} An observable sequence that contains the elements of each given sequence, in sequential order.\n   */\n  observableProto.concat = function () {\n    for(var args = [], i = 0, len = arguments.length; i < len; i++) { args.push(arguments[i]); }\n    args.unshift(this);\n    return observableConcat.apply(null, args);\n  };\n\n  var ConcatObserver = (function(__super__) {\n    inherits(ConcatObserver, __super__);\n    function ConcatObserver(s, fn) {\n      this._s = s;\n      this._fn = fn;\n      __super__.call(this);\n    }\n\n    ConcatObserver.prototype.next = function (x) { this._s.o.onNext(x); };\n    ConcatObserver.prototype.error = function (e) { this._s.o.onError(e); };\n    ConcatObserver.prototype.completed = function () { this._s.i++; this._fn(this._s); };\n\n    return ConcatObserver;\n  }(AbstractObserver));\n\n  var ConcatObservable = (function(__super__) {\n    inherits(ConcatObservable, __super__);\n    function ConcatObservable(sources) {\n      this._sources = sources;\n      __super__.call(this);\n    }\n\n    function scheduleRecursive (state, recurse) {\n      if (state.disposable.isDisposed) { return; }\n      if (state.i === state.sources.length) { return state.o.onCompleted(); }\n\n      // Check if promise\n      var currentValue = state.sources[state.i];\n      isPromise(currentValue) && (currentValue = observableFromPromise(currentValue));\n\n      var d = new SingleAssignmentDisposable();\n      state.subscription.setDisposable(d);\n      d.setDisposable(currentValue.subscribe(new ConcatObserver(state, recurse)));\n    }\n\n    ConcatObservable.prototype.subscribeCore = function(o) {\n      var subscription = new SerialDisposable();\n      var disposable = disposableCreate(noop);\n      var state = {\n        o: o,\n        i: 0,\n        subscription: subscription,\n        disposable: disposable,\n        sources: this._sources\n      };\n\n      var cancelable = immediateScheduler.scheduleRecursive(state, scheduleRecursive);\n      return new NAryDisposable([subscription, disposable, cancelable]);\n    };\n\n    return ConcatObservable;\n  }(ObservableBase));\n\n  /**\n   * Concatenates all the observable sequences.\n   * @param {Array | Arguments} args Arguments or an array to concat to the observable sequence.\n   * @returns {Observable} An observable sequence that contains the elements of each given sequence, in sequential order.\n   */\n  var observableConcat = Observable.concat = function () {\n    var args;\n    if (Array.isArray(arguments[0])) {\n      args = arguments[0];\n    } else {\n      args = new Array(arguments.length);\n      for(var i = 0, len = arguments.length; i < len; i++) { args[i] = arguments[i]; }\n    }\n    return new ConcatObservable(args);\n  };\n\n  /**\n   * Concatenates an observable sequence of observable sequences.\n   * @returns {Observable} An observable sequence that contains the elements of each observed inner sequence, in sequential order.\n   */\n  observableProto.concatAll = function () {\n    return this.merge(1);\n  };\n\n  var MergeObservable = (function (__super__) {\n    inherits(MergeObservable, __super__);\n\n    function MergeObservable(source, maxConcurrent) {\n      this.source = source;\n      this.maxConcurrent = maxConcurrent;\n      __super__.call(this);\n    }\n\n    MergeObservable.prototype.subscribeCore = function(observer) {\n      var g = new CompositeDisposable();\n      g.add(this.source.subscribe(new MergeObserver(observer, this.maxConcurrent, g)));\n      return g;\n    };\n\n    return MergeObservable;\n\n  }(ObservableBase));\n\n  var MergeObserver = (function (__super__) {\n    function MergeObserver(o, max, g) {\n      this.o = o;\n      this.max = max;\n      this.g = g;\n      this.done = false;\n      this.q = [];\n      this.activeCount = 0;\n      __super__.call(this);\n    }\n\n    inherits(MergeObserver, __super__);\n\n    MergeObserver.prototype.handleSubscribe = function (xs) {\n      var sad = new SingleAssignmentDisposable();\n      this.g.add(sad);\n      isPromise(xs) && (xs = observableFromPromise(xs));\n      sad.setDisposable(xs.subscribe(new InnerObserver(this, sad)));\n    };\n\n    MergeObserver.prototype.next = function (innerSource) {\n      if(this.activeCount < this.max) {\n        this.activeCount++;\n        this.handleSubscribe(innerSource);\n      } else {\n        this.q.push(innerSource);\n      }\n    };\n    MergeObserver.prototype.error = function (e) { this.o.onError(e); };\n    MergeObserver.prototype.completed = function () { this.done = true; this.activeCount === 0 && this.o.onCompleted(); };\n\n    function InnerObserver(parent, sad) {\n      this.parent = parent;\n      this.sad = sad;\n      __super__.call(this);\n    }\n\n    inherits(InnerObserver, __super__);\n\n    InnerObserver.prototype.next = function (x) { this.parent.o.onNext(x); };\n    InnerObserver.prototype.error = function (e) { this.parent.o.onError(e); };\n    InnerObserver.prototype.completed = function () {\n      this.parent.g.remove(this.sad);\n      if (this.parent.q.length > 0) {\n        this.parent.handleSubscribe(this.parent.q.shift());\n      } else {\n        this.parent.activeCount--;\n        this.parent.done && this.parent.activeCount === 0 && this.parent.o.onCompleted();\n      }\n    };\n\n    return MergeObserver;\n  }(AbstractObserver));\n\n  /**\n  * Merges an observable sequence of observable sequences into an observable sequence, limiting the number of concurrent subscriptions to inner sequences.\n  * Or merges two observable sequences into a single observable sequence.\n  * @param {Mixed} [maxConcurrentOrOther] Maximum number of inner observable sequences being subscribed to concurrently or the second observable sequence.\n  * @returns {Observable} The observable sequence that merges the elements of the inner sequences.\n  */\n  observableProto.merge = function (maxConcurrentOrOther) {\n    return typeof maxConcurrentOrOther !== 'number' ?\n      observableMerge(this, maxConcurrentOrOther) :\n      new MergeObservable(this, maxConcurrentOrOther);\n  };\n\n  /**\n   * Merges all the observable sequences into a single observable sequence.\n   * The scheduler is optional and if not specified, the immediate scheduler is used.\n   * @returns {Observable} The observable sequence that merges the elements of the observable sequences.\n   */\n  var observableMerge = Observable.merge = function () {\n    var scheduler, sources = [], i, len = arguments.length;\n    if (!arguments[0]) {\n      scheduler = immediateScheduler;\n      for(i = 1; i < len; i++) { sources.push(arguments[i]); }\n    } else if (isScheduler(arguments[0])) {\n      scheduler = arguments[0];\n      for(i = 1; i < len; i++) { sources.push(arguments[i]); }\n    } else {\n      scheduler = immediateScheduler;\n      for(i = 0; i < len; i++) { sources.push(arguments[i]); }\n    }\n    if (Array.isArray(sources[0])) {\n      sources = sources[0];\n    }\n    return observableOf(scheduler, sources).mergeAll();\n  };\n\n  var MergeAllObservable = (function (__super__) {\n    inherits(MergeAllObservable, __super__);\n\n    function MergeAllObservable(source) {\n      this.source = source;\n      __super__.call(this);\n    }\n\n    MergeAllObservable.prototype.subscribeCore = function (o) {\n      var g = new CompositeDisposable(), m = new SingleAssignmentDisposable();\n      g.add(m);\n      m.setDisposable(this.source.subscribe(new MergeAllObserver(o, g)));\n      return g;\n    };\n\n    return MergeAllObservable;\n  }(ObservableBase));\n\n  var MergeAllObserver = (function (__super__) {\n    function MergeAllObserver(o, g) {\n      this.o = o;\n      this.g = g;\n      this.done = false;\n      __super__.call(this);\n    }\n\n    inherits(MergeAllObserver, __super__);\n\n    MergeAllObserver.prototype.next = function(innerSource) {\n      var sad = new SingleAssignmentDisposable();\n      this.g.add(sad);\n      isPromise(innerSource) && (innerSource = observableFromPromise(innerSource));\n      sad.setDisposable(innerSource.subscribe(new InnerObserver(this, sad)));\n    };\n\n    MergeAllObserver.prototype.error = function (e) {\n      this.o.onError(e);\n    };\n\n    MergeAllObserver.prototype.completed = function () {\n      this.done = true;\n      this.g.length === 1 && this.o.onCompleted();\n    };\n\n    function InnerObserver(parent, sad) {\n      this.parent = parent;\n      this.sad = sad;\n      __super__.call(this);\n    }\n\n    inherits(InnerObserver, __super__);\n\n    InnerObserver.prototype.next = function (x) {\n      this.parent.o.onNext(x);\n    };\n    InnerObserver.prototype.error = function (e) {\n      this.parent.o.onError(e);\n    };\n    InnerObserver.prototype.completed = function () {\n      this.parent.g.remove(this.sad);\n      this.parent.done && this.parent.g.length === 1 && this.parent.o.onCompleted();\n    };\n\n    return MergeAllObserver;\n  }(AbstractObserver));\n\n  /**\n  * Merges an observable sequence of observable sequences into an observable sequence.\n  * @returns {Observable} The observable sequence that merges the elements of the inner sequences.\n  */\n  observableProto.mergeAll = function () {\n    return new MergeAllObservable(this);\n  };\n\n  var CompositeError = Rx.CompositeError = function(errors) {\n    this.innerErrors = errors;\n    this.message = 'This contains multiple errors. Check the innerErrors';\n    Error.call(this);\n  };\n  CompositeError.prototype = Object.create(Error.prototype);\n  CompositeError.prototype.name = 'CompositeError';\n\n  var MergeDelayErrorObservable = (function(__super__) {\n    inherits(MergeDelayErrorObservable, __super__);\n    function MergeDelayErrorObservable(source) {\n      this.source = source;\n      __super__.call(this);\n    }\n\n    MergeDelayErrorObservable.prototype.subscribeCore = function (o) {\n      var group = new CompositeDisposable(),\n        m = new SingleAssignmentDisposable(),\n        state = { isStopped: false, errors: [], o: o };\n\n      group.add(m);\n      m.setDisposable(this.source.subscribe(new MergeDelayErrorObserver(group, state)));\n\n      return group;\n    };\n\n    return MergeDelayErrorObservable;\n  }(ObservableBase));\n\n  var MergeDelayErrorObserver = (function(__super__) {\n    inherits(MergeDelayErrorObserver, __super__);\n    function MergeDelayErrorObserver(group, state) {\n      this._group = group;\n      this._state = state;\n      __super__.call(this);\n    }\n\n    function setCompletion(o, errors) {\n      if (errors.length === 0) {\n        o.onCompleted();\n      } else if (errors.length === 1) {\n        o.onError(errors[0]);\n      } else {\n        o.onError(new CompositeError(errors));\n      }\n    }\n\n    MergeDelayErrorObserver.prototype.next = function (x) {\n      var inner = new SingleAssignmentDisposable();\n      this._group.add(inner);\n\n      // Check for promises support\n      isPromise(x) && (x = observableFromPromise(x));\n      inner.setDisposable(x.subscribe(new InnerObserver(inner, this._group, this._state)));\n    };\n\n    MergeDelayErrorObserver.prototype.error = function (e) {\n      this._state.errors.push(e);\n      this._state.isStopped = true;\n      this._group.length === 1 && setCompletion(this._state.o, this._state.errors);\n    };\n\n    MergeDelayErrorObserver.prototype.completed = function () {\n      this._state.isStopped = true;\n      this._group.length === 1 && setCompletion(this._state.o, this._state.errors);\n    };\n\n    inherits(InnerObserver, __super__);\n    function InnerObserver(inner, group, state) {\n      this._inner = inner;\n      this._group = group;\n      this._state = state;\n      __super__.call(this);\n    }\n\n    InnerObserver.prototype.next = function (x) { this._state.o.onNext(x); };\n    InnerObserver.prototype.error = function (e) {\n      this._state.errors.push(e);\n      this._group.remove(this._inner);\n      this._state.isStopped && this._group.length === 1 && setCompletion(this._state.o, this._state.errors);\n    };\n    InnerObserver.prototype.completed = function () {\n      this._group.remove(this._inner);\n      this._state.isStopped && this._group.length === 1 && setCompletion(this._state.o, this._state.errors);\n    };\n\n    return MergeDelayErrorObserver;\n  }(AbstractObserver));\n\n  /**\n  * Flattens an Observable that emits Observables into one Observable, in a way that allows an Observer to\n  * receive all successfully emitted items from all of the source Observables without being interrupted by\n  * an error notification from one of them.\n  *\n  * This behaves like Observable.prototype.mergeAll except that if any of the merged Observables notify of an\n  * error via the Observer's onError, mergeDelayError will refrain from propagating that\n  * error notification until all of the merged Observables have finished emitting items.\n  * @param {Array | Arguments} args Arguments or an array to merge.\n  * @returns {Observable} an Observable that emits all of the items emitted by the Observables emitted by the Observable\n  */\n  Observable.mergeDelayError = function() {\n    var args;\n    if (Array.isArray(arguments[0])) {\n      args = arguments[0];\n    } else {\n      var len = arguments.length;\n      args = new Array(len);\n      for(var i = 0; i < len; i++) { args[i] = arguments[i]; }\n    }\n    var source = observableOf(null, args);\n    return new MergeDelayErrorObservable(source);\n  };\n\n  /**\n   * Continues an observable sequence that is terminated normally or by an exception with the next observable sequence.\n   * @param {Observable} second Second observable sequence used to produce results after the first sequence terminates.\n   * @returns {Observable} An observable sequence that concatenates the first and second sequence, even if the first sequence terminates exceptionally.\n   */\n  observableProto.onErrorResumeNext = function (second) {\n    if (!second) { throw new Error('Second observable is required'); }\n    return onErrorResumeNext([this, second]);\n  };\n\n  var OnErrorResumeNextObservable = (function(__super__) {\n    inherits(OnErrorResumeNextObservable, __super__);\n    function OnErrorResumeNextObservable(sources) {\n      this.sources = sources;\n      __super__.call(this);\n    }\n\n    function scheduleMethod(state, recurse) {\n      if (state.pos < state.sources.length) {\n        var current = state.sources[state.pos++];\n        isPromise(current) && (current = observableFromPromise(current));\n        var d = new SingleAssignmentDisposable();\n        state.subscription.setDisposable(d);\n        d.setDisposable(current.subscribe(new OnErrorResumeNextObserver(state, recurse)));\n      } else {\n        state.o.onCompleted();\n      }\n    }\n\n    OnErrorResumeNextObservable.prototype.subscribeCore = function (o) {\n      var subscription = new SerialDisposable(),\n          state = {pos: 0, subscription: subscription, o: o, sources: this.sources },\n          cancellable = immediateScheduler.scheduleRecursive(state, scheduleMethod);\n\n      return new BinaryDisposable(subscription, cancellable);\n    };\n\n    return OnErrorResumeNextObservable;\n  }(ObservableBase));\n\n  var OnErrorResumeNextObserver = (function(__super__) {\n    inherits(OnErrorResumeNextObserver, __super__);\n    function OnErrorResumeNextObserver(state, recurse) {\n      this._state = state;\n      this._recurse = recurse;\n      __super__.call(this);\n    }\n\n    OnErrorResumeNextObserver.prototype.next = function (x) { this._state.o.onNext(x); };\n    OnErrorResumeNextObserver.prototype.error = function () { this._recurse(this._state); };\n    OnErrorResumeNextObserver.prototype.completed = function () { this._recurse(this._state); };\n\n    return OnErrorResumeNextObserver;\n  }(AbstractObserver));\n\n  /**\n   * Continues an observable sequence that is terminated normally or by an exception with the next observable sequence.\n   * @returns {Observable} An observable sequence that concatenates the source sequences, even if a sequence terminates exceptionally.\n   */\n  var onErrorResumeNext = Observable.onErrorResumeNext = function () {\n    var sources = [];\n    if (Array.isArray(arguments[0])) {\n      sources = arguments[0];\n    } else {\n      var len = arguments.length;\n      sources = new Array(len);\n      for(var i = 0; i < len; i++) { sources[i] = arguments[i]; }\n    }\n    return new OnErrorResumeNextObservable(sources);\n  };\n\n  var SkipUntilObservable = (function(__super__) {\n    inherits(SkipUntilObservable, __super__);\n\n    function SkipUntilObservable(source, other) {\n      this._s = source;\n      this._o = isPromise(other) ? observableFromPromise(other) : other;\n      this._open = false;\n      __super__.call(this);\n    }\n\n    SkipUntilObservable.prototype.subscribeCore = function(o) {\n      var leftSubscription = new SingleAssignmentDisposable();\n      leftSubscription.setDisposable(this._s.subscribe(new SkipUntilSourceObserver(o, this)));\n\n      isPromise(this._o) && (this._o = observableFromPromise(this._o));\n\n      var rightSubscription = new SingleAssignmentDisposable();\n      rightSubscription.setDisposable(this._o.subscribe(new SkipUntilOtherObserver(o, this, rightSubscription)));\n\n      return new BinaryDisposable(leftSubscription, rightSubscription);\n    };\n\n    return SkipUntilObservable;\n  }(ObservableBase));\n\n  var SkipUntilSourceObserver = (function(__super__) {\n    inherits(SkipUntilSourceObserver, __super__);\n    function SkipUntilSourceObserver(o, p) {\n      this._o = o;\n      this._p = p;\n      __super__.call(this);\n    }\n\n    SkipUntilSourceObserver.prototype.next = function (x) {\n      this._p._open && this._o.onNext(x);\n    };\n\n    SkipUntilSourceObserver.prototype.error = function (err) {\n      this._o.onError(err);\n    };\n\n    SkipUntilSourceObserver.prototype.onCompleted = function () {\n      this._p._open && this._o.onCompleted();\n    };\n\n    return SkipUntilSourceObserver;\n  }(AbstractObserver));\n\n  var SkipUntilOtherObserver = (function(__super__) {\n    inherits(SkipUntilOtherObserver, __super__);\n    function SkipUntilOtherObserver(o, p, r) {\n      this._o = o;\n      this._p = p;\n      this._r = r;\n      __super__.call(this);\n    }\n\n    SkipUntilOtherObserver.prototype.next = function () {\n      this._p._open = true;\n      this._r.dispose();\n    };\n\n    SkipUntilOtherObserver.prototype.error = function (err) {\n      this._o.onError(err);\n    };\n\n    SkipUntilOtherObserver.prototype.onCompleted = function () {\n      this._r.dispose();\n    };\n\n    return SkipUntilOtherObserver;\n  }(AbstractObserver));\n\n  /**\n   * Returns the values from the source observable sequence only after the other observable sequence produces a value.\n   * @param {Observable | Promise} other The observable sequence or Promise that triggers propagation of elements of the source sequence.\n   * @returns {Observable} An observable sequence containing the elements of the source sequence starting from the point the other sequence triggered propagation.\n   */\n  observableProto.skipUntil = function (other) {\n    return new SkipUntilObservable(this, other);\n  };\n\n  var SwitchObservable = (function(__super__) {\n    inherits(SwitchObservable, __super__);\n    function SwitchObservable(source) {\n      this.source = source;\n      __super__.call(this);\n    }\n\n    SwitchObservable.prototype.subscribeCore = function (o) {\n      var inner = new SerialDisposable(), s = this.source.subscribe(new SwitchObserver(o, inner));\n      return new BinaryDisposable(s, inner);\n    };\n\n    inherits(SwitchObserver, AbstractObserver);\n    function SwitchObserver(o, inner) {\n      this.o = o;\n      this.inner = inner;\n      this.stopped = false;\n      this.latest = 0;\n      this.hasLatest = false;\n      AbstractObserver.call(this);\n    }\n\n    SwitchObserver.prototype.next = function (innerSource) {\n      var d = new SingleAssignmentDisposable(), id = ++this.latest;\n      this.hasLatest = true;\n      this.inner.setDisposable(d);\n      isPromise(innerSource) && (innerSource = observableFromPromise(innerSource));\n      d.setDisposable(innerSource.subscribe(new InnerObserver(this, id)));\n    };\n\n    SwitchObserver.prototype.error = function (e) {\n      this.o.onError(e);\n    };\n\n    SwitchObserver.prototype.completed = function () {\n      this.stopped = true;\n      !this.hasLatest && this.o.onCompleted();\n    };\n\n    inherits(InnerObserver, AbstractObserver);\n    function InnerObserver(parent, id) {\n      this.parent = parent;\n      this.id = id;\n      AbstractObserver.call(this);\n    }\n    InnerObserver.prototype.next = function (x) {\n      this.parent.latest === this.id && this.parent.o.onNext(x);\n    };\n\n    InnerObserver.prototype.error = function (e) {\n      this.parent.latest === this.id && this.parent.o.onError(e);\n    };\n\n    InnerObserver.prototype.completed = function () {\n      if (this.parent.latest === this.id) {\n        this.parent.hasLatest = false;\n        this.parent.stopped && this.parent.o.onCompleted();\n      }\n    };\n\n    return SwitchObservable;\n  }(ObservableBase));\n\n  /**\n  * Transforms an observable sequence of observable sequences into an observable sequence producing values only from the most recent observable sequence.\n  * @returns {Observable} The observable sequence that at any point in time produces the elements of the most recent inner observable sequence that has been received.\n  */\n  observableProto['switch'] = observableProto.switchLatest = function () {\n    return new SwitchObservable(this);\n  };\n\n  var TakeUntilObservable = (function(__super__) {\n    inherits(TakeUntilObservable, __super__);\n\n    function TakeUntilObservable(source, other) {\n      this.source = source;\n      this.other = isPromise(other) ? observableFromPromise(other) : other;\n      __super__.call(this);\n    }\n\n    TakeUntilObservable.prototype.subscribeCore = function(o) {\n      return new BinaryDisposable(\n        this.source.subscribe(o),\n        this.other.subscribe(new TakeUntilObserver(o))\n      );\n    };\n\n    return TakeUntilObservable;\n  }(ObservableBase));\n\n  var TakeUntilObserver = (function(__super__) {\n    inherits(TakeUntilObserver, __super__);\n    function TakeUntilObserver(o) {\n      this._o = o;\n      __super__.call(this);\n    }\n\n    TakeUntilObserver.prototype.next = function () {\n      this._o.onCompleted();\n    };\n\n    TakeUntilObserver.prototype.error = function (err) {\n      this._o.onError(err);\n    };\n\n    TakeUntilObserver.prototype.onCompleted = noop;\n\n    return TakeUntilObserver;\n  }(AbstractObserver));\n\n  /**\n   * Returns the values from the source observable sequence until the other observable sequence produces a value.\n   * @param {Observable | Promise} other Observable sequence or Promise that terminates propagation of elements of the source sequence.\n   * @returns {Observable} An observable sequence containing the elements of the source sequence up to the point the other sequence interrupted further propagation.\n   */\n  observableProto.takeUntil = function (other) {\n    return new TakeUntilObservable(this, other);\n  };\n\n  function falseFactory() { return false; }\n  function argumentsToArray() {\n    var len = arguments.length, args = new Array(len);\n    for(var i = 0; i < len; i++) { args[i] = arguments[i]; }\n    return args;\n  }\n\n  var WithLatestFromObservable = (function(__super__) {\n    inherits(WithLatestFromObservable, __super__);\n    function WithLatestFromObservable(source, sources, resultSelector) {\n      this._s = source;\n      this._ss = sources;\n      this._cb = resultSelector;\n      __super__.call(this);\n    }\n\n    WithLatestFromObservable.prototype.subscribeCore = function (o) {\n      var len = this._ss.length;\n      var state = {\n        hasValue: arrayInitialize(len, falseFactory),\n        hasValueAll: false,\n        values: new Array(len)\n      };\n\n      var n = this._ss.length, subscriptions = new Array(n + 1);\n      for (var i = 0; i < n; i++) {\n        var other = this._ss[i], sad = new SingleAssignmentDisposable();\n        isPromise(other) && (other = observableFromPromise(other));\n        sad.setDisposable(other.subscribe(new WithLatestFromOtherObserver(o, i, state)));\n        subscriptions[i] = sad;\n      }\n\n      var outerSad = new SingleAssignmentDisposable();\n      outerSad.setDisposable(this._s.subscribe(new WithLatestFromSourceObserver(o, this._cb, state)));\n      subscriptions[n] = outerSad;\n\n      return new NAryDisposable(subscriptions);\n    };\n\n    return WithLatestFromObservable;\n  }(ObservableBase));\n\n  var WithLatestFromOtherObserver = (function (__super__) {\n    inherits(WithLatestFromOtherObserver, __super__);\n    function WithLatestFromOtherObserver(o, i, state) {\n      this._o = o;\n      this._i = i;\n      this._state = state;\n      __super__.call(this);\n    }\n\n    WithLatestFromOtherObserver.prototype.next = function (x) {\n      this._state.values[this._i] = x;\n      this._state.hasValue[this._i] = true;\n      this._state.hasValueAll = this._state.hasValue.every(identity);\n    };\n\n    WithLatestFromOtherObserver.prototype.error = function (e) {\n      this._o.onError(e);\n    };\n\n    WithLatestFromOtherObserver.prototype.completed = noop;\n\n    return WithLatestFromOtherObserver;\n  }(AbstractObserver));\n\n  var WithLatestFromSourceObserver = (function (__super__) {\n    inherits(WithLatestFromSourceObserver, __super__);\n    function WithLatestFromSourceObserver(o, cb, state) {\n      this._o = o;\n      this._cb = cb;\n      this._state = state;\n      __super__.call(this);\n    }\n\n    WithLatestFromSourceObserver.prototype.next = function (x) {\n      var allValues = [x].concat(this._state.values);\n      if (!this._state.hasValueAll) { return; }\n      var res = tryCatch(this._cb).apply(null, allValues);\n      if (res === errorObj) { return this._o.onError(res.e); }\n      this._o.onNext(res);\n    };\n\n    WithLatestFromSourceObserver.prototype.error = function (e) {\n      this._o.onError(e);\n    };\n\n    WithLatestFromSourceObserver.prototype.completed = function () {\n      this._o.onCompleted();\n    };\n\n    return WithLatestFromSourceObserver;\n  }(AbstractObserver));\n\n  /**\n   * Merges the specified observable sequences into one observable sequence by using the selector function only when the (first) source observable sequence produces an element.\n   * @returns {Observable} An observable sequence containing the result of combining elements of the sources using the specified result selector function.\n   */\n  observableProto.withLatestFrom = function () {\n    if (arguments.length === 0) { throw new Error('invalid arguments'); }\n\n    var len = arguments.length, args = new Array(len);\n    for(var i = 0; i < len; i++) { args[i] = arguments[i]; }\n    var resultSelector = isFunction(args[len - 1]) ? args.pop() : argumentsToArray;\n    Array.isArray(args[0]) && (args = args[0]);\n\n    return new WithLatestFromObservable(this, args, resultSelector);\n  };\n\n  function falseFactory() { return false; }\n  function emptyArrayFactory() { return []; }\n\n  var ZipObservable = (function(__super__) {\n    inherits(ZipObservable, __super__);\n    function ZipObservable(sources, resultSelector) {\n      this._s = sources;\n      this._cb = resultSelector;\n      __super__.call(this);\n    }\n\n    ZipObservable.prototype.subscribeCore = function(observer) {\n      var n = this._s.length,\n          subscriptions = new Array(n),\n          done = arrayInitialize(n, falseFactory),\n          q = arrayInitialize(n, emptyArrayFactory);\n\n      for (var i = 0; i < n; i++) {\n        var source = this._s[i], sad = new SingleAssignmentDisposable();\n        subscriptions[i] = sad;\n        isPromise(source) && (source = observableFromPromise(source));\n        sad.setDisposable(source.subscribe(new ZipObserver(observer, i, this, q, done)));\n      }\n\n      return new NAryDisposable(subscriptions);\n    };\n\n    return ZipObservable;\n  }(ObservableBase));\n\n  var ZipObserver = (function (__super__) {\n    inherits(ZipObserver, __super__);\n    function ZipObserver(o, i, p, q, d) {\n      this._o = o;\n      this._i = i;\n      this._p = p;\n      this._q = q;\n      this._d = d;\n      __super__.call(this);\n    }\n\n    function notEmpty(x) { return x.length > 0; }\n    function shiftEach(x) { return x.shift(); }\n    function notTheSame(i) {\n      return function (x, j) {\n        return j !== i;\n      };\n    }\n\n    ZipObserver.prototype.next = function (x) {\n      this._q[this._i].push(x);\n      if (this._q.every(notEmpty)) {\n        var queuedValues = this._q.map(shiftEach);\n        var res = tryCatch(this._p._cb).apply(null, queuedValues);\n        if (res === errorObj) { return this._o.onError(res.e); }\n        this._o.onNext(res);\n      } else if (this._d.filter(notTheSame(this._i)).every(identity)) {\n        this._o.onCompleted();\n      }\n    };\n\n    ZipObserver.prototype.error = function (e) {\n      this._o.onError(e);\n    };\n\n    ZipObserver.prototype.completed = function () {\n      this._d[this._i] = true;\n      this._d.every(identity) && this._o.onCompleted();\n    };\n\n    return ZipObserver;\n  }(AbstractObserver));\n\n  /**\n   * Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences or an array have produced an element at a corresponding index.\n   * The last element in the arguments must be a function to invoke for each series of elements at corresponding indexes in the args.\n   * @returns {Observable} An observable sequence containing the result of combining elements of the args using the specified result selector function.\n   */\n  observableProto.zip = function () {\n    if (arguments.length === 0) { throw new Error('invalid arguments'); }\n\n    var len = arguments.length, args = new Array(len);\n    for(var i = 0; i < len; i++) { args[i] = arguments[i]; }\n    var resultSelector = isFunction(args[len - 1]) ? args.pop() : argumentsToArray;\n    Array.isArray(args[0]) && (args = args[0]);\n\n    var parent = this;\n    args.unshift(parent);\n\n    return new ZipObservable(args, resultSelector);\n  };\n\n  /**\n   * Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences have produced an element at a corresponding index.\n   * @param arguments Observable sources.\n   * @param {Function} resultSelector Function to invoke for each series of elements at corresponding indexes in the sources.\n   * @returns {Observable} An observable sequence containing the result of combining elements of the sources using the specified result selector function.\n   */\n  Observable.zip = function () {\n    var len = arguments.length, args = new Array(len);\n    for(var i = 0; i < len; i++) { args[i] = arguments[i]; }\n    if (Array.isArray(args[0])) {\n      args = isFunction(args[1]) ? args[0].concat(args[1]) : args[0];\n    }\n    var first = args.shift();\n    return first.zip.apply(first, args);\n  };\n\nfunction falseFactory() { return false; }\nfunction emptyArrayFactory() { return []; }\nfunction argumentsToArray() {\n  var len = arguments.length, args = new Array(len);\n  for(var i = 0; i < len; i++) { args[i] = arguments[i]; }\n  return args;\n}\n\nvar ZipIterableObservable = (function(__super__) {\n  inherits(ZipIterableObservable, __super__);\n  function ZipIterableObservable(sources, cb) {\n    this.sources = sources;\n    this._cb = cb;\n    __super__.call(this);\n  }\n\n  ZipIterableObservable.prototype.subscribeCore = function (o) {\n    var sources = this.sources, len = sources.length, subscriptions = new Array(len);\n\n    var state = {\n      q: arrayInitialize(len, emptyArrayFactory),\n      done: arrayInitialize(len, falseFactory),\n      cb: this._cb,\n      o: o\n    };\n\n    for (var i = 0; i < len; i++) {\n      (function (i) {\n        var source = sources[i], sad = new SingleAssignmentDisposable();\n        (isArrayLike(source) || isIterable(source)) && (source = observableFrom(source));\n\n        subscriptions[i] = sad;\n        sad.setDisposable(source.subscribe(new ZipIterableObserver(state, i)));\n      }(i));\n    }\n\n    return new NAryDisposable(subscriptions);\n  };\n\n  return ZipIterableObservable;\n}(ObservableBase));\n\nvar ZipIterableObserver = (function (__super__) {\n  inherits(ZipIterableObserver, __super__);\n  function ZipIterableObserver(s, i) {\n    this._s = s;\n    this._i = i;\n    __super__.call(this);\n  }\n\n  function notEmpty(x) { return x.length > 0; }\n  function shiftEach(x) { return x.shift(); }\n  function notTheSame(i) {\n    return function (x, j) {\n      return j !== i;\n    };\n  }\n\n  ZipIterableObserver.prototype.next = function (x) {\n    this._s.q[this._i].push(x);\n    if (this._s.q.every(notEmpty)) {\n      var queuedValues = this._s.q.map(shiftEach),\n          res = tryCatch(this._s.cb).apply(null, queuedValues);\n      if (res === errorObj) { return this._s.o.onError(res.e); }\n      this._s.o.onNext(res);\n    } else if (this._s.done.filter(notTheSame(this._i)).every(identity)) {\n      this._s.o.onCompleted();\n    }\n  };\n\n  ZipIterableObserver.prototype.error = function (e) { this._s.o.onError(e); };\n\n  ZipIterableObserver.prototype.completed = function () {\n    this._s.done[this._i] = true;\n    this._s.done.every(identity) && this._s.o.onCompleted();\n  };\n\n  return ZipIterableObserver;\n}(AbstractObserver));\n\n/**\n * Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences or an array have produced an element at a corresponding index.\n * The last element in the arguments must be a function to invoke for each series of elements at corresponding indexes in the args.\n * @returns {Observable} An observable sequence containing the result of combining elements of the args using the specified result selector function.\n */\nobservableProto.zipIterable = function () {\n  if (arguments.length === 0) { throw new Error('invalid arguments'); }\n\n  var len = arguments.length, args = new Array(len);\n  for(var i = 0; i < len; i++) { args[i] = arguments[i]; }\n  var resultSelector = isFunction(args[len - 1]) ? args.pop() : argumentsToArray;\n\n  var parent = this;\n  args.unshift(parent);\n  return new ZipIterableObservable(args, resultSelector);\n};\n\n  function asObservable(source) {\n    return function subscribe(o) { return source.subscribe(o); };\n  }\n\n  /**\n   *  Hides the identity of an observable sequence.\n   * @returns {Observable} An observable sequence that hides the identity of the source sequence.\n   */\n  observableProto.asObservable = function () {\n    return new AnonymousObservable(asObservable(this), this);\n  };\n\n  function toArray(x) { return x.toArray(); }\n  function notEmpty(x) { return x.length > 0; }\n\n  /**\n   *  Projects each element of an observable sequence into zero or more buffers which are produced based on element count information.\n   * @param {Number} count Length of each buffer.\n   * @param {Number} [skip] Number of elements to skip between creation of consecutive buffers. If not provided, defaults to the count.\n   * @returns {Observable} An observable sequence of buffers.\n   */\n  observableProto.bufferWithCount = function (count, skip) {\n    typeof skip !== 'number' && (skip = count);\n    return this.windowWithCount(count, skip)\n      .flatMap(toArray)\n      .filter(notEmpty);\n  };\n\n  var DematerializeObservable = (function (__super__) {\n    inherits(DematerializeObservable, __super__);\n    function DematerializeObservable(source) {\n      this.source = source;\n      __super__.call(this);\n    }\n\n    DematerializeObservable.prototype.subscribeCore = function (o) {\n      return this.source.subscribe(new DematerializeObserver(o));\n    };\n\n    return DematerializeObservable;\n  }(ObservableBase));\n\n  var DematerializeObserver = (function (__super__) {\n    inherits(DematerializeObserver, __super__);\n\n    function DematerializeObserver(o) {\n      this._o = o;\n      __super__.call(this);\n    }\n\n    DematerializeObserver.prototype.next = function (x) { x.accept(this._o); };\n    DematerializeObserver.prototype.error = function (e) { this._o.onError(e); };\n    DematerializeObserver.prototype.completed = function () { this._o.onCompleted(); };\n\n    return DematerializeObserver;\n  }(AbstractObserver));\n\n  /**\n   * Dematerializes the explicit notification values of an observable sequence as implicit notifications.\n   * @returns {Observable} An observable sequence exhibiting the behavior corresponding to the source sequence's notification values.\n   */\n  observableProto.dematerialize = function () {\n    return new DematerializeObservable(this);\n  };\n\n  var DistinctUntilChangedObservable = (function(__super__) {\n    inherits(DistinctUntilChangedObservable, __super__);\n    function DistinctUntilChangedObservable(source, keyFn, comparer) {\n      this.source = source;\n      this.keyFn = keyFn;\n      this.comparer = comparer;\n      __super__.call(this);\n    }\n\n    DistinctUntilChangedObservable.prototype.subscribeCore = function (o) {\n      return this.source.subscribe(new DistinctUntilChangedObserver(o, this.keyFn, this.comparer));\n    };\n\n    return DistinctUntilChangedObservable;\n  }(ObservableBase));\n\n  var DistinctUntilChangedObserver = (function(__super__) {\n    inherits(DistinctUntilChangedObserver, __super__);\n    function DistinctUntilChangedObserver(o, keyFn, comparer) {\n      this.o = o;\n      this.keyFn = keyFn;\n      this.comparer = comparer;\n      this.hasCurrentKey = false;\n      this.currentKey = null;\n      __super__.call(this);\n    }\n\n    DistinctUntilChangedObserver.prototype.next = function (x) {\n      var key = x, comparerEquals;\n      if (isFunction(this.keyFn)) {\n        key = tryCatch(this.keyFn)(x);\n        if (key === errorObj) { return this.o.onError(key.e); }\n      }\n      if (this.hasCurrentKey) {\n        comparerEquals = tryCatch(this.comparer)(this.currentKey, key);\n        if (comparerEquals === errorObj) { return this.o.onError(comparerEquals.e); }\n      }\n      if (!this.hasCurrentKey || !comparerEquals) {\n        this.hasCurrentKey = true;\n        this.currentKey = key;\n        this.o.onNext(x);\n      }\n    };\n    DistinctUntilChangedObserver.prototype.error = function(e) {\n      this.o.onError(e);\n    };\n    DistinctUntilChangedObserver.prototype.completed = function () {\n      this.o.onCompleted();\n    };\n\n    return DistinctUntilChangedObserver;\n  }(AbstractObserver));\n\n  /**\n  *  Returns an observable sequence that contains only distinct contiguous elements according to the keyFn and the comparer.\n  * @param {Function} [keyFn] A function to compute the comparison key for each element. If not provided, it projects the value.\n  * @param {Function} [comparer] Equality comparer for computed key values. If not provided, defaults to an equality comparer function.\n  * @returns {Observable} An observable sequence only containing the distinct contiguous elements, based on a computed key value, from the source sequence.\n  */\n  observableProto.distinctUntilChanged = function (keyFn, comparer) {\n    comparer || (comparer = defaultComparer);\n    return new DistinctUntilChangedObservable(this, keyFn, comparer);\n  };\n\n  var TapObservable = (function(__super__) {\n    inherits(TapObservable,__super__);\n    function TapObservable(source, observerOrOnNext, onError, onCompleted) {\n      this.source = source;\n      this._oN = observerOrOnNext;\n      this._oE = onError;\n      this._oC = onCompleted;\n      __super__.call(this);\n    }\n\n    TapObservable.prototype.subscribeCore = function(o) {\n      return this.source.subscribe(new InnerObserver(o, this));\n    };\n\n    inherits(InnerObserver, AbstractObserver);\n    function InnerObserver(o, p) {\n      this.o = o;\n      this.t = !p._oN || isFunction(p._oN) ?\n        observerCreate(p._oN || noop, p._oE || noop, p._oC || noop) :\n        p._oN;\n      this.isStopped = false;\n      AbstractObserver.call(this);\n    }\n    InnerObserver.prototype.next = function(x) {\n      var res = tryCatch(this.t.onNext).call(this.t, x);\n      if (res === errorObj) { this.o.onError(res.e); }\n      this.o.onNext(x);\n    };\n    InnerObserver.prototype.error = function(err) {\n      var res = tryCatch(this.t.onError).call(this.t, err);\n      if (res === errorObj) { return this.o.onError(res.e); }\n      this.o.onError(err);\n    };\n    InnerObserver.prototype.completed = function() {\n      var res = tryCatch(this.t.onCompleted).call(this.t);\n      if (res === errorObj) { return this.o.onError(res.e); }\n      this.o.onCompleted();\n    };\n\n    return TapObservable;\n  }(ObservableBase));\n\n  /**\n  *  Invokes an action for each element in the observable sequence and invokes an action upon graceful or exceptional termination of the observable sequence.\n  *  This method can be used for debugging, logging, etc. of query behavior by intercepting the message stream to run arbitrary actions for messages on the pipeline.\n  * @param {Function | Observer} observerOrOnNext Action to invoke for each element in the observable sequence or an o.\n  * @param {Function} [onError]  Action to invoke upon exceptional termination of the observable sequence. Used if only the observerOrOnNext parameter is also a function.\n  * @param {Function} [onCompleted]  Action to invoke upon graceful termination of the observable sequence. Used if only the observerOrOnNext parameter is also a function.\n  * @returns {Observable} The source sequence with the side-effecting behavior applied.\n  */\n  observableProto['do'] = observableProto.tap = observableProto.doAction = function (observerOrOnNext, onError, onCompleted) {\n    return new TapObservable(this, observerOrOnNext, onError, onCompleted);\n  };\n\n  /**\n  *  Invokes an action for each element in the observable sequence.\n  *  This method can be used for debugging, logging, etc. of query behavior by intercepting the message stream to run arbitrary actions for messages on the pipeline.\n  * @param {Function} onNext Action to invoke for each element in the observable sequence.\n  * @param {Any} [thisArg] Object to use as this when executing callback.\n  * @returns {Observable} The source sequence with the side-effecting behavior applied.\n  */\n  observableProto.doOnNext = observableProto.tapOnNext = function (onNext, thisArg) {\n    return this.tap(typeof thisArg !== 'undefined' ? function (x) { onNext.call(thisArg, x); } : onNext);\n  };\n\n  /**\n  *  Invokes an action upon exceptional termination of the observable sequence.\n  *  This method can be used for debugging, logging, etc. of query behavior by intercepting the message stream to run arbitrary actions for messages on the pipeline.\n  * @param {Function} onError Action to invoke upon exceptional termination of the observable sequence.\n  * @param {Any} [thisArg] Object to use as this when executing callback.\n  * @returns {Observable} The source sequence with the side-effecting behavior applied.\n  */\n  observableProto.doOnError = observableProto.tapOnError = function (onError, thisArg) {\n    return this.tap(noop, typeof thisArg !== 'undefined' ? function (e) { onError.call(thisArg, e); } : onError);\n  };\n\n  /**\n  *  Invokes an action upon graceful termination of the observable sequence.\n  *  This method can be used for debugging, logging, etc. of query behavior by intercepting the message stream to run arbitrary actions for messages on the pipeline.\n  * @param {Function} onCompleted Action to invoke upon graceful termination of the observable sequence.\n  * @param {Any} [thisArg] Object to use as this when executing callback.\n  * @returns {Observable} The source sequence with the side-effecting behavior applied.\n  */\n  observableProto.doOnCompleted = observableProto.tapOnCompleted = function (onCompleted, thisArg) {\n    return this.tap(noop, null, typeof thisArg !== 'undefined' ? function () { onCompleted.call(thisArg); } : onCompleted);\n  };\n\n  var FinallyObservable = (function (__super__) {\n    inherits(FinallyObservable, __super__);\n    function FinallyObservable(source, fn, thisArg) {\n      this.source = source;\n      this._fn = bindCallback(fn, thisArg, 0);\n      __super__.call(this);\n    }\n\n    FinallyObservable.prototype.subscribeCore = function (o) {\n      var d = tryCatch(this.source.subscribe).call(this.source, o);\n      if (d === errorObj) {\n        this._fn();\n        thrower(d.e);\n      }\n\n      return new FinallyDisposable(d, this._fn);\n    };\n\n    function FinallyDisposable(s, fn) {\n      this.isDisposed = false;\n      this._s = s;\n      this._fn = fn;\n    }\n    FinallyDisposable.prototype.dispose = function () {\n      if (!this.isDisposed) {\n        var res = tryCatch(this._s.dispose).call(this._s);\n        this._fn();\n        res === errorObj && thrower(res.e);\n      }\n    };\n\n    return FinallyObservable;\n\n  }(ObservableBase));\n\n  /**\n   *  Invokes a specified action after the source observable sequence terminates gracefully or exceptionally.\n   * @param {Function} finallyAction Action to invoke after the source observable sequence terminates.\n   * @returns {Observable} Source sequence with the action-invoking termination behavior applied.\n   */\n  observableProto['finally'] = function (action, thisArg) {\n    return new FinallyObservable(this, action, thisArg);\n  };\n\n  var IgnoreElementsObservable = (function(__super__) {\n    inherits(IgnoreElementsObservable, __super__);\n\n    function IgnoreElementsObservable(source) {\n      this.source = source;\n      __super__.call(this);\n    }\n\n    IgnoreElementsObservable.prototype.subscribeCore = function (o) {\n      return this.source.subscribe(new InnerObserver(o));\n    };\n\n    function InnerObserver(o) {\n      this.o = o;\n      this.isStopped = false;\n    }\n    InnerObserver.prototype.onNext = noop;\n    InnerObserver.prototype.onError = function (err) {\n      if(!this.isStopped) {\n        this.isStopped = true;\n        this.o.onError(err);\n      }\n    };\n    InnerObserver.prototype.onCompleted = function () {\n      if(!this.isStopped) {\n        this.isStopped = true;\n        this.o.onCompleted();\n      }\n    };\n    InnerObserver.prototype.dispose = function() { this.isStopped = true; };\n    InnerObserver.prototype.fail = function (e) {\n      if (!this.isStopped) {\n        this.isStopped = true;\n        this.observer.onError(e);\n        return true;\n      }\n\n      return false;\n    };\n\n    return IgnoreElementsObservable;\n  }(ObservableBase));\n\n  /**\n   *  Ignores all elements in an observable sequence leaving only the termination messages.\n   * @returns {Observable} An empty observable sequence that signals termination, successful or exceptional, of the source sequence.\n   */\n  observableProto.ignoreElements = function () {\n    return new IgnoreElementsObservable(this);\n  };\n\n  var MaterializeObservable = (function (__super__) {\n    inherits(MaterializeObservable, __super__);\n    function MaterializeObservable(source, fn) {\n      this.source = source;\n      __super__.call(this);\n    }\n\n    MaterializeObservable.prototype.subscribeCore = function (o) {\n      return this.source.subscribe(new MaterializeObserver(o));\n    };\n\n    return MaterializeObservable;\n  }(ObservableBase));\n\n  var MaterializeObserver = (function (__super__) {\n    inherits(MaterializeObserver, __super__);\n\n    function MaterializeObserver(o) {\n      this._o = o;\n      __super__.call(this);\n    }\n\n    MaterializeObserver.prototype.next = function (x) { this._o.onNext(notificationCreateOnNext(x)) };\n    MaterializeObserver.prototype.error = function (e) { this._o.onNext(notificationCreateOnError(e)); this._o.onCompleted(); };\n    MaterializeObserver.prototype.completed = function () { this._o.onNext(notificationCreateOnCompleted()); this._o.onCompleted(); };\n\n    return MaterializeObserver;\n  }(AbstractObserver));\n\n  /**\n   *  Materializes the implicit notifications of an observable sequence as explicit notification values.\n   * @returns {Observable} An observable sequence containing the materialized notification values from the source sequence.\n   */\n  observableProto.materialize = function () {\n    return new MaterializeObservable(this);\n  };\n\n  /**\n   *  Repeats the observable sequence a specified number of times. If the repeat count is not specified, the sequence repeats indefinitely.\n   * @param {Number} [repeatCount]  Number of times to repeat the sequence. If not provided, repeats the sequence indefinitely.\n   * @returns {Observable} The observable sequence producing the elements of the given sequence repeatedly.\n   */\n  observableProto.repeat = function (repeatCount) {\n    return enumerableRepeat(this, repeatCount).concat();\n  };\n\n  /**\n   *  Repeats the source observable sequence the specified number of times or until it successfully terminates. If the retry count is not specified, it retries indefinitely.\n   *  Note if you encounter an error and want it to retry once, then you must use .retry(2);\n   *\n   * @example\n   *  var res = retried = retry.repeat();\n   *  var res = retried = retry.repeat(2);\n   * @param {Number} [retryCount]  Number of times to retry the sequence. If not provided, retry the sequence indefinitely.\n   * @returns {Observable} An observable sequence producing the elements of the given sequence repeatedly until it terminates successfully.\n   */\n  observableProto.retry = function (retryCount) {\n    return enumerableRepeat(this, retryCount).catchError();\n  };\n\n  /**\n   *  Repeats the source observable sequence upon error each time the notifier emits or until it successfully terminates. \n   *  if the notifier completes, the observable sequence completes.\n   *\n   * @example\n   *  var timer = Observable.timer(500);\n   *  var source = observable.retryWhen(timer);\n   * @param {Observable} [notifier] An observable that triggers the retries or completes the observable with onNext or onCompleted respectively.\n   * @returns {Observable} An observable sequence producing the elements of the given sequence repeatedly until it terminates successfully.\n   */\n  observableProto.retryWhen = function (notifier) {\n    return enumerableRepeat(this).catchErrorWhen(notifier);\n  };\n  var ScanObservable = (function(__super__) {\n    inherits(ScanObservable, __super__);\n    function ScanObservable(source, accumulator, hasSeed, seed) {\n      this.source = source;\n      this.accumulator = accumulator;\n      this.hasSeed = hasSeed;\n      this.seed = seed;\n      __super__.call(this);\n    }\n\n    ScanObservable.prototype.subscribeCore = function(o) {\n      return this.source.subscribe(new ScanObserver(o,this));\n    };\n\n    return ScanObservable;\n  }(ObservableBase));\n\n  var ScanObserver = (function (__super__) {\n    inherits(ScanObserver, __super__);\n    function ScanObserver(o, parent) {\n      this._o = o;\n      this._p = parent;\n      this._fn = parent.accumulator;\n      this._hs = parent.hasSeed;\n      this._s = parent.seed;\n      this._ha = false;\n      this._a = null;\n      this._hv = false;\n      this._i = 0;\n      __super__.call(this);\n    }\n\n    ScanObserver.prototype.next = function (x) {\n      !this._hv && (this._hv = true);\n      if (this._ha) {\n        this._a = tryCatch(this._fn)(this._a, x, this._i, this._p);\n      } else {\n        this._a = this._hs ? tryCatch(this._fn)(this._s, x, this._i, this._p) : x;\n        this._ha = true;\n      }\n      if (this._a === errorObj) { return this._o.onError(this._a.e); }\n      this._o.onNext(this._a);\n      this._i++;\n    };\n\n    ScanObserver.prototype.error = function (e) {\n      this._o.onError(e);\n    };\n\n    ScanObserver.prototype.completed = function () {\n      !this._hv && this._hs && this._o.onNext(this._s);\n      this._o.onCompleted();\n    };\n\n    return ScanObserver;\n  }(AbstractObserver));\n\n  /**\n  *  Applies an accumulator function over an observable sequence and returns each intermediate result. The optional seed value is used as the initial accumulator value.\n  *  For aggregation behavior with no intermediate results, see Observable.aggregate.\n  * @param {Mixed} [seed] The initial accumulator value.\n  * @param {Function} accumulator An accumulator function to be invoked on each element.\n  * @returns {Observable} An observable sequence containing the accumulated values.\n  */\n  observableProto.scan = function () {\n    var hasSeed = false, seed, accumulator = arguments[0];\n    if (arguments.length === 2) {\n      hasSeed = true;\n      seed = arguments[1];\n    }\n    return new ScanObservable(this, accumulator, hasSeed, seed);\n  };\n\n  var SkipLastObservable = (function (__super__) {\n    inherits(SkipLastObservable, __super__);\n    function SkipLastObservable(source, c) {\n      this.source = source;\n      this._c = c;\n      __super__.call(this);\n    }\n\n    SkipLastObservable.prototype.subscribeCore = function (o) {\n      return this.source.subscribe(new SkipLastObserver(o, this._c));\n    };\n\n    return SkipLastObservable;\n  }(ObservableBase));\n\n  var SkipLastObserver = (function (__super__) {\n    inherits(SkipLastObserver, __super__);\n    function SkipLastObserver(o, c) {\n      this._o = o;\n      this._c = c;\n      this._q = [];\n      __super__.call(this);\n    }\n\n    SkipLastObserver.prototype.next = function (x) {\n      this._q.push(x);\n      this._q.length > this._c && this._o.onNext(this._q.shift());\n    };\n\n    SkipLastObserver.prototype.error = function (e) {\n      this._o.onError(e);\n    };\n\n    SkipLastObserver.prototype.completed = function () {\n      this._o.onCompleted();\n    };\n\n    return SkipLastObserver;\n  }(AbstractObserver));\n\n  /**\n   *  Bypasses a specified number of elements at the end of an observable sequence.\n   * @description\n   *  This operator accumulates a queue with a length enough to store the first `count` elements. As more elements are\n   *  received, elements are taken from the front of the queue and produced on the result sequence. This causes elements to be delayed.\n   * @param count Number of elements to bypass at the end of the source sequence.\n   * @returns {Observable} An observable sequence containing the source sequence elements except for the bypassed ones at the end.\n   */\n  observableProto.skipLast = function (count) {\n    if (count < 0) { throw new ArgumentOutOfRangeError(); }\n    return new SkipLastObservable(this, count);\n  };\n\n  /**\n   *  Prepends a sequence of values to an observable sequence with an optional scheduler and an argument list of values to prepend.\n   *  @example\n   *  var res = source.startWith(1, 2, 3);\n   *  var res = source.startWith(Rx.Scheduler.timeout, 1, 2, 3);\n   * @param {Arguments} args The specified values to prepend to the observable sequence\n   * @returns {Observable} The source sequence prepended with the specified values.\n   */\n  observableProto.startWith = function () {\n    var values, scheduler, start = 0;\n    if (!!arguments.length && isScheduler(arguments[0])) {\n      scheduler = arguments[0];\n      start = 1;\n    } else {\n      scheduler = immediateScheduler;\n    }\n    for(var args = [], i = start, len = arguments.length; i < len; i++) { args.push(arguments[i]); }\n    return enumerableOf([observableFromArray(args, scheduler), this]).concat();\n  };\n\n  var TakeLastObserver = (function (__super__) {\n    inherits(TakeLastObserver, __super__);\n    function TakeLastObserver(o, c) {\n      this._o = o;\n      this._c = c;\n      this._q = [];\n      __super__.call(this);\n    }\n\n    TakeLastObserver.prototype.next = function (x) {\n      this._q.push(x);\n      this._q.length > this._c && this._q.shift();\n    };\n\n    TakeLastObserver.prototype.error = function (e) {\n      this._o.onError(e);\n    };\n\n    TakeLastObserver.prototype.completed = function () {\n      while (this._q.length > 0) { this._o.onNext(this._q.shift()); }\n      this._o.onCompleted();\n    };\n\n    return TakeLastObserver;\n  }(AbstractObserver));\n\n  /**\n   *  Returns a specified number of contiguous elements from the end of an observable sequence.\n   * @description\n   *  This operator accumulates a buffer with a length enough to store elements count elements. Upon completion of\n   *  the source sequence, this buffer is drained on the result sequence. This causes the elements to be delayed.\n   * @param {Number} count Number of elements to take from the end of the source sequence.\n   * @returns {Observable} An observable sequence containing the specified number of elements from the end of the source sequence.\n   */\n  observableProto.takeLast = function (count) {\n    if (count < 0) { throw new ArgumentOutOfRangeError(); }\n    var source = this;\n    return new AnonymousObservable(function (o) {\n      return source.subscribe(new TakeLastObserver(o, count));\n    }, source);\n  };\n\n  var TakeLastBufferObserver = (function (__super__) {\n    inherits(TakeLastBufferObserver, __super__);\n    function TakeLastBufferObserver(o, c) {\n      this._o = o;\n      this._c = c;\n      this._q = [];\n      __super__.call(this);\n    }\n\n    TakeLastBufferObserver.prototype.next = function (x) {\n      this._q.push(x);\n      this._q.length > this._c && this._q.shift();\n    };\n\n    TakeLastBufferObserver.prototype.error = function (e) {\n      this._o.onError(e);\n    };\n\n    TakeLastBufferObserver.prototype.completed = function () {\n      this._o.onNext(this._q);\n      this._o.onCompleted();\n    };\n\n    return TakeLastBufferObserver;\n  }(AbstractObserver));\n\n  /**\n   *  Returns an array with the specified number of contiguous elements from the end of an observable sequence.\n   *\n   * @description\n   *  This operator accumulates a buffer with a length enough to store count elements. Upon completion of the\n   *  source sequence, this buffer is produced on the result sequence.\n   * @param {Number} count Number of elements to take from the end of the source sequence.\n   * @returns {Observable} An observable sequence containing a single array with the specified number of elements from the end of the source sequence.\n   */\n  observableProto.takeLastBuffer = function (count) {\n    if (count < 0) { throw new ArgumentOutOfRangeError(); }\n    var source = this;\n    return new AnonymousObservable(function (o) {\n      return source.subscribe(new TakeLastBufferObserver(o, count));\n    }, source);\n  };\n\n  /**\n   *  Projects each element of an observable sequence into zero or more windows which are produced based on element count information.\n   * @param {Number} count Length of each window.\n   * @param {Number} [skip] Number of elements to skip between creation of consecutive windows. If not specified, defaults to the count.\n   * @returns {Observable} An observable sequence of windows.\n   */\n  observableProto.windowWithCount = function (count, skip) {\n    var source = this;\n    +count || (count = 0);\n    Math.abs(count) === Infinity && (count = 0);\n    if (count <= 0) { throw new ArgumentOutOfRangeError(); }\n    skip == null && (skip = count);\n    +skip || (skip = 0);\n    Math.abs(skip) === Infinity && (skip = 0);\n\n    if (skip <= 0) { throw new ArgumentOutOfRangeError(); }\n    return new AnonymousObservable(function (observer) {\n      var m = new SingleAssignmentDisposable(),\n        refCountDisposable = new RefCountDisposable(m),\n        n = 0,\n        q = [];\n\n      function createWindow () {\n        var s = new Subject();\n        q.push(s);\n        observer.onNext(addRef(s, refCountDisposable));\n      }\n\n      createWindow();\n\n      m.setDisposable(source.subscribe(\n        function (x) {\n          for (var i = 0, len = q.length; i < len; i++) { q[i].onNext(x); }\n          var c = n - count + 1;\n          c >= 0 && c % skip === 0 && q.shift().onCompleted();\n          ++n % skip === 0 && createWindow();\n        },\n        function (e) {\n          while (q.length > 0) { q.shift().onError(e); }\n          observer.onError(e);\n        },\n        function () {\n          while (q.length > 0) { q.shift().onCompleted(); }\n          observer.onCompleted();\n        }\n      ));\n      return refCountDisposable;\n    }, source);\n  };\n\n  function concatMap(source, selector, thisArg) {\n    var selectorFunc = bindCallback(selector, thisArg, 3);\n    return source.map(function (x, i) {\n      var result = selectorFunc(x, i, source);\n      isPromise(result) && (result = observableFromPromise(result));\n      (isArrayLike(result) || isIterable(result)) && (result = observableFrom(result));\n      return result;\n    }).concatAll();\n  }\n\n  /**\n   *  One of the Following:\n   *  Projects each element of an observable sequence to an observable sequence and merges the resulting observable sequences into one observable sequence.\n   *\n   * @example\n   *  var res = source.concatMap(function (x) { return Rx.Observable.range(0, x); });\n   *  Or:\n   *  Projects each element of an observable sequence to an observable sequence, invokes the result selector for the source element and each of the corresponding inner sequence's elements, and merges the results into one observable sequence.\n   *\n   *  var res = source.concatMap(function (x) { return Rx.Observable.range(0, x); }, function (x, y) { return x + y; });\n   *  Or:\n   *  Projects each element of the source observable sequence to the other observable sequence and merges the resulting observable sequences into one observable sequence.\n   *\n   *  var res = source.concatMap(Rx.Observable.fromArray([1,2,3]));\n   * @param {Function} selector A transform function to apply to each element or an observable sequence to project each element from the\n   * source sequence onto which could be either an observable or Promise.\n   * @param {Function} [resultSelector]  A transform function to apply to each element of the intermediate sequence.\n   * @returns {Observable} An observable sequence whose elements are the result of invoking the one-to-many transform function collectionSelector on each element of the input sequence and then mapping each of those sequence elements and their corresponding source element to a result element.\n   */\n  observableProto.selectConcat = observableProto.concatMap = function (selector, resultSelector, thisArg) {\n    if (isFunction(selector) && isFunction(resultSelector)) {\n      return this.concatMap(function (x, i) {\n        var selectorResult = selector(x, i);\n        isPromise(selectorResult) && (selectorResult = observableFromPromise(selectorResult));\n        (isArrayLike(selectorResult) || isIterable(selectorResult)) && (selectorResult = observableFrom(selectorResult));\n\n        return selectorResult.map(function (y, i2) {\n          return resultSelector(x, y, i, i2);\n        });\n      });\n    }\n    return isFunction(selector) ?\n      concatMap(this, selector, thisArg) :\n      concatMap(this, function () { return selector; });\n  };\n\n  /**\n   * Projects each notification of an observable sequence to an observable sequence and concats the resulting observable sequences into one observable sequence.\n   * @param {Function} onNext A transform function to apply to each element; the second parameter of the function represents the index of the source element.\n   * @param {Function} onError A transform function to apply when an error occurs in the source sequence.\n   * @param {Function} onCompleted A transform function to apply when the end of the source sequence is reached.\n   * @param {Any} [thisArg] An optional \"this\" to use to invoke each transform.\n   * @returns {Observable} An observable sequence whose elements are the result of invoking the one-to-many transform function corresponding to each notification in the input sequence.\n   */\n  observableProto.concatMapObserver = observableProto.selectConcatObserver = function(onNext, onError, onCompleted, thisArg) {\n    var source = this,\n        onNextFunc = bindCallback(onNext, thisArg, 2),\n        onErrorFunc = bindCallback(onError, thisArg, 1),\n        onCompletedFunc = bindCallback(onCompleted, thisArg, 0);\n    return new AnonymousObservable(function (observer) {\n      var index = 0;\n      return source.subscribe(\n        function (x) {\n          var result;\n          try {\n            result = onNextFunc(x, index++);\n          } catch (e) {\n            observer.onError(e);\n            return;\n          }\n          isPromise(result) && (result = observableFromPromise(result));\n          observer.onNext(result);\n        },\n        function (err) {\n          var result;\n          try {\n            result = onErrorFunc(err);\n          } catch (e) {\n            observer.onError(e);\n            return;\n          }\n          isPromise(result) && (result = observableFromPromise(result));\n          observer.onNext(result);\n          observer.onCompleted();\n        },\n        function () {\n          var result;\n          try {\n            result = onCompletedFunc();\n          } catch (e) {\n            observer.onError(e);\n            return;\n          }\n          isPromise(result) && (result = observableFromPromise(result));\n          observer.onNext(result);\n          observer.onCompleted();\n        });\n    }, this).concatAll();\n  };\n\n  var DefaultIfEmptyObserver = (function (__super__) {\n    inherits(DefaultIfEmptyObserver, __super__);\n    function DefaultIfEmptyObserver(o, d) {\n      this._o = o;\n      this._d = d;\n      this._f = false;\n      __super__.call(this);\n    }\n\n    DefaultIfEmptyObserver.prototype.next = function (x) {\n      this._f = true;\n      this._o.onNext(x);\n    };\n\n    DefaultIfEmptyObserver.prototype.error = function (e) {\n      this._o.onError(e);\n    };\n\n    DefaultIfEmptyObserver.prototype.completed = function () {\n      !this._f && this._o.onNext(this._d);\n      this._o.onCompleted();\n    };\n\n    return DefaultIfEmptyObserver;\n  }(AbstractObserver));\n\n  /**\n   *  Returns the elements of the specified sequence or the specified value in a singleton sequence if the sequence is empty.\n   *\n   *  var res = obs = xs.defaultIfEmpty();\n   *  2 - obs = xs.defaultIfEmpty(false);\n   *\n   * @memberOf Observable#\n   * @param defaultValue The value to return if the sequence is empty. If not provided, this defaults to null.\n   * @returns {Observable} An observable sequence that contains the specified default value if the source is empty; otherwise, the elements of the source itself.\n   */\n    observableProto.defaultIfEmpty = function (defaultValue) {\n      var source = this;\n      defaultValue === undefined && (defaultValue = null);\n      return new AnonymousObservable(function (o) {\n        return source.subscribe(new DefaultIfEmptyObserver(o, defaultValue));\n      }, source);\n    };\n\n  // Swap out for Array.findIndex\n  function arrayIndexOfComparer(array, item, comparer) {\n    for (var i = 0, len = array.length; i < len; i++) {\n      if (comparer(array[i], item)) { return i; }\n    }\n    return -1;\n  }\n\n  function HashSet(comparer) {\n    this.comparer = comparer;\n    this.set = [];\n  }\n  HashSet.prototype.push = function(value) {\n    var retValue = arrayIndexOfComparer(this.set, value, this.comparer) === -1;\n    retValue && this.set.push(value);\n    return retValue;\n  };\n\n  var DistinctObservable = (function (__super__) {\n    inherits(DistinctObservable, __super__);\n    function DistinctObservable(source, keyFn, cmpFn) {\n      this.source = source;\n      this._keyFn = keyFn;\n      this._cmpFn = cmpFn;\n      __super__.call(this);\n    }\n\n    DistinctObservable.prototype.subscribeCore = function (o) {\n      return this.source.subscribe(new DistinctObserver(o, this._keyFn, this._cmpFn));\n    };\n\n    return DistinctObservable;\n  }(ObservableBase));\n\n  var DistinctObserver = (function (__super__) {\n    inherits(DistinctObserver, __super__);\n    function DistinctObserver(o, keyFn, cmpFn) {\n      this._o = o;\n      this._keyFn = keyFn;\n      this._h = new HashSet(cmpFn);\n      __super__.call(this);\n    }\n\n    DistinctObserver.prototype.next = function (x) {\n      var key = x;\n      if (isFunction(this._keyFn)) {\n        key = tryCatch(this._keyFn)(x);\n        if (key === errorObj) { return this._o.onError(key.e); }\n      }\n      this._h.push(key) && this._o.onNext(x);\n    };\n\n    DistinctObserver.prototype.error = function (e) { this._o.onError(e); };\n    DistinctObserver.prototype.completed = function () { this._o.onCompleted(); };\n\n    return DistinctObserver;\n  }(AbstractObserver));\n\n  /**\n   *  Returns an observable sequence that contains only distinct elements according to the keySelector and the comparer.\n   *  Usage of this operator should be considered carefully due to the maintenance of an internal lookup structure which can grow large.\n   *\n   * @example\n   *  var res = obs = xs.distinct();\n   *  2 - obs = xs.distinct(function (x) { return x.id; });\n   *  2 - obs = xs.distinct(function (x) { return x.id; }, function (a,b) { return a === b; });\n   * @param {Function} [keySelector]  A function to compute the comparison key for each element.\n   * @param {Function} [comparer]  Used to compare items in the collection.\n   * @returns {Observable} An observable sequence only containing the distinct elements, based on a computed key value, from the source sequence.\n   */\n  observableProto.distinct = function (keySelector, comparer) {\n    comparer || (comparer = defaultComparer);\n    return new DistinctObservable(this, keySelector, comparer);\n  };\n\n  /**\n   *  Groups the elements of an observable sequence according to a specified key selector function and comparer and selects the resulting elements by using a specified function.\n   *\n   * @example\n   *  var res = observable.groupBy(function (x) { return x.id; });\n   *  2 - observable.groupBy(function (x) { return x.id; }), function (x) { return x.name; });\n   *  3 - observable.groupBy(function (x) { return x.id; }), function (x) { return x.name; }, function (x) { return x.toString(); });\n   * @param {Function} keySelector A function to extract the key for each element.\n   * @param {Function} [elementSelector]  A function to map each source element to an element in an observable group.\n   * @returns {Observable} A sequence of observable groups, each of which corresponds to a unique key value, containing all elements that share that same key value.\n   */\n  observableProto.groupBy = function (keySelector, elementSelector) {\n    return this.groupByUntil(keySelector, elementSelector, observableNever);\n  };\n\n    /**\n     *  Groups the elements of an observable sequence according to a specified key selector function.\n     *  A duration selector function is used to control the lifetime of groups. When a group expires, it receives an OnCompleted notification. When a new element with the same\n     *  key value as a reclaimed group occurs, the group will be reborn with a new lifetime request.\n     *\n     * @example\n     *  var res = observable.groupByUntil(function (x) { return x.id; }, null,  function () { return Rx.Observable.never(); });\n     *  2 - observable.groupBy(function (x) { return x.id; }), function (x) { return x.name; },  function () { return Rx.Observable.never(); });\n     *  3 - observable.groupBy(function (x) { return x.id; }), function (x) { return x.name; },  function () { return Rx.Observable.never(); }, function (x) { return x.toString(); });\n     * @param {Function} keySelector A function to extract the key for each element.\n     * @param {Function} durationSelector A function to signal the expiration of a group.\n     * @returns {Observable}\n     *  A sequence of observable groups, each of which corresponds to a unique key value, containing all elements that share that same key value.\n     *  If a group's lifetime expires, a new group with the same key value can be created once an element with such a key value is encoutered.\n     *\n     */\n    observableProto.groupByUntil = function (keySelector, elementSelector, durationSelector) {\n      var source = this;\n      return new AnonymousObservable(function (o) {\n        var map = new Map(),\n          groupDisposable = new CompositeDisposable(),\n          refCountDisposable = new RefCountDisposable(groupDisposable),\n          handleError = function (e) { return function (item) { item.onError(e); }; };\n\n        groupDisposable.add(\n          source.subscribe(function (x) {\n            var key = tryCatch(keySelector)(x);\n            if (key === errorObj) {\n              map.forEach(handleError(key.e));\n              return o.onError(key.e);\n            }\n\n            var fireNewMapEntry = false, writer = map.get(key);\n            if (writer === undefined) {\n              writer = new Subject();\n              map.set(key, writer);\n              fireNewMapEntry = true;\n            }\n\n            if (fireNewMapEntry) {\n              var group = new GroupedObservable(key, writer, refCountDisposable),\n                durationGroup = new GroupedObservable(key, writer);\n              var duration = tryCatch(durationSelector)(durationGroup);\n              if (duration === errorObj) {\n                map.forEach(handleError(duration.e));\n                return o.onError(duration.e);\n              }\n\n              o.onNext(group);\n\n              var md = new SingleAssignmentDisposable();\n              groupDisposable.add(md);\n\n              md.setDisposable(duration.take(1).subscribe(\n                noop,\n                function (e) {\n                  map.forEach(handleError(e));\n                  o.onError(e);\n                },\n                function () {\n                  if (map['delete'](key)) { writer.onCompleted(); }\n                  groupDisposable.remove(md);\n                }));\n            }\n\n            var element = x;\n            if (isFunction(elementSelector)) {\n              element = tryCatch(elementSelector)(x);\n              if (element === errorObj) {\n                map.forEach(handleError(element.e));\n                return o.onError(element.e);\n              }\n            }\n\n            writer.onNext(element);\n        }, function (e) {\n          map.forEach(handleError(e));\n          o.onError(e);\n        }, function () {\n          map.forEach(function (item) { item.onCompleted(); });\n          o.onCompleted();\n        }));\n\n      return refCountDisposable;\n    }, source);\n  };\n\n  var MapObservable = (function (__super__) {\n    inherits(MapObservable, __super__);\n\n    function MapObservable(source, selector, thisArg) {\n      this.source = source;\n      this.selector = bindCallback(selector, thisArg, 3);\n      __super__.call(this);\n    }\n\n    function innerMap(selector, self) {\n      return function (x, i, o) { return selector.call(this, self.selector(x, i, o), i, o); };\n    }\n\n    MapObservable.prototype.internalMap = function (selector, thisArg) {\n      return new MapObservable(this.source, innerMap(selector, this), thisArg);\n    };\n\n    MapObservable.prototype.subscribeCore = function (o) {\n      return this.source.subscribe(new InnerObserver(o, this.selector, this));\n    };\n\n    inherits(InnerObserver, AbstractObserver);\n    function InnerObserver(o, selector, source) {\n      this.o = o;\n      this.selector = selector;\n      this.source = source;\n      this.i = 0;\n      AbstractObserver.call(this);\n    }\n\n    InnerObserver.prototype.next = function(x) {\n      var result = tryCatch(this.selector)(x, this.i++, this.source);\n      if (result === errorObj) { return this.o.onError(result.e); }\n      this.o.onNext(result);\n    };\n\n    InnerObserver.prototype.error = function (e) {\n      this.o.onError(e);\n    };\n\n    InnerObserver.prototype.completed = function () {\n      this.o.onCompleted();\n    };\n\n    return MapObservable;\n\n  }(ObservableBase));\n\n  /**\n  * Projects each element of an observable sequence into a new form by incorporating the element's index.\n  * @param {Function} selector A transform function to apply to each source element; the second parameter of the function represents the index of the source element.\n  * @param {Any} [thisArg] Object to use as this when executing callback.\n  * @returns {Observable} An observable sequence whose elements are the result of invoking the transform function on each element of source.\n  */\n  observableProto.map = observableProto.select = function (selector, thisArg) {\n    var selectorFn = typeof selector === 'function' ? selector : function () { return selector; };\n    return this instanceof MapObservable ?\n      this.internalMap(selectorFn, thisArg) :\n      new MapObservable(this, selectorFn, thisArg);\n  };\n\n  function plucker(args, len) {\n    return function mapper(x) {\n      var currentProp = x;\n      for (var i = 0; i < len; i++) {\n        var p = currentProp[args[i]];\n        if (typeof p !== 'undefined') {\n          currentProp = p;\n        } else {\n          return undefined;\n        }\n      }\n      return currentProp;\n    }\n  }\n\n  /**\n   * Retrieves the value of a specified nested property from all elements in\n   * the Observable sequence.\n   * @param {Arguments} arguments The nested properties to pluck.\n   * @returns {Observable} Returns a new Observable sequence of property values.\n   */\n  observableProto.pluck = function () {\n    var len = arguments.length, args = new Array(len);\n    if (len === 0) { throw new Error('List of properties cannot be empty.'); }\n    for(var i = 0; i < len; i++) { args[i] = arguments[i]; }\n    return this.map(plucker(args, len));\n  };\n\nobservableProto.flatMap = observableProto.selectMany = function(selector, resultSelector, thisArg) {\n    return new FlatMapObservable(this, selector, resultSelector, thisArg).mergeAll();\n};\n\n  /**\n   * Projects each notification of an observable sequence to an observable sequence and merges the resulting observable sequences into one observable sequence.\n   * @param {Function} onNext A transform function to apply to each element; the second parameter of the function represents the index of the source element.\n   * @param {Function} onError A transform function to apply when an error occurs in the source sequence.\n   * @param {Function} onCompleted A transform function to apply when the end of the source sequence is reached.\n   * @param {Any} [thisArg] An optional \"this\" to use to invoke each transform.\n   * @returns {Observable} An observable sequence whose elements are the result of invoking the one-to-many transform function corresponding to each notification in the input sequence.\n   */\n  observableProto.flatMapObserver = observableProto.selectManyObserver = function (onNext, onError, onCompleted, thisArg) {\n    var source = this;\n    return new AnonymousObservable(function (observer) {\n      var index = 0;\n\n      return source.subscribe(\n        function (x) {\n          var result;\n          try {\n            result = onNext.call(thisArg, x, index++);\n          } catch (e) {\n            observer.onError(e);\n            return;\n          }\n          isPromise(result) && (result = observableFromPromise(result));\n          observer.onNext(result);\n        },\n        function (err) {\n          var result;\n          try {\n            result = onError.call(thisArg, err);\n          } catch (e) {\n            observer.onError(e);\n            return;\n          }\n          isPromise(result) && (result = observableFromPromise(result));\n          observer.onNext(result);\n          observer.onCompleted();\n        },\n        function () {\n          var result;\n          try {\n            result = onCompleted.call(thisArg);\n          } catch (e) {\n            observer.onError(e);\n            return;\n          }\n          isPromise(result) && (result = observableFromPromise(result));\n          observer.onNext(result);\n          observer.onCompleted();\n        });\n    }, source).mergeAll();\n  };\n\nRx.Observable.prototype.flatMapLatest = function(selector, resultSelector, thisArg) {\n    return new FlatMapObservable(this, selector, resultSelector, thisArg).switchLatest();\n};\n  var SkipObservable = (function(__super__) {\n    inherits(SkipObservable, __super__);\n    function SkipObservable(source, count) {\n      this.source = source;\n      this._count = count;\n      __super__.call(this);\n    }\n\n    SkipObservable.prototype.subscribeCore = function (o) {\n      return this.source.subscribe(new SkipObserver(o, this._count));\n    };\n\n    function SkipObserver(o, c) {\n      this._o = o;\n      this._r = c;\n      AbstractObserver.call(this);\n    }\n\n    inherits(SkipObserver, AbstractObserver);\n\n    SkipObserver.prototype.next = function (x) {\n      if (this._r <= 0) {\n        this._o.onNext(x);\n      } else {\n        this._r--;\n      }\n    };\n    SkipObserver.prototype.error = function(e) { this._o.onError(e); };\n    SkipObserver.prototype.completed = function() { this._o.onCompleted(); };\n\n    return SkipObservable;\n  }(ObservableBase));\n\n  /**\n   * Bypasses a specified number of elements in an observable sequence and then returns the remaining elements.\n   * @param {Number} count The number of elements to skip before returning the remaining elements.\n   * @returns {Observable} An observable sequence that contains the elements that occur after the specified index in the input sequence.\n   */\n  observableProto.skip = function (count) {\n    if (count < 0) { throw new ArgumentOutOfRangeError(); }\n    return new SkipObservable(this, count);\n  };\n\n  var SkipWhileObservable = (function (__super__) {\n    inherits(SkipWhileObservable, __super__);\n    function SkipWhileObservable(source, fn) {\n      this.source = source;\n      this._fn = fn;\n      __super__.call(this);\n    }\n\n    SkipWhileObservable.prototype.subscribeCore = function (o) {\n      return this.source.subscribe(new SkipWhileObserver(o, this));\n    };\n\n    return SkipWhileObservable;\n  }(ObservableBase));\n\n  var SkipWhileObserver = (function (__super__) {\n    inherits(SkipWhileObserver, __super__);\n\n    function SkipWhileObserver(o, p) {\n      this._o = o;\n      this._p = p;\n      this._i = 0;\n      this._r = false;\n      __super__.call(this);\n    }\n\n    SkipWhileObserver.prototype.next = function (x) {\n      if (!this._r) {\n        var res = tryCatch(this._p._fn)(x, this._i++, this._p);\n        if (res === errorObj) { return this._o.onError(res.e); }\n        this._r = !res;\n      }\n      this._r && this._o.onNext(x);\n    };\n    SkipWhileObserver.prototype.error = function (e) { this._o.onError(e); };\n    SkipWhileObserver.prototype.completed = function () { this._o.onCompleted(); };\n\n    return SkipWhileObserver;\n  }(AbstractObserver));\n\n  /**\n   *  Bypasses elements in an observable sequence as long as a specified condition is true and then returns the remaining elements.\n   *  The element's index is used in the logic of the predicate function.\n   *\n   *  var res = source.skipWhile(function (value) { return value < 10; });\n   *  var res = source.skipWhile(function (value, index) { return value < 10 || index < 10; });\n   * @param {Function} predicate A function to test each element for a condition; the second parameter of the function represents the index of the source element.\n   * @param {Any} [thisArg] Object to use as this when executing callback.\n   * @returns {Observable} An observable sequence that contains the elements from the input sequence starting at the first element in the linear series that does not pass the test specified by predicate.\n   */\n  observableProto.skipWhile = function (predicate, thisArg) {\n    var fn = bindCallback(predicate, thisArg, 3);\n    return new SkipWhileObservable(this, fn);\n  };\n\n  var TakeObservable = (function(__super__) {\n    inherits(TakeObservable, __super__);\n    function TakeObservable(source, count) {\n      this.source = source;\n      this._count = count;\n      __super__.call(this);\n    }\n\n    TakeObservable.prototype.subscribeCore = function (o) {\n      return this.source.subscribe(new TakeObserver(o, this._count));\n    };\n\n    function TakeObserver(o, c) {\n      this._o = o;\n      this._c = c;\n      this._r = c;\n      AbstractObserver.call(this);\n    }\n\n    inherits(TakeObserver, AbstractObserver);\n\n    TakeObserver.prototype.next = function (x) {\n      if (this._r-- > 0) {\n        this._o.onNext(x);\n        this._r <= 0 && this._o.onCompleted();\n      }\n    };\n\n    TakeObserver.prototype.error = function (e) { this._o.onError(e); };\n    TakeObserver.prototype.completed = function () { this._o.onCompleted(); };\n\n    return TakeObservable;\n  }(ObservableBase));\n\n  /**\n   *  Returns a specified number of contiguous elements from the start of an observable sequence, using the specified scheduler for the edge case of take(0).\n   * @param {Number} count The number of elements to return.\n   * @param {Scheduler} [scheduler] Scheduler used to produce an OnCompleted message in case <paramref name=\"count count</paramref> is set to 0.\n   * @returns {Observable} An observable sequence that contains the specified number of elements from the start of the input sequence.\n   */\n  observableProto.take = function (count, scheduler) {\n    if (count < 0) { throw new ArgumentOutOfRangeError(); }\n    if (count === 0) { return observableEmpty(scheduler); }\n    return new TakeObservable(this, count);\n  };\n\n  var TakeWhileObservable = (function (__super__) {\n    inherits(TakeWhileObservable, __super__);\n    function TakeWhileObservable(source, fn) {\n      this.source = source;\n      this._fn = fn;\n      __super__.call(this);\n    }\n\n    TakeWhileObservable.prototype.subscribeCore = function (o) {\n      return this.source.subscribe(new TakeWhileObserver(o, this));\n    };\n\n    return TakeWhileObservable;\n  }(ObservableBase));\n\n  var TakeWhileObserver = (function (__super__) {\n    inherits(TakeWhileObserver, __super__);\n\n    function TakeWhileObserver(o, p) {\n      this._o = o;\n      this._p = p;\n      this._i = 0;\n      this._r = true;\n      __super__.call(this);\n    }\n\n    TakeWhileObserver.prototype.next = function (x) {\n      if (this._r) {\n        this._r = tryCatch(this._p._fn)(x, this._i++, this._p);\n        if (this._r === errorObj) { return this._o.onError(this._r.e); }\n      }\n      if (this._r) {\n        this._o.onNext(x);\n      } else {\n        this._o.onCompleted();\n      }\n    };\n    TakeWhileObserver.prototype.error = function (e) { this._o.onError(e); };\n    TakeWhileObserver.prototype.completed = function () { this._o.onCompleted(); };\n\n    return TakeWhileObserver;\n  }(AbstractObserver));\n\n  /**\n   *  Returns elements from an observable sequence as long as a specified condition is true.\n   *  The element's index is used in the logic of the predicate function.\n   * @param {Function} predicate A function to test each element for a condition; the second parameter of the function represents the index of the source element.\n   * @param {Any} [thisArg] Object to use as this when executing callback.\n   * @returns {Observable} An observable sequence that contains the elements from the input sequence that occur before the element at which the test no longer passes.\n   */\n  observableProto.takeWhile = function (predicate, thisArg) {\n    var fn = bindCallback(predicate, thisArg, 3);\n    return new TakeWhileObservable(this, fn);\n  };\n\n  var FilterObservable = (function (__super__) {\n    inherits(FilterObservable, __super__);\n\n    function FilterObservable(source, predicate, thisArg) {\n      this.source = source;\n      this.predicate = bindCallback(predicate, thisArg, 3);\n      __super__.call(this);\n    }\n\n    FilterObservable.prototype.subscribeCore = function (o) {\n      return this.source.subscribe(new InnerObserver(o, this.predicate, this));\n    };\n\n    function innerPredicate(predicate, self) {\n      return function(x, i, o) { return self.predicate(x, i, o) && predicate.call(this, x, i, o); }\n    }\n\n    FilterObservable.prototype.internalFilter = function(predicate, thisArg) {\n      return new FilterObservable(this.source, innerPredicate(predicate, this), thisArg);\n    };\n\n    inherits(InnerObserver, AbstractObserver);\n    function InnerObserver(o, predicate, source) {\n      this.o = o;\n      this.predicate = predicate;\n      this.source = source;\n      this.i = 0;\n      AbstractObserver.call(this);\n    }\n\n    InnerObserver.prototype.next = function(x) {\n      var shouldYield = tryCatch(this.predicate)(x, this.i++, this.source);\n      if (shouldYield === errorObj) {\n        return this.o.onError(shouldYield.e);\n      }\n      shouldYield && this.o.onNext(x);\n    };\n\n    InnerObserver.prototype.error = function (e) {\n      this.o.onError(e);\n    };\n\n    InnerObserver.prototype.completed = function () {\n      this.o.onCompleted();\n    };\n\n    return FilterObservable;\n\n  }(ObservableBase));\n\n  /**\n  *  Filters the elements of an observable sequence based on a predicate by incorporating the element's index.\n  * @param {Function} predicate A function to test each source element for a condition; the second parameter of the function represents the index of the source element.\n  * @param {Any} [thisArg] Object to use as this when executing callback.\n  * @returns {Observable} An observable sequence that contains elements from the input sequence that satisfy the condition.\n  */\n  observableProto.filter = observableProto.where = function (predicate, thisArg) {\n    return this instanceof FilterObservable ? this.internalFilter(predicate, thisArg) :\n      new FilterObservable(this, predicate, thisArg);\n  };\n\n  var ExtremaByObservable = (function (__super__) {\n    inherits(ExtremaByObservable, __super__);\n    function ExtremaByObservable(source, k, c) {\n      this.source = source;\n      this._k = k;\n      this._c = c;\n      __super__.call(this);\n    }\n\n    ExtremaByObservable.prototype.subscribeCore = function (o) {\n      return this.source.subscribe(new ExtremaByObserver(o, this._k, this._c));\n    };\n\n    return ExtremaByObservable;\n  }(ObservableBase));\n\n  var ExtremaByObserver = (function (__super__) {\n    inherits(ExtremaByObserver, __super__);\n    function ExtremaByObserver(o, k, c) {\n      this._o = o;\n      this._k = k;\n      this._c = c;\n      this._v = null;\n      this._hv = false;\n      this._l = [];\n      __super__.call(this);\n    }\n\n    ExtremaByObserver.prototype.next = function (x) {\n      var key = tryCatch(this._k)(x);\n      if (key === errorObj) { return this._o.onError(key.e); }\n      var comparison = 0;\n      if (!this._hv) {\n        this._hv = true;\n        this._v = key;\n      } else {\n        comparison = tryCatch(this._c)(key, this._v);\n        if (comparison === errorObj) { return this._o.onError(comparison.e); }\n      }\n      if (comparison > 0) {\n        this._v = key;\n        this._l = [];\n      }\n      if (comparison >= 0) { this._l.push(x); }\n    };\n\n    ExtremaByObserver.prototype.error = function (e) {\n      this._o.onError(e);\n    };\n\n    ExtremaByObserver.prototype.completed = function () {\n      this._o.onNext(this._l);\n      this._o.onCompleted();\n    };\n\n    return ExtremaByObserver;\n  }(AbstractObserver));\n\n  function firstOnly(x) {\n    if (x.length === 0) { throw new EmptyError(); }\n    return x[0];\n  }\n\n  var ReduceObservable = (function(__super__) {\n    inherits(ReduceObservable, __super__);\n    function ReduceObservable(source, accumulator, hasSeed, seed) {\n      this.source = source;\n      this.accumulator = accumulator;\n      this.hasSeed = hasSeed;\n      this.seed = seed;\n      __super__.call(this);\n    }\n\n    ReduceObservable.prototype.subscribeCore = function(observer) {\n      return this.source.subscribe(new ReduceObserver(observer,this));\n    };\n\n    return ReduceObservable;\n  }(ObservableBase));\n\n  var ReduceObserver = (function (__super__) {\n    inherits(ReduceObserver, __super__);\n    function ReduceObserver(o, parent) {\n      this._o = o;\n      this._p = parent;\n      this._fn = parent.accumulator;\n      this._hs = parent.hasSeed;\n      this._s = parent.seed;\n      this._ha = false;\n      this._a = null;\n      this._hv = false;\n      this._i = 0;\n      __super__.call(this);\n    }\n\n    ReduceObserver.prototype.next = function (x) {\n      !this._hv && (this._hv = true);\n      if (this._ha) {\n        this._a = tryCatch(this._fn)(this._a, x, this._i, this._p);\n      } else {\n        this._a = this._hs ? tryCatch(this._fn)(this._s, x, this._i, this._p) : x;\n        this._ha = true;\n      }\n      if (this._a === errorObj) { return this._o.onError(this._a.e); }\n      this._i++;\n    };\n\n    ReduceObserver.prototype.error = function (e) {\n      this._o.onError(e);\n    };\n\n    ReduceObserver.prototype.completed = function () {\n      this._hv && this._o.onNext(this._a);\n      !this._hv && this._hs && this._o.onNext(this._s);\n      !this._hv && !this._hs && this._o.onError(new EmptyError());\n      this._o.onCompleted();\n    };\n\n    return ReduceObserver;\n  }(AbstractObserver));\n\n  /**\n  * Applies an accumulator function over an observable sequence, returning the result of the aggregation as a single element in the result sequence. The specified seed value is used as the initial accumulator value.\n  * For aggregation behavior with incremental intermediate results, see Observable.scan.\n  * @param {Function} accumulator An accumulator function to be invoked on each element.\n  * @param {Any} [seed] The initial accumulator value.\n  * @returns {Observable} An observable sequence containing a single element with the final accumulator value.\n  */\n  observableProto.reduce = function () {\n    var hasSeed = false, seed, accumulator = arguments[0];\n    if (arguments.length === 2) {\n      hasSeed = true;\n      seed = arguments[1];\n    }\n    return new ReduceObservable(this, accumulator, hasSeed, seed);\n  };\n\n  var SomeObservable = (function (__super__) {\n    inherits(SomeObservable, __super__);\n    function SomeObservable(source, fn) {\n      this.source = source;\n      this._fn = fn;\n      __super__.call(this);\n    }\n\n    SomeObservable.prototype.subscribeCore = function (o) {\n      return this.source.subscribe(new SomeObserver(o, this._fn, this.source));\n    };\n\n    return SomeObservable;\n  }(ObservableBase));\n\n  var SomeObserver = (function (__super__) {\n    inherits(SomeObserver, __super__);\n\n    function SomeObserver(o, fn, s) {\n      this._o = o;\n      this._fn = fn;\n      this._s = s;\n      this._i = 0;\n      __super__.call(this);\n    }\n\n    SomeObserver.prototype.next = function (x) {\n      var result = tryCatch(this._fn)(x, this._i++, this._s);\n      if (result === errorObj) { return this._o.onError(result.e); }\n      if (Boolean(result)) {\n        this._o.onNext(true);\n        this._o.onCompleted();\n      }\n    };\n    SomeObserver.prototype.error = function (e) { this._o.onError(e); };\n    SomeObserver.prototype.completed = function () {\n      this._o.onNext(false);\n      this._o.onCompleted();\n    };\n\n    return SomeObserver;\n  }(AbstractObserver));\n\n  /**\n   * Determines whether any element of an observable sequence satisfies a condition if present, else if any items are in the sequence.\n   * @param {Function} [predicate] A function to test each element for a condition.\n   * @returns {Observable} An observable sequence containing a single element determining whether any elements in the source sequence pass the test in the specified predicate if given, else if any items are in the sequence.\n   */\n  observableProto.some = function (predicate, thisArg) {\n    var fn = bindCallback(predicate, thisArg, 3);\n    return new SomeObservable(this, fn);\n  };\n\n  var IsEmptyObservable = (function (__super__) {\n    inherits(IsEmptyObservable, __super__);\n    function IsEmptyObservable(source) {\n      this.source = source;\n      __super__.call(this);\n    }\n\n    IsEmptyObservable.prototype.subscribeCore = function (o) {\n      return this.source.subscribe(new IsEmptyObserver(o));\n    };\n\n    return IsEmptyObservable;\n  }(ObservableBase));\n\n  var IsEmptyObserver = (function(__super__) {\n    inherits(IsEmptyObserver, __super__);\n    function IsEmptyObserver(o) {\n      this._o = o;\n      __super__.call(this);\n    }\n\n    IsEmptyObserver.prototype.next = function () {\n      this._o.onNext(false);\n      this._o.onCompleted();\n    };\n    IsEmptyObserver.prototype.error = function (e) { this._o.onError(e); };\n    IsEmptyObserver.prototype.completed = function () {\n      this._o.onNext(true);\n      this._o.onCompleted();\n    };\n\n    return IsEmptyObserver;\n  }(AbstractObserver));\n\n  /**\n   * Determines whether an observable sequence is empty.\n   * @returns {Observable} An observable sequence containing a single element determining whether the source sequence is empty.\n   */\n  observableProto.isEmpty = function () {\n    return new IsEmptyObservable(this);\n  };\n\n  var EveryObservable = (function (__super__) {\n    inherits(EveryObservable, __super__);\n    function EveryObservable(source, fn) {\n      this.source = source;\n      this._fn = fn;\n      __super__.call(this);\n    }\n\n    EveryObservable.prototype.subscribeCore = function (o) {\n      return this.source.subscribe(new EveryObserver(o, this._fn, this.source));\n    };\n\n    return EveryObservable;\n  }(ObservableBase));\n\n  var EveryObserver = (function (__super__) {\n    inherits(EveryObserver, __super__);\n\n    function EveryObserver(o, fn, s) {\n      this._o = o;\n      this._fn = fn;\n      this._s = s;\n      this._i = 0;\n      __super__.call(this);\n    }\n\n    EveryObserver.prototype.next = function (x) {\n      var result = tryCatch(this._fn)(x, this._i++, this._s);\n      if (result === errorObj) { return this._o.onError(result.e); }\n      if (!Boolean(result)) {\n        this._o.onNext(false);\n        this._o.onCompleted();\n      }\n    };\n    EveryObserver.prototype.error = function (e) { this._o.onError(e); };\n    EveryObserver.prototype.completed = function () {\n      this._o.onNext(true);\n      this._o.onCompleted();\n    };\n\n    return EveryObserver;\n  }(AbstractObserver));\n\n  /**\n   * Determines whether all elements of an observable sequence satisfy a condition.\n   * @param {Function} [predicate] A function to test each element for a condition.\n   * @param {Any} [thisArg] Object to use as this when executing callback.\n   * @returns {Observable} An observable sequence containing a single element determining whether all elements in the source sequence pass the test in the specified predicate.\n   */\n  observableProto.every = function (predicate, thisArg) {\n    var fn = bindCallback(predicate, thisArg, 3);\n    return new EveryObservable(this, fn);\n  };\n\n  var IncludesObservable = (function (__super__) {\n    inherits(IncludesObservable, __super__);\n    function IncludesObservable(source, elem, idx) {\n      var n = +idx || 0;\n      Math.abs(n) === Infinity && (n = 0);\n\n      this.source = source;\n      this._elem = elem;\n      this._n = n;\n      __super__.call(this);\n    }\n\n    IncludesObservable.prototype.subscribeCore = function (o) {\n      if (this._n < 0) {\n        o.onNext(false);\n        o.onCompleted();\n        return disposableEmpty;\n      }\n\n      return this.source.subscribe(new IncludesObserver(o, this._elem, this._n));\n    };\n\n    return IncludesObservable;\n  }(ObservableBase));\n\n  var IncludesObserver = (function (__super__) {\n    inherits(IncludesObserver, __super__);\n    function IncludesObserver(o, elem, n) {\n      this._o = o;\n      this._elem = elem;\n      this._n = n;\n      this._i = 0;\n      __super__.call(this);\n    }\n\n    function comparer(a, b) {\n      return (a === 0 && b === 0) || (a === b || (isNaN(a) && isNaN(b)));\n    }\n\n    IncludesObserver.prototype.next = function (x) {\n      if (this._i++ >= this._n && comparer(x, this._elem)) {\n        this._o.onNext(true);\n        this._o.onCompleted();\n      }\n    };\n    IncludesObserver.prototype.error = function (e) { this._o.onError(e); };\n    IncludesObserver.prototype.completed = function () { this._o.onNext(false); this._o.onCompleted(); };\n\n    return IncludesObserver;\n  }(AbstractObserver));\n\n  /**\n   * Determines whether an observable sequence includes a specified element with an optional equality comparer.\n   * @param searchElement The value to locate in the source sequence.\n   * @param {Number} [fromIndex] An equality comparer to compare elements.\n   * @returns {Observable} An observable sequence containing a single element determining whether the source sequence includes an element that has the specified value from the given index.\n   */\n  observableProto.includes = function (searchElement, fromIndex) {\n    return new IncludesObservable(this, searchElement, fromIndex);\n  };\n\n  var CountObservable = (function (__super__) {\n    inherits(CountObservable, __super__);\n    function CountObservable(source, fn) {\n      this.source = source;\n      this._fn = fn;\n      __super__.call(this);\n    }\n\n    CountObservable.prototype.subscribeCore = function (o) {\n      return this.source.subscribe(new CountObserver(o, this._fn, this.source));\n    };\n\n    return CountObservable;\n  }(ObservableBase));\n\n  var CountObserver = (function (__super__) {\n    inherits(CountObserver, __super__);\n\n    function CountObserver(o, fn, s) {\n      this._o = o;\n      this._fn = fn;\n      this._s = s;\n      this._i = 0;\n      this._c = 0;\n      __super__.call(this);\n    }\n\n    CountObserver.prototype.next = function (x) {\n      if (this._fn) {\n        var result = tryCatch(this._fn)(x, this._i++, this._s);\n        if (result === errorObj) { return this._o.onError(result.e); }\n        Boolean(result) && (this._c++);\n      } else {\n        this._c++;\n      }\n    };\n    CountObserver.prototype.error = function (e) { this._o.onError(e); };\n    CountObserver.prototype.completed = function () {\n      this._o.onNext(this._c);\n      this._o.onCompleted();\n    };\n\n    return CountObserver;\n  }(AbstractObserver));\n\n  /**\n   * Returns an observable sequence containing a value that represents how many elements in the specified observable sequence satisfy a condition if provided, else the count of items.\n   * @example\n   * res = source.count();\n   * res = source.count(function (x) { return x > 3; });\n   * @param {Function} [predicate]A function to test each element for a condition.\n   * @param {Any} [thisArg] Object to use as this when executing callback.\n   * @returns {Observable} An observable sequence containing a single element with a number that represents how many elements in the input sequence satisfy the condition in the predicate function if provided, else the count of items in the sequence.\n   */\n  observableProto.count = function (predicate, thisArg) {\n    var fn = bindCallback(predicate, thisArg, 3);\n    return new CountObservable(this, fn);\n  };\n\n  var IndexOfObservable = (function (__super__) {\n    inherits(IndexOfObservable, __super__);\n    function IndexOfObservable(source, e, n) {\n      this.source = source;\n      this._e = e;\n      this._n = n;\n      __super__.call(this);\n    }\n\n    IndexOfObservable.prototype.subscribeCore = function (o) {\n      if (this._n < 0) {\n        o.onNext(-1);\n        o.onCompleted();\n        return disposableEmpty;\n      }\n\n      return this.source.subscribe(new IndexOfObserver(o, this._e, this._n));\n    };\n\n    return IndexOfObservable;\n  }(ObservableBase));\n\n  var IndexOfObserver = (function (__super__) {\n    inherits(IndexOfObserver, __super__);\n    function IndexOfObserver(o, e, n) {\n      this._o = o;\n      this._e = e;\n      this._n = n;\n      this._i = 0;\n      __super__.call(this);\n    }\n\n    IndexOfObserver.prototype.next = function (x) {\n      if (this._i >= this._n && x === this._e) {\n        this._o.onNext(this._i);\n        this._o.onCompleted();\n      }\n      this._i++;\n    };\n    IndexOfObserver.prototype.error = function (e) { this._o.onError(e); };\n    IndexOfObserver.prototype.completed = function () { this._o.onNext(-1); this._o.onCompleted(); };\n\n    return IndexOfObserver;\n  }(AbstractObserver));\n\n  /**\n   * Returns the first index at which a given element can be found in the observable sequence, or -1 if it is not present.\n   * @param {Any} searchElement Element to locate in the array.\n   * @param {Number} [fromIndex] The index to start the search.  If not specified, defaults to 0.\n   * @returns {Observable} And observable sequence containing the first index at which a given element can be found in the observable sequence, or -1 if it is not present.\n   */\n  observableProto.indexOf = function(searchElement, fromIndex) {\n    var n = +fromIndex || 0;\n    Math.abs(n) === Infinity && (n = 0);\n    return new IndexOfObservable(this, searchElement, n);\n  };\n\n  var SumObservable = (function (__super__) {\n    inherits(SumObservable, __super__);\n    function SumObservable(source, fn) {\n      this.source = source;\n      this._fn = fn;\n      __super__.call(this);\n    }\n\n    SumObservable.prototype.subscribeCore = function (o) {\n      return this.source.subscribe(new SumObserver(o, this._fn, this.source));\n    };\n\n    return SumObservable;\n  }(ObservableBase));\n\n  var SumObserver = (function (__super__) {\n    inherits(SumObserver, __super__);\n\n    function SumObserver(o, fn, s) {\n      this._o = o;\n      this._fn = fn;\n      this._s = s;\n      this._i = 0;\n      this._c = 0;\n      __super__.call(this);\n    }\n\n    SumObserver.prototype.next = function (x) {\n      if (this._fn) {\n        var result = tryCatch(this._fn)(x, this._i++, this._s);\n        if (result === errorObj) { return this._o.onError(result.e); }\n        this._c += result;\n      } else {\n        this._c += x;\n      }\n    };\n    SumObserver.prototype.error = function (e) { this._o.onError(e); };\n    SumObserver.prototype.completed = function () {\n      this._o.onNext(this._c);\n      this._o.onCompleted();\n    };\n\n    return SumObserver;\n  }(AbstractObserver));\n\n  /**\n   * Computes the sum of a sequence of values that are obtained by invoking an optional transform function on each element of the input sequence, else if not specified computes the sum on each item in the sequence.\n   * @param {Function} [selector] A transform function to apply to each element.\n   * @param {Any} [thisArg] Object to use as this when executing callback.\n   * @returns {Observable} An observable sequence containing a single element with the sum of the values in the source sequence.\n   */\n  observableProto.sum = function (keySelector, thisArg) {\n    var fn = bindCallback(keySelector, thisArg, 3);\n    return new SumObservable(this, fn);\n  };\n\n  /**\n   * Returns the elements in an observable sequence with the minimum key value according to the specified comparer.\n   * @example\n   * var res = source.minBy(function (x) { return x.value; });\n   * var res = source.minBy(function (x) { return x.value; }, function (x, y) { return x - y; });\n   * @param {Function} keySelector Key selector function.\n   * @param {Function} [comparer] Comparer used to compare key values.\n   * @returns {Observable} An observable sequence containing a list of zero or more elements that have a minimum key value.\n   */\n  observableProto.minBy = function (keySelector, comparer) {\n    comparer || (comparer = defaultSubComparer);\n    return new ExtremaByObservable(this, keySelector, function (x, y) { return comparer(x, y) * -1; });\n  };\n\n  /**\n   * Returns the minimum element in an observable sequence according to the optional comparer else a default greater than less than check.\n   * @example\n   * var res = source.min();\n   * var res = source.min(function (x, y) { return x.value - y.value; });\n   * @param {Function} [comparer] Comparer used to compare elements.\n   * @returns {Observable} An observable sequence containing a single element with the minimum element in the source sequence.\n   */\n  observableProto.min = function (comparer) {\n    return this.minBy(identity, comparer).map(function (x) { return firstOnly(x); });\n  };\n\n  /**\n   * Returns the elements in an observable sequence with the maximum  key value according to the specified comparer.\n   * @example\n   * var res = source.maxBy(function (x) { return x.value; });\n   * var res = source.maxBy(function (x) { return x.value; }, function (x, y) { return x - y;; });\n   * @param {Function} keySelector Key selector function.\n   * @param {Function} [comparer]  Comparer used to compare key values.\n   * @returns {Observable} An observable sequence containing a list of zero or more elements that have a maximum key value.\n   */\n  observableProto.maxBy = function (keySelector, comparer) {\n    comparer || (comparer = defaultSubComparer);\n    return new ExtremaByObservable(this, keySelector, comparer);\n  };\n\n  /**\n   * Returns the maximum value in an observable sequence according to the specified comparer.\n   * @example\n   * var res = source.max();\n   * var res = source.max(function (x, y) { return x.value - y.value; });\n   * @param {Function} [comparer] Comparer used to compare elements.\n   * @returns {Observable} An observable sequence containing a single element with the maximum element in the source sequence.\n   */\n  observableProto.max = function (comparer) {\n    return this.maxBy(identity, comparer).map(function (x) { return firstOnly(x); });\n  };\n\n  var AverageObservable = (function (__super__) {\n    inherits(AverageObservable, __super__);\n    function AverageObservable(source, fn) {\n      this.source = source;\n      this._fn = fn;\n      __super__.call(this);\n    }\n\n    AverageObservable.prototype.subscribeCore = function (o) {\n      return this.source.subscribe(new AverageObserver(o, this._fn, this.source));\n    };\n\n    return AverageObservable;\n  }(ObservableBase));\n\n  var AverageObserver = (function(__super__) {\n    inherits(AverageObserver, __super__);\n    function AverageObserver(o, fn, s) {\n      this._o = o;\n      this._fn = fn;\n      this._s = s;\n      this._c = 0;\n      this._t = 0;\n      __super__.call(this);\n    }\n\n    AverageObserver.prototype.next = function (x) {\n      if(this._fn) {\n        var r = tryCatch(this._fn)(x, this._c++, this._s);\n        if (r === errorObj) { return this._o.onError(r.e); }\n        this._t += r;\n      } else {\n        this._c++;\n        this._t += x;\n      }\n    };\n    AverageObserver.prototype.error = function (e) { this._o.onError(e); };\n    AverageObserver.prototype.completed = function () {\n      if (this._c === 0) { return this._o.onError(new EmptyError()); }\n      this._o.onNext(this._t / this._c);\n      this._o.onCompleted();\n    };\n\n    return AverageObserver;\n  }(AbstractObserver));\n\n  /**\n   * Computes the average of an observable sequence of values that are in the sequence or obtained by invoking a transform function on each element of the input sequence if present.\n   * @param {Function} [selector] A transform function to apply to each element.\n   * @param {Any} [thisArg] Object to use as this when executing callback.\n   * @returns {Observable} An observable sequence containing a single element with the average of the sequence of values.\n   */\n  observableProto.average = function (keySelector, thisArg) {\n    var source = this, fn;\n    if (isFunction(keySelector)) {\n      fn = bindCallback(keySelector, thisArg, 3);\n    }\n    return new AverageObservable(source, fn);\n  };\n\n  /**\n   *  Determines whether two sequences are equal by comparing the elements pairwise using a specified equality comparer.\n   *\n   * @example\n   * var res = res = source.sequenceEqual([1,2,3]);\n   * var res = res = source.sequenceEqual([{ value: 42 }], function (x, y) { return x.value === y.value; });\n   * 3 - res = source.sequenceEqual(Rx.Observable.returnValue(42));\n   * 4 - res = source.sequenceEqual(Rx.Observable.returnValue({ value: 42 }), function (x, y) { return x.value === y.value; });\n   * @param {Observable} second Second observable sequence or array to compare.\n   * @param {Function} [comparer] Comparer used to compare elements of both sequences.\n   * @returns {Observable} An observable sequence that contains a single element which indicates whether both sequences are of equal length and their corresponding elements are equal according to the specified equality comparer.\n   */\n  observableProto.sequenceEqual = function (second, comparer) {\n    var first = this;\n    comparer || (comparer = defaultComparer);\n    return new AnonymousObservable(function (o) {\n      var donel = false, doner = false, ql = [], qr = [];\n      var subscription1 = first.subscribe(function (x) {\n        if (qr.length > 0) {\n          var v = qr.shift();\n          var equal = tryCatch(comparer)(v, x);\n          if (equal === errorObj) { return o.onError(equal.e); }\n          if (!equal) {\n            o.onNext(false);\n            o.onCompleted();\n          }\n        } else if (doner) {\n          o.onNext(false);\n          o.onCompleted();\n        } else {\n          ql.push(x);\n        }\n      }, function(e) { o.onError(e); }, function () {\n        donel = true;\n        if (ql.length === 0) {\n          if (qr.length > 0) {\n            o.onNext(false);\n            o.onCompleted();\n          } else if (doner) {\n            o.onNext(true);\n            o.onCompleted();\n          }\n        }\n      });\n\n      (isArrayLike(second) || isIterable(second)) && (second = observableFrom(second));\n      isPromise(second) && (second = observableFromPromise(second));\n      var subscription2 = second.subscribe(function (x) {\n        if (ql.length > 0) {\n          var v = ql.shift();\n          var equal = tryCatch(comparer)(v, x);\n          if (equal === errorObj) { return o.onError(equal.e); }\n          if (!equal) {\n            o.onNext(false);\n            o.onCompleted();\n          }\n        } else if (donel) {\n          o.onNext(false);\n          o.onCompleted();\n        } else {\n          qr.push(x);\n        }\n      }, function(e) { o.onError(e); }, function () {\n        doner = true;\n        if (qr.length === 0) {\n          if (ql.length > 0) {\n            o.onNext(false);\n            o.onCompleted();\n          } else if (donel) {\n            o.onNext(true);\n            o.onCompleted();\n          }\n        }\n      });\n      return new BinaryDisposable(subscription1, subscription2);\n    }, first);\n  };\n\n  var ElementAtObservable = (function (__super__) {\n    inherits(ElementAtObservable, __super__);\n    function ElementAtObservable(source, i, d) {\n      this.source = source;\n      this._i = i;\n      this._d = d;\n      __super__.call(this);\n    }\n\n    ElementAtObservable.prototype.subscribeCore = function (o) {\n      return this.source.subscribe(new ElementAtObserver(o, this._i, this._d));\n    };\n\n    return ElementAtObservable;\n  }(ObservableBase));\n\n  var ElementAtObserver = (function (__super__) {\n    inherits(ElementAtObserver, __super__);\n\n    function ElementAtObserver(o, i, d) {\n      this._o = o;\n      this._i = i;\n      this._d = d;\n      __super__.call(this);\n    }\n\n    ElementAtObserver.prototype.next = function (x) {\n      if (this._i-- === 0) {\n        this._o.onNext(x);\n        this._o.onCompleted();\n      }\n    };\n    ElementAtObserver.prototype.error = function (e) { this._o.onError(e); };\n    ElementAtObserver.prototype.completed = function () {\n      if (this._d === undefined) {\n        this._o.onError(new ArgumentOutOfRangeError());\n      } else {\n        this._o.onNext(this._d);\n        this._o.onCompleted();\n      }\n    };\n\n    return ElementAtObserver;\n  }(AbstractObserver));\n\n  /**\n   * Returns the element at a specified index in a sequence or default value if not found.\n   * @param {Number} index The zero-based index of the element to retrieve.\n   * @param {Any} [defaultValue] The default value to use if elementAt does not find a value.\n   * @returns {Observable} An observable sequence that produces the element at the specified position in the source sequence.\n   */\n  observableProto.elementAt =  function (index, defaultValue) {\n    if (index < 0) { throw new ArgumentOutOfRangeError(); }\n    return new ElementAtObservable(this, index, defaultValue);\n  };\n\n  var SingleObserver = (function(__super__) {\n    inherits(SingleObserver, __super__);\n    function SingleObserver(o, obj, s) {\n      this._o = o;\n      this._obj = obj;\n      this._s = s;\n      this._i = 0;\n      this._hv = false;\n      this._v = null;\n      __super__.call(this);\n    }\n\n    SingleObserver.prototype.next = function (x) {\n      var shouldYield = false;\n      if (this._obj.predicate) {\n        var res = tryCatch(this._obj.predicate)(x, this._i++, this._s);\n        if (res === errorObj) { return this._o.onError(res.e); }\n        Boolean(res) && (shouldYield = true);\n      } else if (!this._obj.predicate) {\n        shouldYield = true;\n      }\n      if (shouldYield) {\n        if (this._hv) {\n          return this._o.onError(new Error('Sequence contains more than one matching element'));\n        }\n        this._hv = true;\n        this._v = x;\n      }\n    };\n    SingleObserver.prototype.error = function (e) { this._o.onError(e); };\n    SingleObserver.prototype.completed = function () {\n      if (this._hv) {\n        this._o.onNext(this._v);\n        this._o.onCompleted();\n      }\n      else if (this._obj.defaultValue === undefined) {\n        this._o.onError(new EmptyError());\n      } else {\n        this._o.onNext(this._obj.defaultValue);\n        this._o.onCompleted();\n      }\n    };\n\n    return SingleObserver;\n  }(AbstractObserver));\n\n\n    /**\n     * Returns the only element of an observable sequence that satisfies the condition in the optional predicate, and reports an exception if there is not exactly one element in the observable sequence.\n     * @returns {Observable} Sequence containing the single element in the observable sequence that satisfies the condition in the predicate.\n     */\n    observableProto.single = function (predicate, thisArg) {\n      var obj = {}, source = this;\n      if (typeof arguments[0] === 'object') {\n        obj = arguments[0];\n      } else {\n        obj = {\n          predicate: arguments[0],\n          thisArg: arguments[1],\n          defaultValue: arguments[2]\n        };\n      }\n      if (isFunction (obj.predicate)) {\n        var fn = obj.predicate;\n        obj.predicate = bindCallback(fn, obj.thisArg, 3);\n      }\n      return new AnonymousObservable(function (o) {\n        return source.subscribe(new SingleObserver(o, obj, source));\n      }, source);\n    };\n\n  var FirstObservable = (function (__super__) {\n    inherits(FirstObservable, __super__);\n    function FirstObservable(source, obj) {\n      this.source = source;\n      this._obj = obj;\n      __super__.call(this);\n    }\n\n    FirstObservable.prototype.subscribeCore = function (o) {\n      return this.source.subscribe(new FirstObserver(o, this._obj, this.source));\n    };\n\n    return FirstObservable;\n  }(ObservableBase));\n\n  var FirstObserver = (function(__super__) {\n    inherits(FirstObserver, __super__);\n    function FirstObserver(o, obj, s) {\n      this._o = o;\n      this._obj = obj;\n      this._s = s;\n      this._i = 0;\n      __super__.call(this);\n    }\n\n    FirstObserver.prototype.next = function (x) {\n      if (this._obj.predicate) {\n        var res = tryCatch(this._obj.predicate)(x, this._i++, this._s);\n        if (res === errorObj) { return this._o.onError(res.e); }\n        if (Boolean(res)) {\n          this._o.onNext(x);\n          this._o.onCompleted();\n        }\n      } else if (!this._obj.predicate) {\n        this._o.onNext(x);\n        this._o.onCompleted();\n      }\n    };\n    FirstObserver.prototype.error = function (e) { this._o.onError(e); };\n    FirstObserver.prototype.completed = function () {\n      if (this._obj.defaultValue === undefined) {\n        this._o.onError(new EmptyError());\n      } else {\n        this._o.onNext(this._obj.defaultValue);\n        this._o.onCompleted();\n      }\n    };\n\n    return FirstObserver;\n  }(AbstractObserver));\n\n  /**\n   * Returns the first element of an observable sequence that satisfies the condition in the predicate if present else the first item in the sequence.\n   * @returns {Observable} Sequence containing the first element in the observable sequence that satisfies the condition in the predicate if provided, else the first item in the sequence.\n   */\n  observableProto.first = function () {\n    var obj = {}, source = this;\n    if (typeof arguments[0] === 'object') {\n      obj = arguments[0];\n    } else {\n      obj = {\n        predicate: arguments[0],\n        thisArg: arguments[1],\n        defaultValue: arguments[2]\n      };\n    }\n    if (isFunction (obj.predicate)) {\n      var fn = obj.predicate;\n      obj.predicate = bindCallback(fn, obj.thisArg, 3);\n    }\n    return new FirstObservable(this, obj);\n  };\n\n  var LastObservable = (function (__super__) {\n    inherits(LastObservable, __super__);\n    function LastObservable(source, obj) {\n      this.source = source;\n      this._obj = obj;\n      __super__.call(this);\n    }\n\n    LastObservable.prototype.subscribeCore = function (o) {\n      return this.source.subscribe(new LastObserver(o, this._obj, this.source));\n    };\n\n    return LastObservable;\n  }(ObservableBase));\n\n  var LastObserver = (function(__super__) {\n    inherits(LastObserver, __super__);\n    function LastObserver(o, obj, s) {\n      this._o = o;\n      this._obj = obj;\n      this._s = s;\n      this._i = 0;\n      this._hv = false;\n      this._v = null;\n      __super__.call(this);\n    }\n\n    LastObserver.prototype.next = function (x) {\n      var shouldYield = false;\n      if (this._obj.predicate) {\n        var res = tryCatch(this._obj.predicate)(x, this._i++, this._s);\n        if (res === errorObj) { return this._o.onError(res.e); }\n        Boolean(res) && (shouldYield = true);\n      } else if (!this._obj.predicate) {\n        shouldYield = true;\n      }\n      if (shouldYield) {\n        this._hv = true;\n        this._v = x;\n      }\n    };\n    LastObserver.prototype.error = function (e) { this._o.onError(e); };\n    LastObserver.prototype.completed = function () {\n      if (this._hv) {\n        this._o.onNext(this._v);\n        this._o.onCompleted();\n      }\n      else if (this._obj.defaultValue === undefined) {\n        this._o.onError(new EmptyError());\n      } else {\n        this._o.onNext(this._obj.defaultValue);\n        this._o.onCompleted();\n      }\n    };\n\n    return LastObserver;\n  }(AbstractObserver));\n\n  /**\n   * Returns the last element of an observable sequence that satisfies the condition in the predicate if specified, else the last element.\n   * @returns {Observable} Sequence containing the last element in the observable sequence that satisfies the condition in the predicate.\n   */\n  observableProto.last = function () {\n    var obj = {}, source = this;\n    if (typeof arguments[0] === 'object') {\n      obj = arguments[0];\n    } else {\n      obj = {\n        predicate: arguments[0],\n        thisArg: arguments[1],\n        defaultValue: arguments[2]\n      };\n    }\n    if (isFunction (obj.predicate)) {\n      var fn = obj.predicate;\n      obj.predicate = bindCallback(fn, obj.thisArg, 3);\n    }\n    return new LastObservable(this, obj);\n  };\n\n  var FindValueObserver = (function(__super__) {\n    inherits(FindValueObserver, __super__);\n    function FindValueObserver(observer, source, callback, yieldIndex) {\n      this._o = observer;\n      this._s = source;\n      this._cb = callback;\n      this._y = yieldIndex;\n      this._i = 0;\n      __super__.call(this);\n    }\n\n    FindValueObserver.prototype.next = function (x) {\n      var shouldRun = tryCatch(this._cb)(x, this._i, this._s);\n      if (shouldRun === errorObj) { return this._o.onError(shouldRun.e); }\n      if (shouldRun) {\n        this._o.onNext(this._y ? this._i : x);\n        this._o.onCompleted();\n      } else {\n        this._i++;\n      }\n    };\n\n    FindValueObserver.prototype.error = function (e) {\n      this._o.onError(e);\n    };\n\n    FindValueObserver.prototype.completed = function () {\n      this._y && this._o.onNext(-1);\n      this._o.onCompleted();\n    };\n\n    return FindValueObserver;\n  }(AbstractObserver));\n\n  function findValue (source, predicate, thisArg, yieldIndex) {\n    var callback = bindCallback(predicate, thisArg, 3);\n    return new AnonymousObservable(function (o) {\n      return source.subscribe(new FindValueObserver(o, source, callback, yieldIndex));\n    }, source);\n  }\n\n  /**\n   * Searches for an element that matches the conditions defined by the specified predicate, and returns the first occurrence within the entire Observable sequence.\n   * @param {Function} predicate The predicate that defines the conditions of the element to search for.\n   * @param {Any} [thisArg] Object to use as `this` when executing the predicate.\n   * @returns {Observable} An Observable sequence with the first element that matches the conditions defined by the specified predicate, if found; otherwise, undefined.\n   */\n  observableProto.find = function (predicate, thisArg) {\n    return findValue(this, predicate, thisArg, false);\n  };\n\n  /**\n   * Searches for an element that matches the conditions defined by the specified predicate, and returns\n   * an Observable sequence with the zero-based index of the first occurrence within the entire Observable sequence.\n   * @param {Function} predicate The predicate that defines the conditions of the element to search for.\n   * @param {Any} [thisArg] Object to use as `this` when executing the predicate.\n   * @returns {Observable} An Observable sequence with the zero-based index of the first occurrence of an element that matches the conditions defined by match, if found; otherwise, –1.\n  */\n  observableProto.findIndex = function (predicate, thisArg) {\n    return findValue(this, predicate, thisArg, true);\n  };\n\n  var ToSetObservable = (function (__super__) {\n    inherits(ToSetObservable, __super__);\n    function ToSetObservable(source) {\n      this.source = source;\n      __super__.call(this);\n    }\n\n    ToSetObservable.prototype.subscribeCore = function (o) {\n      return this.source.subscribe(new ToSetObserver(o));\n    };\n\n    return ToSetObservable;\n  }(ObservableBase));\n\n  var ToSetObserver = (function (__super__) {\n    inherits(ToSetObserver, __super__);\n    function ToSetObserver(o) {\n      this._o = o;\n      this._s = new root.Set();\n      __super__.call(this);\n    }\n\n    ToSetObserver.prototype.next = function (x) {\n      this._s.add(x);\n    };\n\n    ToSetObserver.prototype.error = function (e) {\n      this._o.onError(e);\n    };\n\n    ToSetObserver.prototype.completed = function () {\n      this._o.onNext(this._s);\n      this._o.onCompleted();\n    };\n\n    return ToSetObserver;\n  }(AbstractObserver));\n\n  /**\n   * Converts the observable sequence to a Set if it exists.\n   * @returns {Observable} An observable sequence with a single value of a Set containing the values from the observable sequence.\n   */\n  observableProto.toSet = function () {\n    if (typeof root.Set === 'undefined') { throw new TypeError(); }\n    return new ToSetObservable(this);\n  };\n\n  var ToMapObservable = (function (__super__) {\n    inherits(ToMapObservable, __super__);\n    function ToMapObservable(source, k, e) {\n      this.source = source;\n      this._k = k;\n      this._e = e;\n      __super__.call(this);\n    }\n\n    ToMapObservable.prototype.subscribeCore = function (o) {\n      return this.source.subscribe(new ToMapObserver(o, this._k, this._e));\n    };\n\n    return ToMapObservable;\n  }(ObservableBase));\n\n  var ToMapObserver = (function (__super__) {\n    inherits(ToMapObserver, __super__);\n    function ToMapObserver(o, k, e) {\n      this._o = o;\n      this._k = k;\n      this._e = e;\n      this._m = new root.Map();\n      __super__.call(this);\n    }\n\n    ToMapObserver.prototype.next = function (x) {\n      var key = tryCatch(this._k)(x);\n      if (key === errorObj) { return this._o.onError(key.e); }\n      var elem = x;\n      if (this._e) {\n        elem = tryCatch(this._e)(x);\n        if (elem === errorObj) { return this._o.onError(elem.e); }\n      }\n\n      this._m.set(key, elem);\n    };\n\n    ToMapObserver.prototype.error = function (e) {\n      this._o.onError(e);\n    };\n\n    ToMapObserver.prototype.completed = function () {\n      this._o.onNext(this._m);\n      this._o.onCompleted();\n    };\n\n    return ToMapObserver;\n  }(AbstractObserver));\n\n  /**\n  * Converts the observable sequence to a Map if it exists.\n  * @param {Function} keySelector A function which produces the key for the Map.\n  * @param {Function} [elementSelector] An optional function which produces the element for the Map. If not present, defaults to the value from the observable sequence.\n  * @returns {Observable} An observable sequence with a single value of a Map containing the values from the observable sequence.\n  */\n  observableProto.toMap = function (keySelector, elementSelector) {\n    if (typeof root.Map === 'undefined') { throw new TypeError(); }\n    return new ToMapObservable(this, keySelector, elementSelector);\n  };\n\n  var SliceObservable = (function (__super__) {\n    inherits(SliceObservable, __super__);\n    function SliceObservable(source, b, e) {\n      this.source = source;\n      this._b = b;\n      this._e = e;\n      __super__.call(this);\n    }\n\n    SliceObservable.prototype.subscribeCore = function (o) {\n      return this.source.subscribe(new SliceObserver(o, this._b, this._e));\n    };\n\n    return SliceObservable;\n  }(ObservableBase));\n\n  var SliceObserver = (function (__super__) {\n    inherits(SliceObserver, __super__);\n\n    function SliceObserver(o, b, e) {\n      this._o = o;\n      this._b = b;\n      this._e = e;\n      this._i = 0;\n      __super__.call(this);\n    }\n\n    SliceObserver.prototype.next = function (x) {\n      if (this._i >= this._b) {\n        if (this._e === this._i) {\n          this._o.onCompleted();\n        } else {\n          this._o.onNext(x);\n        }\n      }\n      this._i++;\n    };\n    SliceObserver.prototype.error = function (e) { this._o.onError(e); };\n    SliceObserver.prototype.completed = function () { this._o.onCompleted(); };\n\n    return SliceObserver;\n  }(AbstractObserver));\n\n  /*\n  * The slice() method returns a shallow copy of a portion of an Observable into a new Observable object.\n  * Unlike the array version, this does not support negative numbers for being or end.\n  * @param {Number} [begin] Zero-based index at which to begin extraction. If omitted, this will default to zero.\n  * @param {Number} [end] Zero-based index at which to end extraction. slice extracts up to but not including end.\n  * If omitted, this will emit the rest of the Observable object.\n  * @returns {Observable} A shallow copy of a portion of an Observable into a new Observable object.\n  */\n  observableProto.slice = function (begin, end) {\n    var start = begin || 0;\n    if (start < 0) { throw new Rx.ArgumentOutOfRangeError(); }\n    if (typeof end === 'number' && end < start) {\n      throw new Rx.ArgumentOutOfRangeError();\n    }\n    return new SliceObservable(this, start, end);\n  };\n\n  var LastIndexOfObservable = (function (__super__) {\n    inherits(LastIndexOfObservable, __super__);\n    function LastIndexOfObservable(source, e, n) {\n      this.source = source;\n      this._e = e;\n      this._n = n;\n      __super__.call(this);\n    }\n\n    LastIndexOfObservable.prototype.subscribeCore = function (o) {\n      if (this._n < 0) {\n        o.onNext(-1);\n        o.onCompleted();\n        return disposableEmpty;\n      }\n\n      return this.source.subscribe(new LastIndexOfObserver(o, this._e, this._n));\n    };\n\n    return LastIndexOfObservable;\n  }(ObservableBase));\n\n  var LastIndexOfObserver = (function (__super__) {\n    inherits(LastIndexOfObserver, __super__);\n    function LastIndexOfObserver(o, e, n) {\n      this._o = o;\n      this._e = e;\n      this._n = n;\n      this._v = 0;\n      this._hv = false;\n      this._i = 0;\n      __super__.call(this);\n    }\n\n    LastIndexOfObserver.prototype.next = function (x) {\n      if (this._i >= this._n && x === this._e) {\n        this._hv = true;\n        this._v = this._i;\n      }\n      this._i++;\n    };\n    LastIndexOfObserver.prototype.error = function (e) { this._o.onError(e); };\n    LastIndexOfObserver.prototype.completed = function () {\n      if (this._hv) {\n        this._o.onNext(this._v);\n      } else {\n        this._o.onNext(-1);\n      }\n      this._o.onCompleted();\n    };\n\n    return LastIndexOfObserver;\n  }(AbstractObserver));\n\n  /**\n   * Returns the last index at which a given element can be found in the observable sequence, or -1 if it is not present.\n   * @param {Any} searchElement Element to locate in the array.\n   * @param {Number} [fromIndex] The index to start the search.  If not specified, defaults to 0.\n   * @returns {Observable} And observable sequence containing the last index at which a given element can be found in the observable sequence, or -1 if it is not present.\n   */\n  observableProto.lastIndexOf = function(searchElement, fromIndex) {\n    var n = +fromIndex || 0;\n    Math.abs(n) === Infinity && (n = 0);\n    return new LastIndexOfObservable(this, searchElement, n);\n  };\n\n  Observable.wrap = function (fn) {\n    function createObservable() {\n      return Observable.spawn.call(this, fn.apply(this, arguments));\n    }\n\n    createObservable.__generatorFunction__ = fn;\n    return createObservable;\n  };\n\n  var spawn = Observable.spawn = function () {\n    var gen = arguments[0], self = this, args = [];\n    for (var i = 1, len = arguments.length; i < len; i++) { args.push(arguments[i]); }\n\n    return new AnonymousObservable(function (o) {\n      var g = new CompositeDisposable();\n\n      if (isFunction(gen)) { gen = gen.apply(self, args); }\n      if (!gen || !isFunction(gen.next)) {\n        o.onNext(gen);\n        return o.onCompleted();\n      }\n\n      function processGenerator(res) {\n        var ret = tryCatch(gen.next).call(gen, res);\n        if (ret === errorObj) { return o.onError(ret.e); }\n        next(ret);\n      }\n\n      processGenerator();\n\n      function onError(err) {\n        var ret = tryCatch(gen.next).call(gen, err);\n        if (ret === errorObj) { return o.onError(ret.e); }\n        next(ret);\n      }\n\n      function next(ret) {\n        if (ret.done) {\n          o.onNext(ret.value);\n          o.onCompleted();\n          return;\n        }\n        var obs = toObservable.call(self, ret.value);\n        var value = null;\n        var hasValue = false;\n        if (Observable.isObservable(obs)) {\n          g.add(obs.subscribe(function(val) {\n            hasValue = true;\n            value = val;\n          }, onError, function() {\n            hasValue && processGenerator(value);\n          }));\n        } else {\n          onError(new TypeError('type not supported'));\n        }\n      }\n\n      return g;\n    });\n  };\n\n  function toObservable(obj) {\n    if (!obj) { return obj; }\n    if (Observable.isObservable(obj)) { return obj; }\n    if (isPromise(obj)) { return Observable.fromPromise(obj); }\n    if (isGeneratorFunction(obj) || isGenerator(obj)) { return spawn.call(this, obj); }\n    if (isFunction(obj)) { return thunkToObservable.call(this, obj); }\n    if (isArrayLike(obj) || isIterable(obj)) { return arrayToObservable.call(this, obj); }\n    if (isObject(obj)) {return objectToObservable.call(this, obj);}\n    return obj;\n  }\n\n  function arrayToObservable (obj) {\n    return Observable.from(obj).concatMap(function(o) {\n      if(Observable.isObservable(o) || isObject(o)) {\n        return toObservable.call(null, o);\n      } else {\n        return Rx.Observable.just(o);\n      }\n    }).toArray();\n  }\n\n  function objectToObservable (obj) {\n    var results = new obj.constructor(), keys = Object.keys(obj), observables = [];\n    for (var i = 0, len = keys.length; i < len; i++) {\n      var key = keys[i];\n      var observable = toObservable.call(this, obj[key]);\n\n      if(observable && Observable.isObservable(observable)) {\n        defer(observable, key);\n      } else {\n        results[key] = obj[key];\n      }\n    }\n\n    return Observable.forkJoin.apply(Observable, observables).map(function() {\n      return results;\n    });\n\n\n    function defer (observable, key) {\n      results[key] = undefined;\n      observables.push(observable.map(function (next) {\n        results[key] = next;\n      }));\n    }\n  }\n\n  function thunkToObservable(fn) {\n    var self = this;\n    return new AnonymousObservable(function (o) {\n      fn.call(self, function () {\n        var err = arguments[0], res = arguments[1];\n        if (err) { return o.onError(err); }\n        if (arguments.length > 2) {\n          var args = [];\n          for (var i = 1, len = arguments.length; i < len; i++) { args.push(arguments[i]); }\n          res = args;\n        }\n        o.onNext(res);\n        o.onCompleted();\n      });\n    });\n  }\n\n  function isGenerator(obj) {\n    return isFunction (obj.next) && isFunction (obj['throw']);\n  }\n\n  function isGeneratorFunction(obj) {\n    var ctor = obj.constructor;\n    if (!ctor) { return false; }\n    if (ctor.name === 'GeneratorFunction' || ctor.displayName === 'GeneratorFunction') { return true; }\n    return isGenerator(ctor.prototype);\n  }\n\n  function isObject(val) {\n    return Object == val.constructor;\n  }\n\n  /**\n   * Invokes the specified function asynchronously on the specified scheduler, surfacing the result through an observable sequence.\n   *\n   * @example\n   * var res = Rx.Observable.start(function () { console.log('hello'); });\n   * var res = Rx.Observable.start(function () { console.log('hello'); }, Rx.Scheduler.timeout);\n   * var res = Rx.Observable.start(function () { this.log('hello'); }, Rx.Scheduler.timeout, console);\n   *\n   * @param {Function} func Function to run asynchronously.\n   * @param {Scheduler} [scheduler]  Scheduler to run the function on. If not specified, defaults to Scheduler.timeout.\n   * @param [context]  The context for the func parameter to be executed.  If not specified, defaults to undefined.\n   * @returns {Observable} An observable sequence exposing the function's result value, or an exception.\n   *\n   * Remarks\n   * * The function is called immediately, not during the subscription of the resulting sequence.\n   * * Multiple subscriptions to the resulting sequence can observe the function's result.\n   */\n  Observable.start = function (func, context, scheduler) {\n    return observableToAsync(func, context, scheduler)();\n  };\n\n  /**\n   * Converts the function into an asynchronous function. Each invocation of the resulting asynchronous function causes an invocation of the original synchronous function on the specified scheduler.\n   * @param {Function} function Function to convert to an asynchronous function.\n   * @param {Scheduler} [scheduler] Scheduler to run the function on. If not specified, defaults to Scheduler.timeout.\n   * @param {Mixed} [context] The context for the func parameter to be executed.  If not specified, defaults to undefined.\n   * @returns {Function} Asynchronous function.\n   */\n  var observableToAsync = Observable.toAsync = function (func, context, scheduler) {\n    isScheduler(scheduler) || (scheduler = defaultScheduler);\n    return function () {\n      var args = arguments,\n        subject = new AsyncSubject();\n\n      scheduler.schedule(null, function () {\n        var result;\n        try {\n          result = func.apply(context, args);\n        } catch (e) {\n          subject.onError(e);\n          return;\n        }\n        subject.onNext(result);\n        subject.onCompleted();\n      });\n      return subject.asObservable();\n    };\n  };\n\nfunction createCbObservable(fn, ctx, selector, args) {\n  var o = new AsyncSubject();\n\n  args.push(createCbHandler(o, ctx, selector));\n  fn.apply(ctx, args);\n\n  return o.asObservable();\n}\n\nfunction createCbHandler(o, ctx, selector) {\n  return function handler () {\n    var len = arguments.length, results = new Array(len);\n    for(var i = 0; i < len; i++) { results[i] = arguments[i]; }\n\n    if (isFunction(selector)) {\n      results = tryCatch(selector).apply(ctx, results);\n      if (results === errorObj) { return o.onError(results.e); }\n      o.onNext(results);\n    } else {\n      if (results.length <= 1) {\n        o.onNext(results[0]);\n      } else {\n        o.onNext(results);\n      }\n    }\n\n    o.onCompleted();\n  };\n}\n\n/**\n * Converts a callback function to an observable sequence.\n *\n * @param {Function} fn Function with a callback as the last parameter to convert to an Observable sequence.\n * @param {Mixed} [ctx] The context for the func parameter to be executed.  If not specified, defaults to undefined.\n * @param {Function} [selector] A selector which takes the arguments from the callback to produce a single item to yield on next.\n * @returns {Function} A function, when executed with the required parameters minus the callback, produces an Observable sequence with a single value of the arguments to the callback as an array.\n */\nObservable.fromCallback = function (fn, ctx, selector) {\n  return function () {\n    typeof ctx === 'undefined' && (ctx = this); \n\n    var len = arguments.length, args = new Array(len)\n    for(var i = 0; i < len; i++) { args[i] = arguments[i]; }\n    return createCbObservable(fn, ctx, selector, args);\n  };\n};\n\nfunction createNodeObservable(fn, ctx, selector, args) {\n  var o = new AsyncSubject();\n\n  args.push(createNodeHandler(o, ctx, selector));\n  fn.apply(ctx, args);\n\n  return o.asObservable();\n}\n\nfunction createNodeHandler(o, ctx, selector) {\n  return function handler () {\n    var err = arguments[0];\n    if (err) { return o.onError(err); }\n\n    var len = arguments.length, results = [];\n    for(var i = 1; i < len; i++) { results[i - 1] = arguments[i]; }\n\n    if (isFunction(selector)) {\n      var results = tryCatch(selector).apply(ctx, results);\n      if (results === errorObj) { return o.onError(results.e); }\n      o.onNext(results);\n    } else {\n      if (results.length <= 1) {\n        o.onNext(results[0]);\n      } else {\n        o.onNext(results);\n      }\n    }\n\n    o.onCompleted();\n  };\n}\n\n/**\n * Converts a Node.js callback style function to an observable sequence.  This must be in function (err, ...) format.\n * @param {Function} fn The function to call\n * @param {Mixed} [ctx] The context for the func parameter to be executed.  If not specified, defaults to undefined.\n * @param {Function} [selector] A selector which takes the arguments from the callback minus the error to produce a single item to yield on next.\n * @returns {Function} An async function which when applied, returns an observable sequence with the callback arguments as an array.\n */\nObservable.fromNodeCallback = function (fn, ctx, selector) {\n  return function () {\n    typeof ctx === 'undefined' && (ctx = this); \n    var len = arguments.length, args = new Array(len);\n    for(var i = 0; i < len; i++) { args[i] = arguments[i]; }\n    return createNodeObservable(fn, ctx, selector, args);\n  };\n};\n\n  function isNodeList(el) {\n    if (root.StaticNodeList) {\n      // IE8 Specific\n      // instanceof is slower than Object#toString, but Object#toString will not work as intended in IE8\n      return el instanceof root.StaticNodeList || el instanceof root.NodeList;\n    } else {\n      return Object.prototype.toString.call(el) === '[object NodeList]';\n    }\n  }\n\n  function ListenDisposable(e, n, fn) {\n    this._e = e;\n    this._n = n;\n    this._fn = fn;\n    this._e.addEventListener(this._n, this._fn, false);\n    this.isDisposed = false;\n  }\n  ListenDisposable.prototype.dispose = function () {\n    if (!this.isDisposed) {\n      this._e.removeEventListener(this._n, this._fn, false);\n      this.isDisposed = true;\n    }\n  };\n\n  function createEventListener (el, eventName, handler) {\n    var disposables = new CompositeDisposable();\n\n    // Asume NodeList or HTMLCollection\n    var elemToString = Object.prototype.toString.call(el);\n    if (isNodeList(el) || elemToString === '[object HTMLCollection]') {\n      for (var i = 0, len = el.length; i < len; i++) {\n        disposables.add(createEventListener(el.item(i), eventName, handler));\n      }\n    } else if (el) {\n      disposables.add(new ListenDisposable(el, eventName, handler));\n    }\n\n    return disposables;\n  }\n\n  /**\n   * Configuration option to determine whether to use native events only\n   */\n  Rx.config.useNativeEvents = false;\n\n  var EventObservable = (function(__super__) {\n    inherits(EventObservable, __super__);\n    function EventObservable(el, name, fn) {\n      this._el = el;\n      this._n = name;\n      this._fn = fn;\n      __super__.call(this);\n    }\n\n    function createHandler(o, fn) {\n      return function handler () {\n        var results = arguments[0];\n        if (isFunction(fn)) {\n          results = tryCatch(fn).apply(null, arguments);\n          if (results === errorObj) { return o.onError(results.e); }\n        }\n        o.onNext(results);\n      };\n    }\n\n    EventObservable.prototype.subscribeCore = function (o) {\n      return createEventListener(\n        this._el,\n        this._n,\n        createHandler(o, this._fn));\n    };\n\n    return EventObservable;\n  }(ObservableBase));\n\n  /**\n   * Creates an observable sequence by adding an event listener to the matching DOMElement or each item in the NodeList.\n   * @param {Object} element The DOMElement or NodeList to attach a listener.\n   * @param {String} eventName The event name to attach the observable sequence.\n   * @param {Function} [selector] A selector which takes the arguments from the event handler to produce a single item to yield on next.\n   * @returns {Observable} An observable sequence of events from the specified element and the specified event.\n   */\n  Observable.fromEvent = function (element, eventName, selector) {\n    // Node.js specific\n    if (element.addListener) {\n      return fromEventPattern(\n        function (h) { element.addListener(eventName, h); },\n        function (h) { element.removeListener(eventName, h); },\n        selector);\n    }\n\n    // Use only if non-native events are allowed\n    if (!Rx.config.useNativeEvents) {\n      // Handles jq, Angular.js, Zepto, Marionette, Ember.js\n      if (typeof element.on === 'function' && typeof element.off === 'function') {\n        return fromEventPattern(\n          function (h) { element.on(eventName, h); },\n          function (h) { element.off(eventName, h); },\n          selector);\n      }\n    }\n\n    return new EventObservable(element, eventName, selector).publish().refCount();\n  };\n\n  var EventPatternObservable = (function(__super__) {\n    inherits(EventPatternObservable, __super__);\n    function EventPatternObservable(add, del, fn) {\n      this._add = add;\n      this._del = del;\n      this._fn = fn;\n      __super__.call(this);\n    }\n\n    function createHandler(o, fn) {\n      return function handler () {\n        var results = arguments[0];\n        if (isFunction(fn)) {\n          results = tryCatch(fn).apply(null, arguments);\n          if (results === errorObj) { return o.onError(results.e); }\n        }\n        o.onNext(results);\n      };\n    }\n\n    EventPatternObservable.prototype.subscribeCore = function (o) {\n      var fn = createHandler(o, this._fn);\n      var returnValue = this._add(fn);\n      return new EventPatternDisposable(this._del, fn, returnValue);\n    };\n\n    function EventPatternDisposable(del, fn, ret) {\n      this._del = del;\n      this._fn = fn;\n      this._ret = ret;\n      this.isDisposed = false;\n    }\n\n    EventPatternDisposable.prototype.dispose = function () {\n      if(!this.isDisposed) {\n        isFunction(this._del) && this._del(this._fn, this._ret);\n      }\n    };\n\n    return EventPatternObservable;\n  }(ObservableBase));\n\n  /**\n   * Creates an observable sequence from an event emitter via an addHandler/removeHandler pair.\n   * @param {Function} addHandler The function to add a handler to the emitter.\n   * @param {Function} [removeHandler] The optional function to remove a handler from an emitter.\n   * @param {Function} [selector] A selector which takes the arguments from the event handler to produce a single item to yield on next.\n   * @returns {Observable} An observable sequence which wraps an event from an event emitter\n   */\n  var fromEventPattern = Observable.fromEventPattern = function (addHandler, removeHandler, selector) {\n    return new EventPatternObservable(addHandler, removeHandler, selector).publish().refCount();\n  };\n\n  /**\n   * Invokes the asynchronous function, surfacing the result through an observable sequence.\n   * @param {Function} functionAsync Asynchronous function which returns a Promise to run.\n   * @returns {Observable} An observable sequence exposing the function's result value, or an exception.\n   */\n  Observable.startAsync = function (functionAsync) {\n    var promise = tryCatch(functionAsync)();\n    if (promise === errorObj) { return observableThrow(promise.e); }\n    return observableFromPromise(promise);\n  };\n\n  var PausableObservable = (function (__super__) {\n    inherits(PausableObservable, __super__);\n    function PausableObservable(source, pauser) {\n      this.source = source;\n      this.controller = new Subject();\n\n      if (pauser && pauser.subscribe) {\n        this.pauser = this.controller.merge(pauser);\n      } else {\n        this.pauser = this.controller;\n      }\n\n      __super__.call(this);\n    }\n\n    PausableObservable.prototype._subscribe = function (o) {\n      var conn = this.source.publish(),\n        subscription = conn.subscribe(o),\n        connection = disposableEmpty;\n\n      var pausable = this.pauser.distinctUntilChanged().subscribe(function (b) {\n        if (b) {\n          connection = conn.connect();\n        } else {\n          connection.dispose();\n          connection = disposableEmpty;\n        }\n      });\n\n      return new NAryDisposable([subscription, connection, pausable]);\n    };\n\n    PausableObservable.prototype.pause = function () {\n      this.controller.onNext(false);\n    };\n\n    PausableObservable.prototype.resume = function () {\n      this.controller.onNext(true);\n    };\n\n    return PausableObservable;\n\n  }(Observable));\n\n  /**\n   * Pauses the underlying observable sequence based upon the observable sequence which yields true/false.\n   * @example\n   * var pauser = new Rx.Subject();\n   * var source = Rx.Observable.interval(100).pausable(pauser);\n   * @param {Observable} pauser The observable sequence used to pause the underlying sequence.\n   * @returns {Observable} The observable sequence which is paused based upon the pauser.\n   */\n  observableProto.pausable = function (pauser) {\n    return new PausableObservable(this, pauser);\n  };\n\n  function combineLatestSource(source, subject, resultSelector) {\n    return new AnonymousObservable(function (o) {\n      var hasValue = [false, false],\n        hasValueAll = false,\n        isDone = false,\n        values = new Array(2),\n        err;\n\n      function next(x, i) {\n        values[i] = x;\n        hasValue[i] = true;\n        if (hasValueAll || (hasValueAll = hasValue.every(identity))) {\n          if (err) { return o.onError(err); }\n          var res = tryCatch(resultSelector).apply(null, values);\n          if (res === errorObj) { return o.onError(res.e); }\n          o.onNext(res);\n        }\n        isDone && values[1] && o.onCompleted();\n      }\n\n      return new BinaryDisposable(\n        source.subscribe(\n          function (x) {\n            next(x, 0);\n          },\n          function (e) {\n            if (values[1]) {\n              o.onError(e);\n            } else {\n              err = e;\n            }\n          },\n          function () {\n            isDone = true;\n            values[1] && o.onCompleted();\n          }),\n        subject.subscribe(\n          function (x) {\n            next(x, 1);\n          },\n          function (e) { o.onError(e); },\n          function () {\n            isDone = true;\n            next(true, 1);\n          })\n        );\n    }, source);\n  }\n\n  var PausableBufferedObservable = (function (__super__) {\n    inherits(PausableBufferedObservable, __super__);\n    function PausableBufferedObservable(source, pauser) {\n      this.source = source;\n      this.controller = new Subject();\n\n      if (pauser && pauser.subscribe) {\n        this.pauser = this.controller.merge(pauser);\n      } else {\n        this.pauser = this.controller;\n      }\n\n      __super__.call(this);\n    }\n\n    PausableBufferedObservable.prototype._subscribe = function (o) {\n      var q = [], previousShouldFire;\n\n      function drainQueue() { while (q.length > 0) { o.onNext(q.shift()); } }\n\n      var subscription =\n        combineLatestSource(\n          this.source,\n          this.pauser.startWith(false).distinctUntilChanged(),\n          function (data, shouldFire) {\n            return { data: data, shouldFire: shouldFire };\n          })\n          .subscribe(\n            function (results) {\n              if (previousShouldFire !== undefined && results.shouldFire !== previousShouldFire) {\n                previousShouldFire = results.shouldFire;\n                // change in shouldFire\n                if (results.shouldFire) { drainQueue(); }\n              } else {\n                previousShouldFire = results.shouldFire;\n                // new data\n                if (results.shouldFire) {\n                  o.onNext(results.data);\n                } else {\n                  q.push(results.data);\n                }\n              }\n            },\n            function (err) {\n              drainQueue();\n              o.onError(err);\n            },\n            function () {\n              drainQueue();\n              o.onCompleted();\n            }\n          );\n      return subscription;      \n    };\n\n    PausableBufferedObservable.prototype.pause = function () {\n      this.controller.onNext(false);\n    };\n\n    PausableBufferedObservable.prototype.resume = function () {\n      this.controller.onNext(true);\n    };\n\n    return PausableBufferedObservable;\n\n  }(Observable));\n\n  /**\n   * Pauses the underlying observable sequence based upon the observable sequence which yields true/false,\n   * and yields the values that were buffered while paused.\n   * @example\n   * var pauser = new Rx.Subject();\n   * var source = Rx.Observable.interval(100).pausableBuffered(pauser);\n   * @param {Observable} pauser The observable sequence used to pause the underlying sequence.\n   * @returns {Observable} The observable sequence which is paused based upon the pauser.\n   */\n  observableProto.pausableBuffered = function (pauser) {\n    return new PausableBufferedObservable(this, pauser);\n  };\n\n  var ControlledObservable = (function (__super__) {\n    inherits(ControlledObservable, __super__);\n    function ControlledObservable (source, enableQueue, scheduler) {\n      __super__.call(this);\n      this.subject = new ControlledSubject(enableQueue, scheduler);\n      this.source = source.multicast(this.subject).refCount();\n    }\n\n    ControlledObservable.prototype._subscribe = function (o) {\n      return this.source.subscribe(o);\n    };\n\n    ControlledObservable.prototype.request = function (numberOfItems) {\n      return this.subject.request(numberOfItems == null ? -1 : numberOfItems);\n    };\n\n    return ControlledObservable;\n\n  }(Observable));\n\n  var ControlledSubject = (function (__super__) {\n    inherits(ControlledSubject, __super__);\n    function ControlledSubject(enableQueue, scheduler) {\n      enableQueue == null && (enableQueue = true);\n\n      __super__.call(this);\n      this.subject = new Subject();\n      this.enableQueue = enableQueue;\n      this.queue = enableQueue ? [] : null;\n      this.requestedCount = 0;\n      this.requestedDisposable = null;\n      this.error = null;\n      this.hasFailed = false;\n      this.hasCompleted = false;\n      this.scheduler = scheduler || currentThreadScheduler;\n    }\n\n    addProperties(ControlledSubject.prototype, Observer, {\n      _subscribe: function (o) {\n        return this.subject.subscribe(o);\n      },\n      onCompleted: function () {\n        this.hasCompleted = true;\n        if (!this.enableQueue || this.queue.length === 0) {\n          this.subject.onCompleted();\n          this.disposeCurrentRequest();\n        } else {\n          this.queue.push(Notification.createOnCompleted());\n        }\n      },\n      onError: function (error) {\n        this.hasFailed = true;\n        this.error = error;\n        if (!this.enableQueue || this.queue.length === 0) {\n          this.subject.onError(error);\n          this.disposeCurrentRequest();\n        } else {\n          this.queue.push(Notification.createOnError(error));\n        }\n      },\n      onNext: function (value) {\n        if (this.requestedCount <= 0) {\n          this.enableQueue && this.queue.push(Notification.createOnNext(value));\n        } else {\n          (this.requestedCount-- === 0) && this.disposeCurrentRequest();\n          this.subject.onNext(value);\n        }\n      },\n      _processRequest: function (numberOfItems) {\n        if (this.enableQueue) {\n          while (this.queue.length > 0 && (numberOfItems > 0 || this.queue[0].kind !== 'N')) {\n            var first = this.queue.shift();\n            first.accept(this.subject);\n            if (first.kind === 'N') {\n              numberOfItems--;\n            } else {\n              this.disposeCurrentRequest();\n              this.queue = [];\n            }\n          }\n        }\n\n        return numberOfItems;\n      },\n      request: function (number) {\n        this.disposeCurrentRequest();\n        var self = this;\n\n        this.requestedDisposable = this.scheduler.schedule(number,\n        function(s, i) {\n          var remaining = self._processRequest(i);\n          var stopped = self.hasCompleted || self.hasFailed;\n          if (!stopped && remaining > 0) {\n            self.requestedCount = remaining;\n\n            return disposableCreate(function () {\n              self.requestedCount = 0;\n            });\n              // Scheduled item is still in progress. Return a new\n              // disposable to allow the request to be interrupted\n              // via dispose.\n          }\n        });\n\n        return this.requestedDisposable;\n      },\n      disposeCurrentRequest: function () {\n        if (this.requestedDisposable) {\n          this.requestedDisposable.dispose();\n          this.requestedDisposable = null;\n        }\n      }\n    });\n\n    return ControlledSubject;\n  }(Observable));\n\n  /**\n   * Attaches a controller to the observable sequence with the ability to queue.\n   * @example\n   * var source = Rx.Observable.interval(100).controlled();\n   * source.request(3); // Reads 3 values\n   * @param {bool} enableQueue truthy value to determine if values should be queued pending the next request\n   * @param {Scheduler} scheduler determines how the requests will be scheduled\n   * @returns {Observable} The observable sequence which only propagates values on request.\n   */\n  observableProto.controlled = function (enableQueue, scheduler) {\n\n    if (enableQueue && isScheduler(enableQueue)) {\n      scheduler = enableQueue;\n      enableQueue = true;\n    }\n\n    if (enableQueue == null) {  enableQueue = true; }\n    return new ControlledObservable(this, enableQueue, scheduler);\n  };\n\n  var StopAndWaitObservable = (function (__super__) {\n    inherits(StopAndWaitObservable, __super__);\n    function StopAndWaitObservable (source) {\n      __super__.call(this);\n      this.source = source;\n    }\n\n    function scheduleMethod(s, self) {\n      self.source.request(1);\n    }\n\n    StopAndWaitObservable.prototype._subscribe = function (o) {\n      this.subscription = this.source.subscribe(new StopAndWaitObserver(o, this, this.subscription));\n      return new BinaryDisposable(\n        this.subscription,\n        defaultScheduler.schedule(this, scheduleMethod)\n      );\n    };\n\n    var StopAndWaitObserver = (function (__sub__) {\n      inherits(StopAndWaitObserver, __sub__);\n      function StopAndWaitObserver (observer, observable, cancel) {\n        __sub__.call(this);\n        this.observer = observer;\n        this.observable = observable;\n        this.cancel = cancel;\n        this.scheduleDisposable = null;\n      }\n\n      StopAndWaitObserver.prototype.completed = function () {\n        this.observer.onCompleted();\n        this.dispose();\n      };\n\n      StopAndWaitObserver.prototype.error = function (error) {\n        this.observer.onError(error);\n        this.dispose();\n      };\n\n      function innerScheduleMethod(s, self) {\n        self.observable.source.request(1);\n      }\n\n      StopAndWaitObserver.prototype.next = function (value) {\n        this.observer.onNext(value);\n        this.scheduleDisposable = defaultScheduler.schedule(this, innerScheduleMethod);\n      };\n\n      StopAndWaitObservable.dispose = function () {\n        this.observer = null;\n        if (this.cancel) {\n          this.cancel.dispose();\n          this.cancel = null;\n        }\n        if (this.scheduleDisposable) {\n          this.scheduleDisposable.dispose();\n          this.scheduleDisposable = null;\n        }\n        __sub__.prototype.dispose.call(this);\n      };\n\n      return StopAndWaitObserver;\n    }(AbstractObserver));\n\n    return StopAndWaitObservable;\n  }(Observable));\n\n\n  /**\n   * Attaches a stop and wait observable to the current observable.\n   * @returns {Observable} A stop and wait observable.\n   */\n  ControlledObservable.prototype.stopAndWait = function () {\n    return new StopAndWaitObservable(this);\n  };\n\n  var WindowedObservable = (function (__super__) {\n    inherits(WindowedObservable, __super__);\n    function WindowedObservable(source, windowSize) {\n      __super__.call(this);\n      this.source = source;\n      this.windowSize = windowSize;\n    }\n\n    function scheduleMethod(s, self) {\n      self.source.request(self.windowSize);\n    }\n\n    WindowedObservable.prototype._subscribe = function (o) {\n      this.subscription = this.source.subscribe(new WindowedObserver(o, this, this.subscription));\n      return new BinaryDisposable(\n        this.subscription,\n        defaultScheduler.schedule(this, scheduleMethod)\n      );\n    };\n\n    var WindowedObserver = (function (__sub__) {\n      inherits(WindowedObserver, __sub__);\n      function WindowedObserver(observer, observable, cancel) {\n        this.observer = observer;\n        this.observable = observable;\n        this.cancel = cancel;\n        this.received = 0;\n        this.scheduleDisposable = null;\n        __sub__.call(this);\n      }\n\n      WindowedObserver.prototype.completed = function () {\n        this.observer.onCompleted();\n        this.dispose();\n      };\n\n      WindowedObserver.prototype.error = function (error) {\n        this.observer.onError(error);\n        this.dispose();\n      };\n\n      function innerScheduleMethod(s, self) {\n        self.observable.source.request(self.observable.windowSize);\n      }\n\n      WindowedObserver.prototype.next = function (value) {\n        this.observer.onNext(value);\n        this.received = ++this.received % this.observable.windowSize;\n        this.received === 0 && (this.scheduleDisposable = defaultScheduler.schedule(this, innerScheduleMethod));\n      };\n\n      WindowedObserver.prototype.dispose = function () {\n        this.observer = null;\n        if (this.cancel) {\n          this.cancel.dispose();\n          this.cancel = null;\n        }\n        if (this.scheduleDisposable) {\n          this.scheduleDisposable.dispose();\n          this.scheduleDisposable = null;\n        }\n        __sub__.prototype.dispose.call(this);\n      };\n\n      return WindowedObserver;\n    }(AbstractObserver));\n\n    return WindowedObservable;\n  }(Observable));\n\n  /**\n   * Creates a sliding windowed observable based upon the window size.\n   * @param {Number} windowSize The number of items in the window\n   * @returns {Observable} A windowed observable based upon the window size.\n   */\n  ControlledObservable.prototype.windowed = function (windowSize) {\n    return new WindowedObservable(this, windowSize);\n  };\n\n  /**\n   * Pipes the existing Observable sequence into a Node.js Stream.\n   * @param {Stream} dest The destination Node.js stream.\n   * @returns {Stream} The destination stream.\n   */\n  observableProto.pipe = function (dest) {\n    var source = this.pausableBuffered();\n\n    function onDrain() {\n      source.resume();\n    }\n\n    dest.addListener('drain', onDrain);\n\n    source.subscribe(\n      function (x) {\n        !dest.write(String(x)) && source.pause();\n      },\n      function (err) {\n        dest.emit('error', err);\n      },\n      function () {\n        // Hack check because STDIO is not closable\n        !dest._isStdio && dest.end();\n        dest.removeListener('drain', onDrain);\n      });\n\n    source.resume();\n\n    return dest;\n  };\n\n  var MulticastObservable = (function (__super__) {\n    inherits(MulticastObservable, __super__);\n    function MulticastObservable(source, fn1, fn2) {\n      this.source = source;\n      this._fn1 = fn1;\n      this._fn2 = fn2;\n      __super__.call(this);\n    }\n\n    MulticastObservable.prototype.subscribeCore = function (o) {\n      var connectable = this.source.multicast(this._fn1());\n      return new BinaryDisposable(this._fn2(connectable).subscribe(o), connectable.connect());\n    };\n\n    return MulticastObservable;\n  }(ObservableBase));\n\n  /**\n   * Multicasts the source sequence notifications through an instantiated subject into all uses of the sequence within a selector function. Each\n   * subscription to the resulting sequence causes a separate multicast invocation, exposing the sequence resulting from the selector function's\n   * invocation. For specializations with fixed subject types, see Publish, PublishLast, and Replay.\n   *\n   * @example\n   * 1 - res = source.multicast(observable);\n   * 2 - res = source.multicast(function () { return new Subject(); }, function (x) { return x; });\n   *\n   * @param {Function|Subject} subjectOrSubjectSelector\n   * Factory function to create an intermediate subject through which the source sequence's elements will be multicast to the selector function.\n   * Or:\n   * Subject to push source elements into.\n   *\n   * @param {Function} [selector] Optional selector function which can use the multicasted source sequence subject to the policies enforced by the created subject. Specified only if <paramref name=\"subjectOrSubjectSelector\" is a factory function.\n   * @returns {Observable} An observable sequence that contains the elements of a sequence produced by multicasting the source sequence within a selector function.\n   */\n  observableProto.multicast = function (subjectOrSubjectSelector, selector) {\n    return isFunction(subjectOrSubjectSelector) ?\n      new MulticastObservable(this, subjectOrSubjectSelector, selector) :\n      new ConnectableObservable(this, subjectOrSubjectSelector);\n  };\n\n  /**\n   * Returns an observable sequence that is the result of invoking the selector on a connectable observable sequence that shares a single subscription to the underlying sequence.\n   * This operator is a specialization of Multicast using a regular Subject.\n   *\n   * @example\n   * var resres = source.publish();\n   * var res = source.publish(function (x) { return x; });\n   *\n   * @param {Function} [selector] Selector function which can use the multicasted source sequence as many times as needed, without causing multiple subscriptions to the source sequence. Subscribers to the given source will receive all notifications of the source from the time of the subscription on.\n   * @returns {Observable} An observable sequence that contains the elements of a sequence produced by multicasting the source sequence within a selector function.\n   */\n  observableProto.publish = function (selector) {\n    return selector && isFunction(selector) ?\n      this.multicast(function () { return new Subject(); }, selector) :\n      this.multicast(new Subject());\n  };\n\n  /**\n   * Returns an observable sequence that shares a single subscription to the underlying sequence.\n   * This operator is a specialization of publish which creates a subscription when the number of observers goes from zero to one, then shares that subscription with all subsequent observers until the number of observers returns to zero, at which point the subscription is disposed.\n   * @returns {Observable} An observable sequence that contains the elements of a sequence produced by multicasting the source sequence.\n   */\n  observableProto.share = function () {\n    return this.publish().refCount();\n  };\n\n  /**\n   * Returns an observable sequence that is the result of invoking the selector on a connectable observable sequence that shares a single subscription to the underlying sequence containing only the last notification.\n   * This operator is a specialization of Multicast using a AsyncSubject.\n   *\n   * @example\n   * var res = source.publishLast();\n   * var res = source.publishLast(function (x) { return x; });\n   *\n   * @param selector [Optional] Selector function which can use the multicasted source sequence as many times as needed, without causing multiple subscriptions to the source sequence. Subscribers to the given source will only receive the last notification of the source.\n   * @returns {Observable} An observable sequence that contains the elements of a sequence produced by multicasting the source sequence within a selector function.\n   */\n  observableProto.publishLast = function (selector) {\n    return selector && isFunction(selector) ?\n      this.multicast(function () { return new AsyncSubject(); }, selector) :\n      this.multicast(new AsyncSubject());\n  };\n\n  /**\n   * Returns an observable sequence that is the result of invoking the selector on a connectable observable sequence that shares a single subscription to the underlying sequence and starts with initialValue.\n   * This operator is a specialization of Multicast using a BehaviorSubject.\n   *\n   * @example\n   * var res = source.publishValue(42);\n   * var res = source.publishValue(function (x) { return x.select(function (y) { return y * y; }) }, 42);\n   *\n   * @param {Function} [selector] Optional selector function which can use the multicasted source sequence as many times as needed, without causing multiple subscriptions to the source sequence. Subscribers to the given source will receive immediately receive the initial value, followed by all notifications of the source from the time of the subscription on.\n   * @param {Mixed} initialValue Initial value received by observers upon subscription.\n   * @returns {Observable} An observable sequence that contains the elements of a sequence produced by multicasting the source sequence within a selector function.\n   */\n  observableProto.publishValue = function (initialValueOrSelector, initialValue) {\n    return arguments.length === 2 ?\n      this.multicast(function () {\n        return new BehaviorSubject(initialValue);\n      }, initialValueOrSelector) :\n      this.multicast(new BehaviorSubject(initialValueOrSelector));\n  };\n\n  /**\n   * Returns an observable sequence that shares a single subscription to the underlying sequence and starts with an initialValue.\n   * This operator is a specialization of publishValue which creates a subscription when the number of observers goes from zero to one, then shares that subscription with all subsequent observers until the number of observers returns to zero, at which point the subscription is disposed.\n   * @param {Mixed} initialValue Initial value received by observers upon subscription.\n   * @returns {Observable} An observable sequence that contains the elements of a sequence produced by multicasting the source sequence.\n   */\n  observableProto.shareValue = function (initialValue) {\n    return this.publishValue(initialValue).refCount();\n  };\n\n  /**\n   * Returns an observable sequence that is the result of invoking the selector on a connectable observable sequence that shares a single subscription to the underlying sequence replaying notifications subject to a maximum time length for the replay buffer.\n   * This operator is a specialization of Multicast using a ReplaySubject.\n   *\n   * @example\n   * var res = source.replay(null, 3);\n   * var res = source.replay(null, 3, 500);\n   * var res = source.replay(null, 3, 500, scheduler);\n   * var res = source.replay(function (x) { return x.take(6).repeat(); }, 3, 500, scheduler);\n   *\n   * @param selector [Optional] Selector function which can use the multicasted source sequence as many times as needed, without causing multiple subscriptions to the source sequence. Subscribers to the given source will receive all the notifications of the source subject to the specified replay buffer trimming policy.\n   * @param bufferSize [Optional] Maximum element count of the replay buffer.\n   * @param windowSize [Optional] Maximum time length of the replay buffer.\n   * @param scheduler [Optional] Scheduler where connected observers within the selector function will be invoked on.\n   * @returns {Observable} An observable sequence that contains the elements of a sequence produced by multicasting the source sequence within a selector function.\n   */\n  observableProto.replay = function (selector, bufferSize, windowSize, scheduler) {\n    return selector && isFunction(selector) ?\n      this.multicast(function () { return new ReplaySubject(bufferSize, windowSize, scheduler); }, selector) :\n      this.multicast(new ReplaySubject(bufferSize, windowSize, scheduler));\n  };\n\n  /**\n   * Returns an observable sequence that shares a single subscription to the underlying sequence replaying notifications subject to a maximum time length for the replay buffer.\n   * This operator is a specialization of replay which creates a subscription when the number of observers goes from zero to one, then shares that subscription with all subsequent observers until the number of observers returns to zero, at which point the subscription is disposed.\n   *\n   * @example\n   * var res = source.shareReplay(3);\n   * var res = source.shareReplay(3, 500);\n   * var res = source.shareReplay(3, 500, scheduler);\n   *\n\n   * @param bufferSize [Optional] Maximum element count of the replay buffer.\n   * @param window [Optional] Maximum time length of the replay buffer.\n   * @param scheduler [Optional] Scheduler where connected observers within the selector function will be invoked on.\n   * @returns {Observable} An observable sequence that contains the elements of a sequence produced by multicasting the source sequence.\n   */\n  observableProto.shareReplay = function (bufferSize, windowSize, scheduler) {\n    return this.replay(null, bufferSize, windowSize, scheduler).refCount();\n  };\n\n  var InnerSubscription = function (s, o) {\n    this._s = s;\n    this._o = o;\n  };\n\n  InnerSubscription.prototype.dispose = function () {\n    if (!this._s.isDisposed && this._o !== null) {\n      var idx = this._s.observers.indexOf(this._o);\n      this._s.observers.splice(idx, 1);\n      this._o = null;\n    }\n  };\n\n  var RefCountObservable = (function (__super__) {\n    inherits(RefCountObservable, __super__);\n    function RefCountObservable(source) {\n      this.source = source;\n      this._count = 0;\n      this._connectableSubscription = null;\n      __super__.call(this);\n    }\n\n    RefCountObservable.prototype.subscribeCore = function (o) {\n      var subscription = this.source.subscribe(o);\n      ++this._count === 1 && (this._connectableSubscription = this.source.connect());\n      return new RefCountDisposable(this, subscription);\n    };\n\n    function RefCountDisposable(p, s) {\n      this._p = p;\n      this._s = s;\n      this.isDisposed = false;\n    }\n\n    RefCountDisposable.prototype.dispose = function () {\n      if (!this.isDisposed) {\n        this.isDisposed = true;\n        this._s.dispose();\n        --this._p._count === 0 && this._p._connectableSubscription.dispose();\n      }\n    };\n\n    return RefCountObservable;\n  }(ObservableBase));\n\n  var ConnectableObservable = Rx.ConnectableObservable = (function (__super__) {\n    inherits(ConnectableObservable, __super__);\n    function ConnectableObservable(source, subject) {\n      this.source = source;\n      this._connection = null;\n      this._source = source.asObservable();\n      this._subject = subject;\n      __super__.call(this);\n    }\n\n    function ConnectDisposable(parent, subscription) {\n      this._p = parent;\n      this._s = subscription;\n    }\n\n    ConnectDisposable.prototype.dispose = function () {\n      if (this._s) {\n        this._s.dispose();\n        this._s = null;\n        this._p._connection = null;\n      }\n    };\n\n    ConnectableObservable.prototype.connect = function () {\n      if (!this._connection) {\n        var subscription = this._source.subscribe(this._subject);\n        this._connection = new ConnectDisposable(this, subscription);\n      }\n      return this._connection;\n    };\n\n    ConnectableObservable.prototype._subscribe = function (o) {\n      return this._subject.subscribe(o);\n    };\n\n    ConnectableObservable.prototype.refCount = function () {\n      return new RefCountObservable(this);\n    };\n\n    return ConnectableObservable;\n  }(Observable));\n\n  /**\n   * Returns an observable sequence that shares a single subscription to the underlying sequence. This observable sequence\n   * can be resubscribed to, even if all prior subscriptions have ended. (unlike `.publish().refCount()`)\n   * @returns {Observable} An observable sequence that contains the elements of a sequence produced by multicasting the source.\n   */\n  observableProto.singleInstance = function() {\n    var source = this, hasObservable = false, observable;\n\n    function getObservable() {\n      if (!hasObservable) {\n        hasObservable = true;\n        observable = source['finally'](function() { hasObservable = false; }).publish().refCount();\n      }\n      return observable;\n    }\n\n    return new AnonymousObservable(function(o) {\n      return getObservable().subscribe(o);\n    });\n  };\n\n  /**\n   *  Correlates the elements of two sequences based on overlapping durations.\n   *\n   *  @param {Observable} right The right observable sequence to join elements for.\n   *  @param {Function} leftDurationSelector A function to select the duration (expressed as an observable sequence) of each element of the left observable sequence, used to determine overlap.\n   *  @param {Function} rightDurationSelector A function to select the duration (expressed as an observable sequence) of each element of the right observable sequence, used to determine overlap.\n   *  @param {Function} resultSelector A function invoked to compute a result element for any two overlapping elements of the left and right observable sequences. The parameters passed to the function correspond with the elements from the left and right source sequences for which overlap occurs.\n   *  @returns {Observable} An observable sequence that contains result elements computed from source elements that have an overlapping duration.\n   */\n  observableProto.join = function (right, leftDurationSelector, rightDurationSelector, resultSelector) {\n    var left = this;\n    return new AnonymousObservable(function (o) {\n      var group = new CompositeDisposable();\n      var leftDone = false, rightDone = false;\n      var leftId = 0, rightId = 0;\n      var leftMap = new Map(), rightMap = new Map();\n      var handleError = function (e) { o.onError(e); };\n\n      group.add(left.subscribe(\n        function (value) {\n          var id = leftId++, md = new SingleAssignmentDisposable();\n\n          leftMap.set(id, value);\n          group.add(md);\n\n          var duration = tryCatch(leftDurationSelector)(value);\n          if (duration === errorObj) { return o.onError(duration.e); }\n\n          md.setDisposable(duration.take(1).subscribe(\n            noop,\n            handleError,\n            function () {\n              leftMap['delete'](id) && leftMap.size === 0 && leftDone && o.onCompleted();\n              group.remove(md);\n            }));\n\n          rightMap.forEach(function (v) {\n            var result = tryCatch(resultSelector)(value, v);\n            if (result === errorObj) { return o.onError(result.e); }\n            o.onNext(result);\n          });\n        },\n        handleError,\n        function () {\n          leftDone = true;\n          (rightDone || leftMap.size === 0) && o.onCompleted();\n        })\n      );\n\n      group.add(right.subscribe(\n        function (value) {\n          var id = rightId++, md = new SingleAssignmentDisposable();\n\n          rightMap.set(id, value);\n          group.add(md);\n\n          var duration = tryCatch(rightDurationSelector)(value);\n          if (duration === errorObj) { return o.onError(duration.e); }\n\n          md.setDisposable(duration.take(1).subscribe(\n            noop,\n            handleError,\n            function () {\n              rightMap['delete'](id) && rightMap.size === 0 && rightDone && o.onCompleted();\n              group.remove(md);\n            }));\n\n          leftMap.forEach(function (v) {\n            var result = tryCatch(resultSelector)(v, value);\n            if (result === errorObj) { return o.onError(result.e); }\n            o.onNext(result);\n          });\n        },\n        handleError,\n        function () {\n          rightDone = true;\n          (leftDone || rightMap.size === 0) && o.onCompleted();\n        })\n      );\n      return group;\n    }, left);\n  };\n\n  /**\n   *  Correlates the elements of two sequences based on overlapping durations, and groups the results.\n   *\n   *  @param {Observable} right The right observable sequence to join elements for.\n   *  @param {Function} leftDurationSelector A function to select the duration (expressed as an observable sequence) of each element of the left observable sequence, used to determine overlap.\n   *  @param {Function} rightDurationSelector A function to select the duration (expressed as an observable sequence) of each element of the right observable sequence, used to determine overlap.\n   *  @param {Function} resultSelector A function invoked to compute a result element for any element of the left sequence with overlapping elements from the right observable sequence. The first parameter passed to the function is an element of the left sequence. The second parameter passed to the function is an observable sequence with elements from the right sequence that overlap with the left sequence's element.\n   *  @returns {Observable} An observable sequence that contains result elements computed from source elements that have an overlapping duration.\n   */\n  observableProto.groupJoin = function (right, leftDurationSelector, rightDurationSelector, resultSelector) {\n    var left = this;\n    return new AnonymousObservable(function (o) {\n      var group = new CompositeDisposable();\n      var r = new RefCountDisposable(group);\n      var leftMap = new Map(), rightMap = new Map();\n      var leftId = 0, rightId = 0;\n      var handleError = function (e) { return function (v) { v.onError(e); }; };\n\n      function handleError(e) { };\n\n      group.add(left.subscribe(\n        function (value) {\n          var s = new Subject();\n          var id = leftId++;\n          leftMap.set(id, s);\n\n          var result = tryCatch(resultSelector)(value, addRef(s, r));\n          if (result === errorObj) {\n            leftMap.forEach(handleError(result.e));\n            return o.onError(result.e);\n          }\n          o.onNext(result);\n\n          rightMap.forEach(function (v) { s.onNext(v); });\n\n          var md = new SingleAssignmentDisposable();\n          group.add(md);\n\n          var duration = tryCatch(leftDurationSelector)(value);\n          if (duration === errorObj) {\n            leftMap.forEach(handleError(duration.e));\n            return o.onError(duration.e);\n          }\n\n          md.setDisposable(duration.take(1).subscribe(\n            noop,\n            function (e) {\n              leftMap.forEach(handleError(e));\n              o.onError(e);\n            },\n            function () {\n              leftMap['delete'](id) && s.onCompleted();\n              group.remove(md);\n            }));\n        },\n        function (e) {\n          leftMap.forEach(handleError(e));\n          o.onError(e);\n        },\n        function () { o.onCompleted(); })\n      );\n\n      group.add(right.subscribe(\n        function (value) {\n          var id = rightId++;\n          rightMap.set(id, value);\n\n          var md = new SingleAssignmentDisposable();\n          group.add(md);\n\n          var duration = tryCatch(rightDurationSelector)(value);\n          if (duration === errorObj) {\n            leftMap.forEach(handleError(duration.e));\n            return o.onError(duration.e);\n          }\n\n          md.setDisposable(duration.take(1).subscribe(\n            noop,\n            function (e) {\n              leftMap.forEach(handleError(e));\n              o.onError(e);\n            },\n            function () {\n              rightMap['delete'](id);\n              group.remove(md);\n            }));\n\n          leftMap.forEach(function (v) { v.onNext(value); });\n        },\n        function (e) {\n          leftMap.forEach(handleError(e));\n          o.onError(e);\n        })\n      );\n\n      return r;\n    }, left);\n  };\n\n  function toArray(x) { return x.toArray(); }\n\n  /**\n   *  Projects each element of an observable sequence into zero or more buffers.\n   *  @param {Mixed} bufferOpeningsOrClosingSelector Observable sequence whose elements denote the creation of new windows, or, a function invoked to define the boundaries of the produced windows (a new window is started when the previous one is closed, resulting in non-overlapping windows).\n   *  @param {Function} [bufferClosingSelector] A function invoked to define the closing of each produced window. If a closing selector function is specified for the first parameter, this parameter is ignored.\n   *  @returns {Observable} An observable sequence of windows.\n   */\n  observableProto.buffer = function () {\n    return this.window.apply(this, arguments)\n      .flatMap(toArray);\n  };\n\n  /**\n   *  Projects each element of an observable sequence into zero or more windows.\n   *\n   *  @param {Mixed} windowOpeningsOrClosingSelector Observable sequence whose elements denote the creation of new windows, or, a function invoked to define the boundaries of the produced windows (a new window is started when the previous one is closed, resulting in non-overlapping windows).\n   *  @param {Function} [windowClosingSelector] A function invoked to define the closing of each produced window. If a closing selector function is specified for the first parameter, this parameter is ignored.\n   *  @returns {Observable} An observable sequence of windows.\n   */\n  observableProto.window = function (windowOpeningsOrClosingSelector, windowClosingSelector) {\n    if (arguments.length === 1 && typeof arguments[0] !== 'function') {\n      return observableWindowWithBoundaries.call(this, windowOpeningsOrClosingSelector);\n    }\n    return typeof windowOpeningsOrClosingSelector === 'function' ?\n      observableWindowWithClosingSelector.call(this, windowOpeningsOrClosingSelector) :\n      observableWindowWithOpenings.call(this, windowOpeningsOrClosingSelector, windowClosingSelector);\n  };\n\n  function observableWindowWithOpenings(windowOpenings, windowClosingSelector) {\n    return windowOpenings.groupJoin(this, windowClosingSelector, observableEmpty, function (_, win) {\n      return win;\n    });\n  }\n\n  function observableWindowWithBoundaries(windowBoundaries) {\n    var source = this;\n    return new AnonymousObservable(function (observer) {\n      var win = new Subject(),\n        d = new CompositeDisposable(),\n        r = new RefCountDisposable(d);\n\n      observer.onNext(addRef(win, r));\n\n      d.add(source.subscribe(function (x) {\n        win.onNext(x);\n      }, function (err) {\n        win.onError(err);\n        observer.onError(err);\n      }, function () {\n        win.onCompleted();\n        observer.onCompleted();\n      }));\n\n      isPromise(windowBoundaries) && (windowBoundaries = observableFromPromise(windowBoundaries));\n\n      d.add(windowBoundaries.subscribe(function (w) {\n        win.onCompleted();\n        win = new Subject();\n        observer.onNext(addRef(win, r));\n      }, function (err) {\n        win.onError(err);\n        observer.onError(err);\n      }, function () {\n        win.onCompleted();\n        observer.onCompleted();\n      }));\n\n      return r;\n    }, source);\n  }\n\n  function observableWindowWithClosingSelector(windowClosingSelector) {\n    var source = this;\n    return new AnonymousObservable(function (observer) {\n      var m = new SerialDisposable(),\n        d = new CompositeDisposable(m),\n        r = new RefCountDisposable(d),\n        win = new Subject();\n      observer.onNext(addRef(win, r));\n      d.add(source.subscribe(function (x) {\n          win.onNext(x);\n      }, function (err) {\n          win.onError(err);\n          observer.onError(err);\n      }, function () {\n          win.onCompleted();\n          observer.onCompleted();\n      }));\n\n      function createWindowClose () {\n        var windowClose;\n        try {\n          windowClose = windowClosingSelector();\n        } catch (e) {\n          observer.onError(e);\n          return;\n        }\n\n        isPromise(windowClose) && (windowClose = observableFromPromise(windowClose));\n\n        var m1 = new SingleAssignmentDisposable();\n        m.setDisposable(m1);\n        m1.setDisposable(windowClose.take(1).subscribe(noop, function (err) {\n          win.onError(err);\n          observer.onError(err);\n        }, function () {\n          win.onCompleted();\n          win = new Subject();\n          observer.onNext(addRef(win, r));\n          createWindowClose();\n        }));\n      }\n\n      createWindowClose();\n      return r;\n    }, source);\n  }\n\n  var PairwiseObservable = (function (__super__) {\n    inherits(PairwiseObservable, __super__);\n    function PairwiseObservable(source) {\n      this.source = source;\n      __super__.call(this);\n    }\n\n    PairwiseObservable.prototype.subscribeCore = function (o) {\n      return this.source.subscribe(new PairwiseObserver(o));\n    };\n\n    return PairwiseObservable;\n  }(ObservableBase));\n\n  var PairwiseObserver = (function(__super__) {\n    inherits(PairwiseObserver, __super__);\n    function PairwiseObserver(o) {\n      this._o = o;\n      this._p = null;\n      this._hp = false;\n    }\n\n    PairwiseObserver.prototype.next = function (x) {\n      if (this._hp) {\n        this._o.onNext([this._p, x]);\n      } else {\n        this._hp = true;\n      }\n      this._p = x;\n    };\n    PairwiseObserver.prototype.error = function (err) { this._o.onError(err); };\n    PairwiseObserver.prototype.completed = function () { this._o.onCompleted(); };\n\n    return PairwiseObserver;\n  }(AbstractObserver));\n\n  /**\n   * Returns a new observable that triggers on the second and subsequent triggerings of the input observable.\n   * The Nth triggering of the input observable passes the arguments from the N-1th and Nth triggering as a pair.\n   * The argument passed to the N-1th triggering is held in hidden internal state until the Nth triggering occurs.\n   * @returns {Observable} An observable that triggers on successive pairs of observations from the input observable as an array.\n   */\n  observableProto.pairwise = function () {\n    return new PairwiseObservable(this);\n  };\n\n  /**\n   * Returns two observables which partition the observations of the source by the given function.\n   * The first will trigger observations for those values for which the predicate returns true.\n   * The second will trigger observations for those values where the predicate returns false.\n   * The predicate is executed once for each subscribed observer.\n   * Both also propagate all error observations arising from the source and each completes\n   * when the source completes.\n   * @param {Function} predicate\n   *    The function to determine which output Observable will trigger a particular observation.\n   * @returns {Array}\n   *    An array of observables. The first triggers when the predicate returns true,\n   *    and the second triggers when the predicate returns false.\n  */\n  observableProto.partition = function(predicate, thisArg) {\n    var fn = bindCallback(predicate, thisArg, 3);\n    return [\n      this.filter(predicate, thisArg),\n      this.filter(function (x, i, o) { return !fn(x, i, o); })\n    ];\n  };\n\n  var WhileEnumerable = (function(__super__) {\n    inherits(WhileEnumerable, __super__);\n    function WhileEnumerable(c, s) {\n      this.c = c;\n      this.s = s;\n    }\n    WhileEnumerable.prototype[$iterator$] = function () {\n      var self = this;\n      return {\n        next: function () {\n          return self.c() ?\n           { done: false, value: self.s } :\n           { done: true, value: void 0 };\n        }\n      };\n    };\n    return WhileEnumerable;\n  }(Enumerable));\n  \n  function enumerableWhile(condition, source) {\n    return new WhileEnumerable(condition, source);\n  }  \n\n   /**\n   *  Returns an observable sequence that is the result of invoking the selector on the source sequence, without sharing subscriptions.\n   *  This operator allows for a fluent style of writing queries that use the same sequence multiple times.\n   *\n   * @param {Function} selector Selector function which can use the source sequence as many times as needed, without sharing subscriptions to the source sequence.\n   * @returns {Observable} An observable sequence that contains the elements of a sequence produced by multicasting the source sequence within a selector function.\n   */\n  observableProto.letBind = observableProto['let'] = function (func) {\n    return func(this);\n  };\n\n   /**\n   *  Determines whether an observable collection contains values. \n   *\n   * @example\n   *  1 - res = Rx.Observable.if(condition, obs1);\n   *  2 - res = Rx.Observable.if(condition, obs1, obs2);\n   *  3 - res = Rx.Observable.if(condition, obs1, scheduler);\n   * @param {Function} condition The condition which determines if the thenSource or elseSource will be run.\n   * @param {Observable} thenSource The observable sequence or Promise that will be run if the condition function returns true.\n   * @param {Observable} [elseSource] The observable sequence or Promise that will be run if the condition function returns false. If this is not provided, it defaults to Rx.Observabe.Empty with the specified scheduler.\n   * @returns {Observable} An observable sequence which is either the thenSource or elseSource.\n   */\n  Observable['if'] = function (condition, thenSource, elseSourceOrScheduler) {\n    return observableDefer(function () {\n      elseSourceOrScheduler || (elseSourceOrScheduler = observableEmpty());\n\n      isPromise(thenSource) && (thenSource = observableFromPromise(thenSource));\n      isPromise(elseSourceOrScheduler) && (elseSourceOrScheduler = observableFromPromise(elseSourceOrScheduler));\n\n      // Assume a scheduler for empty only\n      typeof elseSourceOrScheduler.now === 'function' && (elseSourceOrScheduler = observableEmpty(elseSourceOrScheduler));\n      return condition() ? thenSource : elseSourceOrScheduler;\n    });\n  };\n\n   /**\n   *  Concatenates the observable sequences obtained by running the specified result selector for each element in source.\n   * There is an alias for this method called 'forIn' for browsers <IE9\n   * @param {Array} sources An array of values to turn into an observable sequence.\n   * @param {Function} resultSelector A function to apply to each item in the sources array to turn it into an observable sequence.\n   * @returns {Observable} An observable sequence from the concatenated observable sequences.\n   */\n  Observable['for'] = Observable.forIn = function (sources, resultSelector, thisArg) {\n    return enumerableOf(sources, resultSelector, thisArg).concat();\n  };\n\n   /**\n   *  Repeats source as long as condition holds emulating a while loop.\n   * There is an alias for this method called 'whileDo' for browsers <IE9\n   *\n   * @param {Function} condition The condition which determines if the source will be repeated.\n   * @param {Observable} source The observable sequence that will be run if the condition function returns true.\n   * @returns {Observable} An observable sequence which is repeated as long as the condition holds.\n   */\n  var observableWhileDo = Observable['while'] = Observable.whileDo = function (condition, source) {\n    isPromise(source) && (source = observableFromPromise(source));\n    return enumerableWhile(condition, source).concat();\n  };\n\n   /**\n   *  Repeats source as long as condition holds emulating a do while loop.\n   *\n   * @param {Function} condition The condition which determines if the source will be repeated.\n   * @param {Observable} source The observable sequence that will be run if the condition function returns true.\n   * @returns {Observable} An observable sequence which is repeated as long as the condition holds.\n   */\n  observableProto.doWhile = function (condition) {\n    return observableConcat([this, observableWhileDo(condition, this)]);\n  };\n\n   /**\n   *  Uses selector to determine which source in sources to use.\n   * @param {Function} selector The function which extracts the value for to test in a case statement.\n   * @param {Array} sources A object which has keys which correspond to the case statement labels.\n   * @param {Observable} [elseSource] The observable sequence or Promise that will be run if the sources are not matched. If this is not provided, it defaults to Rx.Observabe.empty with the specified scheduler.\n   *\n   * @returns {Observable} An observable sequence which is determined by a case statement.\n   */\n  Observable['case'] = function (selector, sources, defaultSourceOrScheduler) {\n    return observableDefer(function () {\n      isPromise(defaultSourceOrScheduler) && (defaultSourceOrScheduler = observableFromPromise(defaultSourceOrScheduler));\n      defaultSourceOrScheduler || (defaultSourceOrScheduler = observableEmpty());\n\n      isScheduler(defaultSourceOrScheduler) && (defaultSourceOrScheduler = observableEmpty(defaultSourceOrScheduler));\n\n      var result = sources[selector()];\n      isPromise(result) && (result = observableFromPromise(result));\n\n      return result || defaultSourceOrScheduler;\n    });\n  };\n\n  var ExpandObservable = (function(__super__) {\n    inherits(ExpandObservable, __super__);\n    function ExpandObservable(source, fn, scheduler) {\n      this.source = source;\n      this._fn = fn;\n      this._scheduler = scheduler;\n      __super__.call(this);\n    }\n\n    function scheduleRecursive(args, recurse) {\n      var state = args[0], self = args[1];\n      var work;\n      if (state.q.length > 0) {\n        work = state.q.shift();\n      } else {\n        state.isAcquired = false;\n        return;\n      }\n      var m1 = new SingleAssignmentDisposable();\n      state.d.add(m1);\n      m1.setDisposable(work.subscribe(new ExpandObserver(state, self, m1)));\n      recurse([state, self]);\n    }\n\n    ExpandObservable.prototype._ensureActive = function (state) {\n      var isOwner = false;\n      if (state.q.length > 0) {\n        isOwner = !state.isAcquired;\n        state.isAcquired = true;\n      }\n      isOwner && state.m.setDisposable(this._scheduler.scheduleRecursive([state, this], scheduleRecursive));\n    };\n\n    ExpandObservable.prototype.subscribeCore = function (o) {\n      var m = new SerialDisposable(),\n        d = new CompositeDisposable(m),\n        state = {\n          q: [],\n          m: m,\n          d: d,\n          activeCount: 0,\n          isAcquired: false,\n          o: o\n        };\n\n      state.q.push(this.source);\n      state.activeCount++;\n      this._ensureActive(state);\n      return d;\n    };\n\n    return ExpandObservable;\n  }(ObservableBase));\n\n  var ExpandObserver = (function(__super__) {\n    inherits(ExpandObserver, __super__);\n    function ExpandObserver(state, parent, m1) {\n      this._s = state;\n      this._p = parent;\n      this._m1 = m1;\n      __super__.call(this);\n    }\n\n    ExpandObserver.prototype.next = function (x) {\n      this._s.o.onNext(x);\n      var result = tryCatch(this._p._fn)(x);\n      if (result === errorObj) { return this._s.o.onError(result.e); }\n      this._s.q.push(result);\n      this._s.activeCount++;\n      this._p._ensureActive(this._s);\n    };\n\n    ExpandObserver.prototype.error = function (e) {\n      this._s.o.onError(e);\n    };\n\n    ExpandObserver.prototype.completed = function () {\n      this._s.d.remove(this._m1);\n      this._s.activeCount--;\n      this._s.activeCount === 0 && this._s.o.onCompleted();\n    };\n\n    return ExpandObserver;\n  }(AbstractObserver));\n\n   /**\n   *  Expands an observable sequence by recursively invoking selector.\n   *\n   * @param {Function} selector Selector function to invoke for each produced element, resulting in another sequence to which the selector will be invoked recursively again.\n   * @param {Scheduler} [scheduler] Scheduler on which to perform the expansion. If not provided, this defaults to the current thread scheduler.\n   * @returns {Observable} An observable sequence containing all the elements produced by the recursive expansion.\n   */\n  observableProto.expand = function (selector, scheduler) {\n    isScheduler(scheduler) || (scheduler = currentThreadScheduler);\n    return new ExpandObservable(this, selector, scheduler);\n  };\n\n  function argumentsToArray() {\n    var len = arguments.length, args = new Array(len);\n    for(var i = 0; i < len; i++) { args[i] = arguments[i]; }\n    return args;\n  }\n\n  var ForkJoinObservable = (function (__super__) {\n    inherits(ForkJoinObservable, __super__);\n    function ForkJoinObservable(sources, cb) {\n      this._sources = sources;\n      this._cb = cb;\n      __super__.call(this);\n    }\n\n    ForkJoinObservable.prototype.subscribeCore = function (o) {\n      if (this._sources.length === 0) {\n        o.onCompleted();\n        return disposableEmpty;\n      }\n\n      var count = this._sources.length;\n      var state = {\n        finished: false,\n        hasResults: new Array(count),\n        hasCompleted: new Array(count),\n        results: new Array(count)\n      };\n\n      var subscriptions = new CompositeDisposable();\n      for (var i = 0, len = this._sources.length; i < len; i++) {\n        var source = this._sources[i];\n        isPromise(source) && (source = observableFromPromise(source));\n        subscriptions.add(source.subscribe(new ForkJoinObserver(o, state, i, this._cb, subscriptions)));\n      }\n\n      return subscriptions;\n    };\n\n    return ForkJoinObservable;\n  }(ObservableBase));\n\n  var ForkJoinObserver = (function(__super__) {\n    inherits(ForkJoinObserver, __super__);\n    function ForkJoinObserver(o, s, i, cb, subs) {\n      this._o = o;\n      this._s = s;\n      this._i = i;\n      this._cb = cb;\n      this._subs = subs;\n      __super__.call(this);\n    }\n\n    ForkJoinObserver.prototype.next = function (x) {\n      if (!this._s.finished) {\n        this._s.hasResults[this._i] = true;\n        this._s.results[this._i] = x;\n      }\n    };\n\n    ForkJoinObserver.prototype.error = function (e) {\n      this._s.finished = true;\n      this._o.onError(e);\n      this._subs.dispose();\n    };\n\n    ForkJoinObserver.prototype.completed = function () {\n      if (!this._s.finished) {\n        if (!this._s.hasResults[this._i]) {\n          return this._o.onCompleted();\n        }\n        this._s.hasCompleted[this._i] = true;\n        for (var i = 0; i < this._s.results.length; i++) {\n          if (!this._s.hasCompleted[i]) { return; }\n        }\n        this._s.finished = true;\n\n        var res = tryCatch(this._cb).apply(null, this._s.results);\n        if (res === errorObj) { return this._o.onError(res.e); }\n\n        this._o.onNext(res);\n        this._o.onCompleted();\n      }\n    };\n\n    return ForkJoinObserver;\n  }(AbstractObserver));\n\n   /**\n   *  Runs all observable sequences in parallel and collect their last elements.\n   *\n   * @example\n   *  1 - res = Rx.Observable.forkJoin([obs1, obs2]);\n   *  1 - res = Rx.Observable.forkJoin(obs1, obs2, ...);\n   * @returns {Observable} An observable sequence with an array collecting the last elements of all the input sequences.\n   */\n  Observable.forkJoin = function () {\n    var len = arguments.length, args = new Array(len);\n    for(var i = 0; i < len; i++) { args[i] = arguments[i]; }\n    var resultSelector = isFunction(args[len - 1]) ? args.pop() : argumentsToArray;\n    Array.isArray(args[0]) && (args = args[0]);\n    return new ForkJoinObservable(args, resultSelector);\n  };\n\n   /**\n   *  Runs two observable sequences in parallel and combines their last elemenets.\n   * @param {Observable} second Second observable sequence.\n   * @param {Function} resultSelector Result selector function to invoke with the last elements of both sequences.\n   * @returns {Observable} An observable sequence with the result of calling the selector function with the last elements of both input sequences.\n   */\n  observableProto.forkJoin = function () {\n    var len = arguments.length, args = new Array(len);\n    for(var i = 0; i < len; i++) { args[i] = arguments[i]; }\n    if (Array.isArray(args[0])) {\n      args[0].unshift(this);\n    } else {\n      args.unshift(this);\n    }\n    return Observable.forkJoin.apply(null, args);\n  };\n\n  /**\n   * Comonadic bind operator.\n   * @param {Function} selector A transform function to apply to each element.\n   * @param {Object} scheduler Scheduler used to execute the operation. If not specified, defaults to the ImmediateScheduler.\n   * @returns {Observable} An observable sequence which results from the comonadic bind operation.\n   */\n  observableProto.manySelect = observableProto.extend = function (selector, scheduler) {\n    isScheduler(scheduler) || (scheduler = Rx.Scheduler.immediate);\n    var source = this;\n    return observableDefer(function () {\n      var chain;\n\n      return source\n        .map(function (x) {\n          var curr = new ChainObservable(x);\n\n          chain && chain.onNext(x);\n          chain = curr;\n\n          return curr;\n        })\n        .tap(\n          noop,\n          function (e) { chain && chain.onError(e); },\n          function () { chain && chain.onCompleted(); }\n        )\n        .observeOn(scheduler)\n        .map(selector);\n    }, source);\n  };\n\n  var ChainObservable = (function (__super__) {\n    inherits(ChainObservable, __super__);\n    function ChainObservable(head) {\n      __super__.call(this);\n      this.head = head;\n      this.tail = new AsyncSubject();\n    }\n\n    addProperties(ChainObservable.prototype, Observer, {\n      _subscribe: function (o) {\n        var g = new CompositeDisposable();\n        g.add(currentThreadScheduler.schedule(this, function (_, self) {\n          o.onNext(self.head);\n          g.add(self.tail.mergeAll().subscribe(o));\n        }));\n\n        return g;\n      },\n      onCompleted: function () {\n        this.onNext(Observable.empty());\n      },\n      onError: function (e) {\n        this.onNext(Observable['throw'](e));\n      },\n      onNext: function (v) {\n        this.tail.onNext(v);\n        this.tail.onCompleted();\n      }\n    });\n\n    return ChainObservable;\n\n  }(Observable));\n\n  var Map = root.Map || (function () {\n    function Map() {\n      this.size = 0;\n      this._values = [];\n      this._keys = [];\n    }\n\n    Map.prototype['delete'] = function (key) {\n      var i = this._keys.indexOf(key);\n      if (i === -1) { return false; }\n      this._values.splice(i, 1);\n      this._keys.splice(i, 1);\n      this.size--;\n      return true;\n    };\n\n    Map.prototype.get = function (key) {\n      var i = this._keys.indexOf(key);\n      return i === -1 ? undefined : this._values[i];\n    };\n\n    Map.prototype.set = function (key, value) {\n      var i = this._keys.indexOf(key);\n      if (i === -1) {\n        this._keys.push(key);\n        this._values.push(value);\n        this.size++;\n      } else {\n        this._values[i] = value;\n      }\n      return this;\n    };\n\n    Map.prototype.forEach = function (cb, thisArg) {\n      for (var i = 0; i < this.size; i++) {\n        cb.call(thisArg, this._values[i], this._keys[i]);\n      }\n    };\n\n    return Map;\n  }());\n\n  /**\n   * @constructor\n   * Represents a join pattern over observable sequences.\n   */\n  function Pattern(patterns) {\n    this.patterns = patterns;\n  }\n\n  /**\n   *  Creates a pattern that matches the current plan matches and when the specified observable sequences has an available value.\n   *  @param other Observable sequence to match in addition to the current pattern.\n   *  @return {Pattern} Pattern object that matches when all observable sequences in the pattern have an available value.\n   */\n  Pattern.prototype.and = function (other) {\n    return new Pattern(this.patterns.concat(other));\n  };\n\n  /**\n   *  Matches when all observable sequences in the pattern (specified using a chain of and operators) have an available value and projects the values.\n   *  @param {Function} selector Selector that will be invoked with available values from the source sequences, in the same order of the sequences in the pattern.\n   *  @return {Plan} Plan that produces the projected values, to be fed (with other plans) to the when operator.\n   */\n  Pattern.prototype.thenDo = function (selector) {\n    return new Plan(this, selector);\n  };\n\n  function Plan(expression, selector) {\n    this.expression = expression;\n    this.selector = selector;\n  }\n\n  function handleOnError(o) { return function (e) { o.onError(e); }; }\n  function handleOnNext(self, observer) {\n    return function onNext () {\n      var result = tryCatch(self.selector).apply(self, arguments);\n      if (result === errorObj) { return observer.onError(result.e); }\n      observer.onNext(result);\n    };\n  }\n\n  Plan.prototype.activate = function (externalSubscriptions, observer, deactivate) {\n    var joinObservers = [], errHandler = handleOnError(observer);\n    for (var i = 0, len = this.expression.patterns.length; i < len; i++) {\n      joinObservers.push(planCreateObserver(externalSubscriptions, this.expression.patterns[i], errHandler));\n    }\n    var activePlan = new ActivePlan(joinObservers, handleOnNext(this, observer), function () {\n      for (var j = 0, jlen = joinObservers.length; j < jlen; j++) {\n        joinObservers[j].removeActivePlan(activePlan);\n      }\n      deactivate(activePlan);\n    });\n    for (i = 0, len = joinObservers.length; i < len; i++) {\n      joinObservers[i].addActivePlan(activePlan);\n    }\n    return activePlan;\n  };\n\n  function planCreateObserver(externalSubscriptions, observable, onError) {\n    var entry = externalSubscriptions.get(observable);\n    if (!entry) {\n      var observer = new JoinObserver(observable, onError);\n      externalSubscriptions.set(observable, observer);\n      return observer;\n    }\n    return entry;\n  }\n\n  function ActivePlan(joinObserverArray, onNext, onCompleted) {\n    this.joinObserverArray = joinObserverArray;\n    this.onNext = onNext;\n    this.onCompleted = onCompleted;\n    this.joinObservers = new Map();\n    for (var i = 0, len = this.joinObserverArray.length; i < len; i++) {\n      var joinObserver = this.joinObserverArray[i];\n      this.joinObservers.set(joinObserver, joinObserver);\n    }\n  }\n\n  ActivePlan.prototype.dequeue = function () {\n    this.joinObservers.forEach(function (v) { v.queue.shift(); });\n  };\n\n  ActivePlan.prototype.match = function () {\n    var i, len, hasValues = true;\n    for (i = 0, len = this.joinObserverArray.length; i < len; i++) {\n      if (this.joinObserverArray[i].queue.length === 0) {\n        hasValues = false;\n        break;\n      }\n    }\n    if (hasValues) {\n      var firstValues = [],\n          isCompleted = false;\n      for (i = 0, len = this.joinObserverArray.length; i < len; i++) {\n        firstValues.push(this.joinObserverArray[i].queue[0]);\n        this.joinObserverArray[i].queue[0].kind === 'C' && (isCompleted = true);\n      }\n      if (isCompleted) {\n        this.onCompleted();\n      } else {\n        this.dequeue();\n        var values = [];\n        for (i = 0, len = firstValues.length; i < firstValues.length; i++) {\n          values.push(firstValues[i].value);\n        }\n        this.onNext.apply(this, values);\n      }\n    }\n  };\n\n  var JoinObserver = (function (__super__) {\n    inherits(JoinObserver, __super__);\n\n    function JoinObserver(source, onError) {\n      __super__.call(this);\n      this.source = source;\n      this.onError = onError;\n      this.queue = [];\n      this.activePlans = [];\n      this.subscription = new SingleAssignmentDisposable();\n      this.isDisposed = false;\n    }\n\n    var JoinObserverPrototype = JoinObserver.prototype;\n\n    JoinObserverPrototype.next = function (notification) {\n      if (!this.isDisposed) {\n        if (notification.kind === 'E') {\n          return this.onError(notification.error);\n        }\n        this.queue.push(notification);\n        var activePlans = this.activePlans.slice(0);\n        for (var i = 0, len = activePlans.length; i < len; i++) {\n          activePlans[i].match();\n        }\n      }\n    };\n\n    JoinObserverPrototype.error = noop;\n    JoinObserverPrototype.completed = noop;\n\n    JoinObserverPrototype.addActivePlan = function (activePlan) {\n      this.activePlans.push(activePlan);\n    };\n\n    JoinObserverPrototype.subscribe = function () {\n      this.subscription.setDisposable(this.source.materialize().subscribe(this));\n    };\n\n    JoinObserverPrototype.removeActivePlan = function (activePlan) {\n      this.activePlans.splice(this.activePlans.indexOf(activePlan), 1);\n      this.activePlans.length === 0 && this.dispose();\n    };\n\n    JoinObserverPrototype.dispose = function () {\n      __super__.prototype.dispose.call(this);\n      if (!this.isDisposed) {\n        this.isDisposed = true;\n        this.subscription.dispose();\n      }\n    };\n\n    return JoinObserver;\n  } (AbstractObserver));\n\n  /**\n   *  Creates a pattern that matches when both observable sequences have an available value.\n   *\n   *  @param right Observable sequence to match with the current sequence.\n   *  @return {Pattern} Pattern object that matches when both observable sequences have an available value.\n   */\n  observableProto.and = function (right) {\n    return new Pattern([this, right]);\n  };\n\n  /**\n   *  Matches when the observable sequence has an available value and projects the value.\n   *\n   *  @param {Function} selector Selector that will be invoked for values in the source sequence.\n   *  @returns {Plan} Plan that produces the projected values, to be fed (with other plans) to the when operator.\n   */\n  observableProto.thenDo = function (selector) {\n    return new Pattern([this]).thenDo(selector);\n  };\n\n  /**\n   *  Joins together the results from several patterns.\n   *\n   *  @param plans A series of plans (specified as an Array of as a series of arguments) created by use of the Then operator on patterns.\n   *  @returns {Observable} Observable sequence with the results form matching several patterns.\n   */\n  Observable.when = function () {\n    var len = arguments.length, plans;\n    if (Array.isArray(arguments[0])) {\n      plans = arguments[0];\n    } else {\n      plans = new Array(len);\n      for(var i = 0; i < len; i++) { plans[i] = arguments[i]; }\n    }\n    return new AnonymousObservable(function (o) {\n      var activePlans = [],\n          externalSubscriptions = new Map();\n      var outObserver = observerCreate(\n        function (x) { o.onNext(x); },\n        function (err) {\n          externalSubscriptions.forEach(function (v) { v.onError(err); });\n          o.onError(err);\n        },\n        function (x) { o.onCompleted(); }\n      );\n      try {\n        for (var i = 0, len = plans.length; i < len; i++) {\n          activePlans.push(plans[i].activate(externalSubscriptions, outObserver, function (activePlan) {\n            var idx = activePlans.indexOf(activePlan);\n            activePlans.splice(idx, 1);\n            activePlans.length === 0 && o.onCompleted();\n          }));\n        }\n      } catch (e) {\n        observableThrow(e).subscribe(o);\n      }\n      var group = new CompositeDisposable();\n      externalSubscriptions.forEach(function (joinObserver) {\n        joinObserver.subscribe();\n        group.add(joinObserver);\n      });\n\n      return group;\n    });\n  };\n\n  var TimerObservable = (function(__super__) {\n    inherits(TimerObservable, __super__);\n    function TimerObservable(dt, s) {\n      this._dt = dt;\n      this._s = s;\n      __super__.call(this);\n    }\n\n    TimerObservable.prototype.subscribeCore = function (o) {\n      return this._s.scheduleFuture(o, this._dt, scheduleMethod);\n    };\n\n    function scheduleMethod(s, o) {\n      o.onNext(0);\n      o.onCompleted();\n    }\n\n    return TimerObservable;\n  }(ObservableBase));\n\n  function _observableTimer(dueTime, scheduler) {\n    return new TimerObservable(dueTime, scheduler);\n  }\n\n  function observableTimerDateAndPeriod(dueTime, period, scheduler) {\n    return new AnonymousObservable(function (observer) {\n      var d = dueTime, p = normalizeTime(period);\n      return scheduler.scheduleRecursiveFuture(0, d, function (count, self) {\n        if (p > 0) {\n          var now = scheduler.now();\n          d = new Date(d.getTime() + p);\n          d.getTime() <= now && (d = new Date(now + p));\n        }\n        observer.onNext(count);\n        self(count + 1, new Date(d));\n      });\n    });\n  }\n\n  function observableTimerTimeSpanAndPeriod(dueTime, period, scheduler) {\n    return dueTime === period ?\n      new AnonymousObservable(function (observer) {\n        return scheduler.schedulePeriodic(0, period, function (count) {\n          observer.onNext(count);\n          return count + 1;\n        });\n      }) :\n      observableDefer(function () {\n        return observableTimerDateAndPeriod(new Date(scheduler.now() + dueTime), period, scheduler);\n      });\n  }\n\n  /**\n   *  Returns an observable sequence that produces a value after each period.\n   *\n   * @example\n   *  1 - res = Rx.Observable.interval(1000);\n   *  2 - res = Rx.Observable.interval(1000, Rx.Scheduler.timeout);\n   *\n   * @param {Number} period Period for producing the values in the resulting sequence (specified as an integer denoting milliseconds).\n   * @param {Scheduler} [scheduler] Scheduler to run the timer on. If not specified, Rx.Scheduler.timeout is used.\n   * @returns {Observable} An observable sequence that produces a value after each period.\n   */\n  var observableinterval = Observable.interval = function (period, scheduler) {\n    return observableTimerTimeSpanAndPeriod(period, period, isScheduler(scheduler) ? scheduler : defaultScheduler);\n  };\n\n  /**\n   *  Returns an observable sequence that produces a value after dueTime has elapsed and then after each period.\n   * @param {Number} dueTime Absolute (specified as a Date object) or relative time (specified as an integer denoting milliseconds) at which to produce the first value.\n   * @param {Mixed} [periodOrScheduler]  Period to produce subsequent values (specified as an integer denoting milliseconds), or the scheduler to run the timer on. If not specified, the resulting timer is not recurring.\n   * @param {Scheduler} [scheduler]  Scheduler to run the timer on. If not specified, the timeout scheduler is used.\n   * @returns {Observable} An observable sequence that produces a value after due time has elapsed and then each period.\n   */\n  var observableTimer = Observable.timer = function (dueTime, periodOrScheduler, scheduler) {\n    var period;\n    isScheduler(scheduler) || (scheduler = defaultScheduler);\n    if (periodOrScheduler != null && typeof periodOrScheduler === 'number') {\n      period = periodOrScheduler;\n    } else if (isScheduler(periodOrScheduler)) {\n      scheduler = periodOrScheduler;\n    }\n    if ((dueTime instanceof Date || typeof dueTime === 'number') && period === undefined) {\n      return _observableTimer(dueTime, scheduler);\n    }\n    if (dueTime instanceof Date && period !== undefined) {\n      return observableTimerDateAndPeriod(dueTime.getTime(), periodOrScheduler, scheduler);\n    }\n    return observableTimerTimeSpanAndPeriod(dueTime, period, scheduler);\n  };\n\n  function observableDelayRelative(source, dueTime, scheduler) {\n    return new AnonymousObservable(function (o) {\n      var active = false,\n        cancelable = new SerialDisposable(),\n        exception = null,\n        q = [],\n        running = false,\n        subscription;\n      subscription = source.materialize().timestamp(scheduler).subscribe(function (notification) {\n        var d, shouldRun;\n        if (notification.value.kind === 'E') {\n          q = [];\n          q.push(notification);\n          exception = notification.value.error;\n          shouldRun = !running;\n        } else {\n          q.push({ value: notification.value, timestamp: notification.timestamp + dueTime });\n          shouldRun = !active;\n          active = true;\n        }\n        if (shouldRun) {\n          if (exception !== null) {\n            o.onError(exception);\n          } else {\n            d = new SingleAssignmentDisposable();\n            cancelable.setDisposable(d);\n            d.setDisposable(scheduler.scheduleRecursiveFuture(null, dueTime, function (_, self) {\n              var e, recurseDueTime, result, shouldRecurse;\n              if (exception !== null) {\n                return;\n              }\n              running = true;\n              do {\n                result = null;\n                if (q.length > 0 && q[0].timestamp - scheduler.now() <= 0) {\n                  result = q.shift().value;\n                }\n                if (result !== null) {\n                  result.accept(o);\n                }\n              } while (result !== null);\n              shouldRecurse = false;\n              recurseDueTime = 0;\n              if (q.length > 0) {\n                shouldRecurse = true;\n                recurseDueTime = Math.max(0, q[0].timestamp - scheduler.now());\n              } else {\n                active = false;\n              }\n              e = exception;\n              running = false;\n              if (e !== null) {\n                o.onError(e);\n              } else if (shouldRecurse) {\n                self(null, recurseDueTime);\n              }\n            }));\n          }\n        }\n      });\n      return new BinaryDisposable(subscription, cancelable);\n    }, source);\n  }\n\n  function observableDelayAbsolute(source, dueTime, scheduler) {\n    return observableDefer(function () {\n      return observableDelayRelative(source, dueTime - scheduler.now(), scheduler);\n    });\n  }\n\n  function delayWithSelector(source, subscriptionDelay, delayDurationSelector) {\n    var subDelay, selector;\n    if (isFunction(subscriptionDelay)) {\n      selector = subscriptionDelay;\n    } else {\n      subDelay = subscriptionDelay;\n      selector = delayDurationSelector;\n    }\n    return new AnonymousObservable(function (o) {\n      var delays = new CompositeDisposable(), atEnd = false, subscription = new SerialDisposable();\n\n      function start() {\n        subscription.setDisposable(source.subscribe(\n          function (x) {\n            var delay = tryCatch(selector)(x);\n            if (delay === errorObj) { return o.onError(delay.e); }\n            var d = new SingleAssignmentDisposable();\n            delays.add(d);\n            d.setDisposable(delay.subscribe(\n              function () {\n                o.onNext(x);\n                delays.remove(d);\n                done();\n              },\n              function (e) { o.onError(e); },\n              function () {\n                o.onNext(x);\n                delays.remove(d);\n                done();\n              }\n            ));\n          },\n          function (e) { o.onError(e); },\n          function () {\n            atEnd = true;\n            subscription.dispose();\n            done();\n          }\n        ));\n      }\n\n      function done () {\n        atEnd && delays.length === 0 && o.onCompleted();\n      }\n\n      if (!subDelay) {\n        start();\n      } else {\n        subscription.setDisposable(subDelay.subscribe(start, function (e) { o.onError(e); }, start));\n      }\n\n      return new BinaryDisposable(subscription, delays);\n    }, this);\n  }\n\n  /**\n   *  Time shifts the observable sequence by dueTime.\n   *  The relative time intervals between the values are preserved.\n   *\n   * @param {Number} dueTime Absolute (specified as a Date object) or relative time (specified as an integer denoting milliseconds) by which to shift the observable sequence.\n   * @param {Scheduler} [scheduler] Scheduler to run the delay timers on. If not specified, the timeout scheduler is used.\n   * @returns {Observable} Time-shifted sequence.\n   */\n  observableProto.delay = function () {\n    var firstArg = arguments[0];\n    if (typeof firstArg === 'number' || firstArg instanceof Date) {\n      var dueTime = firstArg, scheduler = arguments[1];\n      isScheduler(scheduler) || (scheduler = defaultScheduler);\n      return dueTime instanceof Date ?\n        observableDelayAbsolute(this, dueTime, scheduler) :\n        observableDelayRelative(this, dueTime, scheduler);\n    } else if (Observable.isObservable(firstArg) || isFunction(firstArg)) {\n      return delayWithSelector(this, firstArg, arguments[1]);\n    } else {\n      throw new Error('Invalid arguments');\n    }\n  };\n\n  var DebounceObservable = (function (__super__) {\n    inherits(DebounceObservable, __super__);\n    function DebounceObservable(source, dt, s) {\n      isScheduler(s) || (s = defaultScheduler);\n      this.source = source;\n      this._dt = dt;\n      this._s = s;\n      __super__.call(this);\n    }\n\n    DebounceObservable.prototype.subscribeCore = function (o) {\n      var cancelable = new SerialDisposable();\n      return new BinaryDisposable(\n        this.source.subscribe(new DebounceObserver(o, this.source, this._dt, this._s, cancelable)),\n        cancelable);\n    };\n\n    return DebounceObservable;\n  }(ObservableBase));\n\n  var DebounceObserver = (function (__super__) {\n    inherits(DebounceObserver, __super__);\n    function DebounceObserver(observer, source, dueTime, scheduler, cancelable) {\n      this._o = observer;\n      this._s = source;\n      this._d = dueTime;\n      this._scheduler = scheduler;\n      this._c = cancelable;\n      this._v = null;\n      this._hv = false;\n      this._id = 0;\n      __super__.call(this);\n    }\n\n    DebounceObserver.prototype.next = function (x) {\n      this._hv = true;\n      this._v = x;\n      var currentId = ++this._id, d = new SingleAssignmentDisposable();\n      this._c.setDisposable(d);\n      d.setDisposable(this._scheduler.scheduleFuture(this, this._d, function (_, self) {\n        self._hv && self._id === currentId && self._o.onNext(x);\n        self._hv = false;\n      }));\n    };\n\n    DebounceObserver.prototype.error = function (e) {\n      this._c.dispose();\n      this._o.onError(e);\n      this._hv = false;\n      this._id++;\n    };\n\n    DebounceObserver.prototype.completed = function () {\n      this._c.dispose();\n      this._hv && this._o.onNext(this._v);\n      this._o.onCompleted();\n      this._hv = false;\n      this._id++;\n    };\n\n    return DebounceObserver;\n  }(AbstractObserver));\n\n  function debounceWithSelector(source, durationSelector) {\n    return new AnonymousObservable(function (o) {\n      var value, hasValue = false, cancelable = new SerialDisposable(), id = 0;\n      var subscription = source.subscribe(\n        function (x) {\n          var throttle = tryCatch(durationSelector)(x);\n          if (throttle === errorObj) { return o.onError(throttle.e); }\n\n          isPromise(throttle) && (throttle = observableFromPromise(throttle));\n\n          hasValue = true;\n          value = x;\n          id++;\n          var currentid = id, d = new SingleAssignmentDisposable();\n          cancelable.setDisposable(d);\n          d.setDisposable(throttle.subscribe(\n            function () {\n              hasValue && id === currentid && o.onNext(value);\n              hasValue = false;\n              d.dispose();\n            },\n            function (e) { o.onError(e); },\n            function () {\n              hasValue && id === currentid && o.onNext(value);\n              hasValue = false;\n              d.dispose();\n            }\n          ));\n        },\n        function (e) {\n          cancelable.dispose();\n          o.onError(e);\n          hasValue = false;\n          id++;\n        },\n        function () {\n          cancelable.dispose();\n          hasValue && o.onNext(value);\n          o.onCompleted();\n          hasValue = false;\n          id++;\n        }\n      );\n      return new BinaryDisposable(subscription, cancelable);\n    }, source);\n  }\n\n  observableProto.debounce = function () {\n    if (isFunction (arguments[0])) {\n      return debounceWithSelector(this, arguments[0]);\n    } else if (typeof arguments[0] === 'number') {\n      return new DebounceObservable(this, arguments[0], arguments[1]);\n    } else {\n      throw new Error('Invalid arguments');\n    }\n  };\n\n  /**\n   *  Projects each element of an observable sequence into zero or more windows which are produced based on timing information.\n   * @param {Number} timeSpan Length of each window (specified as an integer denoting milliseconds).\n   * @param {Mixed} [timeShiftOrScheduler]  Interval between creation of consecutive windows (specified as an integer denoting milliseconds), or an optional scheduler parameter. If not specified, the time shift corresponds to the timeSpan parameter, resulting in non-overlapping adjacent windows.\n   * @param {Scheduler} [scheduler]  Scheduler to run windowing timers on. If not specified, the timeout scheduler is used.\n   * @returns {Observable} An observable sequence of windows.\n   */\n  observableProto.windowWithTime = function (timeSpan, timeShiftOrScheduler, scheduler) {\n    var source = this, timeShift;\n    timeShiftOrScheduler == null && (timeShift = timeSpan);\n    isScheduler(scheduler) || (scheduler = defaultScheduler);\n    if (typeof timeShiftOrScheduler === 'number') {\n      timeShift = timeShiftOrScheduler;\n    } else if (isScheduler(timeShiftOrScheduler)) {\n      timeShift = timeSpan;\n      scheduler = timeShiftOrScheduler;\n    }\n    return new AnonymousObservable(function (observer) {\n      var groupDisposable,\n        nextShift = timeShift,\n        nextSpan = timeSpan,\n        q = [],\n        refCountDisposable,\n        timerD = new SerialDisposable(),\n        totalTime = 0;\n        groupDisposable = new CompositeDisposable(timerD),\n        refCountDisposable = new RefCountDisposable(groupDisposable);\n\n       function createTimer () {\n        var m = new SingleAssignmentDisposable(),\n          isSpan = false,\n          isShift = false;\n        timerD.setDisposable(m);\n        if (nextSpan === nextShift) {\n          isSpan = true;\n          isShift = true;\n        } else if (nextSpan < nextShift) {\n            isSpan = true;\n        } else {\n          isShift = true;\n        }\n        var newTotalTime = isSpan ? nextSpan : nextShift,\n          ts = newTotalTime - totalTime;\n        totalTime = newTotalTime;\n        if (isSpan) {\n          nextSpan += timeShift;\n        }\n        if (isShift) {\n          nextShift += timeShift;\n        }\n        m.setDisposable(scheduler.scheduleFuture(null, ts, function () {\n          if (isShift) {\n            var s = new Subject();\n            q.push(s);\n            observer.onNext(addRef(s, refCountDisposable));\n          }\n          isSpan && q.shift().onCompleted();\n          createTimer();\n        }));\n      };\n      q.push(new Subject());\n      observer.onNext(addRef(q[0], refCountDisposable));\n      createTimer();\n      groupDisposable.add(source.subscribe(\n        function (x) {\n          for (var i = 0, len = q.length; i < len; i++) { q[i].onNext(x); }\n        },\n        function (e) {\n          for (var i = 0, len = q.length; i < len; i++) { q[i].onError(e); }\n          observer.onError(e);\n        },\n        function () {\n          for (var i = 0, len = q.length; i < len; i++) { q[i].onCompleted(); }\n          observer.onCompleted();\n        }\n      ));\n      return refCountDisposable;\n    }, source);\n  };\n\n  /**\n   *  Projects each element of an observable sequence into a window that is completed when either it's full or a given amount of time has elapsed.\n   * @param {Number} timeSpan Maximum time length of a window.\n   * @param {Number} count Maximum element count of a window.\n   * @param {Scheduler} [scheduler]  Scheduler to run windowing timers on. If not specified, the timeout scheduler is used.\n   * @returns {Observable} An observable sequence of windows.\n   */\n  observableProto.windowWithTimeOrCount = function (timeSpan, count, scheduler) {\n    var source = this;\n    isScheduler(scheduler) || (scheduler = defaultScheduler);\n    return new AnonymousObservable(function (observer) {\n      var timerD = new SerialDisposable(),\n          groupDisposable = new CompositeDisposable(timerD),\n          refCountDisposable = new RefCountDisposable(groupDisposable),\n          n = 0,\n          windowId = 0,\n          s = new Subject();\n\n      function createTimer(id) {\n        var m = new SingleAssignmentDisposable();\n        timerD.setDisposable(m);\n        m.setDisposable(scheduler.scheduleFuture(null, timeSpan, function () {\n          if (id !== windowId) { return; }\n          n = 0;\n          var newId = ++windowId;\n          s.onCompleted();\n          s = new Subject();\n          observer.onNext(addRef(s, refCountDisposable));\n          createTimer(newId);\n        }));\n      }\n\n      observer.onNext(addRef(s, refCountDisposable));\n      createTimer(0);\n\n      groupDisposable.add(source.subscribe(\n        function (x) {\n          var newId = 0, newWindow = false;\n          s.onNext(x);\n          if (++n === count) {\n            newWindow = true;\n            n = 0;\n            newId = ++windowId;\n            s.onCompleted();\n            s = new Subject();\n            observer.onNext(addRef(s, refCountDisposable));\n          }\n          newWindow && createTimer(newId);\n        },\n        function (e) {\n          s.onError(e);\n          observer.onError(e);\n        }, function () {\n          s.onCompleted();\n          observer.onCompleted();\n        }\n      ));\n      return refCountDisposable;\n    }, source);\n  };\n\n  function toArray(x) { return x.toArray(); }\n\n  /**\n   *  Projects each element of an observable sequence into zero or more buffers which are produced based on timing information.\n   * @param {Number} timeSpan Length of each buffer (specified as an integer denoting milliseconds).\n   * @param {Mixed} [timeShiftOrScheduler]  Interval between creation of consecutive buffers (specified as an integer denoting milliseconds), or an optional scheduler parameter. If not specified, the time shift corresponds to the timeSpan parameter, resulting in non-overlapping adjacent buffers.\n   * @param {Scheduler} [scheduler]  Scheduler to run buffer timers on. If not specified, the timeout scheduler is used.\n   * @returns {Observable} An observable sequence of buffers.\n   */\n  observableProto.bufferWithTime = function (timeSpan, timeShiftOrScheduler, scheduler) {\n    return this.windowWithTime(timeSpan, timeShiftOrScheduler, scheduler).flatMap(toArray);\n  };\n\n  function toArray(x) { return x.toArray(); }\n\n  /**\n   *  Projects each element of an observable sequence into a buffer that is completed when either it's full or a given amount of time has elapsed.\n   * @param {Number} timeSpan Maximum time length of a buffer.\n   * @param {Number} count Maximum element count of a buffer.\n   * @param {Scheduler} [scheduler]  Scheduler to run bufferin timers on. If not specified, the timeout scheduler is used.\n   * @returns {Observable} An observable sequence of buffers.\n   */\n  observableProto.bufferWithTimeOrCount = function (timeSpan, count, scheduler) {\n    return this.windowWithTimeOrCount(timeSpan, count, scheduler).flatMap(toArray);\n  };\n\n  var TimeIntervalObservable = (function (__super__) {\n    inherits(TimeIntervalObservable, __super__);\n    function TimeIntervalObservable(source, s) {\n      this.source = source;\n      this._s = s;\n      __super__.call(this);\n    }\n\n    TimeIntervalObservable.prototype.subscribeCore = function (o) {\n      return this.source.subscribe(new TimeIntervalObserver(o, this._s));\n    };\n\n    return TimeIntervalObservable;\n  }(ObservableBase));\n\n  var TimeIntervalObserver = (function (__super__) {\n    inherits(TimeIntervalObserver, __super__);\n\n    function TimeIntervalObserver(o, s) {\n      this._o = o;\n      this._s = s;\n      this._l = s.now();\n      __super__.call(this);\n    }\n\n    TimeIntervalObserver.prototype.next = function (x) {\n      var now = this._s.now(), span = now - this._l;\n      this._l = now;\n      this._o.onNext({ value: x, interval: span });\n    };\n    TimeIntervalObserver.prototype.error = function (e) { this._o.onError(e); };\n    TimeIntervalObserver.prototype.completed = function () { this._o.onCompleted(); };\n\n    return TimeIntervalObserver;\n  }(AbstractObserver));\n\n  /**\n   *  Records the time interval between consecutive values in an observable sequence.\n   *\n   * @example\n   *  1 - res = source.timeInterval();\n   *  2 - res = source.timeInterval(Rx.Scheduler.timeout);\n   *\n   * @param [scheduler]  Scheduler used to compute time intervals. If not specified, the timeout scheduler is used.\n   * @returns {Observable} An observable sequence with time interval information on values.\n   */\n  observableProto.timeInterval = function (scheduler) {\n    isScheduler(scheduler) || (scheduler = defaultScheduler);\n    return new TimeIntervalObservable(this, scheduler);\n  };\n\n  var TimestampObservable = (function (__super__) {\n    inherits(TimestampObservable, __super__);\n    function TimestampObservable(source, s) {\n      this.source = source;\n      this._s = s;\n      __super__.call(this);\n    }\n\n    TimestampObservable.prototype.subscribeCore = function (o) {\n      return this.source.subscribe(new TimestampObserver(o, this._s));\n    };\n\n    return TimestampObservable;\n  }(ObservableBase));\n\n  var TimestampObserver = (function (__super__) {\n    inherits(TimestampObserver, __super__);\n    function TimestampObserver(o, s) {\n      this._o = o;\n      this._s = s;\n      __super__.call(this);\n    }\n\n    TimestampObserver.prototype.next = function (x) {\n      this._o.onNext({ value: x, timestamp: this._s.now() });\n    };\n\n    TimestampObserver.prototype.error = function (e) {\n      this._o.onError(e);\n    };\n\n    TimestampObserver.prototype.completed = function () {\n      this._o.onCompleted();\n    };\n\n    return TimestampObserver;\n  }(AbstractObserver));\n\n  /**\n   *  Records the timestamp for each value in an observable sequence.\n   *\n   * @example\n   *  1 - res = source.timestamp(); // produces { value: x, timestamp: ts }\n   *  2 - res = source.timestamp(Rx.Scheduler.default);\n   *\n   * @param {Scheduler} [scheduler]  Scheduler used to compute timestamps. If not specified, the default scheduler is used.\n   * @returns {Observable} An observable sequence with timestamp information on values.\n   */\n  observableProto.timestamp = function (scheduler) {\n    isScheduler(scheduler) || (scheduler = defaultScheduler);\n    return new TimestampObservable(this, scheduler);\n  };\n\n  function sampleObservable(source, sampler) {\n    return new AnonymousObservable(function (o) {\n      var atEnd = false, value, hasValue = false;\n\n      function sampleSubscribe() {\n        if (hasValue) {\n          hasValue = false;\n          o.onNext(value);\n        }\n        atEnd && o.onCompleted();\n      }\n\n      var sourceSubscription = new SingleAssignmentDisposable();\n      sourceSubscription.setDisposable(source.subscribe(\n        function (newValue) {\n          hasValue = true;\n          value = newValue;\n        },\n        function (e) { o.onError(e); },\n        function () {\n          atEnd = true;\n          sourceSubscription.dispose();\n        }\n      ));\n\n      return new BinaryDisposable(\n        sourceSubscription,\n        sampler.subscribe(sampleSubscribe, function (e) { o.onError(e); }, sampleSubscribe)\n      );\n    }, source);\n  }\n\n  /**\n   *  Samples the observable sequence at each interval.\n   *\n   * @example\n   *  1 - res = source.sample(sampleObservable); // Sampler tick sequence\n   *  2 - res = source.sample(5000); // 5 seconds\n   *  2 - res = source.sample(5000, Rx.Scheduler.timeout); // 5 seconds\n   *\n   * @param {Mixed} intervalOrSampler Interval at which to sample (specified as an integer denoting milliseconds) or Sampler Observable.\n   * @param {Scheduler} [scheduler]  Scheduler to run the sampling timer on. If not specified, the timeout scheduler is used.\n   * @returns {Observable} Sampled observable sequence.\n   */\n  observableProto.sample = observableProto.throttleLatest = function (intervalOrSampler, scheduler) {\n    isScheduler(scheduler) || (scheduler = defaultScheduler);\n    return typeof intervalOrSampler === 'number' ?\n      sampleObservable(this, observableinterval(intervalOrSampler, scheduler)) :\n      sampleObservable(this, intervalOrSampler);\n  };\n\n  var TimeoutError = Rx.TimeoutError = function(message) {\n    this.message = message || 'Timeout has occurred';\n    this.name = 'TimeoutError';\n    Error.call(this);\n  };\n  TimeoutError.prototype = Object.create(Error.prototype);\n\n  function timeoutWithSelector(source, firstTimeout, timeoutDurationSelector, other) {\n    if (isFunction(firstTimeout)) {\n      other = timeoutDurationSelector;\n      timeoutDurationSelector = firstTimeout;\n      firstTimeout = observableNever();\n    }\n    Observable.isObservable(other) || (other = observableThrow(new TimeoutError()));\n    return new AnonymousObservable(function (o) {\n      var subscription = new SerialDisposable(),\n        timer = new SerialDisposable(),\n        original = new SingleAssignmentDisposable();\n\n      subscription.setDisposable(original);\n\n      var id = 0, switched = false;\n\n      function setTimer(timeout) {\n        var myId = id, d = new SingleAssignmentDisposable();\n\n        function timerWins() {\n          switched = (myId === id);\n          return switched;\n        }\n\n        timer.setDisposable(d);\n        d.setDisposable(timeout.subscribe(function () {\n          timerWins() && subscription.setDisposable(other.subscribe(o));\n          d.dispose();\n        }, function (e) {\n          timerWins() && o.onError(e);\n        }, function () {\n          timerWins() && subscription.setDisposable(other.subscribe(o));\n        }));\n      };\n\n      setTimer(firstTimeout);\n\n      function oWins() {\n        var res = !switched;\n        if (res) { id++; }\n        return res;\n      }\n\n      original.setDisposable(source.subscribe(function (x) {\n        if (oWins()) {\n          o.onNext(x);\n          var timeout = tryCatch(timeoutDurationSelector)(x);\n          if (timeout === errorObj) { return o.onError(timeout.e); }\n          setTimer(isPromise(timeout) ? observableFromPromise(timeout) : timeout);\n        }\n      }, function (e) {\n        oWins() && o.onError(e);\n      }, function () {\n        oWins() && o.onCompleted();\n      }));\n      return new BinaryDisposable(subscription, timer);\n    }, source);\n  }\n\n  function timeout(source, dueTime, other, scheduler) {\n    if (isScheduler(other)) {\n      scheduler = other;\n      other = observableThrow(new TimeoutError());\n    }\n    if (other instanceof Error) { other = observableThrow(other); }\n    isScheduler(scheduler) || (scheduler = defaultScheduler);\n    Observable.isObservable(other) || (other = observableThrow(new TimeoutError()));\n    return new AnonymousObservable(function (o) {\n      var id = 0,\n        original = new SingleAssignmentDisposable(),\n        subscription = new SerialDisposable(),\n        switched = false,\n        timer = new SerialDisposable();\n\n      subscription.setDisposable(original);\n\n      function createTimer() {\n        var myId = id;\n        timer.setDisposable(scheduler.scheduleFuture(null, dueTime, function () {\n          switched = id === myId;\n          if (switched) {\n            isPromise(other) && (other = observableFromPromise(other));\n            subscription.setDisposable(other.subscribe(o));\n          }\n        }));\n      }\n\n      createTimer();\n\n      original.setDisposable(source.subscribe(function (x) {\n        if (!switched) {\n          id++;\n          o.onNext(x);\n          createTimer();\n        }\n      }, function (e) {\n        if (!switched) {\n          id++;\n          o.onError(e);\n        }\n      }, function () {\n        if (!switched) {\n          id++;\n          o.onCompleted();\n        }\n      }));\n      return new BinaryDisposable(subscription, timer);\n    }, source);\n  }\n\n  observableProto.timeout = function () {\n    var firstArg = arguments[0];\n    if (firstArg instanceof Date || typeof firstArg === 'number') {\n      return timeout(this, firstArg, arguments[1], arguments[2]);\n    } else if (Observable.isObservable(firstArg) || isFunction(firstArg)) {\n      return timeoutWithSelector(this, firstArg, arguments[1], arguments[2]);\n    } else {\n      throw new Error('Invalid arguments');\n    }\n  };\n\n  var GenerateAbsoluteObservable = (function (__super__) {\n    inherits(GenerateAbsoluteObservable, __super__);\n    function GenerateAbsoluteObservable(state, cndFn, itrFn, resFn, timeFn, s) {\n      this._state = state;\n      this._cndFn = cndFn;\n      this._itrFn = itrFn;\n      this._resFn = resFn;\n      this._timeFn = timeFn;\n      this._s = s;\n      this._first = true;\n      this._hasResult = false;\n      __super__.call(this);\n    }\n\n    function scheduleRecursive(self, recurse) {\n      self._hasResult && self._o.onNext(self._state);\n\n      if (self._first) {\n        self._first = false;\n      } else {\n        self._state = tryCatch(self._itrFn)(self._state);\n        if (self._state === errorObj) { return self._o.onError(self._state.e); }\n      }\n      self._hasResult = tryCatch(self._cndFn)(self._state);\n      if (self._hasResult === errorObj) { return self._o.onError(self._hasResult.e); }\n      if (self._hasResult) {\n        var result = tryCatch(self._resFn)(self._state);\n        if (result === errorObj) { return self._o.onError(result.e); }\n        var time = tryCatch(self._timeFn)(self._state);\n        if (time === errorObj) { return self._o.onError(time.e); }\n        recurse(self, time);\n      } else {\n        self._o.onCompleted();\n      }\n    }\n\n    GenerateAbsoluteObservable.prototype.subscribeCore = function (o) {\n      this._o = o;\n      return this._s.scheduleRecursiveFuture(this, new Date(this._s.now()), scheduleRecursive);\n    };\n\n    return GenerateAbsoluteObservable;\n  }(ObservableBase));\n\n  /**\n   *  GenerateAbsolutes an observable sequence by iterating a state from an initial state until the condition fails.\n   *\n   * @example\n   *  res = source.generateWithAbsoluteTime(0,\n   *      function (x) { return return true; },\n   *      function (x) { return x + 1; },\n   *      function (x) { return x; },\n   *      function (x) { return new Date(); }\n   *  });\n   *\n   * @param {Mixed} initialState Initial state.\n   * @param {Function} condition Condition to terminate generation (upon returning false).\n   * @param {Function} iterate Iteration step function.\n   * @param {Function} resultSelector Selector function for results produced in the sequence.\n   * @param {Function} timeSelector Time selector function to control the speed of values being produced each iteration, returning Date values.\n   * @param {Scheduler} [scheduler]  Scheduler on which to run the generator loop. If not specified, the timeout scheduler is used.\n   * @returns {Observable} The generated sequence.\n   */\n  Observable.generateWithAbsoluteTime = function (initialState, condition, iterate, resultSelector, timeSelector, scheduler) {\n    isScheduler(scheduler) || (scheduler = defaultScheduler);\n    return new GenerateAbsoluteObservable(initialState, condition, iterate, resultSelector, timeSelector, scheduler);\n  };\n\n  var GenerateRelativeObservable = (function (__super__) {\n    inherits(GenerateRelativeObservable, __super__);\n    function GenerateRelativeObservable(state, cndFn, itrFn, resFn, timeFn, s) {\n      this._state = state;\n      this._cndFn = cndFn;\n      this._itrFn = itrFn;\n      this._resFn = resFn;\n      this._timeFn = timeFn;\n      this._s = s;\n      this._first = true;\n      this._hasResult = false;\n      __super__.call(this);\n    }\n\n    function scheduleRecursive(self, recurse) {\n      self._hasResult && self._o.onNext(self._state);\n\n      if (self._first) {\n        self._first = false;\n      } else {\n        self._state = tryCatch(self._itrFn)(self._state);\n        if (self._state === errorObj) { return self._o.onError(self._state.e); }\n      }\n      self._hasResult = tryCatch(self._cndFn)(self._state);\n      if (self._hasResult === errorObj) { return self._o.onError(self._hasResult.e); }\n      if (self._hasResult) {\n        var result = tryCatch(self._resFn)(self._state);\n        if (result === errorObj) { return self._o.onError(result.e); }\n        var time = tryCatch(self._timeFn)(self._state);\n        if (time === errorObj) { return self._o.onError(time.e); }\n        recurse(self, time);\n      } else {\n        self._o.onCompleted();\n      }\n    }\n\n    GenerateRelativeObservable.prototype.subscribeCore = function (o) {\n      this._o = o;\n      return this._s.scheduleRecursiveFuture(this, 0, scheduleRecursive);\n    };\n\n    return GenerateRelativeObservable;\n  }(ObservableBase));\n\n  /**\n   *  Generates an observable sequence by iterating a state from an initial state until the condition fails.\n   *\n   * @example\n   *  res = source.generateWithRelativeTime(0,\n   *      function (x) { return return true; },\n   *      function (x) { return x + 1; },\n   *      function (x) { return x; },\n   *      function (x) { return 500; }\n   *  );\n   *\n   * @param {Mixed} initialState Initial state.\n   * @param {Function} condition Condition to terminate generation (upon returning false).\n   * @param {Function} iterate Iteration step function.\n   * @param {Function} resultSelector Selector function for results produced in the sequence.\n   * @param {Function} timeSelector Time selector function to control the speed of values being produced each iteration, returning integer values denoting milliseconds.\n   * @param {Scheduler} [scheduler]  Scheduler on which to run the generator loop. If not specified, the timeout scheduler is used.\n   * @returns {Observable} The generated sequence.\n   */\n  Observable.generateWithRelativeTime = function (initialState, condition, iterate, resultSelector, timeSelector, scheduler) {\n    isScheduler(scheduler) || (scheduler = defaultScheduler);\n    return new GenerateRelativeObservable(initialState, condition, iterate, resultSelector, timeSelector, scheduler);\n  };\n\n  var DelaySubscription = (function(__super__) {\n    inherits(DelaySubscription, __super__);\n    function DelaySubscription(source, dt, s) {\n      this.source = source;\n      this._dt = dt;\n      this._s = s;\n      __super__.call(this);\n    }\n\n    DelaySubscription.prototype.subscribeCore = function (o) {\n      var d = new SerialDisposable();\n\n      d.setDisposable(this._s.scheduleFuture([this.source, o, d], this._dt, scheduleMethod));\n\n      return d;\n    };\n\n    function scheduleMethod(s, state) {\n      var source = state[0], o = state[1], d = state[2];\n      d.setDisposable(source.subscribe(o));\n    }\n\n    return DelaySubscription;\n  }(ObservableBase));\n\n  /**\n   *  Time shifts the observable sequence by delaying the subscription with the specified relative time duration, using the specified scheduler to run timers.\n   *\n   * @example\n   *  1 - res = source.delaySubscription(5000); // 5s\n   *  2 - res = source.delaySubscription(5000, Rx.Scheduler.default); // 5 seconds\n   *\n   * @param {Number} dueTime Relative or absolute time shift of the subscription.\n   * @param {Scheduler} [scheduler]  Scheduler to run the subscription delay timer on. If not specified, the timeout scheduler is used.\n   * @returns {Observable} Time-shifted sequence.\n   */\n  observableProto.delaySubscription = function (dueTime, scheduler) {\n    isScheduler(scheduler) || (scheduler = defaultScheduler);\n    return new DelaySubscription(this, dueTime, scheduler);\n  };\n\n  var SkipLastWithTimeObservable = (function (__super__) {\n    inherits(SkipLastWithTimeObservable, __super__);\n    function SkipLastWithTimeObservable(source, d, s) {\n      this.source = source;\n      this._d = d;\n      this._s = s;\n      __super__.call(this);\n    }\n\n    SkipLastWithTimeObservable.prototype.subscribeCore = function (o) {\n      return this.source.subscribe(new SkipLastWithTimeObserver(o, this));\n    };\n\n    return SkipLastWithTimeObservable;\n  }(ObservableBase));\n\n  var SkipLastWithTimeObserver = (function (__super__) {\n    inherits(SkipLastWithTimeObserver, __super__);\n\n    function SkipLastWithTimeObserver(o, p) {\n      this._o = o;\n      this._s = p._s;\n      this._d = p._d;\n      this._q = [];\n      __super__.call(this);\n    }\n\n    SkipLastWithTimeObserver.prototype.next = function (x) {\n      var now = this._s.now();\n      this._q.push({ interval: now, value: x });\n      while (this._q.length > 0 && now - this._q[0].interval >= this._d) {\n        this._o.onNext(this._q.shift().value);\n      }\n    };\n    SkipLastWithTimeObserver.prototype.error = function (e) { this._o.onError(e); };\n    SkipLastWithTimeObserver.prototype.completed = function () {\n      var now = this._s.now();\n      while (this._q.length > 0 && now - this._q[0].interval >= this._d) {\n        this._o.onNext(this._q.shift().value);\n      }\n      this._o.onCompleted();\n    };\n\n    return SkipLastWithTimeObserver;\n  }(AbstractObserver));\n\n  /**\n   *  Skips elements for the specified duration from the end of the observable source sequence, using the specified scheduler to run timers.\n   * @description\n   *  This operator accumulates a queue with a length enough to store elements received during the initial duration window.\n   *  As more elements are received, elements older than the specified duration are taken from the queue and produced on the\n   *  result sequence. This causes elements to be delayed with duration.\n   * @param {Number} duration Duration for skipping elements from the end of the sequence.\n   * @param {Scheduler} [scheduler]  Scheduler to run the timer on. If not specified, defaults to Rx.Scheduler.timeout\n   * @returns {Observable} An observable sequence with the elements skipped during the specified duration from the end of the source sequence.\n   */\n  observableProto.skipLastWithTime = function (duration, scheduler) {\n    isScheduler(scheduler) || (scheduler = defaultScheduler);\n    return new SkipLastWithTimeObservable(this, duration, scheduler);\n  };\n\n  var TakeLastWithTimeObservable = (function (__super__) {\n    inherits(TakeLastWithTimeObservable, __super__);\n    function TakeLastWithTimeObservable(source, d, s) {\n      this.source = source;\n      this._d = d;\n      this._s = s;\n      __super__.call(this);\n    }\n\n    TakeLastWithTimeObservable.prototype.subscribeCore = function (o) {\n      return this.source.subscribe(new TakeLastWithTimeObserver(o, this._d, this._s));\n    };\n\n    return TakeLastWithTimeObservable;\n  }(ObservableBase));\n\n  var TakeLastWithTimeObserver = (function (__super__) {\n    inherits(TakeLastWithTimeObserver, __super__);\n\n    function TakeLastWithTimeObserver(o, d, s) {\n      this._o = o;\n      this._d = d;\n      this._s = s;\n      this._q = [];\n      __super__.call(this);\n    }\n\n    TakeLastWithTimeObserver.prototype.next = function (x) {\n      var now = this._s.now();\n      this._q.push({ interval: now, value: x });\n      while (this._q.length > 0 && now - this._q[0].interval >= this._d) {\n        this._q.shift();\n      }\n    };\n    TakeLastWithTimeObserver.prototype.error = function (e) { this._o.onError(e); };\n    TakeLastWithTimeObserver.prototype.completed = function () {\n      var now = this._s.now();\n      while (this._q.length > 0) {\n        var next = this._q.shift();\n        if (now - next.interval <= this._d) { this._o.onNext(next.value); }\n      }\n      this._o.onCompleted();\n    };\n\n    return TakeLastWithTimeObserver;\n  }(AbstractObserver));\n\n  /**\n   *  Returns elements within the specified duration from the end of the observable source sequence, using the specified schedulers to run timers and to drain the collected elements.\n   * @description\n   *  This operator accumulates a queue with a length enough to store elements received during the initial duration window.\n   *  As more elements are received, elements older than the specified duration are taken from the queue and produced on the\n   *  result sequence. This causes elements to be delayed with duration.\n   * @param {Number} duration Duration for taking elements from the end of the sequence.\n   * @param {Scheduler} [scheduler]  Scheduler to run the timer on. If not specified, defaults to Rx.Scheduler.timeout.\n   * @returns {Observable} An observable sequence with the elements taken during the specified duration from the end of the source sequence.\n   */\n  observableProto.takeLastWithTime = function (duration, scheduler) {\n    isScheduler(scheduler) || (scheduler = defaultScheduler);\n    return new TakeLastWithTimeObservable(this, duration, scheduler);\n  };\n\n  /**\n   *  Returns an array with the elements within the specified duration from the end of the observable source sequence, using the specified scheduler to run timers.\n   * @description\n   *  This operator accumulates a queue with a length enough to store elements received during the initial duration window.\n   *  As more elements are received, elements older than the specified duration are taken from the queue and produced on the\n   *  result sequence. This causes elements to be delayed with duration.\n   * @param {Number} duration Duration for taking elements from the end of the sequence.\n   * @param {Scheduler} scheduler Scheduler to run the timer on. If not specified, defaults to Rx.Scheduler.timeout.\n   * @returns {Observable} An observable sequence containing a single array with the elements taken during the specified duration from the end of the source sequence.\n   */\n  observableProto.takeLastBufferWithTime = function (duration, scheduler) {\n    var source = this;\n    isScheduler(scheduler) || (scheduler = defaultScheduler);\n    return new AnonymousObservable(function (o) {\n      var q = [];\n      return source.subscribe(function (x) {\n        var now = scheduler.now();\n        q.push({ interval: now, value: x });\n        while (q.length > 0 && now - q[0].interval >= duration) {\n          q.shift();\n        }\n      }, function (e) { o.onError(e); }, function () {\n        var now = scheduler.now(), res = [];\n        while (q.length > 0) {\n          var next = q.shift();\n          now - next.interval <= duration && res.push(next.value);\n        }\n        o.onNext(res);\n        o.onCompleted();\n      });\n    }, source);\n  };\n\n  var TakeWithTimeObservable = (function (__super__) {\n    inherits(TakeWithTimeObservable, __super__);\n    function TakeWithTimeObservable(source, d, s) {\n      this.source = source;\n      this._d = d;\n      this._s = s;\n      __super__.call(this);\n    }\n\n    function scheduleMethod(s, o) {\n      o.onCompleted();\n    }\n\n    TakeWithTimeObservable.prototype.subscribeCore = function (o) {\n      return new BinaryDisposable(\n        this._s.scheduleFuture(o, this._d, scheduleMethod),\n        this.source.subscribe(o)\n      );\n    };\n\n    return TakeWithTimeObservable;\n  }(ObservableBase));\n\n  /**\n   *  Takes elements for the specified duration from the start of the observable source sequence, using the specified scheduler to run timers.\n   *\n   * @example\n   *  1 - res = source.takeWithTime(5000,  [optional scheduler]);\n   * @description\n   *  This operator accumulates a queue with a length enough to store elements received during the initial duration window.\n   *  As more elements are received, elements older than the specified duration are taken from the queue and produced on the\n   *  result sequence. This causes elements to be delayed with duration.\n   * @param {Number} duration Duration for taking elements from the start of the sequence.\n   * @param {Scheduler} scheduler Scheduler to run the timer on. If not specified, defaults to Rx.Scheduler.timeout.\n   * @returns {Observable} An observable sequence with the elements taken during the specified duration from the start of the source sequence.\n   */\n  observableProto.takeWithTime = function (duration, scheduler) {\n    isScheduler(scheduler) || (scheduler = defaultScheduler);\n    return new TakeWithTimeObservable(this, duration, scheduler);\n  };\n\n  var SkipWithTimeObservable = (function (__super__) {\n    inherits(SkipWithTimeObservable, __super__);\n    function SkipWithTimeObservable(source, d, s) {\n      this.source = source;\n      this._d = d;\n      this._s = s;\n      this._open = false;\n      __super__.call(this);\n    }\n\n    function scheduleMethod(s, self) {\n      self._open = true;\n    }\n\n    SkipWithTimeObservable.prototype.subscribeCore = function (o) {\n      return new BinaryDisposable(\n        this._s.scheduleFuture(this, this._d, scheduleMethod),\n        this.source.subscribe(new SkipWithTimeObserver(o, this))\n      );\n    };\n\n    return SkipWithTimeObservable;\n  }(ObservableBase));\n\n  var SkipWithTimeObserver = (function (__super__) {\n    inherits(SkipWithTimeObserver, __super__);\n\n    function SkipWithTimeObserver(o, p) {\n      this._o = o;\n      this._p = p;\n      __super__.call(this);\n    }\n\n    SkipWithTimeObserver.prototype.next = function (x) { this._p._open && this._o.onNext(x); };\n    SkipWithTimeObserver.prototype.error = function (e) { this._o.onError(e); };\n    SkipWithTimeObserver.prototype.completed = function () { this._o.onCompleted(); };\n\n    return SkipWithTimeObserver;\n  }(AbstractObserver));\n\n  /**\n   *  Skips elements for the specified duration from the start of the observable source sequence, using the specified scheduler to run timers.\n   * @description\n   *  Specifying a zero value for duration doesn't guarantee no elements will be dropped from the start of the source sequence.\n   *  This is a side-effect of the asynchrony introduced by the scheduler, where the action that causes callbacks from the source sequence to be forwarded\n   *  may not execute immediately, despite the zero due time.\n   *\n   *  Errors produced by the source sequence are always forwarded to the result sequence, even if the error occurs before the duration.\n   * @param {Number} duration Duration for skipping elements from the start of the sequence.\n   * @param {Scheduler} scheduler Scheduler to run the timer on. If not specified, defaults to Rx.Scheduler.timeout.\n   * @returns {Observable} An observable sequence with the elements skipped during the specified duration from the start of the source sequence.\n   */\n  observableProto.skipWithTime = function (duration, scheduler) {\n    isScheduler(scheduler) || (scheduler = defaultScheduler);\n    return new SkipWithTimeObservable(this, duration, scheduler);\n  };\n\n  var SkipUntilWithTimeObservable = (function (__super__) {\n    inherits(SkipUntilWithTimeObservable, __super__);\n    function SkipUntilWithTimeObservable(source, startTime, scheduler) {\n      this.source = source;\n      this._st = startTime;\n      this._s = scheduler;\n      __super__.call(this);\n    }\n\n    function scheduleMethod(s, state) {\n      state._open = true;\n    }\n\n    SkipUntilWithTimeObservable.prototype.subscribeCore = function (o) {\n      this._open = false;\n      return new BinaryDisposable(\n        this._s.scheduleFuture(this, this._st, scheduleMethod),\n        this.source.subscribe(new SkipUntilWithTimeObserver(o, this))\n      );\n    };\n\n    return SkipUntilWithTimeObservable;\n  }(ObservableBase));\n\n  var SkipUntilWithTimeObserver = (function (__super__) {\n    inherits(SkipUntilWithTimeObserver, __super__);\n\n    function SkipUntilWithTimeObserver(o, p) {\n      this._o = o;\n      this._p = p;\n      __super__.call(this);\n    }\n\n    SkipUntilWithTimeObserver.prototype.next = function (x) { this._p._open && this._o.onNext(x); };\n    SkipUntilWithTimeObserver.prototype.error = function (e) { this._o.onError(e); };\n    SkipUntilWithTimeObserver.prototype.completed = function () { this._o.onCompleted(); };\n\n    return SkipUntilWithTimeObserver;\n  }(AbstractObserver));\n\n\n  /**\n   *  Skips elements from the observable source sequence until the specified start time, using the specified scheduler to run timers.\n   *  Errors produced by the source sequence are always forwarded to the result sequence, even if the error occurs before the start time.\n   *\n   * @examples\n   *  1 - res = source.skipUntilWithTime(new Date(), [scheduler]);\n   *  2 - res = source.skipUntilWithTime(5000, [scheduler]);\n   * @param {Date|Number} startTime Time to start taking elements from the source sequence. If this value is less than or equal to Date(), no elements will be skipped.\n   * @param {Scheduler} [scheduler] Scheduler to run the timer on. If not specified, defaults to Rx.Scheduler.timeout.\n   * @returns {Observable} An observable sequence with the elements skipped until the specified start time.\n   */\n  observableProto.skipUntilWithTime = function (startTime, scheduler) {\n    isScheduler(scheduler) || (scheduler = defaultScheduler);\n    return new SkipUntilWithTimeObservable(this, startTime, scheduler);\n  };\n\n  /**\n   *  Takes elements for the specified duration until the specified end time, using the specified scheduler to run timers.\n   * @param {Number | Date} endTime Time to stop taking elements from the source sequence. If this value is less than or equal to new Date(), the result stream will complete immediately.\n   * @param {Scheduler} [scheduler] Scheduler to run the timer on.\n   * @returns {Observable} An observable sequence with the elements taken until the specified end time.\n   */\n  observableProto.takeUntilWithTime = function (endTime, scheduler) {\n    isScheduler(scheduler) || (scheduler = defaultScheduler);\n    var source = this;\n    return new AnonymousObservable(function (o) {\n      return new BinaryDisposable(\n        scheduler.scheduleFuture(o, endTime, function (_, o) { o.onCompleted(); }),\n        source.subscribe(o));\n    }, source);\n  };\n\n  /**\n   * Returns an Observable that emits only the first item emitted by the source Observable during sequential time windows of a specified duration.\n   * @param {Number} windowDuration time to wait before emitting another item after emitting the last item\n   * @param {Scheduler} [scheduler] the Scheduler to use internally to manage the timers that handle timeout for each item. If not provided, defaults to Scheduler.timeout.\n   * @returns {Observable} An Observable that performs the throttle operation.\n   */\n  observableProto.throttle = function (windowDuration, scheduler) {\n    isScheduler(scheduler) || (scheduler = defaultScheduler);\n    var duration = +windowDuration || 0;\n    if (duration <= 0) { throw new RangeError('windowDuration cannot be less or equal zero.'); }\n    var source = this;\n    return new AnonymousObservable(function (o) {\n      var lastOnNext = 0;\n      return source.subscribe(\n        function (x) {\n          var now = scheduler.now();\n          if (lastOnNext === 0 || now - lastOnNext >= duration) {\n            lastOnNext = now;\n            o.onNext(x);\n          }\n        },function (e) { o.onError(e); }, function () { o.onCompleted(); }\n      );\n    }, source);\n  };\n\n  var TransduceObserver = (function (__super__) {\n    inherits(TransduceObserver, __super__);\n    function TransduceObserver(o, xform) {\n      this._o = o;\n      this._xform = xform;\n      __super__.call(this);\n    }\n\n    TransduceObserver.prototype.next = function (x) {\n      var res = tryCatch(this._xform['@@transducer/step']).call(this._xform, this._o, x);\n      if (res === errorObj) { this._o.onError(res.e); }\n    };\n\n    TransduceObserver.prototype.error = function (e) { this._o.onError(e); };\n\n    TransduceObserver.prototype.completed = function () {\n      this._xform['@@transducer/result'](this._o);\n    };\n\n    return TransduceObserver;\n  }(AbstractObserver));\n\n  function transformForObserver(o) {\n    return {\n      '@@transducer/init': function() {\n        return o;\n      },\n      '@@transducer/step': function(obs, input) {\n        return obs.onNext(input);\n      },\n      '@@transducer/result': function(obs) {\n        return obs.onCompleted();\n      }\n    };\n  }\n\n  /**\n   * Executes a transducer to transform the observable sequence\n   * @param {Transducer} transducer A transducer to execute\n   * @returns {Observable} An Observable sequence containing the results from the transducer.\n   */\n  observableProto.transduce = function(transducer) {\n    var source = this;\n    return new AnonymousObservable(function(o) {\n      var xform = transducer(transformForObserver(o));\n      return source.subscribe(new TransduceObserver(o, xform));\n    }, source);\n  };\n\n  var SwitchFirstObservable = (function (__super__) {\n    inherits(SwitchFirstObservable, __super__);\n    function SwitchFirstObservable(source) {\n      this.source = source;\n      __super__.call(this);\n    }\n\n    SwitchFirstObservable.prototype.subscribeCore = function (o) {\n      var m = new SingleAssignmentDisposable(),\n        g = new CompositeDisposable(),\n        state = {\n          hasCurrent: false,\n          isStopped: false,\n          o: o,\n          g: g\n        };\n\n      g.add(m);\n      m.setDisposable(this.source.subscribe(new SwitchFirstObserver(state)));\n      return g;\n    };\n\n    return SwitchFirstObservable;\n  }(ObservableBase));\n\n  var SwitchFirstObserver = (function(__super__) {\n    inherits(SwitchFirstObserver, __super__);\n    function SwitchFirstObserver(state) {\n      this._s = state;\n      __super__.call(this);\n    }\n\n    SwitchFirstObserver.prototype.next = function (x) {\n      if (!this._s.hasCurrent) {\n        this._s.hasCurrent = true;\n        isPromise(x) && (x = observableFromPromise(x));\n        var inner = new SingleAssignmentDisposable();\n        this._s.g.add(inner);\n        inner.setDisposable(x.subscribe(new InnerObserver(this._s, inner)));\n      }\n    };\n\n    SwitchFirstObserver.prototype.error = function (e) {\n      this._s.o.onError(e);\n    };\n\n    SwitchFirstObserver.prototype.completed = function () {\n      this._s.isStopped = true;\n      !this._s.hasCurrent && this._s.g.length === 1 && this._s.o.onCompleted();\n    };\n\n    inherits(InnerObserver, __super__);\n    function InnerObserver(state, inner) {\n      this._s = state;\n      this._i = inner;\n      __super__.call(this);\n    }\n\n    InnerObserver.prototype.next = function (x) { this._s.o.onNext(x); };\n    InnerObserver.prototype.error = function (e) { this._s.o.onError(e); };\n    InnerObserver.prototype.completed = function () {\n      this._s.g.remove(this._i);\n      this._s.hasCurrent = false;\n      this._s.isStopped && this._s.g.length === 1 && this._s.o.onCompleted();\n    };\n\n    return SwitchFirstObserver;\n  }(AbstractObserver));\n\n  /**\n   * Performs a exclusive waiting for the first to finish before subscribing to another observable.\n   * Observables that come in between subscriptions will be dropped on the floor.\n   * @returns {Observable} A exclusive observable with only the results that happen when subscribed.\n   */\n  observableProto.switchFirst = function () {\n    return new SwitchFirstObservable(this);\n  };\n\nobservableProto.flatMapFirst = observableProto.selectManyFirst = function(selector, resultSelector, thisArg) {\n    return new FlatMapObservable(this, selector, resultSelector, thisArg).switchFirst();\n};\n\nRx.Observable.prototype.flatMapWithMaxConcurrent = function(limit, selector, resultSelector, thisArg) {\n    return new FlatMapObservable(this, selector, resultSelector, thisArg).merge(limit);\n};\n  /** Provides a set of extension methods for virtual time scheduling. */\n  var VirtualTimeScheduler = Rx.VirtualTimeScheduler = (function (__super__) {\n    inherits(VirtualTimeScheduler, __super__);\n\n    /**\n     * Creates a new virtual time scheduler with the specified initial clock value and absolute time comparer.\n     *\n     * @constructor\n     * @param {Number} initialClock Initial value for the clock.\n     * @param {Function} comparer Comparer to determine causality of events based on absolute time.\n     */\n    function VirtualTimeScheduler(initialClock, comparer) {\n      this.clock = initialClock;\n      this.comparer = comparer;\n      this.isEnabled = false;\n      this.queue = new PriorityQueue(1024);\n      __super__.call(this);\n    }\n\n    var VirtualTimeSchedulerPrototype = VirtualTimeScheduler.prototype;\n\n    VirtualTimeSchedulerPrototype.now = function () {\n      return this.toAbsoluteTime(this.clock);\n    };\n\n    VirtualTimeSchedulerPrototype.schedule = function (state, action) {\n      return this.scheduleAbsolute(state, this.clock, action);\n    };\n\n    VirtualTimeSchedulerPrototype.scheduleFuture = function (state, dueTime, action) {\n      var dt = dueTime instanceof Date ?\n        this.toRelativeTime(dueTime - this.now()) :\n        this.toRelativeTime(dueTime);\n\n      return this.scheduleRelative(state, dt, action);\n    };\n\n    /**\n     * Adds a relative time value to an absolute time value.\n     * @param {Number} absolute Absolute virtual time value.\n     * @param {Number} relative Relative virtual time value to add.\n     * @return {Number} Resulting absolute virtual time sum value.\n     */\n    VirtualTimeSchedulerPrototype.add = notImplemented;\n\n    /**\n     * Converts an absolute time to a number\n     * @param {Any} The absolute time.\n     * @returns {Number} The absolute time in ms\n     */\n    VirtualTimeSchedulerPrototype.toAbsoluteTime = notImplemented;\n\n    /**\n     * Converts the TimeSpan value to a relative virtual time value.\n     * @param {Number} timeSpan TimeSpan value to convert.\n     * @return {Number} Corresponding relative virtual time value.\n     */\n    VirtualTimeSchedulerPrototype.toRelativeTime = notImplemented;\n\n    /**\n     * Schedules a periodic piece of work by dynamically discovering the scheduler's capabilities. The periodic task will be emulated using recursive scheduling.\n     * @param {Mixed} state Initial state passed to the action upon the first iteration.\n     * @param {Number} period Period for running the work periodically.\n     * @param {Function} action Action to be executed, potentially updating the state.\n     * @returns {Disposable} The disposable object used to cancel the scheduled recurring action (best effort).\n     */\n    VirtualTimeSchedulerPrototype.schedulePeriodic = function (state, period, action) {\n      var s = new SchedulePeriodicRecursive(this, state, period, action);\n      return s.start();\n    };\n\n    /**\n     * Schedules an action to be executed after dueTime.\n     * @param {Mixed} state State passed to the action to be executed.\n     * @param {Number} dueTime Relative time after which to execute the action.\n     * @param {Function} action Action to be executed.\n     * @returns {Disposable} The disposable object used to cancel the scheduled action (best effort).\n     */\n    VirtualTimeSchedulerPrototype.scheduleRelative = function (state, dueTime, action) {\n      var runAt = this.add(this.clock, dueTime);\n      return this.scheduleAbsolute(state, runAt, action);\n    };\n\n    /**\n     * Starts the virtual time scheduler.\n     */\n    VirtualTimeSchedulerPrototype.start = function () {\n      if (!this.isEnabled) {\n        this.isEnabled = true;\n        do {\n          var next = this.getNext();\n          if (next !== null) {\n            this.comparer(next.dueTime, this.clock) > 0 && (this.clock = next.dueTime);\n            next.invoke();\n          } else {\n            this.isEnabled = false;\n          }\n        } while (this.isEnabled);\n      }\n    };\n\n    /**\n     * Stops the virtual time scheduler.\n     */\n    VirtualTimeSchedulerPrototype.stop = function () {\n      this.isEnabled = false;\n    };\n\n    /**\n     * Advances the scheduler's clock to the specified time, running all work till that point.\n     * @param {Number} time Absolute time to advance the scheduler's clock to.\n     */\n    VirtualTimeSchedulerPrototype.advanceTo = function (time) {\n      var dueToClock = this.comparer(this.clock, time);\n      if (this.comparer(this.clock, time) > 0) { throw new ArgumentOutOfRangeError(); }\n      if (dueToClock === 0) { return; }\n      if (!this.isEnabled) {\n        this.isEnabled = true;\n        do {\n          var next = this.getNext();\n          if (next !== null && this.comparer(next.dueTime, time) <= 0) {\n            this.comparer(next.dueTime, this.clock) > 0 && (this.clock = next.dueTime);\n            next.invoke();\n          } else {\n            this.isEnabled = false;\n          }\n        } while (this.isEnabled);\n        this.clock = time;\n      }\n    };\n\n    /**\n     * Advances the scheduler's clock by the specified relative time, running all work scheduled for that timespan.\n     * @param {Number} time Relative time to advance the scheduler's clock by.\n     */\n    VirtualTimeSchedulerPrototype.advanceBy = function (time) {\n      var dt = this.add(this.clock, time),\n          dueToClock = this.comparer(this.clock, dt);\n      if (dueToClock > 0) { throw new ArgumentOutOfRangeError(); }\n      if (dueToClock === 0) {  return; }\n\n      this.advanceTo(dt);\n    };\n\n    /**\n     * Advances the scheduler's clock by the specified relative time.\n     * @param {Number} time Relative time to advance the scheduler's clock by.\n     */\n    VirtualTimeSchedulerPrototype.sleep = function (time) {\n      var dt = this.add(this.clock, time);\n      if (this.comparer(this.clock, dt) >= 0) { throw new ArgumentOutOfRangeError(); }\n\n      this.clock = dt;\n    };\n\n    /**\n     * Gets the next scheduled item to be executed.\n     * @returns {ScheduledItem} The next scheduled item.\n     */\n    VirtualTimeSchedulerPrototype.getNext = function () {\n      while (this.queue.length > 0) {\n        var next = this.queue.peek();\n        if (next.isCancelled()) {\n          this.queue.dequeue();\n        } else {\n          return next;\n        }\n      }\n      return null;\n    };\n\n    /**\n     * Schedules an action to be executed at dueTime.\n     * @param {Mixed} state State passed to the action to be executed.\n     * @param {Number} dueTime Absolute time at which to execute the action.\n     * @param {Function} action Action to be executed.\n     * @returns {Disposable} The disposable object used to cancel the scheduled action (best effort).\n     */\n    VirtualTimeSchedulerPrototype.scheduleAbsolute = function (state, dueTime, action) {\n      var self = this;\n\n      function run(scheduler, state1) {\n        self.queue.remove(si);\n        return action(scheduler, state1);\n      }\n\n      var si = new ScheduledItem(this, state, run, dueTime, this.comparer);\n      this.queue.enqueue(si);\n\n      return si.disposable;\n    };\n\n    return VirtualTimeScheduler;\n  }(Scheduler));\n\n  /** Provides a virtual time scheduler that uses Date for absolute time and number for relative time. */\n  Rx.HistoricalScheduler = (function (__super__) {\n    inherits(HistoricalScheduler, __super__);\n\n    /**\n     * Creates a new historical scheduler with the specified initial clock value.\n     * @constructor\n     * @param {Number} initialClock Initial value for the clock.\n     * @param {Function} comparer Comparer to determine causality of events based on absolute time.\n     */\n    function HistoricalScheduler(initialClock, comparer) {\n      var clock = initialClock == null ? 0 : initialClock;\n      var cmp = comparer || defaultSubComparer;\n      __super__.call(this, clock, cmp);\n    }\n\n    var HistoricalSchedulerProto = HistoricalScheduler.prototype;\n\n    /**\n     * Adds a relative time value to an absolute time value.\n     * @param {Number} absolute Absolute virtual time value.\n     * @param {Number} relative Relative virtual time value to add.\n     * @return {Number} Resulting absolute virtual time sum value.\n     */\n    HistoricalSchedulerProto.add = function (absolute, relative) {\n      return absolute + relative;\n    };\n\n    HistoricalSchedulerProto.toAbsoluteTime = function (absolute) {\n      return new Date(absolute).getTime();\n    };\n\n    /**\n     * Converts the TimeSpan value to a relative virtual time value.\n     * @memberOf HistoricalScheduler\n     * @param {Number} timeSpan TimeSpan value to convert.\n     * @return {Number} Corresponding relative virtual time value.\n     */\n    HistoricalSchedulerProto.toRelativeTime = function (timeSpan) {\n      return timeSpan;\n    };\n\n    return HistoricalScheduler;\n  }(Rx.VirtualTimeScheduler));\n\nfunction OnNextPredicate(predicate) {\n    this.predicate = predicate;\n}\n\nOnNextPredicate.prototype.equals = function (other) {\n  if (other === this) { return true; }\n  if (other == null) { return false; }\n  if (other.kind !== 'N') { return false; }\n  return this.predicate(other.value);\n};\n\nfunction OnErrorPredicate(predicate) {\n  this.predicate = predicate;\n}\n\nOnErrorPredicate.prototype.equals = function (other) {\n  if (other === this) { return true; }\n  if (other == null) { return false; }\n  if (other.kind !== 'E') { return false; }\n  return this.predicate(other.error);\n};\n\nvar ReactiveTest = Rx.ReactiveTest = {\n  /** Default virtual time used for creation of observable sequences in unit tests. */\n  created: 100,\n  /** Default virtual time used to subscribe to observable sequences in unit tests. */\n  subscribed: 200,\n  /** Default virtual time used to dispose subscriptions in unit tests. */\n  disposed: 1000,\n\n  /**\n   * Factory method for an OnNext notification record at a given time with a given value or a predicate function.\n   *\n   * 1 - ReactiveTest.onNext(200, 42);\n   * 2 - ReactiveTest.onNext(200, function (x) { return x.length == 2; });\n   *\n   * @param ticks Recorded virtual time the OnNext notification occurs.\n   * @param value Recorded value stored in the OnNext notification or a predicate.\n   * @return Recorded OnNext notification.\n   */\n  onNext: function (ticks, value) {\n    return typeof value === 'function' ?\n      new Recorded(ticks, new OnNextPredicate(value)) :\n      new Recorded(ticks, Notification.createOnNext(value));\n  },\n  /**\n   * Factory method for an OnError notification record at a given time with a given error.\n   *\n   * 1 - ReactiveTest.onNext(200, new Error('error'));\n   * 2 - ReactiveTest.onNext(200, function (e) { return e.message === 'error'; });\n   *\n   * @param ticks Recorded virtual time the OnError notification occurs.\n   * @param exception Recorded exception stored in the OnError notification.\n   * @return Recorded OnError notification.\n   */\n  onError: function (ticks, error) {\n    return typeof error === 'function' ?\n      new Recorded(ticks, new OnErrorPredicate(error)) :\n      new Recorded(ticks, Notification.createOnError(error));\n  },\n  /**\n   * Factory method for an OnCompleted notification record at a given time.\n   *\n   * @param ticks Recorded virtual time the OnCompleted notification occurs.\n   * @return Recorded OnCompleted notification.\n   */\n  onCompleted: function (ticks) {\n    return new Recorded(ticks, Notification.createOnCompleted());\n  },\n  /**\n   * Factory method for a subscription record based on a given subscription and disposal time.\n   *\n   * @param start Virtual time indicating when the subscription was created.\n   * @param end Virtual time indicating when the subscription was disposed.\n   * @return Subscription object.\n   */\n  subscribe: function (start, end) {\n    return new Subscription(start, end);\n  }\n};\n\n  /**\n   * Creates a new object recording the production of the specified value at the given virtual time.\n   *\n   * @constructor\n   * @param {Number} time Virtual time the value was produced on.\n   * @param {Mixed} value Value that was produced.\n   * @param {Function} comparer An optional comparer.\n   */\n  var Recorded = Rx.Recorded = function (time, value, comparer) {\n    this.time = time;\n    this.value = value;\n    this.comparer = comparer || defaultComparer;\n  };\n\n  /**\n   * Checks whether the given recorded object is equal to the current instance.\n   *\n   * @param {Recorded} other Recorded object to check for equality.\n   * @returns {Boolean} true if both objects are equal; false otherwise.\n   */\n  Recorded.prototype.equals = function (other) {\n    return this.time === other.time && this.comparer(this.value, other.value);\n  };\n\n  /**\n   * Returns a string representation of the current Recorded value.\n   *\n   * @returns {String} String representation of the current Recorded value.\n   */\n  Recorded.prototype.toString = function () {\n    return this.value.toString() + '@' + this.time;\n  };\n\n  /**\n   * Creates a new subscription object with the given virtual subscription and unsubscription time.\n   *\n   * @constructor\n   * @param {Number} subscribe Virtual time at which the subscription occurred.\n   * @param {Number} unsubscribe Virtual time at which the unsubscription occurred.\n   */\n  var Subscription = Rx.Subscription = function (start, end) {\n    this.subscribe = start;\n    this.unsubscribe = end || Number.MAX_VALUE;\n  };\n\n  /**\n   * Checks whether the given subscription is equal to the current instance.\n   * @param other Subscription object to check for equality.\n   * @returns {Boolean} true if both objects are equal; false otherwise.\n   */\n  Subscription.prototype.equals = function (other) {\n    return this.subscribe === other.subscribe && this.unsubscribe === other.unsubscribe;\n  };\n\n  /**\n   * Returns a string representation of the current Subscription value.\n   * @returns {String} String representation of the current Subscription value.\n   */\n  Subscription.prototype.toString = function () {\n    return '(' + this.subscribe + ', ' + (this.unsubscribe === Number.MAX_VALUE ? 'Infinite' : this.unsubscribe) + ')';\n  };\n\n  var MockDisposable = Rx.MockDisposable = function (scheduler) {\n    this.scheduler = scheduler;\n    this.disposes = [];\n    this.disposes.push(this.scheduler.clock);\n  };\n\n  MockDisposable.prototype.dispose = function () {\n    this.disposes.push(this.scheduler.clock);\n  };\n\n  var MockObserver = (function (__super__) {\n    inherits(MockObserver, __super__);\n\n    function MockObserver(scheduler) {\n      __super__.call(this);\n      this.scheduler = scheduler;\n      this.messages = [];\n    }\n\n    var MockObserverPrototype = MockObserver.prototype;\n\n    MockObserverPrototype.onNext = function (value) {\n      this.messages.push(new Recorded(this.scheduler.clock, Notification.createOnNext(value)));\n    };\n\n    MockObserverPrototype.onError = function (e) {\n      this.messages.push(new Recorded(this.scheduler.clock, Notification.createOnError(e)));\n    };\n\n    MockObserverPrototype.onCompleted = function () {\n      this.messages.push(new Recorded(this.scheduler.clock, Notification.createOnCompleted()));\n    };\n\n    return MockObserver;\n  })(Observer);\n\n  function MockPromise(scheduler, messages) {\n    var self = this;\n    this.scheduler = scheduler;\n    this.messages = messages;\n    this.subscriptions = [];\n    this.observers = [];\n    for (var i = 0, len = this.messages.length; i < len; i++) {\n      var message = this.messages[i],\n          notification = message.value;\n      (function (innerNotification) {\n        scheduler.scheduleAbsolute(null, message.time, function () {\n          var obs = self.observers.slice(0);\n\n          for (var j = 0, jLen = obs.length; j < jLen; j++) {\n            innerNotification.accept(obs[j]);\n          }\n          return disposableEmpty;\n        });\n      })(notification);\n    }\n  }\n\n  MockPromise.prototype.then = function (onResolved, onRejected) {\n    var self = this;\n\n    this.subscriptions.push(new Subscription(this.scheduler.clock));\n    var index = this.subscriptions.length - 1;\n\n    var newPromise;\n\n    var observer = Rx.Observer.create(\n      function (x) {\n        var retValue = onResolved(x);\n        if (retValue && typeof retValue.then === 'function') {\n          newPromise = retValue;\n        } else {\n          var ticks = self.scheduler.clock;\n          newPromise = new MockPromise(self.scheduler, [Rx.ReactiveTest.onNext(ticks, undefined), Rx.ReactiveTest.onCompleted(ticks)]);\n        }\n        var idx = self.observers.indexOf(observer);\n        self.observers.splice(idx, 1);\n        self.subscriptions[index] = new Subscription(self.subscriptions[index].subscribe, self.scheduler.clock);\n      },\n      function (err) {\n        onRejected(err);\n        var idx = self.observers.indexOf(observer);\n        self.observers.splice(idx, 1);\n        self.subscriptions[index] = new Subscription(self.subscriptions[index].subscribe, self.scheduler.clock);\n      }\n    );\n    this.observers.push(observer);\n\n    return newPromise || new MockPromise(this.scheduler, this.messages);\n  };\n\n  var HotObservable = (function (__super__) {\n    inherits(HotObservable, __super__);\n\n    function HotObservable(scheduler, messages) {\n      __super__.call(this);\n      var message, notification, observable = this;\n      this.scheduler = scheduler;\n      this.messages = messages;\n      this.subscriptions = [];\n      this.observers = [];\n      for (var i = 0, len = this.messages.length; i < len; i++) {\n        message = this.messages[i];\n        notification = message.value;\n        (function (innerNotification) {\n          scheduler.scheduleAbsolute(null, message.time, function () {\n            var obs = observable.observers.slice(0);\n\n            for (var j = 0, jLen = obs.length; j < jLen; j++) {\n              innerNotification.accept(obs[j]);\n            }\n            return disposableEmpty;\n          });\n        })(notification);\n      }\n    }\n\n    HotObservable.prototype._subscribe = function (o) {\n      var observable = this;\n      this.observers.push(o);\n      this.subscriptions.push(new Subscription(this.scheduler.clock));\n      var index = this.subscriptions.length - 1;\n      return disposableCreate(function () {\n        var idx = observable.observers.indexOf(o);\n        observable.observers.splice(idx, 1);\n        observable.subscriptions[index] = new Subscription(observable.subscriptions[index].subscribe, observable.scheduler.clock);\n      });\n    };\n\n    return HotObservable;\n  })(Observable);\n\n  var ColdObservable = (function (__super__) {\n    inherits(ColdObservable, __super__);\n\n    function ColdObservable(scheduler, messages) {\n      __super__.call(this);\n      this.scheduler = scheduler;\n      this.messages = messages;\n      this.subscriptions = [];\n    }\n\n    ColdObservable.prototype._subscribe = function (o) {\n      var message, notification, observable = this;\n      this.subscriptions.push(new Subscription(this.scheduler.clock));\n      var index = this.subscriptions.length - 1;\n      var d = new CompositeDisposable();\n      for (var i = 0, len = this.messages.length; i < len; i++) {\n        message = this.messages[i];\n        notification = message.value;\n        (function (innerNotification) {\n          d.add(observable.scheduler.scheduleRelative(null, message.time, function () {\n            innerNotification.accept(o);\n            return disposableEmpty;\n          }));\n        })(notification);\n      }\n      return disposableCreate(function () {\n        observable.subscriptions[index] = new Subscription(observable.subscriptions[index].subscribe, observable.scheduler.clock);\n        d.dispose();\n      });\n    };\n\n    return ColdObservable;\n  })(Observable);\n\n  /** Virtual time scheduler used for testing applications and libraries built using Reactive Extensions. */\n  Rx.TestScheduler = (function (__super__) {\n    inherits(TestScheduler, __super__);\n\n    function baseComparer(x, y) {\n      return x > y ? 1 : (x < y ? -1 : 0);\n    }\n\n    function TestScheduler() {\n      __super__.call(this, 0, baseComparer);\n    }\n\n    /**\n     * Schedules an action to be executed at the specified virtual time.\n     *\n     * @param state State passed to the action to be executed.\n     * @param dueTime Absolute virtual time at which to execute the action.\n     * @param action Action to be executed.\n     * @return Disposable object used to cancel the scheduled action (best effort).\n     */\n    TestScheduler.prototype.scheduleAbsolute = function (state, dueTime, action) {\n      dueTime <= this.clock && (dueTime = this.clock + 1);\n      return __super__.prototype.scheduleAbsolute.call(this, state, dueTime, action);\n    };\n    /**\n     * Adds a relative virtual time to an absolute virtual time value.\n     *\n     * @param absolute Absolute virtual time value.\n     * @param relative Relative virtual time value to add.\n     * @return Resulting absolute virtual time sum value.\n     */\n    TestScheduler.prototype.add = function (absolute, relative) {\n      return absolute + relative;\n    };\n    /**\n     * Converts the absolute virtual time value to a DateTimeOffset value.\n     *\n     * @param absolute Absolute virtual time value to convert.\n     * @return Corresponding DateTimeOffset value.\n     */\n    TestScheduler.prototype.toAbsoluteTime = function (absolute) {\n      return new Date(absolute).getTime();\n    };\n    /**\n     * Converts the TimeSpan value to a relative virtual time value.\n     *\n     * @param timeSpan TimeSpan value to convert.\n     * @return Corresponding relative virtual time value.\n     */\n    TestScheduler.prototype.toRelativeTime = function (timeSpan) {\n      return timeSpan;\n    };\n    /**\n     * Starts the test scheduler and uses the specified virtual times to invoke the factory function, subscribe to the resulting sequence, and dispose the subscription.\n     *\n     * @param create Factory method to create an observable sequence.\n     * @param created Virtual time at which to invoke the factory to create an observable sequence.\n     * @param subscribed Virtual time at which to subscribe to the created observable sequence.\n     * @param disposed Virtual time at which to dispose the subscription.\n     * @return Observer with timestamped recordings of notification messages that were received during the virtual time window when the subscription to the source sequence was active.\n     */\n    TestScheduler.prototype.startScheduler = function (createFn, settings) {\n      settings || (settings = {});\n      settings.created == null && (settings.created = ReactiveTest.created);\n      settings.subscribed == null && (settings.subscribed = ReactiveTest.subscribed);\n      settings.disposed == null && (settings.disposed = ReactiveTest.disposed);\n\n      var observer = this.createObserver(), source, subscription;\n\n      this.scheduleAbsolute(null, settings.created, function () {\n        source = createFn();\n        return disposableEmpty;\n      });\n\n      this.scheduleAbsolute(null, settings.subscribed, function () {\n        subscription = source.subscribe(observer);\n        return disposableEmpty;\n      });\n\n      this.scheduleAbsolute(null, settings.disposed, function () {\n        subscription.dispose();\n        return disposableEmpty;\n      });\n\n      this.start();\n\n      return observer;\n    };\n\n    /**\n     * Creates a hot observable using the specified timestamped notification messages either as an array or arguments.\n     * @param messages Notifications to surface through the created sequence at their specified absolute virtual times.\n     * @return Hot observable sequence that can be used to assert the timing of subscriptions and notifications.\n     */\n    TestScheduler.prototype.createHotObservable = function () {\n      var len = arguments.length, args;\n      if (Array.isArray(arguments[0])) {\n        args = arguments[0];\n      } else {\n        args = new Array(len);\n        for (var i = 0; i < len; i++) { args[i] = arguments[i]; }\n      }\n      return new HotObservable(this, args);\n    };\n\n    /**\n     * Creates a cold observable using the specified timestamped notification messages either as an array or arguments.\n     * @param messages Notifications to surface through the created sequence at their specified virtual time offsets from the sequence subscription time.\n     * @return Cold observable sequence that can be used to assert the timing of subscriptions and notifications.\n     */\n    TestScheduler.prototype.createColdObservable = function () {\n      var len = arguments.length, args;\n      if (Array.isArray(arguments[0])) {\n        args = arguments[0];\n      } else {\n        args = new Array(len);\n        for (var i = 0; i < len; i++) { args[i] = arguments[i]; }\n      }\n      return new ColdObservable(this, args);\n    };\n\n    /**\n     * Creates a resolved promise with the given value and ticks\n     * @param {Number} ticks The absolute time of the resolution.\n     * @param {Any} value The value to yield at the given tick.\n     * @returns {MockPromise} A mock Promise which fulfills with the given value.\n     */\n    TestScheduler.prototype.createResolvedPromise = function (ticks, value) {\n      return new MockPromise(this, [Rx.ReactiveTest.onNext(ticks, value), Rx.ReactiveTest.onCompleted(ticks)]);\n    };\n\n    /**\n     * Creates a rejected promise with the given reason and ticks\n     * @param {Number} ticks The absolute time of the resolution.\n     * @param {Any} reason The reason for rejection to yield at the given tick.\n     * @returns {MockPromise} A mock Promise which rejects with the given reason.\n     */\n    TestScheduler.prototype.createRejectedPromise = function (ticks, reason) {\n      return new MockPromise(this, [Rx.ReactiveTest.onError(ticks, reason)]);\n    };\n\n    /**\n     * Creates an observer that records received notification messages and timestamps those.\n     * @return Observer that can be used to assert the timing of received notifications.\n     */\n    TestScheduler.prototype.createObserver = function () {\n      return new MockObserver(this);\n    };\n\n    return TestScheduler;\n  })(VirtualTimeScheduler);\n\n  var AnonymousObservable = Rx.AnonymousObservable = (function (__super__) {\n    inherits(AnonymousObservable, __super__);\n\n    // Fix subscriber to check for undefined or function returned to decorate as Disposable\n    function fixSubscriber(subscriber) {\n      return subscriber && isFunction(subscriber.dispose) ? subscriber :\n        isFunction(subscriber) ? disposableCreate(subscriber) : disposableEmpty;\n    }\n\n    function setDisposable(s, state) {\n      var ado = state[0], self = state[1];\n      var sub = tryCatch(self.__subscribe).call(self, ado);\n      if (sub === errorObj && !ado.fail(errorObj.e)) { thrower(errorObj.e); }\n      ado.setDisposable(fixSubscriber(sub));\n    }\n\n    function AnonymousObservable(subscribe, parent) {\n      this.source = parent;\n      this.__subscribe = subscribe;\n      __super__.call(this);\n    }\n\n    AnonymousObservable.prototype._subscribe = function (o) {\n      var ado = new AutoDetachObserver(o), state = [ado, this];\n\n      if (currentThreadScheduler.scheduleRequired()) {\n        currentThreadScheduler.schedule(state, setDisposable);\n      } else {\n        setDisposable(null, state);\n      }\n      return ado;\n    };\n\n    return AnonymousObservable;\n\n  }(Observable));\n\n  var AutoDetachObserver = (function (__super__) {\n    inherits(AutoDetachObserver, __super__);\n\n    function AutoDetachObserver(observer) {\n      __super__.call(this);\n      this.observer = observer;\n      this.m = new SingleAssignmentDisposable();\n    }\n\n    var AutoDetachObserverPrototype = AutoDetachObserver.prototype;\n\n    AutoDetachObserverPrototype.next = function (value) {\n      var result = tryCatch(this.observer.onNext).call(this.observer, value);\n      if (result === errorObj) {\n        this.dispose();\n        thrower(result.e);\n      }\n    };\n\n    AutoDetachObserverPrototype.error = function (err) {\n      var result = tryCatch(this.observer.onError).call(this.observer, err);\n      this.dispose();\n      result === errorObj && thrower(result.e);\n    };\n\n    AutoDetachObserverPrototype.completed = function () {\n      var result = tryCatch(this.observer.onCompleted).call(this.observer);\n      this.dispose();\n      result === errorObj && thrower(result.e);\n    };\n\n    AutoDetachObserverPrototype.setDisposable = function (value) { this.m.setDisposable(value); };\n    AutoDetachObserverPrototype.getDisposable = function () { return this.m.getDisposable(); };\n\n    AutoDetachObserverPrototype.dispose = function () {\n      __super__.prototype.dispose.call(this);\n      this.m.dispose();\n    };\n\n    return AutoDetachObserver;\n  }(AbstractObserver));\n\n  var UnderlyingObservable = (function (__super__) {\n    inherits(UnderlyingObservable, __super__);\n    function UnderlyingObservable(m, u) {\n      this._m = m;\n      this._u = u;\n      __super__.call(this);\n    }\n\n    UnderlyingObservable.prototype.subscribeCore = function (o) {\n      return new BinaryDisposable(this._m.getDisposable(), this._u.subscribe(o));\n    };\n\n    return UnderlyingObservable;\n  }(ObservableBase));\n\n  var GroupedObservable = (function (__super__) {\n    inherits(GroupedObservable, __super__);\n    function GroupedObservable(key, underlyingObservable, mergedDisposable) {\n      __super__.call(this);\n      this.key = key;\n      this.underlyingObservable = !mergedDisposable ?\n        underlyingObservable :\n        new UnderlyingObservable(mergedDisposable, underlyingObservable);\n    }\n\n    GroupedObservable.prototype._subscribe = function (o) {\n      return this.underlyingObservable.subscribe(o);\n    };\n\n    return GroupedObservable;\n  }(Observable));\n\n  /**\n   *  Represents an object that is both an observable sequence as well as an observer.\n   *  Each notification is broadcasted to all subscribed observers.\n   */\n  var Subject = Rx.Subject = (function (__super__) {\n    inherits(Subject, __super__);\n    function Subject() {\n      __super__.call(this);\n      this.isDisposed = false;\n      this.isStopped = false;\n      this.observers = [];\n      this.hasError = false;\n    }\n\n    addProperties(Subject.prototype, Observer.prototype, {\n      _subscribe: function (o) {\n        checkDisposed(this);\n        if (!this.isStopped) {\n          this.observers.push(o);\n          return new InnerSubscription(this, o);\n        }\n        if (this.hasError) {\n          o.onError(this.error);\n          return disposableEmpty;\n        }\n        o.onCompleted();\n        return disposableEmpty;\n      },\n      /**\n       * Indicates whether the subject has observers subscribed to it.\n       * @returns {Boolean} Indicates whether the subject has observers subscribed to it.\n       */\n      hasObservers: function () { return this.observers.length > 0; },\n      /**\n       * Notifies all subscribed observers about the end of the sequence.\n       */\n      onCompleted: function () {\n        checkDisposed(this);\n        if (!this.isStopped) {\n          this.isStopped = true;\n          for (var i = 0, os = cloneArray(this.observers), len = os.length; i < len; i++) {\n            os[i].onCompleted();\n          }\n\n          this.observers.length = 0;\n        }\n      },\n      /**\n       * Notifies all subscribed observers about the exception.\n       * @param {Mixed} error The exception to send to all observers.\n       */\n      onError: function (error) {\n        checkDisposed(this);\n        if (!this.isStopped) {\n          this.isStopped = true;\n          this.error = error;\n          this.hasError = true;\n          for (var i = 0, os = cloneArray(this.observers), len = os.length; i < len; i++) {\n            os[i].onError(error);\n          }\n\n          this.observers.length = 0;\n        }\n      },\n      /**\n       * Notifies all subscribed observers about the arrival of the specified element in the sequence.\n       * @param {Mixed} value The value to send to all observers.\n       */\n      onNext: function (value) {\n        checkDisposed(this);\n        if (!this.isStopped) {\n          for (var i = 0, os = cloneArray(this.observers), len = os.length; i < len; i++) {\n            os[i].onNext(value);\n          }\n        }\n      },\n      /**\n       * Unsubscribe all observers and release resources.\n       */\n      dispose: function () {\n        this.isDisposed = true;\n        this.observers = null;\n      }\n    });\n\n    /**\n     * Creates a subject from the specified observer and observable.\n     * @param {Observer} observer The observer used to send messages to the subject.\n     * @param {Observable} observable The observable used to subscribe to messages sent from the subject.\n     * @returns {Subject} Subject implemented using the given observer and observable.\n     */\n    Subject.create = function (observer, observable) {\n      return new AnonymousSubject(observer, observable);\n    };\n\n    return Subject;\n  }(Observable));\n\n  /**\n   *  Represents the result of an asynchronous operation.\n   *  The last value before the OnCompleted notification, or the error received through OnError, is sent to all subscribed observers.\n   */\n  var AsyncSubject = Rx.AsyncSubject = (function (__super__) {\n    inherits(AsyncSubject, __super__);\n\n    /**\n     * Creates a subject that can only receive one value and that value is cached for all future observations.\n     * @constructor\n     */\n    function AsyncSubject() {\n      __super__.call(this);\n      this.isDisposed = false;\n      this.isStopped = false;\n      this.hasValue = false;\n      this.observers = [];\n      this.hasError = false;\n    }\n\n    addProperties(AsyncSubject.prototype, Observer.prototype, {\n      _subscribe: function (o) {\n        checkDisposed(this);\n\n        if (!this.isStopped) {\n          this.observers.push(o);\n          return new InnerSubscription(this, o);\n        }\n\n        if (this.hasError) {\n          o.onError(this.error);\n        } else if (this.hasValue) {\n          o.onNext(this.value);\n          o.onCompleted();\n        } else {\n          o.onCompleted();\n        }\n\n        return disposableEmpty;\n      },\n      /**\n       * Indicates whether the subject has observers subscribed to it.\n       * @returns {Boolean} Indicates whether the subject has observers subscribed to it.\n       */\n      hasObservers: function () {\n        checkDisposed(this);\n        return this.observers.length > 0;\n      },\n      /**\n       * Notifies all subscribed observers about the end of the sequence, also causing the last received value to be sent out (if any).\n       */\n      onCompleted: function () {\n        var i, len;\n        checkDisposed(this);\n        if (!this.isStopped) {\n          this.isStopped = true;\n          var os = cloneArray(this.observers), len = os.length;\n\n          if (this.hasValue) {\n            for (i = 0; i < len; i++) {\n              var o = os[i];\n              o.onNext(this.value);\n              o.onCompleted();\n            }\n          } else {\n            for (i = 0; i < len; i++) {\n              os[i].onCompleted();\n            }\n          }\n\n          this.observers.length = 0;\n        }\n      },\n      /**\n       * Notifies all subscribed observers about the error.\n       * @param {Mixed} error The Error to send to all observers.\n       */\n      onError: function (error) {\n        checkDisposed(this);\n        if (!this.isStopped) {\n          this.isStopped = true;\n          this.hasError = true;\n          this.error = error;\n\n          for (var i = 0, os = cloneArray(this.observers), len = os.length; i < len; i++) {\n            os[i].onError(error);\n          }\n\n          this.observers.length = 0;\n        }\n      },\n      /**\n       * Sends a value to the subject. The last value received before successful termination will be sent to all subscribed and future observers.\n       * @param {Mixed} value The value to store in the subject.\n       */\n      onNext: function (value) {\n        checkDisposed(this);\n        if (this.isStopped) { return; }\n        this.value = value;\n        this.hasValue = true;\n      },\n      /**\n       * Unsubscribe all observers and release resources.\n       */\n      dispose: function () {\n        this.isDisposed = true;\n        this.observers = null;\n        this.error = null;\n        this.value = null;\n      }\n    });\n\n    return AsyncSubject;\n  }(Observable));\n\n  /**\n   *  Represents a value that changes over time.\n   *  Observers can subscribe to the subject to receive the last (or initial) value and all subsequent notifications.\n   */\n  var BehaviorSubject = Rx.BehaviorSubject = (function (__super__) {\n    inherits(BehaviorSubject, __super__);\n    function BehaviorSubject(value) {\n      __super__.call(this);\n      this.value = value;\n      this.observers = [];\n      this.isDisposed = false;\n      this.isStopped = false;\n      this.hasError = false;\n    }\n\n    addProperties(BehaviorSubject.prototype, Observer.prototype, {\n      _subscribe: function (o) {\n        checkDisposed(this);\n        if (!this.isStopped) {\n          this.observers.push(o);\n          o.onNext(this.value);\n          return new InnerSubscription(this, o);\n        }\n        if (this.hasError) {\n          o.onError(this.error);\n        } else {\n          o.onCompleted();\n        }\n        return disposableEmpty;\n      },\n      /**\n       * Gets the current value or throws an exception.\n       * Value is frozen after onCompleted is called.\n       * After onError is called always throws the specified exception.\n       * An exception is always thrown after dispose is called.\n       * @returns {Mixed} The initial value passed to the constructor until onNext is called; after which, the last value passed to onNext.\n       */\n      getValue: function () {\n        checkDisposed(this);\n        if (this.hasError) { thrower(this.error); }\n        return this.value;\n      },\n      /**\n       * Indicates whether the subject has observers subscribed to it.\n       * @returns {Boolean} Indicates whether the subject has observers subscribed to it.\n       */\n      hasObservers: function () { return this.observers.length > 0; },\n      /**\n       * Notifies all subscribed observers about the end of the sequence.\n       */\n      onCompleted: function () {\n        checkDisposed(this);\n        if (this.isStopped) { return; }\n        this.isStopped = true;\n        for (var i = 0, os = cloneArray(this.observers), len = os.length; i < len; i++) {\n          os[i].onCompleted();\n        }\n\n        this.observers.length = 0;\n      },\n      /**\n       * Notifies all subscribed observers about the exception.\n       * @param {Mixed} error The exception to send to all observers.\n       */\n      onError: function (error) {\n        checkDisposed(this);\n        if (this.isStopped) { return; }\n        this.isStopped = true;\n        this.hasError = true;\n        this.error = error;\n\n        for (var i = 0, os = cloneArray(this.observers), len = os.length; i < len; i++) {\n          os[i].onError(error);\n        }\n\n        this.observers.length = 0;\n      },\n      /**\n       * Notifies all subscribed observers about the arrival of the specified element in the sequence.\n       * @param {Mixed} value The value to send to all observers.\n       */\n      onNext: function (value) {\n        checkDisposed(this);\n        if (this.isStopped) { return; }\n        this.value = value;\n        for (var i = 0, os = cloneArray(this.observers), len = os.length; i < len; i++) {\n          os[i].onNext(value);\n        }\n      },\n      /**\n       * Unsubscribe all observers and release resources.\n       */\n      dispose: function () {\n        this.isDisposed = true;\n        this.observers = null;\n        this.value = null;\n        this.error = null;\n      }\n    });\n\n    return BehaviorSubject;\n  }(Observable));\n\n  /**\n   * Represents an object that is both an observable sequence as well as an observer.\n   * Each notification is broadcasted to all subscribed and future observers, subject to buffer trimming policies.\n   */\n  var ReplaySubject = Rx.ReplaySubject = (function (__super__) {\n\n    var maxSafeInteger = Math.pow(2, 53) - 1;\n\n    function createRemovableDisposable(subject, observer) {\n      return disposableCreate(function () {\n        observer.dispose();\n        !subject.isDisposed && subject.observers.splice(subject.observers.indexOf(observer), 1);\n      });\n    }\n\n    inherits(ReplaySubject, __super__);\n\n    /**\n     *  Initializes a new instance of the ReplaySubject class with the specified buffer size, window size and scheduler.\n     *  @param {Number} [bufferSize] Maximum element count of the replay buffer.\n     *  @param {Number} [windowSize] Maximum time length of the replay buffer.\n     *  @param {Scheduler} [scheduler] Scheduler the observers are invoked on.\n     */\n    function ReplaySubject(bufferSize, windowSize, scheduler) {\n      this.bufferSize = bufferSize == null ? maxSafeInteger : bufferSize;\n      this.windowSize = windowSize == null ? maxSafeInteger : windowSize;\n      this.scheduler = scheduler || currentThreadScheduler;\n      this.q = [];\n      this.observers = [];\n      this.isStopped = false;\n      this.isDisposed = false;\n      this.hasError = false;\n      this.error = null;\n      __super__.call(this);\n    }\n\n    addProperties(ReplaySubject.prototype, Observer.prototype, {\n      _subscribe: function (o) {\n        checkDisposed(this);\n        var so = new ScheduledObserver(this.scheduler, o), subscription = createRemovableDisposable(this, so);\n\n        this._trim(this.scheduler.now());\n        this.observers.push(so);\n\n        for (var i = 0, len = this.q.length; i < len; i++) {\n          so.onNext(this.q[i].value);\n        }\n\n        if (this.hasError) {\n          so.onError(this.error);\n        } else if (this.isStopped) {\n          so.onCompleted();\n        }\n\n        so.ensureActive();\n        return subscription;\n      },\n      /**\n       * Indicates whether the subject has observers subscribed to it.\n       * @returns {Boolean} Indicates whether the subject has observers subscribed to it.\n       */\n      hasObservers: function () {\n        return this.observers.length > 0;\n      },\n      _trim: function (now) {\n        while (this.q.length > this.bufferSize) {\n          this.q.shift();\n        }\n        while (this.q.length > 0 && (now - this.q[0].interval) > this.windowSize) {\n          this.q.shift();\n        }\n      },\n      /**\n       * Notifies all subscribed observers about the arrival of the specified element in the sequence.\n       * @param {Mixed} value The value to send to all observers.\n       */\n      onNext: function (value) {\n        checkDisposed(this);\n        if (this.isStopped) { return; }\n        var now = this.scheduler.now();\n        this.q.push({ interval: now, value: value });\n        this._trim(now);\n\n        for (var i = 0, os = cloneArray(this.observers), len = os.length; i < len; i++) {\n          var observer = os[i];\n          observer.onNext(value);\n          observer.ensureActive();\n        }\n      },\n      /**\n       * Notifies all subscribed observers about the exception.\n       * @param {Mixed} error The exception to send to all observers.\n       */\n      onError: function (error) {\n        checkDisposed(this);\n        if (this.isStopped) { return; }\n        this.isStopped = true;\n        this.error = error;\n        this.hasError = true;\n        var now = this.scheduler.now();\n        this._trim(now);\n        for (var i = 0, os = cloneArray(this.observers), len = os.length; i < len; i++) {\n          var observer = os[i];\n          observer.onError(error);\n          observer.ensureActive();\n        }\n        this.observers.length = 0;\n      },\n      /**\n       * Notifies all subscribed observers about the end of the sequence.\n       */\n      onCompleted: function () {\n        checkDisposed(this);\n        if (this.isStopped) { return; }\n        this.isStopped = true;\n        var now = this.scheduler.now();\n        this._trim(now);\n        for (var i = 0, os = cloneArray(this.observers), len = os.length; i < len; i++) {\n          var observer = os[i];\n          observer.onCompleted();\n          observer.ensureActive();\n        }\n        this.observers.length = 0;\n      },\n      /**\n       * Unsubscribe all observers and release resources.\n       */\n      dispose: function () {\n        this.isDisposed = true;\n        this.observers = null;\n      }\n    });\n\n    return ReplaySubject;\n  }(Observable));\n\n  var AnonymousSubject = Rx.AnonymousSubject = (function (__super__) {\n    inherits(AnonymousSubject, __super__);\n    function AnonymousSubject(observer, observable) {\n      this.observer = observer;\n      this.observable = observable;\n      __super__.call(this);\n    }\n\n    addProperties(AnonymousSubject.prototype, Observer.prototype, {\n      _subscribe: function (o) {\n        return this.observable.subscribe(o);\n      },\n      onCompleted: function () {\n        this.observer.onCompleted();\n      },\n      onError: function (error) {\n        this.observer.onError(error);\n      },\n      onNext: function (value) {\n        this.observer.onNext(value);\n      }\n    });\n\n    return AnonymousSubject;\n  }(Observable));\n\n  /**\n  * Used to pause and resume streams.\n  */\n  Rx.Pauser = (function (__super__) {\n    inherits(Pauser, __super__);\n    function Pauser() {\n      __super__.call(this);\n    }\n\n    /**\n     * Pauses the underlying sequence.\n     */\n    Pauser.prototype.pause = function () { this.onNext(false); };\n\n    /**\n    * Resumes the underlying sequence.\n    */\n    Pauser.prototype.resume = function () { this.onNext(true); };\n\n    return Pauser;\n  }(Subject));\n\n  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {\n    root.Rx = Rx;\n\n    define(function() {\n      return Rx;\n    });\n  } else if (freeExports && freeModule) {\n    // in Node.js or RingoJS\n    if (moduleExports) {\n      (freeModule.exports = Rx).Rx = Rx;\n    } else {\n      freeExports.Rx = Rx;\n    }\n  } else {\n    // in a browser or Rhino\n    root.Rx = Rx;\n  }\n\n  // All code before this point will be filtered from stack traces.\n  var rEndingLine = captureLine();\n\n}.call(this));\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rx/dist/rx.all.js\n ** module id = 49\n ** module chunks = 0\n **/","module.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tmodule.children = [];\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n}\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/buildin/module.js\n ** module id = 50\n ** module chunks = 0\n **/","// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = setTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    clearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/node-libs-browser/~/process/browser.js\n ** module id = 51\n ** module chunks = 0\n **/","(function() {\n  \"use strict\";\n\n  function addPropertyTo(target, methodName, value) {\n    Object.defineProperty(target, methodName, {\n      enumerable: false,\n      configurable: false,\n      writable: false,\n      value: value\n    });\n  }\n\n  function banProperty(target, methodName) {\n    addPropertyTo(target, methodName, function() {\n      throw new ImmutableError(\"The \" + methodName +\n        \" method cannot be invoked on an Immutable data structure.\");\n    });\n  }\n\n  var immutabilityTag = \"__immutable_invariants_hold\";\n\n  function addImmutabilityTag(target) {\n    addPropertyTo(target, immutabilityTag, true);\n  }\n\n  function isImmutable(target) {\n    if (typeof target === \"object\") {\n      return target === null || target.hasOwnProperty(immutabilityTag);\n    } else {\n      // In JavaScript, only objects are even potentially mutable.\n      // strings, numbers, null, and undefined are all naturally immutable.\n      return true;\n    }\n  }\n\n  function isMergableObject(target) {\n    return target !== null && typeof target === \"object\" && !(target instanceof Array) && !(target instanceof Date);\n  }\n\n  var mutatingObjectMethods = [\n    \"setPrototypeOf\"\n  ];\n\n  var nonMutatingObjectMethods = [\n    \"keys\"\n  ];\n\n  var mutatingArrayMethods = mutatingObjectMethods.concat([\n    \"push\", \"pop\", \"sort\", \"splice\", \"shift\", \"unshift\", \"reverse\"\n  ]);\n\n  var nonMutatingArrayMethods = nonMutatingObjectMethods.concat([\n    \"map\", \"filter\", \"slice\", \"concat\", \"reduce\", \"reduceRight\"\n  ]);\n\n  var mutatingDateMethods = mutatingObjectMethods.concat([\n    \"setDate\", \"setFullYear\", \"setHours\", \"setMilliseconds\", \"setMinutes\", \"setMonth\", \"setSeconds\",\n    \"setTime\", \"setUTCDate\", \"setUTCFullYear\", \"setUTCHours\", \"setUTCMilliseconds\", \"setUTCMinutes\",\n    \"setUTCMonth\", \"setUTCSeconds\", \"setYear\"\n  ]);\n\n  function ImmutableError(message) {\n    var err       = new Error(message);\n    err.__proto__ = ImmutableError;\n\n    return err;\n  }\n  ImmutableError.prototype = Error.prototype;\n\n  function makeImmutable(obj, bannedMethods) {\n    // Tag it so we can quickly tell it's immutable later.\n    addImmutabilityTag(obj);\n\n    if (process.env.NODE_ENV !== \"production\") {\n      // Make all mutating methods throw exceptions.\n      for (var index in bannedMethods) {\n        if (bannedMethods.hasOwnProperty(index)) {\n          banProperty(obj, bannedMethods[index]);\n        }\n      }\n\n      // Freeze it and return it.\n      Object.freeze(obj);\n    }\n\n    return obj;\n  }\n\n  function makeMethodReturnImmutable(obj, methodName) {\n    var currentMethod = obj[methodName];\n\n    addPropertyTo(obj, methodName, function() {\n      return Immutable(currentMethod.apply(obj, arguments));\n    });\n  }\n\n  function arraySet(idx, value) {\n    if (idx in this && this[idx] === value) {\n      return this;\n    }\n\n    var mutable = asMutableArray.call(this);\n    mutable[idx] = Immutable(value);\n    return makeImmutableArray(mutable);\n  }\n\n  var immutableEmptyArray = Immutable([]);\n\n  function arraySetIn(pth, value) {\n    var head = pth[0];\n\n    if (pth.length === 1) {\n      return arraySet.call(this, head, value);\n    } else {\n      var tail = pth.slice(1);\n      var thisHead = this[head];\n      var newValue;\n\n      if (typeof(thisHead) === \"object\" && thisHead !== null && typeof(thisHead.setIn) === \"function\") {\n        // Might (validly) be object or array\n        newValue = thisHead.setIn(tail, value);\n      } else {\n        newValue = arraySetIn.call(immutableEmptyArray, tail, value);\n      }\n\n      if (head in this && thisHead === newValue) {\n        return this;\n      }\n\n      var mutable = asMutableArray.call(this);\n      mutable[head] = newValue;\n      return makeImmutableArray(mutable);\n    }\n  }\n\n  function makeImmutableArray(array) {\n    // Don't change their implementations, but wrap these functions to make sure\n    // they always return an immutable value.\n    for (var index in nonMutatingArrayMethods) {\n      if (nonMutatingArrayMethods.hasOwnProperty(index)) {\n        var methodName = nonMutatingArrayMethods[index];\n        makeMethodReturnImmutable(array, methodName);\n      }\n    }\n\n    addPropertyTo(array, \"flatMap\",  flatMap);\n    addPropertyTo(array, \"asObject\", asObject);\n    addPropertyTo(array, \"asMutable\", asMutableArray);\n    addPropertyTo(array, \"set\", arraySet);\n    addPropertyTo(array, \"setIn\", arraySetIn);\n\n    for(var i = 0, length = array.length; i < length; i++) {\n      array[i] = Immutable(array[i]);\n    }\n\n    return makeImmutable(array, mutatingArrayMethods);\n  }\n\n  function makeImmutableDate(date) {\n    addPropertyTo(date, \"asMutable\", asMutableDate);\n\n    return makeImmutable(date, mutatingDateMethods);\n  }\n\n  function asMutableDate() {\n    return new Date(this.getTime());\n  }\n\n  /**\n   * Effectively performs a map() over the elements in the array, using the\n   * provided iterator, except that whenever the iterator returns an array, that\n   * array's elements are added to the final result instead of the array itself.\n   *\n   * @param {function} iterator - The iterator function that will be invoked on each element in the array. It will receive three arguments: the current value, the current index, and the current object.\n   */\n  function flatMap(iterator) {\n    // Calling .flatMap() with no arguments is a no-op. Don't bother cloning.\n    if (arguments.length === 0) {\n      return this;\n    }\n\n    var result = [],\n        length = this.length,\n        index;\n\n    for (index = 0; index < length; index++) {\n      var iteratorResult = iterator(this[index], index, this);\n\n      if (iteratorResult instanceof Array) {\n        // Concatenate Array results into the return value we're building up.\n        result.push.apply(result, iteratorResult);\n      } else {\n        // Handle non-Array results the same way map() does.\n        result.push(iteratorResult);\n      }\n    }\n\n    return makeImmutableArray(result);\n  }\n\n  /**\n   * Returns an Immutable copy of the object without the given keys included.\n   *\n   * @param {array} keysToRemove - A list of strings representing the keys to exclude in the return value. Instead of providing a single array, this method can also be called by passing multiple strings as separate arguments.\n   */\n  function without(keysToRemove) {\n    // Calling .without() with no arguments is a no-op. Don't bother cloning.\n    if (arguments.length === 0) {\n      return this;\n    }\n\n    // If we weren't given an array, use the arguments list.\n    if (!(keysToRemove instanceof Array)) {\n      keysToRemove = Array.prototype.slice.call(arguments);\n    }\n\n    var result = this.instantiateEmptyObject();\n\n    for (var key in this) {\n      if (this.hasOwnProperty(key) && (keysToRemove.indexOf(key) === -1)) {\n        result[key] = this[key];\n      }\n    }\n\n    return makeImmutableObject(result,\n      {instantiateEmptyObject: this.instantiateEmptyObject});\n  }\n\n  function asMutableArray(opts) {\n    var result = [], i, length;\n\n    if(opts && opts.deep) {\n      for(i = 0, length = this.length; i < length; i++) {\n        result.push(asDeepMutable(this[i]));\n      }\n    } else {\n      for(i = 0, length = this.length; i < length; i++) {\n        result.push(this[i]);\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Effectively performs a [map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map) over the elements in the array, expecting that the iterator function\n   * will return an array of two elements - the first representing a key, the other\n   * a value. Then returns an Immutable Object constructed of those keys and values.\n   *\n   * @param {function} iterator - A function which should return an array of two elements - the first representing the desired key, the other the desired value.\n   */\n  function asObject(iterator) {\n    // If no iterator was provided, assume the identity function\n    // (suggesting this array is already a list of key/value pairs.)\n    if (typeof iterator !== \"function\") {\n      iterator = function(value) { return value; };\n    }\n\n    var result = {},\n        length = this.length,\n        index;\n\n    for (index = 0; index < length; index++) {\n      var pair  = iterator(this[index], index, this),\n          key   = pair[0],\n          value = pair[1];\n\n      result[key] = value;\n    }\n\n    return makeImmutableObject(result);\n  }\n\n  function asDeepMutable(obj) {\n    if(!obj || !obj.hasOwnProperty(immutabilityTag) || obj instanceof Date) { return obj; }\n    return obj.asMutable({deep: true});\n  }\n\n  function quickCopy(src, dest) {\n    for (var key in src) {\n      if (src.hasOwnProperty(key)) {\n        dest[key] = src[key];\n      }\n    }\n\n    return dest;\n  }\n\n  /**\n   * Returns an Immutable Object containing the properties and values of both\n   * this object and the provided object, prioritizing the provided object's\n   * values whenever the same key is present in both objects.\n   *\n   * @param {object} other - The other object to merge. Multiple objects can be passed as an array. In such a case, the later an object appears in that list, the higher its priority.\n   * @param {object} config - Optional config object that contains settings. Supported settings are: {deep: true} for deep merge and {merger: mergerFunc} where mergerFunc is a function\n   *                          that takes a property from both objects. If anything is returned it overrides the normal merge behaviour.\n   */\n  function merge(other, config) {\n    // Calling .merge() with no arguments is a no-op. Don't bother cloning.\n    if (arguments.length === 0) {\n      return this;\n    }\n\n    if (other === null || (typeof other !== \"object\")) {\n      throw new TypeError(\"Immutable#merge can only be invoked with objects or arrays, not \" + JSON.stringify(other));\n    }\n\n    var receivedArray = (other instanceof Array),\n        deep          = config && config.deep,\n        merger        = config && config.merger,\n        result;\n\n    // Use the given key to extract a value from the given object, then place\n    // that value in the result object under the same key. If that resulted\n    // in a change from this object's value at that key, set anyChanges = true.\n    function addToResult(currentObj, otherObj, key) {\n      var immutableValue = Immutable(otherObj[key]);\n      var mergerResult = merger && merger(currentObj[key], immutableValue, config);\n      var currentValue = currentObj[key];\n\n      if ((result !== undefined) ||\n        (mergerResult !== undefined) ||\n        (!currentObj.hasOwnProperty(key) ||\n        ((immutableValue !== currentValue) &&\n          // Avoid false positives due to (NaN !== NaN) evaluating to true\n          (immutableValue === immutableValue)))) {\n\n        var newValue;\n\n        if (mergerResult) {\n          newValue = mergerResult;\n        } else if (deep && isMergableObject(currentValue) && isMergableObject(immutableValue)) {\n          newValue = currentValue.merge(immutableValue, config);\n        } else {\n          newValue = immutableValue;\n        }\n\n        // We check (newValue === newValue) because (NaN !== NaN) in JS\n        if (((currentValue !== newValue) && (newValue === newValue)) ||\n            !currentObj.hasOwnProperty(key)) {\n          if (result === undefined) {\n            // Make a shallow clone of the current object.\n            result = quickCopy(currentObj, currentObj.instantiateEmptyObject());\n          }\n\n          result[key] = newValue;\n        }\n      }\n    }\n\n    var key;\n\n    // Achieve prioritization by overriding previous values that get in the way.\n    if (!receivedArray) {\n      // The most common use case: just merge one object into the existing one.\n      for (key in other) {\n        if (other.hasOwnProperty(key)) {\n          addToResult(this, other, key);\n        }\n      }\n    } else {\n      // We also accept an Array\n      for (var index=0; index < other.length; index++) {\n        var otherFromArray = other[index];\n\n        for (key in otherFromArray) {\n          if (otherFromArray.hasOwnProperty(key)) {\n            addToResult(this, otherFromArray, key);\n          }\n        }\n      }\n    }\n\n    if (result === undefined) {\n      return this;\n    } else {\n      return makeImmutableObject(result,\n        {instantiateEmptyObject: this.instantiateEmptyObject});\n    }\n  }\n\n  var immutableEmptyObject = Immutable({});\n\n  function objectSetIn(path, value) {\n    var head = path[0];\n    if (path.length === 1) {\n      return objectSet.call(this, head, value);\n    }\n\n    var tail = path.slice(1);\n    var newValue;\n    var thisHead = this[head];\n\n    if (this.hasOwnProperty(head) && typeof(thisHead) === \"object\" && thisHead !== null && typeof(thisHead.setIn) === \"function\") {\n      // Might (validly) be object or array\n      newValue = thisHead.setIn(tail, value);\n    } else {\n      newValue = objectSetIn.call(immutableEmptyObject, tail, value);\n    }\n\n    if (this.hasOwnProperty(head) && thisHead === newValue) {\n      return this;\n    }\n\n    var mutable = quickCopy(this, this.instantiateEmptyObject());\n    mutable[head] = newValue;\n    return makeImmutableObject(mutable, this);\n  }\n\n  function objectSet(property, value) {\n    if (this.hasOwnProperty(property) && this[property] === value) {\n      return this;\n    }\n\n    var mutable = quickCopy(this, this.instantiateEmptyObject());\n    mutable[property] = Immutable(value);\n    return makeImmutableObject(mutable, this);\n  }\n\n  function asMutableObject(opts) {\n    var result = this.instantiateEmptyObject(), key;\n\n    if(opts && opts.deep) {\n      for (key in this) {\n        if (this.hasOwnProperty(key)) {\n          result[key] = asDeepMutable(this[key]);\n        }\n      }\n    } else {\n      for (key in this) {\n        if (this.hasOwnProperty(key)) {\n          result[key] = this[key];\n        }\n      }\n    }\n\n    return result;\n  }\n\n  // Creates plain object to be used for cloning\n  function instantiatePlainObject() {\n    return {};\n  }\n\n  // Finalizes an object with immutable methods, freezes it, and returns it.\n  function makeImmutableObject(obj, options) {\n    var instantiateEmptyObject =\n      (options && options.instantiateEmptyObject) ?\n        options.instantiateEmptyObject : instantiatePlainObject;\n\n    addPropertyTo(obj, \"merge\", merge);\n    addPropertyTo(obj, \"without\", without);\n    addPropertyTo(obj, \"asMutable\", asMutableObject);\n    addPropertyTo(obj, \"instantiateEmptyObject\", instantiateEmptyObject);\n    addPropertyTo(obj, \"set\", objectSet);\n    addPropertyTo(obj, \"setIn\", objectSetIn);\n\n    return makeImmutable(obj, mutatingObjectMethods);\n  }\n\n  function Immutable(obj, options) {\n    if (isImmutable(obj)) {\n      return obj;\n    } else if (obj instanceof Array) {\n      return makeImmutableArray(obj.slice());\n    } else if (obj instanceof Date) {\n      return makeImmutableDate(new Date(obj.getTime()));\n    } else {\n      // Don't freeze the object we were given; make a clone and use that.\n      var prototype = options && options.prototype;\n      var instantiateEmptyObject =\n        (!prototype || prototype === Object.prototype) ?\n          instantiatePlainObject : (function() { return Object.create(prototype); });\n      var clone = instantiateEmptyObject();\n\n      for (var key in obj) {\n        if (obj.hasOwnProperty(key)) {\n          clone[key] = Immutable(obj[key]);\n        }\n      }\n\n      return makeImmutableObject(clone,\n        {instantiateEmptyObject: instantiateEmptyObject});\n    }\n  }\n\n  // Export the library\n  Immutable.isImmutable    = isImmutable;\n  Immutable.ImmutableError = ImmutableError;\n\n  Object.freeze(Immutable);\n\n  /* istanbul ignore if */\n  if (typeof module === \"object\") {\n    module.exports = Immutable;\n  } else if (typeof exports === \"object\") {\n    exports.Immutable = Immutable;\n  } else if (typeof window === \"object\") {\n    window.Immutable = Immutable;\n  } else if (typeof global === \"object\") {\n    global.Immutable = Immutable;\n  }\n})();\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/seamless-immutable/src/seamless-immutable.js\n ** module id = 52\n ** module chunks = 0\n **/","diff          = require 'virtual-dom/diff'\npatch         = require 'virtual-dom/patch'\ncreateElement = require 'virtual-dom/create-element'\n\ncreatePatcher = (render) ->\n  calculatePatches = (acc, newState) ->\n    newTree = render newState\n\n    state   : newState,\n    vTree   : newTree,\n    patches : diff acc.vTree, newTree\n\nclass RxWidget\n  constructor: (source, render, initialState) ->\n    @seed = vTree: render initialState\n    @_patchObs = source.scan createPatcher(render), @seed\n\n  init: ->\n    domNode = createElement @seed.vTree # mutates\n    @_patcherSubscription = @_patchObs\n      .pluck 'patches'\n      .subscribe (patches) -> patch(domNode, patches)\n    domNode\n\n  destroy: -> @_patcherSubscription.dispose() if @_patcherSubscription\n\nmodule.exports = RxWidget\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/rx-widget.coffee\n **/","var diff = require(\"./vtree/diff.js\")\n\nmodule.exports = diff\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/virtual-dom/diff.js\n ** module id = 54\n ** module chunks = 0\n **/","var isArray = require(\"x-is-array\")\n\nvar VPatch = require(\"../vnode/vpatch\")\nvar isVNode = require(\"../vnode/is-vnode\")\nvar isVText = require(\"../vnode/is-vtext\")\nvar isWidget = require(\"../vnode/is-widget\")\nvar isThunk = require(\"../vnode/is-thunk\")\nvar handleThunk = require(\"../vnode/handle-thunk\")\n\nvar diffProps = require(\"./diff-props\")\n\nmodule.exports = diff\n\nfunction diff(a, b) {\n    var patch = { a: a }\n    walk(a, b, patch, 0)\n    return patch\n}\n\nfunction walk(a, b, patch, index) {\n    if (a === b) {\n        return\n    }\n\n    var apply = patch[index]\n    var applyClear = false\n\n    if (isThunk(a) || isThunk(b)) {\n        thunks(a, b, patch, index)\n    } else if (b == null) {\n\n        // If a is a widget we will add a remove patch for it\n        // Otherwise any child widgets/hooks must be destroyed.\n        // This prevents adding two remove patches for a widget.\n        if (!isWidget(a)) {\n            clearState(a, patch, index)\n            apply = patch[index]\n        }\n\n        apply = appendPatch(apply, new VPatch(VPatch.REMOVE, a, b))\n    } else if (isVNode(b)) {\n        if (isVNode(a)) {\n            if (a.tagName === b.tagName &&\n                a.namespace === b.namespace &&\n                a.key === b.key) {\n                var propsPatch = diffProps(a.properties, b.properties)\n                if (propsPatch) {\n                    apply = appendPatch(apply,\n                        new VPatch(VPatch.PROPS, a, propsPatch))\n                }\n                apply = diffChildren(a, b, patch, apply, index)\n            } else {\n                apply = appendPatch(apply, new VPatch(VPatch.VNODE, a, b))\n                applyClear = true\n            }\n        } else {\n            apply = appendPatch(apply, new VPatch(VPatch.VNODE, a, b))\n            applyClear = true\n        }\n    } else if (isVText(b)) {\n        if (!isVText(a)) {\n            apply = appendPatch(apply, new VPatch(VPatch.VTEXT, a, b))\n            applyClear = true\n        } else if (a.text !== b.text) {\n            apply = appendPatch(apply, new VPatch(VPatch.VTEXT, a, b))\n        }\n    } else if (isWidget(b)) {\n        if (!isWidget(a)) {\n            applyClear = true\n        }\n\n        apply = appendPatch(apply, new VPatch(VPatch.WIDGET, a, b))\n    }\n\n    if (apply) {\n        patch[index] = apply\n    }\n\n    if (applyClear) {\n        clearState(a, patch, index)\n    }\n}\n\nfunction diffChildren(a, b, patch, apply, index) {\n    var aChildren = a.children\n    var orderedSet = reorder(aChildren, b.children)\n    var bChildren = orderedSet.children\n\n    var aLen = aChildren.length\n    var bLen = bChildren.length\n    var len = aLen > bLen ? aLen : bLen\n\n    for (var i = 0; i < len; i++) {\n        var leftNode = aChildren[i]\n        var rightNode = bChildren[i]\n        index += 1\n\n        if (!leftNode) {\n            if (rightNode) {\n                // Excess nodes in b need to be added\n                apply = appendPatch(apply,\n                    new VPatch(VPatch.INSERT, null, rightNode))\n            }\n        } else {\n            walk(leftNode, rightNode, patch, index)\n        }\n\n        if (isVNode(leftNode) && leftNode.count) {\n            index += leftNode.count\n        }\n    }\n\n    if (orderedSet.moves) {\n        // Reorder nodes last\n        apply = appendPatch(apply, new VPatch(\n            VPatch.ORDER,\n            a,\n            orderedSet.moves\n        ))\n    }\n\n    return apply\n}\n\nfunction clearState(vNode, patch, index) {\n    // TODO: Make this a single walk, not two\n    unhook(vNode, patch, index)\n    destroyWidgets(vNode, patch, index)\n}\n\n// Patch records for all destroyed widgets must be added because we need\n// a DOM node reference for the destroy function\nfunction destroyWidgets(vNode, patch, index) {\n    if (isWidget(vNode)) {\n        if (typeof vNode.destroy === \"function\") {\n            patch[index] = appendPatch(\n                patch[index],\n                new VPatch(VPatch.REMOVE, vNode, null)\n            )\n        }\n    } else if (isVNode(vNode) && (vNode.hasWidgets || vNode.hasThunks)) {\n        var children = vNode.children\n        var len = children.length\n        for (var i = 0; i < len; i++) {\n            var child = children[i]\n            index += 1\n\n            destroyWidgets(child, patch, index)\n\n            if (isVNode(child) && child.count) {\n                index += child.count\n            }\n        }\n    } else if (isThunk(vNode)) {\n        thunks(vNode, null, patch, index)\n    }\n}\n\n// Create a sub-patch for thunks\nfunction thunks(a, b, patch, index) {\n    var nodes = handleThunk(a, b)\n    var thunkPatch = diff(nodes.a, nodes.b)\n    if (hasPatches(thunkPatch)) {\n        patch[index] = new VPatch(VPatch.THUNK, null, thunkPatch)\n    }\n}\n\nfunction hasPatches(patch) {\n    for (var index in patch) {\n        if (index !== \"a\") {\n            return true\n        }\n    }\n\n    return false\n}\n\n// Execute hooks when two nodes are identical\nfunction unhook(vNode, patch, index) {\n    if (isVNode(vNode)) {\n        if (vNode.hooks) {\n            patch[index] = appendPatch(\n                patch[index],\n                new VPatch(\n                    VPatch.PROPS,\n                    vNode,\n                    undefinedKeys(vNode.hooks)\n                )\n            )\n        }\n\n        if (vNode.descendantHooks || vNode.hasThunks) {\n            var children = vNode.children\n            var len = children.length\n            for (var i = 0; i < len; i++) {\n                var child = children[i]\n                index += 1\n\n                unhook(child, patch, index)\n\n                if (isVNode(child) && child.count) {\n                    index += child.count\n                }\n            }\n        }\n    } else if (isThunk(vNode)) {\n        thunks(vNode, null, patch, index)\n    }\n}\n\nfunction undefinedKeys(obj) {\n    var result = {}\n\n    for (var key in obj) {\n        result[key] = undefined\n    }\n\n    return result\n}\n\n// List diff, naive left to right reordering\nfunction reorder(aChildren, bChildren) {\n    // O(M) time, O(M) memory\n    var bChildIndex = keyIndex(bChildren)\n    var bKeys = bChildIndex.keys\n    var bFree = bChildIndex.free\n\n    if (bFree.length === bChildren.length) {\n        return {\n            children: bChildren,\n            moves: null\n        }\n    }\n\n    // O(N) time, O(N) memory\n    var aChildIndex = keyIndex(aChildren)\n    var aKeys = aChildIndex.keys\n    var aFree = aChildIndex.free\n\n    if (aFree.length === aChildren.length) {\n        return {\n            children: bChildren,\n            moves: null\n        }\n    }\n\n    // O(MAX(N, M)) memory\n    var newChildren = []\n\n    var freeIndex = 0\n    var freeCount = bFree.length\n    var deletedItems = 0\n\n    // Iterate through a and match a node in b\n    // O(N) time,\n    for (var i = 0 ; i < aChildren.length; i++) {\n        var aItem = aChildren[i]\n        var itemIndex\n\n        if (aItem.key) {\n            if (bKeys.hasOwnProperty(aItem.key)) {\n                // Match up the old keys\n                itemIndex = bKeys[aItem.key]\n                newChildren.push(bChildren[itemIndex])\n\n            } else {\n                // Remove old keyed items\n                itemIndex = i - deletedItems++\n                newChildren.push(null)\n            }\n        } else {\n            // Match the item in a with the next free item in b\n            if (freeIndex < freeCount) {\n                itemIndex = bFree[freeIndex++]\n                newChildren.push(bChildren[itemIndex])\n            } else {\n                // There are no free items in b to match with\n                // the free items in a, so the extra free nodes\n                // are deleted.\n                itemIndex = i - deletedItems++\n                newChildren.push(null)\n            }\n        }\n    }\n\n    var lastFreeIndex = freeIndex >= bFree.length ?\n        bChildren.length :\n        bFree[freeIndex]\n\n    // Iterate through b and append any new keys\n    // O(M) time\n    for (var j = 0; j < bChildren.length; j++) {\n        var newItem = bChildren[j]\n\n        if (newItem.key) {\n            if (!aKeys.hasOwnProperty(newItem.key)) {\n                // Add any new keyed items\n                // We are adding new items to the end and then sorting them\n                // in place. In future we should insert new items in place.\n                newChildren.push(newItem)\n            }\n        } else if (j >= lastFreeIndex) {\n            // Add any leftover non-keyed items\n            newChildren.push(newItem)\n        }\n    }\n\n    var simulate = newChildren.slice()\n    var simulateIndex = 0\n    var removes = []\n    var inserts = []\n    var simulateItem\n\n    for (var k = 0; k < bChildren.length;) {\n        var wantedItem = bChildren[k]\n        simulateItem = simulate[simulateIndex]\n\n        // remove items\n        while (simulateItem === null && simulate.length) {\n            removes.push(remove(simulate, simulateIndex, null))\n            simulateItem = simulate[simulateIndex]\n        }\n\n        if (!simulateItem || simulateItem.key !== wantedItem.key) {\n            // if we need a key in this position...\n            if (wantedItem.key) {\n                if (simulateItem && simulateItem.key) {\n                    // if an insert doesn't put this key in place, it needs to move\n                    if (bKeys[simulateItem.key] !== k + 1) {\n                        removes.push(remove(simulate, simulateIndex, simulateItem.key))\n                        simulateItem = simulate[simulateIndex]\n                        // if the remove didn't put the wanted item in place, we need to insert it\n                        if (!simulateItem || simulateItem.key !== wantedItem.key) {\n                            inserts.push({key: wantedItem.key, to: k})\n                        }\n                        // items are matching, so skip ahead\n                        else {\n                            simulateIndex++\n                        }\n                    }\n                    else {\n                        inserts.push({key: wantedItem.key, to: k})\n                    }\n                }\n                else {\n                    inserts.push({key: wantedItem.key, to: k})\n                }\n                k++\n            }\n            // a key in simulate has no matching wanted key, remove it\n            else if (simulateItem && simulateItem.key) {\n                removes.push(remove(simulate, simulateIndex, simulateItem.key))\n            }\n        }\n        else {\n            simulateIndex++\n            k++\n        }\n    }\n\n    // remove all the remaining nodes from simulate\n    while(simulateIndex < simulate.length) {\n        simulateItem = simulate[simulateIndex]\n        removes.push(remove(simulate, simulateIndex, simulateItem && simulateItem.key))\n    }\n\n    // If the only moves we have are deletes then we can just\n    // let the delete patch remove these items.\n    if (removes.length === deletedItems && !inserts.length) {\n        return {\n            children: newChildren,\n            moves: null\n        }\n    }\n\n    return {\n        children: newChildren,\n        moves: {\n            removes: removes,\n            inserts: inserts\n        }\n    }\n}\n\nfunction remove(arr, index, key) {\n    arr.splice(index, 1)\n\n    return {\n        from: index,\n        key: key\n    }\n}\n\nfunction keyIndex(children) {\n    var keys = {}\n    var free = []\n    var length = children.length\n\n    for (var i = 0; i < length; i++) {\n        var child = children[i]\n\n        if (child.key) {\n            keys[child.key] = i\n        } else {\n            free.push(i)\n        }\n    }\n\n    return {\n        keys: keys,     // A hash of key name to index\n        free: free      // An array of unkeyed item indices\n    }\n}\n\nfunction appendPatch(apply, patch) {\n    if (apply) {\n        if (isArray(apply)) {\n            apply.push(patch)\n        } else {\n            apply = [apply, patch]\n        }\n\n        return apply\n    } else {\n        return patch\n    }\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/virtual-dom/vtree/diff.js\n ** module id = 55\n ** module chunks = 0\n **/","var nativeIsArray = Array.isArray\nvar toString = Object.prototype.toString\n\nmodule.exports = nativeIsArray || isArray\n\nfunction isArray(obj) {\n    return toString.call(obj) === \"[object Array]\"\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/x-is-array/index.js\n ** module id = 56\n ** module chunks = 0\n **/","var version = require(\"./version\")\n\nVirtualPatch.NONE = 0\nVirtualPatch.VTEXT = 1\nVirtualPatch.VNODE = 2\nVirtualPatch.WIDGET = 3\nVirtualPatch.PROPS = 4\nVirtualPatch.ORDER = 5\nVirtualPatch.INSERT = 6\nVirtualPatch.REMOVE = 7\nVirtualPatch.THUNK = 8\n\nmodule.exports = VirtualPatch\n\nfunction VirtualPatch(type, vNode, patch) {\n    this.type = Number(type)\n    this.vNode = vNode\n    this.patch = patch\n}\n\nVirtualPatch.prototype.version = version\nVirtualPatch.prototype.type = \"VirtualPatch\"\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/virtual-dom/vnode/vpatch.js\n ** module id = 57\n ** module chunks = 0\n **/","module.exports = \"2\"\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/virtual-dom/vnode/version.js\n ** module id = 58\n ** module chunks = 0\n **/","var version = require(\"./version\")\n\nmodule.exports = isVirtualNode\n\nfunction isVirtualNode(x) {\n    return x && x.type === \"VirtualNode\" && x.version === version\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/virtual-dom/vnode/is-vnode.js\n ** module id = 59\n ** module chunks = 0\n **/","var version = require(\"./version\")\n\nmodule.exports = isVirtualText\n\nfunction isVirtualText(x) {\n    return x && x.type === \"VirtualText\" && x.version === version\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/virtual-dom/vnode/is-vtext.js\n ** module id = 60\n ** module chunks = 0\n **/","module.exports = isWidget\n\nfunction isWidget(w) {\n    return w && w.type === \"Widget\"\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/virtual-dom/vnode/is-widget.js\n ** module id = 61\n ** module chunks = 0\n **/","module.exports = isThunk\r\n\r\nfunction isThunk(t) {\r\n    return t && t.type === \"Thunk\"\r\n}\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/virtual-dom/vnode/is-thunk.js\n ** module id = 62\n ** module chunks = 0\n **/","var isVNode = require(\"./is-vnode\")\nvar isVText = require(\"./is-vtext\")\nvar isWidget = require(\"./is-widget\")\nvar isThunk = require(\"./is-thunk\")\n\nmodule.exports = handleThunk\n\nfunction handleThunk(a, b) {\n    var renderedA = a\n    var renderedB = b\n\n    if (isThunk(b)) {\n        renderedB = renderThunk(b, a)\n    }\n\n    if (isThunk(a)) {\n        renderedA = renderThunk(a, null)\n    }\n\n    return {\n        a: renderedA,\n        b: renderedB\n    }\n}\n\nfunction renderThunk(thunk, previous) {\n    var renderedThunk = thunk.vnode\n\n    if (!renderedThunk) {\n        renderedThunk = thunk.vnode = thunk.render(previous)\n    }\n\n    if (!(isVNode(renderedThunk) ||\n            isVText(renderedThunk) ||\n            isWidget(renderedThunk))) {\n        throw new Error(\"thunk did not return a valid node\");\n    }\n\n    return renderedThunk\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/virtual-dom/vnode/handle-thunk.js\n ** module id = 63\n ** module chunks = 0\n **/","var isObject = require(\"is-object\")\nvar isHook = require(\"../vnode/is-vhook\")\n\nmodule.exports = diffProps\n\nfunction diffProps(a, b) {\n    var diff\n\n    for (var aKey in a) {\n        if (!(aKey in b)) {\n            diff = diff || {}\n            diff[aKey] = undefined\n        }\n\n        var aValue = a[aKey]\n        var bValue = b[aKey]\n\n        if (aValue === bValue) {\n            continue\n        } else if (isObject(aValue) && isObject(bValue)) {\n            if (getPrototype(bValue) !== getPrototype(aValue)) {\n                diff = diff || {}\n                diff[aKey] = bValue\n            } else if (isHook(bValue)) {\n                 diff = diff || {}\n                 diff[aKey] = bValue\n            } else {\n                var objectDiff = diffProps(aValue, bValue)\n                if (objectDiff) {\n                    diff = diff || {}\n                    diff[aKey] = objectDiff\n                }\n            }\n        } else {\n            diff = diff || {}\n            diff[aKey] = bValue\n        }\n    }\n\n    for (var bKey in b) {\n        if (!(bKey in a)) {\n            diff = diff || {}\n            diff[bKey] = b[bKey]\n        }\n    }\n\n    return diff\n}\n\nfunction getPrototype(value) {\n  if (Object.getPrototypeOf) {\n    return Object.getPrototypeOf(value)\n  } else if (value.__proto__) {\n    return value.__proto__\n  } else if (value.constructor) {\n    return value.constructor.prototype\n  }\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/virtual-dom/vtree/diff-props.js\n ** module id = 64\n ** module chunks = 0\n **/","\"use strict\";\n\nmodule.exports = function isObject(x) {\n\treturn typeof x === \"object\" && x !== null;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/is-object/index.js\n ** module id = 65\n ** module chunks = 0\n **/","module.exports = isHook\n\nfunction isHook(hook) {\n    return hook &&\n      (typeof hook.hook === \"function\" && !hook.hasOwnProperty(\"hook\") ||\n       typeof hook.unhook === \"function\" && !hook.hasOwnProperty(\"unhook\"))\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/virtual-dom/vnode/is-vhook.js\n ** module id = 66\n ** module chunks = 0\n **/","var patch = require(\"./vdom/patch.js\")\n\nmodule.exports = patch\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/virtual-dom/patch.js\n ** module id = 67\n ** module chunks = 0\n **/","var document = require(\"global/document\")\nvar isArray = require(\"x-is-array\")\n\nvar render = require(\"./create-element\")\nvar domIndex = require(\"./dom-index\")\nvar patchOp = require(\"./patch-op\")\nmodule.exports = patch\n\nfunction patch(rootNode, patches, renderOptions) {\n    renderOptions = renderOptions || {}\n    renderOptions.patch = renderOptions.patch && renderOptions.patch !== patch\n        ? renderOptions.patch\n        : patchRecursive\n    renderOptions.render = renderOptions.render || render\n\n    return renderOptions.patch(rootNode, patches, renderOptions)\n}\n\nfunction patchRecursive(rootNode, patches, renderOptions) {\n    var indices = patchIndices(patches)\n\n    if (indices.length === 0) {\n        return rootNode\n    }\n\n    var index = domIndex(rootNode, patches.a, indices)\n    var ownerDocument = rootNode.ownerDocument\n\n    if (!renderOptions.document && ownerDocument !== document) {\n        renderOptions.document = ownerDocument\n    }\n\n    for (var i = 0; i < indices.length; i++) {\n        var nodeIndex = indices[i]\n        rootNode = applyPatch(rootNode,\n            index[nodeIndex],\n            patches[nodeIndex],\n            renderOptions)\n    }\n\n    return rootNode\n}\n\nfunction applyPatch(rootNode, domNode, patchList, renderOptions) {\n    if (!domNode) {\n        return rootNode\n    }\n\n    var newNode\n\n    if (isArray(patchList)) {\n        for (var i = 0; i < patchList.length; i++) {\n            newNode = patchOp(patchList[i], domNode, renderOptions)\n\n            if (domNode === rootNode) {\n                rootNode = newNode\n            }\n        }\n    } else {\n        newNode = patchOp(patchList, domNode, renderOptions)\n\n        if (domNode === rootNode) {\n            rootNode = newNode\n        }\n    }\n\n    return rootNode\n}\n\nfunction patchIndices(patches) {\n    var indices = []\n\n    for (var key in patches) {\n        if (key !== \"a\") {\n            indices.push(Number(key))\n        }\n    }\n\n    return indices\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/virtual-dom/vdom/patch.js\n ** module id = 68\n ** module chunks = 0\n **/","var topLevel = typeof global !== 'undefined' ? global :\n    typeof window !== 'undefined' ? window : {}\nvar minDoc = require('min-document');\n\nif (typeof document !== 'undefined') {\n    module.exports = document;\n} else {\n    var doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'];\n\n    if (!doccy) {\n        doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'] = minDoc;\n    }\n\n    module.exports = doccy;\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/global/document.js\n ** module id = 69\n ** module chunks = 0\n **/","var document = require(\"global/document\")\n\nvar applyProperties = require(\"./apply-properties\")\n\nvar isVNode = require(\"../vnode/is-vnode.js\")\nvar isVText = require(\"../vnode/is-vtext.js\")\nvar isWidget = require(\"../vnode/is-widget.js\")\nvar handleThunk = require(\"../vnode/handle-thunk.js\")\n\nmodule.exports = createElement\n\nfunction createElement(vnode, opts) {\n    var doc = opts ? opts.document || document : document\n    var warn = opts ? opts.warn : null\n\n    vnode = handleThunk(vnode).a\n\n    if (isWidget(vnode)) {\n        return vnode.init()\n    } else if (isVText(vnode)) {\n        return doc.createTextNode(vnode.text)\n    } else if (!isVNode(vnode)) {\n        if (warn) {\n            warn(\"Item is not a valid virtual dom node\", vnode)\n        }\n        return null\n    }\n\n    var node = (vnode.namespace === null) ?\n        doc.createElement(vnode.tagName) :\n        doc.createElementNS(vnode.namespace, vnode.tagName)\n\n    var props = vnode.properties\n    applyProperties(node, props)\n\n    var children = vnode.children\n\n    for (var i = 0; i < children.length; i++) {\n        var childNode = createElement(children[i], opts)\n        if (childNode) {\n            node.appendChild(childNode)\n        }\n    }\n\n    return node\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/virtual-dom/vdom/create-element.js\n ** module id = 71\n ** module chunks = 0\n **/","var isObject = require(\"is-object\")\nvar isHook = require(\"../vnode/is-vhook.js\")\n\nmodule.exports = applyProperties\n\nfunction applyProperties(node, props, previous) {\n    for (var propName in props) {\n        var propValue = props[propName]\n\n        if (propValue === undefined) {\n            removeProperty(node, propName, propValue, previous);\n        } else if (isHook(propValue)) {\n            removeProperty(node, propName, propValue, previous)\n            if (propValue.hook) {\n                propValue.hook(node,\n                    propName,\n                    previous ? previous[propName] : undefined)\n            }\n        } else {\n            if (isObject(propValue)) {\n                patchObject(node, props, previous, propName, propValue);\n            } else {\n                node[propName] = propValue\n            }\n        }\n    }\n}\n\nfunction removeProperty(node, propName, propValue, previous) {\n    if (previous) {\n        var previousValue = previous[propName]\n\n        if (!isHook(previousValue)) {\n            if (propName === \"attributes\") {\n                for (var attrName in previousValue) {\n                    node.removeAttribute(attrName)\n                }\n            } else if (propName === \"style\") {\n                for (var i in previousValue) {\n                    node.style[i] = \"\"\n                }\n            } else if (typeof previousValue === \"string\") {\n                node[propName] = \"\"\n            } else {\n                node[propName] = null\n            }\n        } else if (previousValue.unhook) {\n            previousValue.unhook(node, propName, propValue)\n        }\n    }\n}\n\nfunction patchObject(node, props, previous, propName, propValue) {\n    var previousValue = previous ? previous[propName] : undefined\n\n    // Set attributes\n    if (propName === \"attributes\") {\n        for (var attrName in propValue) {\n            var attrValue = propValue[attrName]\n\n            if (attrValue === undefined) {\n                node.removeAttribute(attrName)\n            } else {\n                node.setAttribute(attrName, attrValue)\n            }\n        }\n\n        return\n    }\n\n    if(previousValue && isObject(previousValue) &&\n        getPrototype(previousValue) !== getPrototype(propValue)) {\n        node[propName] = propValue\n        return\n    }\n\n    if (!isObject(node[propName])) {\n        node[propName] = {}\n    }\n\n    var replacer = propName === \"style\" ? \"\" : undefined\n\n    for (var k in propValue) {\n        var value = propValue[k]\n        node[propName][k] = (value === undefined) ? replacer : value\n    }\n}\n\nfunction getPrototype(value) {\n    if (Object.getPrototypeOf) {\n        return Object.getPrototypeOf(value)\n    } else if (value.__proto__) {\n        return value.__proto__\n    } else if (value.constructor) {\n        return value.constructor.prototype\n    }\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/virtual-dom/vdom/apply-properties.js\n ** module id = 72\n ** module chunks = 0\n **/","// Maps a virtual DOM tree onto a real DOM tree in an efficient manner.\n// We don't want to read all of the DOM nodes in the tree so we use\n// the in-order tree indexing to eliminate recursion down certain branches.\n// We only recurse into a DOM node if we know that it contains a child of\n// interest.\n\nvar noChild = {}\n\nmodule.exports = domIndex\n\nfunction domIndex(rootNode, tree, indices, nodes) {\n    if (!indices || indices.length === 0) {\n        return {}\n    } else {\n        indices.sort(ascending)\n        return recurse(rootNode, tree, indices, nodes, 0)\n    }\n}\n\nfunction recurse(rootNode, tree, indices, nodes, rootIndex) {\n    nodes = nodes || {}\n\n\n    if (rootNode) {\n        if (indexInRange(indices, rootIndex, rootIndex)) {\n            nodes[rootIndex] = rootNode\n        }\n\n        var vChildren = tree.children\n\n        if (vChildren) {\n\n            var childNodes = rootNode.childNodes\n\n            for (var i = 0; i < tree.children.length; i++) {\n                rootIndex += 1\n\n                var vChild = vChildren[i] || noChild\n                var nextIndex = rootIndex + (vChild.count || 0)\n\n                // skip recursion down the tree if there are no nodes down here\n                if (indexInRange(indices, rootIndex, nextIndex)) {\n                    recurse(childNodes[i], vChild, indices, nodes, rootIndex)\n                }\n\n                rootIndex = nextIndex\n            }\n        }\n    }\n\n    return nodes\n}\n\n// Binary search for an index in the interval [left, right]\nfunction indexInRange(indices, left, right) {\n    if (indices.length === 0) {\n        return false\n    }\n\n    var minIndex = 0\n    var maxIndex = indices.length - 1\n    var currentIndex\n    var currentItem\n\n    while (minIndex <= maxIndex) {\n        currentIndex = ((maxIndex + minIndex) / 2) >> 0\n        currentItem = indices[currentIndex]\n\n        if (minIndex === maxIndex) {\n            return currentItem >= left && currentItem <= right\n        } else if (currentItem < left) {\n            minIndex = currentIndex + 1\n        } else  if (currentItem > right) {\n            maxIndex = currentIndex - 1\n        } else {\n            return true\n        }\n    }\n\n    return false;\n}\n\nfunction ascending(a, b) {\n    return a > b ? 1 : -1\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/virtual-dom/vdom/dom-index.js\n ** module id = 73\n ** module chunks = 0\n **/","var applyProperties = require(\"./apply-properties\")\n\nvar isWidget = require(\"../vnode/is-widget.js\")\nvar VPatch = require(\"../vnode/vpatch.js\")\n\nvar updateWidget = require(\"./update-widget\")\n\nmodule.exports = applyPatch\n\nfunction applyPatch(vpatch, domNode, renderOptions) {\n    var type = vpatch.type\n    var vNode = vpatch.vNode\n    var patch = vpatch.patch\n\n    switch (type) {\n        case VPatch.REMOVE:\n            return removeNode(domNode, vNode)\n        case VPatch.INSERT:\n            return insertNode(domNode, patch, renderOptions)\n        case VPatch.VTEXT:\n            return stringPatch(domNode, vNode, patch, renderOptions)\n        case VPatch.WIDGET:\n            return widgetPatch(domNode, vNode, patch, renderOptions)\n        case VPatch.VNODE:\n            return vNodePatch(domNode, vNode, patch, renderOptions)\n        case VPatch.ORDER:\n            reorderChildren(domNode, patch)\n            return domNode\n        case VPatch.PROPS:\n            applyProperties(domNode, patch, vNode.properties)\n            return domNode\n        case VPatch.THUNK:\n            return replaceRoot(domNode,\n                renderOptions.patch(domNode, patch, renderOptions))\n        default:\n            return domNode\n    }\n}\n\nfunction removeNode(domNode, vNode) {\n    var parentNode = domNode.parentNode\n\n    if (parentNode) {\n        parentNode.removeChild(domNode)\n    }\n\n    destroyWidget(domNode, vNode);\n\n    return null\n}\n\nfunction insertNode(parentNode, vNode, renderOptions) {\n    var newNode = renderOptions.render(vNode, renderOptions)\n\n    if (parentNode) {\n        parentNode.appendChild(newNode)\n    }\n\n    return parentNode\n}\n\nfunction stringPatch(domNode, leftVNode, vText, renderOptions) {\n    var newNode\n\n    if (domNode.nodeType === 3) {\n        domNode.replaceData(0, domNode.length, vText.text)\n        newNode = domNode\n    } else {\n        var parentNode = domNode.parentNode\n        newNode = renderOptions.render(vText, renderOptions)\n\n        if (parentNode && newNode !== domNode) {\n            parentNode.replaceChild(newNode, domNode)\n        }\n    }\n\n    return newNode\n}\n\nfunction widgetPatch(domNode, leftVNode, widget, renderOptions) {\n    var updating = updateWidget(leftVNode, widget)\n    var newNode\n\n    if (updating) {\n        newNode = widget.update(leftVNode, domNode) || domNode\n    } else {\n        newNode = renderOptions.render(widget, renderOptions)\n    }\n\n    var parentNode = domNode.parentNode\n\n    if (parentNode && newNode !== domNode) {\n        parentNode.replaceChild(newNode, domNode)\n    }\n\n    if (!updating) {\n        destroyWidget(domNode, leftVNode)\n    }\n\n    return newNode\n}\n\nfunction vNodePatch(domNode, leftVNode, vNode, renderOptions) {\n    var parentNode = domNode.parentNode\n    var newNode = renderOptions.render(vNode, renderOptions)\n\n    if (parentNode && newNode !== domNode) {\n        parentNode.replaceChild(newNode, domNode)\n    }\n\n    return newNode\n}\n\nfunction destroyWidget(domNode, w) {\n    if (typeof w.destroy === \"function\" && isWidget(w)) {\n        w.destroy(domNode)\n    }\n}\n\nfunction reorderChildren(domNode, moves) {\n    var childNodes = domNode.childNodes\n    var keyMap = {}\n    var node\n    var remove\n    var insert\n\n    for (var i = 0; i < moves.removes.length; i++) {\n        remove = moves.removes[i]\n        node = childNodes[remove.from]\n        if (remove.key) {\n            keyMap[remove.key] = node\n        }\n        domNode.removeChild(node)\n    }\n\n    var length = childNodes.length\n    for (var j = 0; j < moves.inserts.length; j++) {\n        insert = moves.inserts[j]\n        node = keyMap[insert.key]\n        // this is the weirdest bug i've ever seen in webkit\n        domNode.insertBefore(node, insert.to >= length++ ? null : childNodes[insert.to])\n    }\n}\n\nfunction replaceRoot(oldRoot, newRoot) {\n    if (oldRoot && newRoot && oldRoot !== newRoot && oldRoot.parentNode) {\n        oldRoot.parentNode.replaceChild(newRoot, oldRoot)\n    }\n\n    return newRoot;\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/virtual-dom/vdom/patch-op.js\n ** module id = 74\n ** module chunks = 0\n **/","var isWidget = require(\"../vnode/is-widget.js\")\n\nmodule.exports = updateWidget\n\nfunction updateWidget(a, b) {\n    if (isWidget(a) && isWidget(b)) {\n        if (\"name\" in a && \"name\" in b) {\n            return a.id === b.id\n        } else {\n            return a.init === b.init\n        }\n    }\n\n    return false\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/virtual-dom/vdom/update-widget.js\n ** module id = 75\n ** module chunks = 0\n **/","var createElement = require(\"./vdom/create-element.js\")\n\nmodule.exports = createElement\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/virtual-dom/create-element.js\n ** module id = 76\n ** module chunks = 0\n **/","var h = require('ub-virtualdom/lib/h');\nvar _ = require('lodash'),\n    Immutable = require('seamless-immutable'),\n    TodoItem = require('./todo-item');\n\nclass TodoList {\n  constructor(emit, eventBus) {\n    this.emit = emit;\n    this.eventBus = eventBus;\n  }\n\n\n  toggelAll(completed) {\n    this.emit({\n      action: 'toggelAll',\n      completed: completed\n    });\n  }\n\n  todoList(show, activeItems, completedItems, allItems) {\n    let todos;\n\n    switch(show) {\n      case 'active':\n        todos = activeItems;\n        break;\n      case 'completed':\n        todos = completedItems;\n        break;\n      case 'all':\n      default:\n        todos = allItems;\n        break;\n    }\n\n    if(todos.length > 0) {\n      let todoItems = _.map(todos, (item) => {\n        let todoItem = new TodoItem(this.emit, this.eventBus);\n        return todoItem.render(item);\n      });\n      return (\n        h('section', {class: \"main\"}, [\n          h('input', {class: \"toggle-all\",\n            type: \"checkbox\",\n            checked:  completedItems.length === allItems.length ? true : undefined,\n            'ev-click':  (ev) => { this.toggelAll(completedItems.length !== allItems.length) }}\n          ),\n          h('label', {for: \"toggle-all\"}, [\"Mark all as complete\"]),\n          h('ul', {class: \"todo-list\"}, [\n            todoItems\n          ])\n        ])\n      );\n    } else {\n      return [];\n    }\n  }\n\n  create(ev) {\n    if(ev.keyCode == 13) {\n      this.emit({\n        action: 'create',\n        text: ev.target.value\n      });\n      ev.target.value = '';\n    }\n  }\n\n  clearButton() {\n    return (\n      h('button', {class: \"clear-completed\",\n        'ev-click':  (ev) => { this.emit({action: 'clearCompleted'}); }}, [\n        \"Clear completed\"\n      ])\n    );\n  }\n\n  render(opts) {\n    let activeItems = _.filter(_.toPairs(opts.todos), ([id, item]) => { return !item.completed; }),\n        completedItems = _.filter(_.toPairs(opts.todos), ([id, item]) => { return item.completed; }),\n        allItems = _.toPairs(opts.todos);\n\n    return (\n      h('div', null, [\n        h('section', {class: \"todoapp\"}, [\n          h('header', {class: \"header\"}, [\n            h('h1', null, [\"todos\"]),\n            h('input', {class: \"new-todo\",\n              'ev-keyup':  (ev) => { return this.create(ev); },\n              placeholder: \"What needs to be completed?\"})\n          ]),\n           this.todoList(opts.show, activeItems, completedItems, allItems),\n          h('footer', {class: \"footer\"}, [\n            h('span', {class: \"todo-count\"}, [h('strong', null, [ activeItems.length]),\" item\",  activeItems.length != 1 ? 's' : '', \" left\"]),\n            h('ul', {class: \"filters\"}, [\n              h('li', null, [\n                h('a', {class:  opts.show === 'all' ? 'selected' : '',\n                  href: \"#/\",\n                  'ev-click':  (ev) => { this.emit({action: 'show', show: 'all'}) }}, [\"All\"])\n              ]),\n              h('li', null, [\n                h('a', {class:  opts.show === 'active' ? 'selected' : '',\n                  href: \"#/active\",\n                  'ev-click':  (ev) => { this.emit({action: 'show', show: 'active'}) }}, [\"Active\"])\n              ]),\n              h('li', null, [\n                h('a', {class:  opts.show === 'completed' ? 'selected' : '',\n                  href: \"#/completed\",\n                  'ev-click':  (ev) => { this.emit({action: 'show', show: 'completed'}) }}, [\"Completed\"])\n              ])\n            ]),\n             completedItems.length > 0 ? this.clearButton() : ''\n          ])\n        ]),\n        h('footer', {class: \"info\"}, [\n          h('p', null, [\"Double-click to edit a todo\"]),\n          h('p', null, [\"Template by \", h('a', {href: \"http://sindresorhus.com\"}, [\"Sindre Sorhus\"])]),\n          h('p', null, [\"Created by \", h('a', {href: \"http://github.com/jpb\"}, [\"you\"])]),\n          h('p', null, [\"Part of \", h('a', {href: \"http://todomvc.com\"}, [\"TodoMVC\"])])\n        ])\n      ])\n    );\n  }\n}\n\nmodule.exports = TodoList;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/todo-list.jsx\n **/","_ = require 'lodash'\norigH = require 'virtual-dom/h'\nisVHook = require 'virtual-dom/vnode/is-vhook'\n\n# require for ev-[eventName] support\nDelegator = require 'dom-delegator'\nnew Delegator()\n\ntopLevelWhitelistedAttrs = [\n  'className'\n  'style'\n  'dataset'\n  'id'\n  ]\n\n# A wrapper around virtual-dom/h which normalizes its 'properties'\n# arguments and prevents common usage mistakes, particularly when used\n# as the node factory for jsx templates. See\n# https://github.com/Matt-Esch/virtual-dom/tree/master/virtual-hyperscript\nh = (first) ->\n  args = Array.apply(null, arguments)\n  secondArg = args[1]\n  if secondArg and typeof secondArg is 'object'\n    origAttributes = secondArg\n    normalizedAttributes = {attributes: origAttributes.attributes || {}}\n    _.forEach origAttributes, (v, k) ->\n      if k.indexOf('ev-') == 0 or k.indexOf('on') == 0\n        normalizedAttributes[k] = v\n      else if k in topLevelWhitelistedAttrs\n        normalizedAttributes[k] = v\n        delete normalizedAttributes.attributes[k]\n      else if k == 'class'\n        if origAttributes.className or normalizedAttributes.attributes.className\n          throw new Error('Use either class or className, not both')\n        normalizedAttributes['className'] = v\n        delete normalizedAttributes.attributes[k]\n      else if isVHook(v)\n        normalizedAttributes[k] = v\n      else if k == 'attributes'\n        true # pass\n      else\n        normalizedAttributes.attributes[k] = v\n\n    args[1] = normalizedAttributes\n  #\n  origH.apply(null, args)\n\nmodule.exports = h\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/ub-virtualdom/lib/h.coffee\n **/","/**\n * @license\n * lodash 3.10.1 (Custom Build) <https://lodash.com/>\n * Build: `lodash modern -d -o ./index.js`\n * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <https://lodash.com/license>\n */\n;(function() {\n\n  /** Used as a safe reference for `undefined` in pre-ES5 environments. */\n  var undefined;\n\n  /** Used as the semantic version number. */\n  var VERSION = '3.10.1';\n\n  /** Used to compose bitmasks for wrapper metadata. */\n  var BIND_FLAG = 1,\n      BIND_KEY_FLAG = 2,\n      CURRY_BOUND_FLAG = 4,\n      CURRY_FLAG = 8,\n      CURRY_RIGHT_FLAG = 16,\n      PARTIAL_FLAG = 32,\n      PARTIAL_RIGHT_FLAG = 64,\n      ARY_FLAG = 128,\n      REARG_FLAG = 256;\n\n  /** Used as default options for `_.trunc`. */\n  var DEFAULT_TRUNC_LENGTH = 30,\n      DEFAULT_TRUNC_OMISSION = '...';\n\n  /** Used to detect when a function becomes hot. */\n  var HOT_COUNT = 150,\n      HOT_SPAN = 16;\n\n  /** Used as the size to enable large array optimizations. */\n  var LARGE_ARRAY_SIZE = 200;\n\n  /** Used to indicate the type of lazy iteratees. */\n  var LAZY_FILTER_FLAG = 1,\n      LAZY_MAP_FLAG = 2;\n\n  /** Used as the `TypeError` message for \"Functions\" methods. */\n  var FUNC_ERROR_TEXT = 'Expected a function';\n\n  /** Used as the internal argument placeholder. */\n  var PLACEHOLDER = '__lodash_placeholder__';\n\n  /** `Object#toString` result references. */\n  var argsTag = '[object Arguments]',\n      arrayTag = '[object Array]',\n      boolTag = '[object Boolean]',\n      dateTag = '[object Date]',\n      errorTag = '[object Error]',\n      funcTag = '[object Function]',\n      mapTag = '[object Map]',\n      numberTag = '[object Number]',\n      objectTag = '[object Object]',\n      regexpTag = '[object RegExp]',\n      setTag = '[object Set]',\n      stringTag = '[object String]',\n      weakMapTag = '[object WeakMap]';\n\n  var arrayBufferTag = '[object ArrayBuffer]',\n      float32Tag = '[object Float32Array]',\n      float64Tag = '[object Float64Array]',\n      int8Tag = '[object Int8Array]',\n      int16Tag = '[object Int16Array]',\n      int32Tag = '[object Int32Array]',\n      uint8Tag = '[object Uint8Array]',\n      uint8ClampedTag = '[object Uint8ClampedArray]',\n      uint16Tag = '[object Uint16Array]',\n      uint32Tag = '[object Uint32Array]';\n\n  /** Used to match empty string literals in compiled template source. */\n  var reEmptyStringLeading = /\\b__p \\+= '';/g,\n      reEmptyStringMiddle = /\\b(__p \\+=) '' \\+/g,\n      reEmptyStringTrailing = /(__e\\(.*?\\)|\\b__t\\)) \\+\\n'';/g;\n\n  /** Used to match HTML entities and HTML characters. */\n  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39|#96);/g,\n      reUnescapedHtml = /[&<>\"'`]/g,\n      reHasEscapedHtml = RegExp(reEscapedHtml.source),\n      reHasUnescapedHtml = RegExp(reUnescapedHtml.source);\n\n  /** Used to match template delimiters. */\n  var reEscape = /<%-([\\s\\S]+?)%>/g,\n      reEvaluate = /<%([\\s\\S]+?)%>/g,\n      reInterpolate = /<%=([\\s\\S]+?)%>/g;\n\n  /** Used to match property names within property paths. */\n  var reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\n\\\\]|\\\\.)*?\\1)\\]/,\n      reIsPlainProp = /^\\w*$/,\n      rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\n\\\\]|\\\\.)*?)\\2)\\]/g;\n\n  /**\n   * Used to match `RegExp` [syntax characters](http://ecma-international.org/ecma-262/6.0/#sec-patterns)\n   * and those outlined by [`EscapeRegExpPattern`](http://ecma-international.org/ecma-262/6.0/#sec-escaperegexppattern).\n   */\n  var reRegExpChars = /^[:!,]|[\\\\^$.*+?()[\\]{}|\\/]|(^[0-9a-fA-Fnrtuvx])|([\\n\\r\\u2028\\u2029])/g,\n      reHasRegExpChars = RegExp(reRegExpChars.source);\n\n  /** Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks). */\n  var reComboMark = /[\\u0300-\\u036f\\ufe20-\\ufe23]/g;\n\n  /** Used to match backslashes in property paths. */\n  var reEscapeChar = /\\\\(\\\\)?/g;\n\n  /** Used to match [ES template delimiters](http://ecma-international.org/ecma-262/6.0/#sec-template-literal-lexical-components). */\n  var reEsTemplate = /\\$\\{([^\\\\}]*(?:\\\\.[^\\\\}]*)*)\\}/g;\n\n  /** Used to match `RegExp` flags from their coerced string values. */\n  var reFlags = /\\w*$/;\n\n  /** Used to detect hexadecimal string values. */\n  var reHasHexPrefix = /^0[xX]/;\n\n  /** Used to detect host constructors (Safari > 5). */\n  var reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n  /** Used to detect unsigned integer values. */\n  var reIsUint = /^\\d+$/;\n\n  /** Used to match latin-1 supplementary letters (excluding mathematical operators). */\n  var reLatin1 = /[\\xc0-\\xd6\\xd8-\\xde\\xdf-\\xf6\\xf8-\\xff]/g;\n\n  /** Used to ensure capturing order of template delimiters. */\n  var reNoMatch = /($^)/;\n\n  /** Used to match unescaped characters in compiled string literals. */\n  var reUnescapedString = /['\\n\\r\\u2028\\u2029\\\\]/g;\n\n  /** Used to match words to create compound words. */\n  var reWords = (function() {\n    var upper = '[A-Z\\\\xc0-\\\\xd6\\\\xd8-\\\\xde]',\n        lower = '[a-z\\\\xdf-\\\\xf6\\\\xf8-\\\\xff]+';\n\n    return RegExp(upper + '+(?=' + upper + lower + ')|' + upper + '?' + lower + '|' + upper + '+|[0-9]+', 'g');\n  }());\n\n  /** Used to assign default `context` object properties. */\n  var contextProps = [\n    'Array', 'ArrayBuffer', 'Date', 'Error', 'Float32Array', 'Float64Array',\n    'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Math', 'Number',\n    'Object', 'RegExp', 'Set', 'String', '_', 'clearTimeout', 'isFinite',\n    'parseFloat', 'parseInt', 'setTimeout', 'TypeError', 'Uint8Array',\n    'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap'\n  ];\n\n  /** Used to make template sourceURLs easier to identify. */\n  var templateCounter = -1;\n\n  /** Used to identify `toStringTag` values of typed arrays. */\n  var typedArrayTags = {};\n  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\n  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\n  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\n  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\n  typedArrayTags[uint32Tag] = true;\n  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =\n  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\n  typedArrayTags[dateTag] = typedArrayTags[errorTag] =\n  typedArrayTags[funcTag] = typedArrayTags[mapTag] =\n  typedArrayTags[numberTag] = typedArrayTags[objectTag] =\n  typedArrayTags[regexpTag] = typedArrayTags[setTag] =\n  typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;\n\n  /** Used to identify `toStringTag` values supported by `_.clone`. */\n  var cloneableTags = {};\n  cloneableTags[argsTag] = cloneableTags[arrayTag] =\n  cloneableTags[arrayBufferTag] = cloneableTags[boolTag] =\n  cloneableTags[dateTag] = cloneableTags[float32Tag] =\n  cloneableTags[float64Tag] = cloneableTags[int8Tag] =\n  cloneableTags[int16Tag] = cloneableTags[int32Tag] =\n  cloneableTags[numberTag] = cloneableTags[objectTag] =\n  cloneableTags[regexpTag] = cloneableTags[stringTag] =\n  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =\n  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;\n  cloneableTags[errorTag] = cloneableTags[funcTag] =\n  cloneableTags[mapTag] = cloneableTags[setTag] =\n  cloneableTags[weakMapTag] = false;\n\n  /** Used to map latin-1 supplementary letters to basic latin letters. */\n  var deburredLetters = {\n    '\\xc0': 'A',  '\\xc1': 'A', '\\xc2': 'A', '\\xc3': 'A', '\\xc4': 'A', '\\xc5': 'A',\n    '\\xe0': 'a',  '\\xe1': 'a', '\\xe2': 'a', '\\xe3': 'a', '\\xe4': 'a', '\\xe5': 'a',\n    '\\xc7': 'C',  '\\xe7': 'c',\n    '\\xd0': 'D',  '\\xf0': 'd',\n    '\\xc8': 'E',  '\\xc9': 'E', '\\xca': 'E', '\\xcb': 'E',\n    '\\xe8': 'e',  '\\xe9': 'e', '\\xea': 'e', '\\xeb': 'e',\n    '\\xcC': 'I',  '\\xcd': 'I', '\\xce': 'I', '\\xcf': 'I',\n    '\\xeC': 'i',  '\\xed': 'i', '\\xee': 'i', '\\xef': 'i',\n    '\\xd1': 'N',  '\\xf1': 'n',\n    '\\xd2': 'O',  '\\xd3': 'O', '\\xd4': 'O', '\\xd5': 'O', '\\xd6': 'O', '\\xd8': 'O',\n    '\\xf2': 'o',  '\\xf3': 'o', '\\xf4': 'o', '\\xf5': 'o', '\\xf6': 'o', '\\xf8': 'o',\n    '\\xd9': 'U',  '\\xda': 'U', '\\xdb': 'U', '\\xdc': 'U',\n    '\\xf9': 'u',  '\\xfa': 'u', '\\xfb': 'u', '\\xfc': 'u',\n    '\\xdd': 'Y',  '\\xfd': 'y', '\\xff': 'y',\n    '\\xc6': 'Ae', '\\xe6': 'ae',\n    '\\xde': 'Th', '\\xfe': 'th',\n    '\\xdf': 'ss'\n  };\n\n  /** Used to map characters to HTML entities. */\n  var htmlEscapes = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#39;',\n    '`': '&#96;'\n  };\n\n  /** Used to map HTML entities to characters. */\n  var htmlUnescapes = {\n    '&amp;': '&',\n    '&lt;': '<',\n    '&gt;': '>',\n    '&quot;': '\"',\n    '&#39;': \"'\",\n    '&#96;': '`'\n  };\n\n  /** Used to determine if values are of the language type `Object`. */\n  var objectTypes = {\n    'function': true,\n    'object': true\n  };\n\n  /** Used to escape characters for inclusion in compiled regexes. */\n  var regexpEscapes = {\n    '0': 'x30', '1': 'x31', '2': 'x32', '3': 'x33', '4': 'x34',\n    '5': 'x35', '6': 'x36', '7': 'x37', '8': 'x38', '9': 'x39',\n    'A': 'x41', 'B': 'x42', 'C': 'x43', 'D': 'x44', 'E': 'x45', 'F': 'x46',\n    'a': 'x61', 'b': 'x62', 'c': 'x63', 'd': 'x64', 'e': 'x65', 'f': 'x66',\n    'n': 'x6e', 'r': 'x72', 't': 'x74', 'u': 'x75', 'v': 'x76', 'x': 'x78'\n  };\n\n  /** Used to escape characters for inclusion in compiled string literals. */\n  var stringEscapes = {\n    '\\\\': '\\\\',\n    \"'\": \"'\",\n    '\\n': 'n',\n    '\\r': 'r',\n    '\\u2028': 'u2028',\n    '\\u2029': 'u2029'\n  };\n\n  /** Detect free variable `exports`. */\n  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;\n\n  /** Detect free variable `module`. */\n  var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;\n\n  /** Detect free variable `global` from Node.js. */\n  var freeGlobal = freeExports && freeModule && typeof global == 'object' && global && global.Object && global;\n\n  /** Detect free variable `self`. */\n  var freeSelf = objectTypes[typeof self] && self && self.Object && self;\n\n  /** Detect free variable `window`. */\n  var freeWindow = objectTypes[typeof window] && window && window.Object && window;\n\n  /** Detect the popular CommonJS extension `module.exports`. */\n  var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;\n\n  /**\n   * Used as a reference to the global object.\n   *\n   * The `this` value is used if it's the global object to avoid Greasemonkey's\n   * restricted `window` object, otherwise the `window` object is used.\n   */\n  var root = freeGlobal || ((freeWindow !== (this && this.window)) && freeWindow) || freeSelf || this;\n\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * The base implementation of `compareAscending` which compares values and\n   * sorts them in ascending order without guaranteeing a stable sort.\n   *\n   * @private\n   * @param {*} value The value to compare.\n   * @param {*} other The other value to compare.\n   * @returns {number} Returns the sort order indicator for `value`.\n   */\n  function baseCompareAscending(value, other) {\n    if (value !== other) {\n      var valIsNull = value === null,\n          valIsUndef = value === undefined,\n          valIsReflexive = value === value;\n\n      var othIsNull = other === null,\n          othIsUndef = other === undefined,\n          othIsReflexive = other === other;\n\n      if ((value > other && !othIsNull) || !valIsReflexive ||\n          (valIsNull && !othIsUndef && othIsReflexive) ||\n          (valIsUndef && othIsReflexive)) {\n        return 1;\n      }\n      if ((value < other && !valIsNull) || !othIsReflexive ||\n          (othIsNull && !valIsUndef && valIsReflexive) ||\n          (othIsUndef && valIsReflexive)) {\n        return -1;\n      }\n    }\n    return 0;\n  }\n\n  /**\n   * The base implementation of `_.findIndex` and `_.findLastIndex` without\n   * support for callback shorthands and `this` binding.\n   *\n   * @private\n   * @param {Array} array The array to search.\n   * @param {Function} predicate The function invoked per iteration.\n   * @param {boolean} [fromRight] Specify iterating from right to left.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function baseFindIndex(array, predicate, fromRight) {\n    var length = array.length,\n        index = fromRight ? length : -1;\n\n    while ((fromRight ? index-- : ++index < length)) {\n      if (predicate(array[index], index, array)) {\n        return index;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * The base implementation of `_.indexOf` without support for binary searches.\n   *\n   * @private\n   * @param {Array} array The array to search.\n   * @param {*} value The value to search for.\n   * @param {number} fromIndex The index to search from.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function baseIndexOf(array, value, fromIndex) {\n    if (value !== value) {\n      return indexOfNaN(array, fromIndex);\n    }\n    var index = fromIndex - 1,\n        length = array.length;\n\n    while (++index < length) {\n      if (array[index] === value) {\n        return index;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * The base implementation of `_.isFunction` without support for environments\n   * with incorrect `typeof` results.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n   */\n  function baseIsFunction(value) {\n    // Avoid a Chakra JIT bug in compatibility modes of IE 11.\n    // See https://github.com/jashkenas/underscore/issues/1621 for more details.\n    return typeof value == 'function' || false;\n  }\n\n  /**\n   * Converts `value` to a string if it's not one. An empty string is returned\n   * for `null` or `undefined` values.\n   *\n   * @private\n   * @param {*} value The value to process.\n   * @returns {string} Returns the string.\n   */\n  function baseToString(value) {\n    return value == null ? '' : (value + '');\n  }\n\n  /**\n   * Used by `_.trim` and `_.trimLeft` to get the index of the first character\n   * of `string` that is not found in `chars`.\n   *\n   * @private\n   * @param {string} string The string to inspect.\n   * @param {string} chars The characters to find.\n   * @returns {number} Returns the index of the first character not found in `chars`.\n   */\n  function charsLeftIndex(string, chars) {\n    var index = -1,\n        length = string.length;\n\n    while (++index < length && chars.indexOf(string.charAt(index)) > -1) {}\n    return index;\n  }\n\n  /**\n   * Used by `_.trim` and `_.trimRight` to get the index of the last character\n   * of `string` that is not found in `chars`.\n   *\n   * @private\n   * @param {string} string The string to inspect.\n   * @param {string} chars The characters to find.\n   * @returns {number} Returns the index of the last character not found in `chars`.\n   */\n  function charsRightIndex(string, chars) {\n    var index = string.length;\n\n    while (index-- && chars.indexOf(string.charAt(index)) > -1) {}\n    return index;\n  }\n\n  /**\n   * Used by `_.sortBy` to compare transformed elements of a collection and stable\n   * sort them in ascending order.\n   *\n   * @private\n   * @param {Object} object The object to compare.\n   * @param {Object} other The other object to compare.\n   * @returns {number} Returns the sort order indicator for `object`.\n   */\n  function compareAscending(object, other) {\n    return baseCompareAscending(object.criteria, other.criteria) || (object.index - other.index);\n  }\n\n  /**\n   * Used by `_.sortByOrder` to compare multiple properties of a value to another\n   * and stable sort them.\n   *\n   * If `orders` is unspecified, all valuess are sorted in ascending order. Otherwise,\n   * a value is sorted in ascending order if its corresponding order is \"asc\", and\n   * descending if \"desc\".\n   *\n   * @private\n   * @param {Object} object The object to compare.\n   * @param {Object} other The other object to compare.\n   * @param {boolean[]} orders The order to sort by for each property.\n   * @returns {number} Returns the sort order indicator for `object`.\n   */\n  function compareMultiple(object, other, orders) {\n    var index = -1,\n        objCriteria = object.criteria,\n        othCriteria = other.criteria,\n        length = objCriteria.length,\n        ordersLength = orders.length;\n\n    while (++index < length) {\n      var result = baseCompareAscending(objCriteria[index], othCriteria[index]);\n      if (result) {\n        if (index >= ordersLength) {\n          return result;\n        }\n        var order = orders[index];\n        return result * ((order === 'asc' || order === true) ? 1 : -1);\n      }\n    }\n    // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications\n    // that causes it, under certain circumstances, to provide the same value for\n    // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247\n    // for more details.\n    //\n    // This also ensures a stable sort in V8 and other engines.\n    // See https://code.google.com/p/v8/issues/detail?id=90 for more details.\n    return object.index - other.index;\n  }\n\n  /**\n   * Used by `_.deburr` to convert latin-1 supplementary letters to basic latin letters.\n   *\n   * @private\n   * @param {string} letter The matched letter to deburr.\n   * @returns {string} Returns the deburred letter.\n   */\n  function deburrLetter(letter) {\n    return deburredLetters[letter];\n  }\n\n  /**\n   * Used by `_.escape` to convert characters to HTML entities.\n   *\n   * @private\n   * @param {string} chr The matched character to escape.\n   * @returns {string} Returns the escaped character.\n   */\n  function escapeHtmlChar(chr) {\n    return htmlEscapes[chr];\n  }\n\n  /**\n   * Used by `_.escapeRegExp` to escape characters for inclusion in compiled regexes.\n   *\n   * @private\n   * @param {string} chr The matched character to escape.\n   * @param {string} leadingChar The capture group for a leading character.\n   * @param {string} whitespaceChar The capture group for a whitespace character.\n   * @returns {string} Returns the escaped character.\n   */\n  function escapeRegExpChar(chr, leadingChar, whitespaceChar) {\n    if (leadingChar) {\n      chr = regexpEscapes[chr];\n    } else if (whitespaceChar) {\n      chr = stringEscapes[chr];\n    }\n    return '\\\\' + chr;\n  }\n\n  /**\n   * Used by `_.template` to escape characters for inclusion in compiled string literals.\n   *\n   * @private\n   * @param {string} chr The matched character to escape.\n   * @returns {string} Returns the escaped character.\n   */\n  function escapeStringChar(chr) {\n    return '\\\\' + stringEscapes[chr];\n  }\n\n  /**\n   * Gets the index at which the first occurrence of `NaN` is found in `array`.\n   *\n   * @private\n   * @param {Array} array The array to search.\n   * @param {number} fromIndex The index to search from.\n   * @param {boolean} [fromRight] Specify iterating from right to left.\n   * @returns {number} Returns the index of the matched `NaN`, else `-1`.\n   */\n  function indexOfNaN(array, fromIndex, fromRight) {\n    var length = array.length,\n        index = fromIndex + (fromRight ? 0 : -1);\n\n    while ((fromRight ? index-- : ++index < length)) {\n      var other = array[index];\n      if (other !== other) {\n        return index;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Checks if `value` is object-like.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n   */\n  function isObjectLike(value) {\n    return !!value && typeof value == 'object';\n  }\n\n  /**\n   * Used by `trimmedLeftIndex` and `trimmedRightIndex` to determine if a\n   * character code is whitespace.\n   *\n   * @private\n   * @param {number} charCode The character code to inspect.\n   * @returns {boolean} Returns `true` if `charCode` is whitespace, else `false`.\n   */\n  function isSpace(charCode) {\n    return ((charCode <= 160 && (charCode >= 9 && charCode <= 13) || charCode == 32 || charCode == 160) || charCode == 5760 || charCode == 6158 ||\n      (charCode >= 8192 && (charCode <= 8202 || charCode == 8232 || charCode == 8233 || charCode == 8239 || charCode == 8287 || charCode == 12288 || charCode == 65279)));\n  }\n\n  /**\n   * Replaces all `placeholder` elements in `array` with an internal placeholder\n   * and returns an array of their indexes.\n   *\n   * @private\n   * @param {Array} array The array to modify.\n   * @param {*} placeholder The placeholder to replace.\n   * @returns {Array} Returns the new array of placeholder indexes.\n   */\n  function replaceHolders(array, placeholder) {\n    var index = -1,\n        length = array.length,\n        resIndex = -1,\n        result = [];\n\n    while (++index < length) {\n      if (array[index] === placeholder) {\n        array[index] = PLACEHOLDER;\n        result[++resIndex] = index;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * An implementation of `_.uniq` optimized for sorted arrays without support\n   * for callback shorthands and `this` binding.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {Function} [iteratee] The function invoked per iteration.\n   * @returns {Array} Returns the new duplicate-value-free array.\n   */\n  function sortedUniq(array, iteratee) {\n    var seen,\n        index = -1,\n        length = array.length,\n        resIndex = -1,\n        result = [];\n\n    while (++index < length) {\n      var value = array[index],\n          computed = iteratee ? iteratee(value, index, array) : value;\n\n      if (!index || seen !== computed) {\n        seen = computed;\n        result[++resIndex] = value;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Used by `_.trim` and `_.trimLeft` to get the index of the first non-whitespace\n   * character of `string`.\n   *\n   * @private\n   * @param {string} string The string to inspect.\n   * @returns {number} Returns the index of the first non-whitespace character.\n   */\n  function trimmedLeftIndex(string) {\n    var index = -1,\n        length = string.length;\n\n    while (++index < length && isSpace(string.charCodeAt(index))) {}\n    return index;\n  }\n\n  /**\n   * Used by `_.trim` and `_.trimRight` to get the index of the last non-whitespace\n   * character of `string`.\n   *\n   * @private\n   * @param {string} string The string to inspect.\n   * @returns {number} Returns the index of the last non-whitespace character.\n   */\n  function trimmedRightIndex(string) {\n    var index = string.length;\n\n    while (index-- && isSpace(string.charCodeAt(index))) {}\n    return index;\n  }\n\n  /**\n   * Used by `_.unescape` to convert HTML entities to characters.\n   *\n   * @private\n   * @param {string} chr The matched character to unescape.\n   * @returns {string} Returns the unescaped character.\n   */\n  function unescapeHtmlChar(chr) {\n    return htmlUnescapes[chr];\n  }\n\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * Create a new pristine `lodash` function using the given `context` object.\n   *\n   * @static\n   * @memberOf _\n   * @category Utility\n   * @param {Object} [context=root] The context object.\n   * @returns {Function} Returns a new `lodash` function.\n   * @example\n   *\n   * _.mixin({ 'foo': _.constant('foo') });\n   *\n   * var lodash = _.runInContext();\n   * lodash.mixin({ 'bar': lodash.constant('bar') });\n   *\n   * _.isFunction(_.foo);\n   * // => true\n   * _.isFunction(_.bar);\n   * // => false\n   *\n   * lodash.isFunction(lodash.foo);\n   * // => false\n   * lodash.isFunction(lodash.bar);\n   * // => true\n   *\n   * // using `context` to mock `Date#getTime` use in `_.now`\n   * var mock = _.runInContext({\n   *   'Date': function() {\n   *     return { 'getTime': getTimeMock };\n   *   }\n   * });\n   *\n   * // or creating a suped-up `defer` in Node.js\n   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;\n   */\n  function runInContext(context) {\n    // Avoid issues with some ES3 environments that attempt to use values, named\n    // after built-in constructors like `Object`, for the creation of literals.\n    // ES5 clears this up by stating that literals must use built-in constructors.\n    // See https://es5.github.io/#x11.1.5 for more details.\n    context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;\n\n    /** Native constructor references. */\n    var Array = context.Array,\n        Date = context.Date,\n        Error = context.Error,\n        Function = context.Function,\n        Math = context.Math,\n        Number = context.Number,\n        Object = context.Object,\n        RegExp = context.RegExp,\n        String = context.String,\n        TypeError = context.TypeError;\n\n    /** Used for native method references. */\n    var arrayProto = Array.prototype,\n        objectProto = Object.prototype,\n        stringProto = String.prototype;\n\n    /** Used to resolve the decompiled source of functions. */\n    var fnToString = Function.prototype.toString;\n\n    /** Used to check objects for own properties. */\n    var hasOwnProperty = objectProto.hasOwnProperty;\n\n    /** Used to generate unique IDs. */\n    var idCounter = 0;\n\n    /**\n     * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\n     * of values.\n     */\n    var objToString = objectProto.toString;\n\n    /** Used to restore the original `_` reference in `_.noConflict`. */\n    var oldDash = root._;\n\n    /** Used to detect if a method is native. */\n    var reIsNative = RegExp('^' +\n      fnToString.call(hasOwnProperty).replace(/[\\\\^$.*+?()[\\]{}|]/g, '\\\\$&')\n      .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n    );\n\n    /** Native method references. */\n    var ArrayBuffer = context.ArrayBuffer,\n        clearTimeout = context.clearTimeout,\n        parseFloat = context.parseFloat,\n        pow = Math.pow,\n        propertyIsEnumerable = objectProto.propertyIsEnumerable,\n        Set = getNative(context, 'Set'),\n        setTimeout = context.setTimeout,\n        splice = arrayProto.splice,\n        Uint8Array = context.Uint8Array,\n        WeakMap = getNative(context, 'WeakMap');\n\n    /* Native method references for those with the same name as other `lodash` methods. */\n    var nativeCeil = Math.ceil,\n        nativeCreate = getNative(Object, 'create'),\n        nativeFloor = Math.floor,\n        nativeIsArray = getNative(Array, 'isArray'),\n        nativeIsFinite = context.isFinite,\n        nativeKeys = getNative(Object, 'keys'),\n        nativeMax = Math.max,\n        nativeMin = Math.min,\n        nativeNow = getNative(Date, 'now'),\n        nativeParseInt = context.parseInt,\n        nativeRandom = Math.random;\n\n    /** Used as references for `-Infinity` and `Infinity`. */\n    var NEGATIVE_INFINITY = Number.NEGATIVE_INFINITY,\n        POSITIVE_INFINITY = Number.POSITIVE_INFINITY;\n\n    /** Used as references for the maximum length and index of an array. */\n    var MAX_ARRAY_LENGTH = 4294967295,\n        MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,\n        HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;\n\n    /**\n     * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)\n     * of an array-like value.\n     */\n    var MAX_SAFE_INTEGER = 9007199254740991;\n\n    /** Used to store function metadata. */\n    var metaMap = WeakMap && new WeakMap;\n\n    /** Used to lookup unminified function names. */\n    var realNames = {};\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a `lodash` object which wraps `value` to enable implicit chaining.\n     * Methods that operate on and return arrays, collections, and functions can\n     * be chained together. Methods that retrieve a single value or may return a\n     * primitive value will automatically end the chain returning the unwrapped\n     * value. Explicit chaining may be enabled using `_.chain`. The execution of\n     * chained methods is lazy, that is, execution is deferred until `_#value`\n     * is implicitly or explicitly called.\n     *\n     * Lazy evaluation allows several methods to support shortcut fusion. Shortcut\n     * fusion is an optimization strategy which merge iteratee calls; this can help\n     * to avoid the creation of intermediate data structures and greatly reduce the\n     * number of iteratee executions.\n     *\n     * Chaining is supported in custom builds as long as the `_#value` method is\n     * directly or indirectly included in the build.\n     *\n     * In addition to lodash methods, wrappers have `Array` and `String` methods.\n     *\n     * The wrapper `Array` methods are:\n     * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`,\n     * `splice`, and `unshift`\n     *\n     * The wrapper `String` methods are:\n     * `replace` and `split`\n     *\n     * The wrapper methods that support shortcut fusion are:\n     * `compact`, `drop`, `dropRight`, `dropRightWhile`, `dropWhile`, `filter`,\n     * `first`, `initial`, `last`, `map`, `pluck`, `reject`, `rest`, `reverse`,\n     * `slice`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, `toArray`,\n     * and `where`\n     *\n     * The chainable wrapper methods are:\n     * `after`, `ary`, `assign`, `at`, `before`, `bind`, `bindAll`, `bindKey`,\n     * `callback`, `chain`, `chunk`, `commit`, `compact`, `concat`, `constant`,\n     * `countBy`, `create`, `curry`, `debounce`, `defaults`, `defaultsDeep`,\n     * `defer`, `delay`, `difference`, `drop`, `dropRight`, `dropRightWhile`,\n     * `dropWhile`, `fill`, `filter`, `flatten`, `flattenDeep`, `flow`, `flowRight`,\n     * `forEach`, `forEachRight`, `forIn`, `forInRight`, `forOwn`, `forOwnRight`,\n     * `functions`, `groupBy`, `indexBy`, `initial`, `intersection`, `invert`,\n     * `invoke`, `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`,\n     * `matchesProperty`, `memoize`, `merge`, `method`, `methodOf`, `mixin`,\n     * `modArgs`, `negate`, `omit`, `once`, `pairs`, `partial`, `partialRight`,\n     * `partition`, `pick`, `plant`, `pluck`, `property`, `propertyOf`, `pull`,\n     * `pullAt`, `push`, `range`, `rearg`, `reject`, `remove`, `rest`, `restParam`,\n     * `reverse`, `set`, `shuffle`, `slice`, `sort`, `sortBy`, `sortByAll`,\n     * `sortByOrder`, `splice`, `spread`, `take`, `takeRight`, `takeRightWhile`,\n     * `takeWhile`, `tap`, `throttle`, `thru`, `times`, `toArray`, `toPlainObject`,\n     * `transform`, `union`, `uniq`, `unshift`, `unzip`, `unzipWith`, `values`,\n     * `valuesIn`, `where`, `without`, `wrap`, `xor`, `zip`, `zipObject`, `zipWith`\n     *\n     * The wrapper methods that are **not** chainable by default are:\n     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clone`, `cloneDeep`,\n     * `deburr`, `endsWith`, `escape`, `escapeRegExp`, `every`, `find`, `findIndex`,\n     * `findKey`, `findLast`, `findLastIndex`, `findLastKey`, `findWhere`, `first`,\n     * `floor`, `get`, `gt`, `gte`, `has`, `identity`, `includes`, `indexOf`,\n     * `inRange`, `isArguments`, `isArray`, `isBoolean`, `isDate`, `isElement`,\n     * `isEmpty`, `isEqual`, `isError`, `isFinite` `isFunction`, `isMatch`,\n     * `isNative`, `isNaN`, `isNull`, `isNumber`, `isObject`, `isPlainObject`,\n     * `isRegExp`, `isString`, `isUndefined`, `isTypedArray`, `join`, `kebabCase`,\n     * `last`, `lastIndexOf`, `lt`, `lte`, `max`, `min`, `noConflict`, `noop`,\n     * `now`, `pad`, `padLeft`, `padRight`, `parseInt`, `pop`, `random`, `reduce`,\n     * `reduceRight`, `repeat`, `result`, `round`, `runInContext`, `shift`, `size`,\n     * `snakeCase`, `some`, `sortedIndex`, `sortedLastIndex`, `startCase`,\n     * `startsWith`, `sum`, `template`, `trim`, `trimLeft`, `trimRight`, `trunc`,\n     * `unescape`, `uniqueId`, `value`, and `words`\n     *\n     * The wrapper method `sample` will return a wrapped value when `n` is provided,\n     * otherwise an unwrapped value is returned.\n     *\n     * @name _\n     * @constructor\n     * @category Chain\n     * @param {*} value The value to wrap in a `lodash` instance.\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var wrapped = _([1, 2, 3]);\n     *\n     * // returns an unwrapped value\n     * wrapped.reduce(function(total, n) {\n     *   return total + n;\n     * });\n     * // => 6\n     *\n     * // returns a wrapped value\n     * var squares = wrapped.map(function(n) {\n     *   return n * n;\n     * });\n     *\n     * _.isArray(squares);\n     * // => false\n     *\n     * _.isArray(squares.value());\n     * // => true\n     */\n    function lodash(value) {\n      if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {\n        if (value instanceof LodashWrapper) {\n          return value;\n        }\n        if (hasOwnProperty.call(value, '__chain__') && hasOwnProperty.call(value, '__wrapped__')) {\n          return wrapperClone(value);\n        }\n      }\n      return new LodashWrapper(value);\n    }\n\n    /**\n     * The function whose prototype all chaining wrappers inherit from.\n     *\n     * @private\n     */\n    function baseLodash() {\n      // No operation performed.\n    }\n\n    /**\n     * The base constructor for creating `lodash` wrapper objects.\n     *\n     * @private\n     * @param {*} value The value to wrap.\n     * @param {boolean} [chainAll] Enable chaining for all wrapper methods.\n     * @param {Array} [actions=[]] Actions to peform to resolve the unwrapped value.\n     */\n    function LodashWrapper(value, chainAll, actions) {\n      this.__wrapped__ = value;\n      this.__actions__ = actions || [];\n      this.__chain__ = !!chainAll;\n    }\n\n    /**\n     * An object environment feature flags.\n     *\n     * @static\n     * @memberOf _\n     * @type Object\n     */\n    var support = lodash.support = {};\n\n    /**\n     * By default, the template delimiters used by lodash are like those in\n     * embedded Ruby (ERB). Change the following template settings to use\n     * alternative delimiters.\n     *\n     * @static\n     * @memberOf _\n     * @type Object\n     */\n    lodash.templateSettings = {\n\n      /**\n       * Used to detect `data` property values to be HTML-escaped.\n       *\n       * @memberOf _.templateSettings\n       * @type RegExp\n       */\n      'escape': reEscape,\n\n      /**\n       * Used to detect code to be evaluated.\n       *\n       * @memberOf _.templateSettings\n       * @type RegExp\n       */\n      'evaluate': reEvaluate,\n\n      /**\n       * Used to detect `data` property values to inject.\n       *\n       * @memberOf _.templateSettings\n       * @type RegExp\n       */\n      'interpolate': reInterpolate,\n\n      /**\n       * Used to reference the data object in the template text.\n       *\n       * @memberOf _.templateSettings\n       * @type string\n       */\n      'variable': '',\n\n      /**\n       * Used to import variables into the compiled template.\n       *\n       * @memberOf _.templateSettings\n       * @type Object\n       */\n      'imports': {\n\n        /**\n         * A reference to the `lodash` function.\n         *\n         * @memberOf _.templateSettings.imports\n         * @type Function\n         */\n        '_': lodash\n      }\n    };\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.\n     *\n     * @private\n     * @param {*} value The value to wrap.\n     */\n    function LazyWrapper(value) {\n      this.__wrapped__ = value;\n      this.__actions__ = [];\n      this.__dir__ = 1;\n      this.__filtered__ = false;\n      this.__iteratees__ = [];\n      this.__takeCount__ = POSITIVE_INFINITY;\n      this.__views__ = [];\n    }\n\n    /**\n     * Creates a clone of the lazy wrapper object.\n     *\n     * @private\n     * @name clone\n     * @memberOf LazyWrapper\n     * @returns {Object} Returns the cloned `LazyWrapper` object.\n     */\n    function lazyClone() {\n      var result = new LazyWrapper(this.__wrapped__);\n      result.__actions__ = arrayCopy(this.__actions__);\n      result.__dir__ = this.__dir__;\n      result.__filtered__ = this.__filtered__;\n      result.__iteratees__ = arrayCopy(this.__iteratees__);\n      result.__takeCount__ = this.__takeCount__;\n      result.__views__ = arrayCopy(this.__views__);\n      return result;\n    }\n\n    /**\n     * Reverses the direction of lazy iteration.\n     *\n     * @private\n     * @name reverse\n     * @memberOf LazyWrapper\n     * @returns {Object} Returns the new reversed `LazyWrapper` object.\n     */\n    function lazyReverse() {\n      if (this.__filtered__) {\n        var result = new LazyWrapper(this);\n        result.__dir__ = -1;\n        result.__filtered__ = true;\n      } else {\n        result = this.clone();\n        result.__dir__ *= -1;\n      }\n      return result;\n    }\n\n    /**\n     * Extracts the unwrapped value from its lazy wrapper.\n     *\n     * @private\n     * @name value\n     * @memberOf LazyWrapper\n     * @returns {*} Returns the unwrapped value.\n     */\n    function lazyValue() {\n      var array = this.__wrapped__.value(),\n          dir = this.__dir__,\n          isArr = isArray(array),\n          isRight = dir < 0,\n          arrLength = isArr ? array.length : 0,\n          view = getView(0, arrLength, this.__views__),\n          start = view.start,\n          end = view.end,\n          length = end - start,\n          index = isRight ? end : (start - 1),\n          iteratees = this.__iteratees__,\n          iterLength = iteratees.length,\n          resIndex = 0,\n          takeCount = nativeMin(length, this.__takeCount__);\n\n      if (!isArr || arrLength < LARGE_ARRAY_SIZE || (arrLength == length && takeCount == length)) {\n        return baseWrapperValue((isRight && isArr) ? array.reverse() : array, this.__actions__);\n      }\n      var result = [];\n\n      outer:\n      while (length-- && resIndex < takeCount) {\n        index += dir;\n\n        var iterIndex = -1,\n            value = array[index];\n\n        while (++iterIndex < iterLength) {\n          var data = iteratees[iterIndex],\n              iteratee = data.iteratee,\n              type = data.type,\n              computed = iteratee(value);\n\n          if (type == LAZY_MAP_FLAG) {\n            value = computed;\n          } else if (!computed) {\n            if (type == LAZY_FILTER_FLAG) {\n              continue outer;\n            } else {\n              break outer;\n            }\n          }\n        }\n        result[resIndex++] = value;\n      }\n      return result;\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a cache object to store key/value pairs.\n     *\n     * @private\n     * @static\n     * @name Cache\n     * @memberOf _.memoize\n     */\n    function MapCache() {\n      this.__data__ = {};\n    }\n\n    /**\n     * Removes `key` and its value from the cache.\n     *\n     * @private\n     * @name delete\n     * @memberOf _.memoize.Cache\n     * @param {string} key The key of the value to remove.\n     * @returns {boolean} Returns `true` if the entry was removed successfully, else `false`.\n     */\n    function mapDelete(key) {\n      return this.has(key) && delete this.__data__[key];\n    }\n\n    /**\n     * Gets the cached value for `key`.\n     *\n     * @private\n     * @name get\n     * @memberOf _.memoize.Cache\n     * @param {string} key The key of the value to get.\n     * @returns {*} Returns the cached value.\n     */\n    function mapGet(key) {\n      return key == '__proto__' ? undefined : this.__data__[key];\n    }\n\n    /**\n     * Checks if a cached value for `key` exists.\n     *\n     * @private\n     * @name has\n     * @memberOf _.memoize.Cache\n     * @param {string} key The key of the entry to check.\n     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n     */\n    function mapHas(key) {\n      return key != '__proto__' && hasOwnProperty.call(this.__data__, key);\n    }\n\n    /**\n     * Sets `value` to `key` of the cache.\n     *\n     * @private\n     * @name set\n     * @memberOf _.memoize.Cache\n     * @param {string} key The key of the value to cache.\n     * @param {*} value The value to cache.\n     * @returns {Object} Returns the cache object.\n     */\n    function mapSet(key, value) {\n      if (key != '__proto__') {\n        this.__data__[key] = value;\n      }\n      return this;\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     *\n     * Creates a cache object to store unique values.\n     *\n     * @private\n     * @param {Array} [values] The values to cache.\n     */\n    function SetCache(values) {\n      var length = values ? values.length : 0;\n\n      this.data = { 'hash': nativeCreate(null), 'set': new Set };\n      while (length--) {\n        this.push(values[length]);\n      }\n    }\n\n    /**\n     * Checks if `value` is in `cache` mimicking the return signature of\n     * `_.indexOf` by returning `0` if the value is found, else `-1`.\n     *\n     * @private\n     * @param {Object} cache The cache to search.\n     * @param {*} value The value to search for.\n     * @returns {number} Returns `0` if `value` is found, else `-1`.\n     */\n    function cacheIndexOf(cache, value) {\n      var data = cache.data,\n          result = (typeof value == 'string' || isObject(value)) ? data.set.has(value) : data.hash[value];\n\n      return result ? 0 : -1;\n    }\n\n    /**\n     * Adds `value` to the cache.\n     *\n     * @private\n     * @name push\n     * @memberOf SetCache\n     * @param {*} value The value to cache.\n     */\n    function cachePush(value) {\n      var data = this.data;\n      if (typeof value == 'string' || isObject(value)) {\n        data.set.add(value);\n      } else {\n        data.hash[value] = true;\n      }\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a new array joining `array` with `other`.\n     *\n     * @private\n     * @param {Array} array The array to join.\n     * @param {Array} other The other array to join.\n     * @returns {Array} Returns the new concatenated array.\n     */\n    function arrayConcat(array, other) {\n      var index = -1,\n          length = array.length,\n          othIndex = -1,\n          othLength = other.length,\n          result = Array(length + othLength);\n\n      while (++index < length) {\n        result[index] = array[index];\n      }\n      while (++othIndex < othLength) {\n        result[index++] = other[othIndex];\n      }\n      return result;\n    }\n\n    /**\n     * Copies the values of `source` to `array`.\n     *\n     * @private\n     * @param {Array} source The array to copy values from.\n     * @param {Array} [array=[]] The array to copy values to.\n     * @returns {Array} Returns `array`.\n     */\n    function arrayCopy(source, array) {\n      var index = -1,\n          length = source.length;\n\n      array || (array = Array(length));\n      while (++index < length) {\n        array[index] = source[index];\n      }\n      return array;\n    }\n\n    /**\n     * A specialized version of `_.forEach` for arrays without support for callback\n     * shorthands and `this` binding.\n     *\n     * @private\n     * @param {Array} array The array to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Array} Returns `array`.\n     */\n    function arrayEach(array, iteratee) {\n      var index = -1,\n          length = array.length;\n\n      while (++index < length) {\n        if (iteratee(array[index], index, array) === false) {\n          break;\n        }\n      }\n      return array;\n    }\n\n    /**\n     * A specialized version of `_.forEachRight` for arrays without support for\n     * callback shorthands and `this` binding.\n     *\n     * @private\n     * @param {Array} array The array to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Array} Returns `array`.\n     */\n    function arrayEachRight(array, iteratee) {\n      var length = array.length;\n\n      while (length--) {\n        if (iteratee(array[length], length, array) === false) {\n          break;\n        }\n      }\n      return array;\n    }\n\n    /**\n     * A specialized version of `_.every` for arrays without support for callback\n     * shorthands and `this` binding.\n     *\n     * @private\n     * @param {Array} array The array to iterate over.\n     * @param {Function} predicate The function invoked per iteration.\n     * @returns {boolean} Returns `true` if all elements pass the predicate check,\n     *  else `false`.\n     */\n    function arrayEvery(array, predicate) {\n      var index = -1,\n          length = array.length;\n\n      while (++index < length) {\n        if (!predicate(array[index], index, array)) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    /**\n     * A specialized version of `baseExtremum` for arrays which invokes `iteratee`\n     * with one argument: (value).\n     *\n     * @private\n     * @param {Array} array The array to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @param {Function} comparator The function used to compare values.\n     * @param {*} exValue The initial extremum value.\n     * @returns {*} Returns the extremum value.\n     */\n    function arrayExtremum(array, iteratee, comparator, exValue) {\n      var index = -1,\n          length = array.length,\n          computed = exValue,\n          result = computed;\n\n      while (++index < length) {\n        var value = array[index],\n            current = +iteratee(value);\n\n        if (comparator(current, computed)) {\n          computed = current;\n          result = value;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * A specialized version of `_.filter` for arrays without support for callback\n     * shorthands and `this` binding.\n     *\n     * @private\n     * @param {Array} array The array to iterate over.\n     * @param {Function} predicate The function invoked per iteration.\n     * @returns {Array} Returns the new filtered array.\n     */\n    function arrayFilter(array, predicate) {\n      var index = -1,\n          length = array.length,\n          resIndex = -1,\n          result = [];\n\n      while (++index < length) {\n        var value = array[index];\n        if (predicate(value, index, array)) {\n          result[++resIndex] = value;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * A specialized version of `_.map` for arrays without support for callback\n     * shorthands and `this` binding.\n     *\n     * @private\n     * @param {Array} array The array to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Array} Returns the new mapped array.\n     */\n    function arrayMap(array, iteratee) {\n      var index = -1,\n          length = array.length,\n          result = Array(length);\n\n      while (++index < length) {\n        result[index] = iteratee(array[index], index, array);\n      }\n      return result;\n    }\n\n    /**\n     * Appends the elements of `values` to `array`.\n     *\n     * @private\n     * @param {Array} array The array to modify.\n     * @param {Array} values The values to append.\n     * @returns {Array} Returns `array`.\n     */\n    function arrayPush(array, values) {\n      var index = -1,\n          length = values.length,\n          offset = array.length;\n\n      while (++index < length) {\n        array[offset + index] = values[index];\n      }\n      return array;\n    }\n\n    /**\n     * A specialized version of `_.reduce` for arrays without support for callback\n     * shorthands and `this` binding.\n     *\n     * @private\n     * @param {Array} array The array to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @param {*} [accumulator] The initial value.\n     * @param {boolean} [initFromArray] Specify using the first element of `array`\n     *  as the initial value.\n     * @returns {*} Returns the accumulated value.\n     */\n    function arrayReduce(array, iteratee, accumulator, initFromArray) {\n      var index = -1,\n          length = array.length;\n\n      if (initFromArray && length) {\n        accumulator = array[++index];\n      }\n      while (++index < length) {\n        accumulator = iteratee(accumulator, array[index], index, array);\n      }\n      return accumulator;\n    }\n\n    /**\n     * A specialized version of `_.reduceRight` for arrays without support for\n     * callback shorthands and `this` binding.\n     *\n     * @private\n     * @param {Array} array The array to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @param {*} [accumulator] The initial value.\n     * @param {boolean} [initFromArray] Specify using the last element of `array`\n     *  as the initial value.\n     * @returns {*} Returns the accumulated value.\n     */\n    function arrayReduceRight(array, iteratee, accumulator, initFromArray) {\n      var length = array.length;\n      if (initFromArray && length) {\n        accumulator = array[--length];\n      }\n      while (length--) {\n        accumulator = iteratee(accumulator, array[length], length, array);\n      }\n      return accumulator;\n    }\n\n    /**\n     * A specialized version of `_.some` for arrays without support for callback\n     * shorthands and `this` binding.\n     *\n     * @private\n     * @param {Array} array The array to iterate over.\n     * @param {Function} predicate The function invoked per iteration.\n     * @returns {boolean} Returns `true` if any element passes the predicate check,\n     *  else `false`.\n     */\n    function arraySome(array, predicate) {\n      var index = -1,\n          length = array.length;\n\n      while (++index < length) {\n        if (predicate(array[index], index, array)) {\n          return true;\n        }\n      }\n      return false;\n    }\n\n    /**\n     * A specialized version of `_.sum` for arrays without support for callback\n     * shorthands and `this` binding..\n     *\n     * @private\n     * @param {Array} array The array to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {number} Returns the sum.\n     */\n    function arraySum(array, iteratee) {\n      var length = array.length,\n          result = 0;\n\n      while (length--) {\n        result += +iteratee(array[length]) || 0;\n      }\n      return result;\n    }\n\n    /**\n     * Used by `_.defaults` to customize its `_.assign` use.\n     *\n     * @private\n     * @param {*} objectValue The destination object property value.\n     * @param {*} sourceValue The source object property value.\n     * @returns {*} Returns the value to assign to the destination object.\n     */\n    function assignDefaults(objectValue, sourceValue) {\n      return objectValue === undefined ? sourceValue : objectValue;\n    }\n\n    /**\n     * Used by `_.template` to customize its `_.assign` use.\n     *\n     * **Note:** This function is like `assignDefaults` except that it ignores\n     * inherited property values when checking if a property is `undefined`.\n     *\n     * @private\n     * @param {*} objectValue The destination object property value.\n     * @param {*} sourceValue The source object property value.\n     * @param {string} key The key associated with the object and source values.\n     * @param {Object} object The destination object.\n     * @returns {*} Returns the value to assign to the destination object.\n     */\n    function assignOwnDefaults(objectValue, sourceValue, key, object) {\n      return (objectValue === undefined || !hasOwnProperty.call(object, key))\n        ? sourceValue\n        : objectValue;\n    }\n\n    /**\n     * A specialized version of `_.assign` for customizing assigned values without\n     * support for argument juggling, multiple sources, and `this` binding `customizer`\n     * functions.\n     *\n     * @private\n     * @param {Object} object The destination object.\n     * @param {Object} source The source object.\n     * @param {Function} customizer The function to customize assigned values.\n     * @returns {Object} Returns `object`.\n     */\n    function assignWith(object, source, customizer) {\n      var index = -1,\n          props = keys(source),\n          length = props.length;\n\n      while (++index < length) {\n        var key = props[index],\n            value = object[key],\n            result = customizer(value, source[key], key, object, source);\n\n        if ((result === result ? (result !== value) : (value === value)) ||\n            (value === undefined && !(key in object))) {\n          object[key] = result;\n        }\n      }\n      return object;\n    }\n\n    /**\n     * The base implementation of `_.assign` without support for argument juggling,\n     * multiple sources, and `customizer` functions.\n     *\n     * @private\n     * @param {Object} object The destination object.\n     * @param {Object} source The source object.\n     * @returns {Object} Returns `object`.\n     */\n    function baseAssign(object, source) {\n      return source == null\n        ? object\n        : baseCopy(source, keys(source), object);\n    }\n\n    /**\n     * The base implementation of `_.at` without support for string collections\n     * and individual key arguments.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {number[]|string[]} props The property names or indexes of elements to pick.\n     * @returns {Array} Returns the new array of picked elements.\n     */\n    function baseAt(collection, props) {\n      var index = -1,\n          isNil = collection == null,\n          isArr = !isNil && isArrayLike(collection),\n          length = isArr ? collection.length : 0,\n          propsLength = props.length,\n          result = Array(propsLength);\n\n      while(++index < propsLength) {\n        var key = props[index];\n        if (isArr) {\n          result[index] = isIndex(key, length) ? collection[key] : undefined;\n        } else {\n          result[index] = isNil ? undefined : collection[key];\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Copies properties of `source` to `object`.\n     *\n     * @private\n     * @param {Object} source The object to copy properties from.\n     * @param {Array} props The property names to copy.\n     * @param {Object} [object={}] The object to copy properties to.\n     * @returns {Object} Returns `object`.\n     */\n    function baseCopy(source, props, object) {\n      object || (object = {});\n\n      var index = -1,\n          length = props.length;\n\n      while (++index < length) {\n        var key = props[index];\n        object[key] = source[key];\n      }\n      return object;\n    }\n\n    /**\n     * The base implementation of `_.callback` which supports specifying the\n     * number of arguments to provide to `func`.\n     *\n     * @private\n     * @param {*} [func=_.identity] The value to convert to a callback.\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @param {number} [argCount] The number of arguments to provide to `func`.\n     * @returns {Function} Returns the callback.\n     */\n    function baseCallback(func, thisArg, argCount) {\n      var type = typeof func;\n      if (type == 'function') {\n        return thisArg === undefined\n          ? func\n          : bindCallback(func, thisArg, argCount);\n      }\n      if (func == null) {\n        return identity;\n      }\n      if (type == 'object') {\n        return baseMatches(func);\n      }\n      return thisArg === undefined\n        ? property(func)\n        : baseMatchesProperty(func, thisArg);\n    }\n\n    /**\n     * The base implementation of `_.clone` without support for argument juggling\n     * and `this` binding `customizer` functions.\n     *\n     * @private\n     * @param {*} value The value to clone.\n     * @param {boolean} [isDeep] Specify a deep clone.\n     * @param {Function} [customizer] The function to customize cloning values.\n     * @param {string} [key] The key of `value`.\n     * @param {Object} [object] The object `value` belongs to.\n     * @param {Array} [stackA=[]] Tracks traversed source objects.\n     * @param {Array} [stackB=[]] Associates clones with source counterparts.\n     * @returns {*} Returns the cloned value.\n     */\n    function baseClone(value, isDeep, customizer, key, object, stackA, stackB) {\n      var result;\n      if (customizer) {\n        result = object ? customizer(value, key, object) : customizer(value);\n      }\n      if (result !== undefined) {\n        return result;\n      }\n      if (!isObject(value)) {\n        return value;\n      }\n      var isArr = isArray(value);\n      if (isArr) {\n        result = initCloneArray(value);\n        if (!isDeep) {\n          return arrayCopy(value, result);\n        }\n      } else {\n        var tag = objToString.call(value),\n            isFunc = tag == funcTag;\n\n        if (tag == objectTag || tag == argsTag || (isFunc && !object)) {\n          result = initCloneObject(isFunc ? {} : value);\n          if (!isDeep) {\n            return baseAssign(result, value);\n          }\n        } else {\n          return cloneableTags[tag]\n            ? initCloneByTag(value, tag, isDeep)\n            : (object ? value : {});\n        }\n      }\n      // Check for circular references and return its corresponding clone.\n      stackA || (stackA = []);\n      stackB || (stackB = []);\n\n      var length = stackA.length;\n      while (length--) {\n        if (stackA[length] == value) {\n          return stackB[length];\n        }\n      }\n      // Add the source value to the stack of traversed objects and associate it with its clone.\n      stackA.push(value);\n      stackB.push(result);\n\n      // Recursively populate clone (susceptible to call stack limits).\n      (isArr ? arrayEach : baseForOwn)(value, function(subValue, key) {\n        result[key] = baseClone(subValue, isDeep, customizer, key, value, stackA, stackB);\n      });\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.create` without support for assigning\n     * properties to the created object.\n     *\n     * @private\n     * @param {Object} prototype The object to inherit from.\n     * @returns {Object} Returns the new object.\n     */\n    var baseCreate = (function() {\n      function object() {}\n      return function(prototype) {\n        if (isObject(prototype)) {\n          object.prototype = prototype;\n          var result = new object;\n          object.prototype = undefined;\n        }\n        return result || {};\n      };\n    }());\n\n    /**\n     * The base implementation of `_.delay` and `_.defer` which accepts an index\n     * of where to slice the arguments to provide to `func`.\n     *\n     * @private\n     * @param {Function} func The function to delay.\n     * @param {number} wait The number of milliseconds to delay invocation.\n     * @param {Object} args The arguments provide to `func`.\n     * @returns {number} Returns the timer id.\n     */\n    function baseDelay(func, wait, args) {\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      return setTimeout(function() { func.apply(undefined, args); }, wait);\n    }\n\n    /**\n     * The base implementation of `_.difference` which accepts a single array\n     * of values to exclude.\n     *\n     * @private\n     * @param {Array} array The array to inspect.\n     * @param {Array} values The values to exclude.\n     * @returns {Array} Returns the new array of filtered values.\n     */\n    function baseDifference(array, values) {\n      var length = array ? array.length : 0,\n          result = [];\n\n      if (!length) {\n        return result;\n      }\n      var index = -1,\n          indexOf = getIndexOf(),\n          isCommon = indexOf == baseIndexOf,\n          cache = (isCommon && values.length >= LARGE_ARRAY_SIZE) ? createCache(values) : null,\n          valuesLength = values.length;\n\n      if (cache) {\n        indexOf = cacheIndexOf;\n        isCommon = false;\n        values = cache;\n      }\n      outer:\n      while (++index < length) {\n        var value = array[index];\n\n        if (isCommon && value === value) {\n          var valuesIndex = valuesLength;\n          while (valuesIndex--) {\n            if (values[valuesIndex] === value) {\n              continue outer;\n            }\n          }\n          result.push(value);\n        }\n        else if (indexOf(values, value, 0) < 0) {\n          result.push(value);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.forEach` without support for callback\n     * shorthands and `this` binding.\n     *\n     * @private\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Array|Object|string} Returns `collection`.\n     */\n    var baseEach = createBaseEach(baseForOwn);\n\n    /**\n     * The base implementation of `_.forEachRight` without support for callback\n     * shorthands and `this` binding.\n     *\n     * @private\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Array|Object|string} Returns `collection`.\n     */\n    var baseEachRight = createBaseEach(baseForOwnRight, true);\n\n    /**\n     * The base implementation of `_.every` without support for callback\n     * shorthands and `this` binding.\n     *\n     * @private\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function} predicate The function invoked per iteration.\n     * @returns {boolean} Returns `true` if all elements pass the predicate check,\n     *  else `false`\n     */\n    function baseEvery(collection, predicate) {\n      var result = true;\n      baseEach(collection, function(value, index, collection) {\n        result = !!predicate(value, index, collection);\n        return result;\n      });\n      return result;\n    }\n\n    /**\n     * Gets the extremum value of `collection` invoking `iteratee` for each value\n     * in `collection` to generate the criterion by which the value is ranked.\n     * The `iteratee` is invoked with three arguments: (value, index|key, collection).\n     *\n     * @private\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @param {Function} comparator The function used to compare values.\n     * @param {*} exValue The initial extremum value.\n     * @returns {*} Returns the extremum value.\n     */\n    function baseExtremum(collection, iteratee, comparator, exValue) {\n      var computed = exValue,\n          result = computed;\n\n      baseEach(collection, function(value, index, collection) {\n        var current = +iteratee(value, index, collection);\n        if (comparator(current, computed) || (current === exValue && current === result)) {\n          computed = current;\n          result = value;\n        }\n      });\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.fill` without an iteratee call guard.\n     *\n     * @private\n     * @param {Array} array The array to fill.\n     * @param {*} value The value to fill `array` with.\n     * @param {number} [start=0] The start position.\n     * @param {number} [end=array.length] The end position.\n     * @returns {Array} Returns `array`.\n     */\n    function baseFill(array, value, start, end) {\n      var length = array.length;\n\n      start = start == null ? 0 : (+start || 0);\n      if (start < 0) {\n        start = -start > length ? 0 : (length + start);\n      }\n      end = (end === undefined || end > length) ? length : (+end || 0);\n      if (end < 0) {\n        end += length;\n      }\n      length = start > end ? 0 : (end >>> 0);\n      start >>>= 0;\n\n      while (start < length) {\n        array[start++] = value;\n      }\n      return array;\n    }\n\n    /**\n     * The base implementation of `_.filter` without support for callback\n     * shorthands and `this` binding.\n     *\n     * @private\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function} predicate The function invoked per iteration.\n     * @returns {Array} Returns the new filtered array.\n     */\n    function baseFilter(collection, predicate) {\n      var result = [];\n      baseEach(collection, function(value, index, collection) {\n        if (predicate(value, index, collection)) {\n          result.push(value);\n        }\n      });\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.find`, `_.findLast`, `_.findKey`, and `_.findLastKey`,\n     * without support for callback shorthands and `this` binding, which iterates\n     * over `collection` using the provided `eachFunc`.\n     *\n     * @private\n     * @param {Array|Object|string} collection The collection to search.\n     * @param {Function} predicate The function invoked per iteration.\n     * @param {Function} eachFunc The function to iterate over `collection`.\n     * @param {boolean} [retKey] Specify returning the key of the found element\n     *  instead of the element itself.\n     * @returns {*} Returns the found element or its key, else `undefined`.\n     */\n    function baseFind(collection, predicate, eachFunc, retKey) {\n      var result;\n      eachFunc(collection, function(value, key, collection) {\n        if (predicate(value, key, collection)) {\n          result = retKey ? key : value;\n          return false;\n        }\n      });\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.flatten` with added support for restricting\n     * flattening and specifying the start index.\n     *\n     * @private\n     * @param {Array} array The array to flatten.\n     * @param {boolean} [isDeep] Specify a deep flatten.\n     * @param {boolean} [isStrict] Restrict flattening to arrays-like objects.\n     * @param {Array} [result=[]] The initial result value.\n     * @returns {Array} Returns the new flattened array.\n     */\n    function baseFlatten(array, isDeep, isStrict, result) {\n      result || (result = []);\n\n      var index = -1,\n          length = array.length;\n\n      while (++index < length) {\n        var value = array[index];\n        if (isObjectLike(value) && isArrayLike(value) &&\n            (isStrict || isArray(value) || isArguments(value))) {\n          if (isDeep) {\n            // Recursively flatten arrays (susceptible to call stack limits).\n            baseFlatten(value, isDeep, isStrict, result);\n          } else {\n            arrayPush(result, value);\n          }\n        } else if (!isStrict) {\n          result[result.length] = value;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `baseForIn` and `baseForOwn` which iterates\n     * over `object` properties returned by `keysFunc` invoking `iteratee` for\n     * each property. Iteratee functions may exit iteration early by explicitly\n     * returning `false`.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @param {Function} keysFunc The function to get the keys of `object`.\n     * @returns {Object} Returns `object`.\n     */\n    var baseFor = createBaseFor();\n\n    /**\n     * This function is like `baseFor` except that it iterates over properties\n     * in the opposite order.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @param {Function} keysFunc The function to get the keys of `object`.\n     * @returns {Object} Returns `object`.\n     */\n    var baseForRight = createBaseFor(true);\n\n    /**\n     * The base implementation of `_.forIn` without support for callback\n     * shorthands and `this` binding.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     */\n    function baseForIn(object, iteratee) {\n      return baseFor(object, iteratee, keysIn);\n    }\n\n    /**\n     * The base implementation of `_.forOwn` without support for callback\n     * shorthands and `this` binding.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     */\n    function baseForOwn(object, iteratee) {\n      return baseFor(object, iteratee, keys);\n    }\n\n    /**\n     * The base implementation of `_.forOwnRight` without support for callback\n     * shorthands and `this` binding.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     */\n    function baseForOwnRight(object, iteratee) {\n      return baseForRight(object, iteratee, keys);\n    }\n\n    /**\n     * The base implementation of `_.functions` which creates an array of\n     * `object` function property names filtered from those provided.\n     *\n     * @private\n     * @param {Object} object The object to inspect.\n     * @param {Array} props The property names to filter.\n     * @returns {Array} Returns the new array of filtered property names.\n     */\n    function baseFunctions(object, props) {\n      var index = -1,\n          length = props.length,\n          resIndex = -1,\n          result = [];\n\n      while (++index < length) {\n        var key = props[index];\n        if (isFunction(object[key])) {\n          result[++resIndex] = key;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `get` without support for string paths\n     * and default values.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Array} path The path of the property to get.\n     * @param {string} [pathKey] The key representation of path.\n     * @returns {*} Returns the resolved value.\n     */\n    function baseGet(object, path, pathKey) {\n      if (object == null) {\n        return;\n      }\n      if (pathKey !== undefined && pathKey in toObject(object)) {\n        path = [pathKey];\n      }\n      var index = 0,\n          length = path.length;\n\n      while (object != null && index < length) {\n        object = object[path[index++]];\n      }\n      return (index && index == length) ? object : undefined;\n    }\n\n    /**\n     * The base implementation of `_.isEqual` without support for `this` binding\n     * `customizer` functions.\n     *\n     * @private\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @param {Function} [customizer] The function to customize comparing values.\n     * @param {boolean} [isLoose] Specify performing partial comparisons.\n     * @param {Array} [stackA] Tracks traversed `value` objects.\n     * @param {Array} [stackB] Tracks traversed `other` objects.\n     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n     */\n    function baseIsEqual(value, other, customizer, isLoose, stackA, stackB) {\n      if (value === other) {\n        return true;\n      }\n      if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {\n        return value !== value && other !== other;\n      }\n      return baseIsEqualDeep(value, other, baseIsEqual, customizer, isLoose, stackA, stackB);\n    }\n\n    /**\n     * A specialized version of `baseIsEqual` for arrays and objects which performs\n     * deep comparisons and tracks traversed objects enabling objects with circular\n     * references to be compared.\n     *\n     * @private\n     * @param {Object} object The object to compare.\n     * @param {Object} other The other object to compare.\n     * @param {Function} equalFunc The function to determine equivalents of values.\n     * @param {Function} [customizer] The function to customize comparing objects.\n     * @param {boolean} [isLoose] Specify performing partial comparisons.\n     * @param {Array} [stackA=[]] Tracks traversed `value` objects.\n     * @param {Array} [stackB=[]] Tracks traversed `other` objects.\n     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n     */\n    function baseIsEqualDeep(object, other, equalFunc, customizer, isLoose, stackA, stackB) {\n      var objIsArr = isArray(object),\n          othIsArr = isArray(other),\n          objTag = arrayTag,\n          othTag = arrayTag;\n\n      if (!objIsArr) {\n        objTag = objToString.call(object);\n        if (objTag == argsTag) {\n          objTag = objectTag;\n        } else if (objTag != objectTag) {\n          objIsArr = isTypedArray(object);\n        }\n      }\n      if (!othIsArr) {\n        othTag = objToString.call(other);\n        if (othTag == argsTag) {\n          othTag = objectTag;\n        } else if (othTag != objectTag) {\n          othIsArr = isTypedArray(other);\n        }\n      }\n      var objIsObj = objTag == objectTag,\n          othIsObj = othTag == objectTag,\n          isSameTag = objTag == othTag;\n\n      if (isSameTag && !(objIsArr || objIsObj)) {\n        return equalByTag(object, other, objTag);\n      }\n      if (!isLoose) {\n        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\n            othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\n        if (objIsWrapped || othIsWrapped) {\n          return equalFunc(objIsWrapped ? object.value() : object, othIsWrapped ? other.value() : other, customizer, isLoose, stackA, stackB);\n        }\n      }\n      if (!isSameTag) {\n        return false;\n      }\n      // Assume cyclic values are equal.\n      // For more information on detecting circular references see https://es5.github.io/#JO.\n      stackA || (stackA = []);\n      stackB || (stackB = []);\n\n      var length = stackA.length;\n      while (length--) {\n        if (stackA[length] == object) {\n          return stackB[length] == other;\n        }\n      }\n      // Add `object` and `other` to the stack of traversed objects.\n      stackA.push(object);\n      stackB.push(other);\n\n      var result = (objIsArr ? equalArrays : equalObjects)(object, other, equalFunc, customizer, isLoose, stackA, stackB);\n\n      stackA.pop();\n      stackB.pop();\n\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.isMatch` without support for callback\n     * shorthands and `this` binding.\n     *\n     * @private\n     * @param {Object} object The object to inspect.\n     * @param {Array} matchData The propery names, values, and compare flags to match.\n     * @param {Function} [customizer] The function to customize comparing objects.\n     * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n     */\n    function baseIsMatch(object, matchData, customizer) {\n      var index = matchData.length,\n          length = index,\n          noCustomizer = !customizer;\n\n      if (object == null) {\n        return !length;\n      }\n      object = toObject(object);\n      while (index--) {\n        var data = matchData[index];\n        if ((noCustomizer && data[2])\n              ? data[1] !== object[data[0]]\n              : !(data[0] in object)\n            ) {\n          return false;\n        }\n      }\n      while (++index < length) {\n        data = matchData[index];\n        var key = data[0],\n            objValue = object[key],\n            srcValue = data[1];\n\n        if (noCustomizer && data[2]) {\n          if (objValue === undefined && !(key in object)) {\n            return false;\n          }\n        } else {\n          var result = customizer ? customizer(objValue, srcValue, key) : undefined;\n          if (!(result === undefined ? baseIsEqual(srcValue, objValue, customizer, true) : result)) {\n            return false;\n          }\n        }\n      }\n      return true;\n    }\n\n    /**\n     * The base implementation of `_.map` without support for callback shorthands\n     * and `this` binding.\n     *\n     * @private\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Array} Returns the new mapped array.\n     */\n    function baseMap(collection, iteratee) {\n      var index = -1,\n          result = isArrayLike(collection) ? Array(collection.length) : [];\n\n      baseEach(collection, function(value, key, collection) {\n        result[++index] = iteratee(value, key, collection);\n      });\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.matches` which does not clone `source`.\n     *\n     * @private\n     * @param {Object} source The object of property values to match.\n     * @returns {Function} Returns the new function.\n     */\n    function baseMatches(source) {\n      var matchData = getMatchData(source);\n      if (matchData.length == 1 && matchData[0][2]) {\n        var key = matchData[0][0],\n            value = matchData[0][1];\n\n        return function(object) {\n          if (object == null) {\n            return false;\n          }\n          return object[key] === value && (value !== undefined || (key in toObject(object)));\n        };\n      }\n      return function(object) {\n        return baseIsMatch(object, matchData);\n      };\n    }\n\n    /**\n     * The base implementation of `_.matchesProperty` which does not clone `srcValue`.\n     *\n     * @private\n     * @param {string} path The path of the property to get.\n     * @param {*} srcValue The value to compare.\n     * @returns {Function} Returns the new function.\n     */\n    function baseMatchesProperty(path, srcValue) {\n      var isArr = isArray(path),\n          isCommon = isKey(path) && isStrictComparable(srcValue),\n          pathKey = (path + '');\n\n      path = toPath(path);\n      return function(object) {\n        if (object == null) {\n          return false;\n        }\n        var key = pathKey;\n        object = toObject(object);\n        if ((isArr || !isCommon) && !(key in object)) {\n          object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));\n          if (object == null) {\n            return false;\n          }\n          key = last(path);\n          object = toObject(object);\n        }\n        return object[key] === srcValue\n          ? (srcValue !== undefined || (key in object))\n          : baseIsEqual(srcValue, object[key], undefined, true);\n      };\n    }\n\n    /**\n     * The base implementation of `_.merge` without support for argument juggling,\n     * multiple sources, and `this` binding `customizer` functions.\n     *\n     * @private\n     * @param {Object} object The destination object.\n     * @param {Object} source The source object.\n     * @param {Function} [customizer] The function to customize merged values.\n     * @param {Array} [stackA=[]] Tracks traversed source objects.\n     * @param {Array} [stackB=[]] Associates values with source counterparts.\n     * @returns {Object} Returns `object`.\n     */\n    function baseMerge(object, source, customizer, stackA, stackB) {\n      if (!isObject(object)) {\n        return object;\n      }\n      var isSrcArr = isArrayLike(source) && (isArray(source) || isTypedArray(source)),\n          props = isSrcArr ? undefined : keys(source);\n\n      arrayEach(props || source, function(srcValue, key) {\n        if (props) {\n          key = srcValue;\n          srcValue = source[key];\n        }\n        if (isObjectLike(srcValue)) {\n          stackA || (stackA = []);\n          stackB || (stackB = []);\n          baseMergeDeep(object, source, key, baseMerge, customizer, stackA, stackB);\n        }\n        else {\n          var value = object[key],\n              result = customizer ? customizer(value, srcValue, key, object, source) : undefined,\n              isCommon = result === undefined;\n\n          if (isCommon) {\n            result = srcValue;\n          }\n          if ((result !== undefined || (isSrcArr && !(key in object))) &&\n              (isCommon || (result === result ? (result !== value) : (value === value)))) {\n            object[key] = result;\n          }\n        }\n      });\n      return object;\n    }\n\n    /**\n     * A specialized version of `baseMerge` for arrays and objects which performs\n     * deep merges and tracks traversed objects enabling objects with circular\n     * references to be merged.\n     *\n     * @private\n     * @param {Object} object The destination object.\n     * @param {Object} source The source object.\n     * @param {string} key The key of the value to merge.\n     * @param {Function} mergeFunc The function to merge values.\n     * @param {Function} [customizer] The function to customize merged values.\n     * @param {Array} [stackA=[]] Tracks traversed source objects.\n     * @param {Array} [stackB=[]] Associates values with source counterparts.\n     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n     */\n    function baseMergeDeep(object, source, key, mergeFunc, customizer, stackA, stackB) {\n      var length = stackA.length,\n          srcValue = source[key];\n\n      while (length--) {\n        if (stackA[length] == srcValue) {\n          object[key] = stackB[length];\n          return;\n        }\n      }\n      var value = object[key],\n          result = customizer ? customizer(value, srcValue, key, object, source) : undefined,\n          isCommon = result === undefined;\n\n      if (isCommon) {\n        result = srcValue;\n        if (isArrayLike(srcValue) && (isArray(srcValue) || isTypedArray(srcValue))) {\n          result = isArray(value)\n            ? value\n            : (isArrayLike(value) ? arrayCopy(value) : []);\n        }\n        else if (isPlainObject(srcValue) || isArguments(srcValue)) {\n          result = isArguments(value)\n            ? toPlainObject(value)\n            : (isPlainObject(value) ? value : {});\n        }\n        else {\n          isCommon = false;\n        }\n      }\n      // Add the source value to the stack of traversed objects and associate\n      // it with its merged value.\n      stackA.push(srcValue);\n      stackB.push(result);\n\n      if (isCommon) {\n        // Recursively merge objects and arrays (susceptible to call stack limits).\n        object[key] = mergeFunc(result, srcValue, customizer, stackA, stackB);\n      } else if (result === result ? (result !== value) : (value === value)) {\n        object[key] = result;\n      }\n    }\n\n    /**\n     * The base implementation of `_.property` without support for deep paths.\n     *\n     * @private\n     * @param {string} key The key of the property to get.\n     * @returns {Function} Returns the new function.\n     */\n    function baseProperty(key) {\n      return function(object) {\n        return object == null ? undefined : object[key];\n      };\n    }\n\n    /**\n     * A specialized version of `baseProperty` which supports deep paths.\n     *\n     * @private\n     * @param {Array|string} path The path of the property to get.\n     * @returns {Function} Returns the new function.\n     */\n    function basePropertyDeep(path) {\n      var pathKey = (path + '');\n      path = toPath(path);\n      return function(object) {\n        return baseGet(object, path, pathKey);\n      };\n    }\n\n    /**\n     * The base implementation of `_.pullAt` without support for individual\n     * index arguments and capturing the removed elements.\n     *\n     * @private\n     * @param {Array} array The array to modify.\n     * @param {number[]} indexes The indexes of elements to remove.\n     * @returns {Array} Returns `array`.\n     */\n    function basePullAt(array, indexes) {\n      var length = array ? indexes.length : 0;\n      while (length--) {\n        var index = indexes[length];\n        if (index != previous && isIndex(index)) {\n          var previous = index;\n          splice.call(array, index, 1);\n        }\n      }\n      return array;\n    }\n\n    /**\n     * The base implementation of `_.random` without support for argument juggling\n     * and returning floating-point numbers.\n     *\n     * @private\n     * @param {number} min The minimum possible value.\n     * @param {number} max The maximum possible value.\n     * @returns {number} Returns the random number.\n     */\n    function baseRandom(min, max) {\n      return min + nativeFloor(nativeRandom() * (max - min + 1));\n    }\n\n    /**\n     * The base implementation of `_.reduce` and `_.reduceRight` without support\n     * for callback shorthands and `this` binding, which iterates over `collection`\n     * using the provided `eachFunc`.\n     *\n     * @private\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @param {*} accumulator The initial value.\n     * @param {boolean} initFromCollection Specify using the first or last element\n     *  of `collection` as the initial value.\n     * @param {Function} eachFunc The function to iterate over `collection`.\n     * @returns {*} Returns the accumulated value.\n     */\n    function baseReduce(collection, iteratee, accumulator, initFromCollection, eachFunc) {\n      eachFunc(collection, function(value, index, collection) {\n        accumulator = initFromCollection\n          ? (initFromCollection = false, value)\n          : iteratee(accumulator, value, index, collection);\n      });\n      return accumulator;\n    }\n\n    /**\n     * The base implementation of `setData` without support for hot loop detection.\n     *\n     * @private\n     * @param {Function} func The function to associate metadata with.\n     * @param {*} data The metadata.\n     * @returns {Function} Returns `func`.\n     */\n    var baseSetData = !metaMap ? identity : function(func, data) {\n      metaMap.set(func, data);\n      return func;\n    };\n\n    /**\n     * The base implementation of `_.slice` without an iteratee call guard.\n     *\n     * @private\n     * @param {Array} array The array to slice.\n     * @param {number} [start=0] The start position.\n     * @param {number} [end=array.length] The end position.\n     * @returns {Array} Returns the slice of `array`.\n     */\n    function baseSlice(array, start, end) {\n      var index = -1,\n          length = array.length;\n\n      start = start == null ? 0 : (+start || 0);\n      if (start < 0) {\n        start = -start > length ? 0 : (length + start);\n      }\n      end = (end === undefined || end > length) ? length : (+end || 0);\n      if (end < 0) {\n        end += length;\n      }\n      length = start > end ? 0 : ((end - start) >>> 0);\n      start >>>= 0;\n\n      var result = Array(length);\n      while (++index < length) {\n        result[index] = array[index + start];\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.some` without support for callback shorthands\n     * and `this` binding.\n     *\n     * @private\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function} predicate The function invoked per iteration.\n     * @returns {boolean} Returns `true` if any element passes the predicate check,\n     *  else `false`.\n     */\n    function baseSome(collection, predicate) {\n      var result;\n\n      baseEach(collection, function(value, index, collection) {\n        result = predicate(value, index, collection);\n        return !result;\n      });\n      return !!result;\n    }\n\n    /**\n     * The base implementation of `_.sortBy` which uses `comparer` to define\n     * the sort order of `array` and replaces criteria objects with their\n     * corresponding values.\n     *\n     * @private\n     * @param {Array} array The array to sort.\n     * @param {Function} comparer The function to define sort order.\n     * @returns {Array} Returns `array`.\n     */\n    function baseSortBy(array, comparer) {\n      var length = array.length;\n\n      array.sort(comparer);\n      while (length--) {\n        array[length] = array[length].value;\n      }\n      return array;\n    }\n\n    /**\n     * The base implementation of `_.sortByOrder` without param guards.\n     *\n     * @private\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.\n     * @param {boolean[]} orders The sort orders of `iteratees`.\n     * @returns {Array} Returns the new sorted array.\n     */\n    function baseSortByOrder(collection, iteratees, orders) {\n      var callback = getCallback(),\n          index = -1;\n\n      iteratees = arrayMap(iteratees, function(iteratee) { return callback(iteratee); });\n\n      var result = baseMap(collection, function(value) {\n        var criteria = arrayMap(iteratees, function(iteratee) { return iteratee(value); });\n        return { 'criteria': criteria, 'index': ++index, 'value': value };\n      });\n\n      return baseSortBy(result, function(object, other) {\n        return compareMultiple(object, other, orders);\n      });\n    }\n\n    /**\n     * The base implementation of `_.sum` without support for callback shorthands\n     * and `this` binding.\n     *\n     * @private\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {number} Returns the sum.\n     */\n    function baseSum(collection, iteratee) {\n      var result = 0;\n      baseEach(collection, function(value, index, collection) {\n        result += +iteratee(value, index, collection) || 0;\n      });\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.uniq` without support for callback shorthands\n     * and `this` binding.\n     *\n     * @private\n     * @param {Array} array The array to inspect.\n     * @param {Function} [iteratee] The function invoked per iteration.\n     * @returns {Array} Returns the new duplicate-value-free array.\n     */\n    function baseUniq(array, iteratee) {\n      var index = -1,\n          indexOf = getIndexOf(),\n          length = array.length,\n          isCommon = indexOf == baseIndexOf,\n          isLarge = isCommon && length >= LARGE_ARRAY_SIZE,\n          seen = isLarge ? createCache() : null,\n          result = [];\n\n      if (seen) {\n        indexOf = cacheIndexOf;\n        isCommon = false;\n      } else {\n        isLarge = false;\n        seen = iteratee ? [] : result;\n      }\n      outer:\n      while (++index < length) {\n        var value = array[index],\n            computed = iteratee ? iteratee(value, index, array) : value;\n\n        if (isCommon && value === value) {\n          var seenIndex = seen.length;\n          while (seenIndex--) {\n            if (seen[seenIndex] === computed) {\n              continue outer;\n            }\n          }\n          if (iteratee) {\n            seen.push(computed);\n          }\n          result.push(value);\n        }\n        else if (indexOf(seen, computed, 0) < 0) {\n          if (iteratee || isLarge) {\n            seen.push(computed);\n          }\n          result.push(value);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.values` and `_.valuesIn` which creates an\n     * array of `object` property values corresponding to the property names\n     * of `props`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Array} props The property names to get values for.\n     * @returns {Object} Returns the array of property values.\n     */\n    function baseValues(object, props) {\n      var index = -1,\n          length = props.length,\n          result = Array(length);\n\n      while (++index < length) {\n        result[index] = object[props[index]];\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.dropRightWhile`, `_.dropWhile`, `_.takeRightWhile`,\n     * and `_.takeWhile` without support for callback shorthands and `this` binding.\n     *\n     * @private\n     * @param {Array} array The array to query.\n     * @param {Function} predicate The function invoked per iteration.\n     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Array} Returns the slice of `array`.\n     */\n    function baseWhile(array, predicate, isDrop, fromRight) {\n      var length = array.length,\n          index = fromRight ? length : -1;\n\n      while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {}\n      return isDrop\n        ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))\n        : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));\n    }\n\n    /**\n     * The base implementation of `wrapperValue` which returns the result of\n     * performing a sequence of actions on the unwrapped `value`, where each\n     * successive action is supplied the return value of the previous.\n     *\n     * @private\n     * @param {*} value The unwrapped value.\n     * @param {Array} actions Actions to peform to resolve the unwrapped value.\n     * @returns {*} Returns the resolved value.\n     */\n    function baseWrapperValue(value, actions) {\n      var result = value;\n      if (result instanceof LazyWrapper) {\n        result = result.value();\n      }\n      var index = -1,\n          length = actions.length;\n\n      while (++index < length) {\n        var action = actions[index];\n        result = action.func.apply(action.thisArg, arrayPush([result], action.args));\n      }\n      return result;\n    }\n\n    /**\n     * Performs a binary search of `array` to determine the index at which `value`\n     * should be inserted into `array` in order to maintain its sort order.\n     *\n     * @private\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @param {boolean} [retHighest] Specify returning the highest qualified index.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     */\n    function binaryIndex(array, value, retHighest) {\n      var low = 0,\n          high = array ? array.length : low;\n\n      if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {\n        while (low < high) {\n          var mid = (low + high) >>> 1,\n              computed = array[mid];\n\n          if ((retHighest ? (computed <= value) : (computed < value)) && computed !== null) {\n            low = mid + 1;\n          } else {\n            high = mid;\n          }\n        }\n        return high;\n      }\n      return binaryIndexBy(array, value, identity, retHighest);\n    }\n\n    /**\n     * This function is like `binaryIndex` except that it invokes `iteratee` for\n     * `value` and each element of `array` to compute their sort ranking. The\n     * iteratee is invoked with one argument; (value).\n     *\n     * @private\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @param {boolean} [retHighest] Specify returning the highest qualified index.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     */\n    function binaryIndexBy(array, value, iteratee, retHighest) {\n      value = iteratee(value);\n\n      var low = 0,\n          high = array ? array.length : 0,\n          valIsNaN = value !== value,\n          valIsNull = value === null,\n          valIsUndef = value === undefined;\n\n      while (low < high) {\n        var mid = nativeFloor((low + high) / 2),\n            computed = iteratee(array[mid]),\n            isDef = computed !== undefined,\n            isReflexive = computed === computed;\n\n        if (valIsNaN) {\n          var setLow = isReflexive || retHighest;\n        } else if (valIsNull) {\n          setLow = isReflexive && isDef && (retHighest || computed != null);\n        } else if (valIsUndef) {\n          setLow = isReflexive && (retHighest || isDef);\n        } else if (computed == null) {\n          setLow = false;\n        } else {\n          setLow = retHighest ? (computed <= value) : (computed < value);\n        }\n        if (setLow) {\n          low = mid + 1;\n        } else {\n          high = mid;\n        }\n      }\n      return nativeMin(high, MAX_ARRAY_INDEX);\n    }\n\n    /**\n     * A specialized version of `baseCallback` which only supports `this` binding\n     * and specifying the number of arguments to provide to `func`.\n     *\n     * @private\n     * @param {Function} func The function to bind.\n     * @param {*} thisArg The `this` binding of `func`.\n     * @param {number} [argCount] The number of arguments to provide to `func`.\n     * @returns {Function} Returns the callback.\n     */\n    function bindCallback(func, thisArg, argCount) {\n      if (typeof func != 'function') {\n        return identity;\n      }\n      if (thisArg === undefined) {\n        return func;\n      }\n      switch (argCount) {\n        case 1: return function(value) {\n          return func.call(thisArg, value);\n        };\n        case 3: return function(value, index, collection) {\n          return func.call(thisArg, value, index, collection);\n        };\n        case 4: return function(accumulator, value, index, collection) {\n          return func.call(thisArg, accumulator, value, index, collection);\n        };\n        case 5: return function(value, other, key, object, source) {\n          return func.call(thisArg, value, other, key, object, source);\n        };\n      }\n      return function() {\n        return func.apply(thisArg, arguments);\n      };\n    }\n\n    /**\n     * Creates a clone of the given array buffer.\n     *\n     * @private\n     * @param {ArrayBuffer} buffer The array buffer to clone.\n     * @returns {ArrayBuffer} Returns the cloned array buffer.\n     */\n    function bufferClone(buffer) {\n      var result = new ArrayBuffer(buffer.byteLength),\n          view = new Uint8Array(result);\n\n      view.set(new Uint8Array(buffer));\n      return result;\n    }\n\n    /**\n     * Creates an array that is the composition of partially applied arguments,\n     * placeholders, and provided arguments into a single array of arguments.\n     *\n     * @private\n     * @param {Array|Object} args The provided arguments.\n     * @param {Array} partials The arguments to prepend to those provided.\n     * @param {Array} holders The `partials` placeholder indexes.\n     * @returns {Array} Returns the new array of composed arguments.\n     */\n    function composeArgs(args, partials, holders) {\n      var holdersLength = holders.length,\n          argsIndex = -1,\n          argsLength = nativeMax(args.length - holdersLength, 0),\n          leftIndex = -1,\n          leftLength = partials.length,\n          result = Array(leftLength + argsLength);\n\n      while (++leftIndex < leftLength) {\n        result[leftIndex] = partials[leftIndex];\n      }\n      while (++argsIndex < holdersLength) {\n        result[holders[argsIndex]] = args[argsIndex];\n      }\n      while (argsLength--) {\n        result[leftIndex++] = args[argsIndex++];\n      }\n      return result;\n    }\n\n    /**\n     * This function is like `composeArgs` except that the arguments composition\n     * is tailored for `_.partialRight`.\n     *\n     * @private\n     * @param {Array|Object} args The provided arguments.\n     * @param {Array} partials The arguments to append to those provided.\n     * @param {Array} holders The `partials` placeholder indexes.\n     * @returns {Array} Returns the new array of composed arguments.\n     */\n    function composeArgsRight(args, partials, holders) {\n      var holdersIndex = -1,\n          holdersLength = holders.length,\n          argsIndex = -1,\n          argsLength = nativeMax(args.length - holdersLength, 0),\n          rightIndex = -1,\n          rightLength = partials.length,\n          result = Array(argsLength + rightLength);\n\n      while (++argsIndex < argsLength) {\n        result[argsIndex] = args[argsIndex];\n      }\n      var offset = argsIndex;\n      while (++rightIndex < rightLength) {\n        result[offset + rightIndex] = partials[rightIndex];\n      }\n      while (++holdersIndex < holdersLength) {\n        result[offset + holders[holdersIndex]] = args[argsIndex++];\n      }\n      return result;\n    }\n\n    /**\n     * Creates a `_.countBy`, `_.groupBy`, `_.indexBy`, or `_.partition` function.\n     *\n     * @private\n     * @param {Function} setter The function to set keys and values of the accumulator object.\n     * @param {Function} [initializer] The function to initialize the accumulator object.\n     * @returns {Function} Returns the new aggregator function.\n     */\n    function createAggregator(setter, initializer) {\n      return function(collection, iteratee, thisArg) {\n        var result = initializer ? initializer() : {};\n        iteratee = getCallback(iteratee, thisArg, 3);\n\n        if (isArray(collection)) {\n          var index = -1,\n              length = collection.length;\n\n          while (++index < length) {\n            var value = collection[index];\n            setter(result, value, iteratee(value, index, collection), collection);\n          }\n        } else {\n          baseEach(collection, function(value, key, collection) {\n            setter(result, value, iteratee(value, key, collection), collection);\n          });\n        }\n        return result;\n      };\n    }\n\n    /**\n     * Creates a `_.assign`, `_.defaults`, or `_.merge` function.\n     *\n     * @private\n     * @param {Function} assigner The function to assign values.\n     * @returns {Function} Returns the new assigner function.\n     */\n    function createAssigner(assigner) {\n      return restParam(function(object, sources) {\n        var index = -1,\n            length = object == null ? 0 : sources.length,\n            customizer = length > 2 ? sources[length - 2] : undefined,\n            guard = length > 2 ? sources[2] : undefined,\n            thisArg = length > 1 ? sources[length - 1] : undefined;\n\n        if (typeof customizer == 'function') {\n          customizer = bindCallback(customizer, thisArg, 5);\n          length -= 2;\n        } else {\n          customizer = typeof thisArg == 'function' ? thisArg : undefined;\n          length -= (customizer ? 1 : 0);\n        }\n        if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n          customizer = length < 3 ? undefined : customizer;\n          length = 1;\n        }\n        while (++index < length) {\n          var source = sources[index];\n          if (source) {\n            assigner(object, source, customizer);\n          }\n        }\n        return object;\n      });\n    }\n\n    /**\n     * Creates a `baseEach` or `baseEachRight` function.\n     *\n     * @private\n     * @param {Function} eachFunc The function to iterate over a collection.\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Function} Returns the new base function.\n     */\n    function createBaseEach(eachFunc, fromRight) {\n      return function(collection, iteratee) {\n        var length = collection ? getLength(collection) : 0;\n        if (!isLength(length)) {\n          return eachFunc(collection, iteratee);\n        }\n        var index = fromRight ? length : -1,\n            iterable = toObject(collection);\n\n        while ((fromRight ? index-- : ++index < length)) {\n          if (iteratee(iterable[index], index, iterable) === false) {\n            break;\n          }\n        }\n        return collection;\n      };\n    }\n\n    /**\n     * Creates a base function for `_.forIn` or `_.forInRight`.\n     *\n     * @private\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Function} Returns the new base function.\n     */\n    function createBaseFor(fromRight) {\n      return function(object, iteratee, keysFunc) {\n        var iterable = toObject(object),\n            props = keysFunc(object),\n            length = props.length,\n            index = fromRight ? length : -1;\n\n        while ((fromRight ? index-- : ++index < length)) {\n          var key = props[index];\n          if (iteratee(iterable[key], key, iterable) === false) {\n            break;\n          }\n        }\n        return object;\n      };\n    }\n\n    /**\n     * Creates a function that wraps `func` and invokes it with the `this`\n     * binding of `thisArg`.\n     *\n     * @private\n     * @param {Function} func The function to bind.\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @returns {Function} Returns the new bound function.\n     */\n    function createBindWrapper(func, thisArg) {\n      var Ctor = createCtorWrapper(func);\n\n      function wrapper() {\n        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;\n        return fn.apply(thisArg, arguments);\n      }\n      return wrapper;\n    }\n\n    /**\n     * Creates a `Set` cache object to optimize linear searches of large arrays.\n     *\n     * @private\n     * @param {Array} [values] The values to cache.\n     * @returns {null|Object} Returns the new cache object if `Set` is supported, else `null`.\n     */\n    function createCache(values) {\n      return (nativeCreate && Set) ? new SetCache(values) : null;\n    }\n\n    /**\n     * Creates a function that produces compound words out of the words in a\n     * given string.\n     *\n     * @private\n     * @param {Function} callback The function to combine each word.\n     * @returns {Function} Returns the new compounder function.\n     */\n    function createCompounder(callback) {\n      return function(string) {\n        var index = -1,\n            array = words(deburr(string)),\n            length = array.length,\n            result = '';\n\n        while (++index < length) {\n          result = callback(result, array[index], index);\n        }\n        return result;\n      };\n    }\n\n    /**\n     * Creates a function that produces an instance of `Ctor` regardless of\n     * whether it was invoked as part of a `new` expression or by `call` or `apply`.\n     *\n     * @private\n     * @param {Function} Ctor The constructor to wrap.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createCtorWrapper(Ctor) {\n      return function() {\n        // Use a `switch` statement to work with class constructors.\n        // See http://ecma-international.org/ecma-262/6.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist\n        // for more details.\n        var args = arguments;\n        switch (args.length) {\n          case 0: return new Ctor;\n          case 1: return new Ctor(args[0]);\n          case 2: return new Ctor(args[0], args[1]);\n          case 3: return new Ctor(args[0], args[1], args[2]);\n          case 4: return new Ctor(args[0], args[1], args[2], args[3]);\n          case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);\n          case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);\n          case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);\n        }\n        var thisBinding = baseCreate(Ctor.prototype),\n            result = Ctor.apply(thisBinding, args);\n\n        // Mimic the constructor's `return` behavior.\n        // See https://es5.github.io/#x13.2.2 for more details.\n        return isObject(result) ? result : thisBinding;\n      };\n    }\n\n    /**\n     * Creates a `_.curry` or `_.curryRight` function.\n     *\n     * @private\n     * @param {boolean} flag The curry bit flag.\n     * @returns {Function} Returns the new curry function.\n     */\n    function createCurry(flag) {\n      function curryFunc(func, arity, guard) {\n        if (guard && isIterateeCall(func, arity, guard)) {\n          arity = undefined;\n        }\n        var result = createWrapper(func, flag, undefined, undefined, undefined, undefined, undefined, arity);\n        result.placeholder = curryFunc.placeholder;\n        return result;\n      }\n      return curryFunc;\n    }\n\n    /**\n     * Creates a `_.defaults` or `_.defaultsDeep` function.\n     *\n     * @private\n     * @param {Function} assigner The function to assign values.\n     * @param {Function} customizer The function to customize assigned values.\n     * @returns {Function} Returns the new defaults function.\n     */\n    function createDefaults(assigner, customizer) {\n      return restParam(function(args) {\n        var object = args[0];\n        if (object == null) {\n          return object;\n        }\n        args.push(customizer);\n        return assigner.apply(undefined, args);\n      });\n    }\n\n    /**\n     * Creates a `_.max` or `_.min` function.\n     *\n     * @private\n     * @param {Function} comparator The function used to compare values.\n     * @param {*} exValue The initial extremum value.\n     * @returns {Function} Returns the new extremum function.\n     */\n    function createExtremum(comparator, exValue) {\n      return function(collection, iteratee, thisArg) {\n        if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {\n          iteratee = undefined;\n        }\n        iteratee = getCallback(iteratee, thisArg, 3);\n        if (iteratee.length == 1) {\n          collection = isArray(collection) ? collection : toIterable(collection);\n          var result = arrayExtremum(collection, iteratee, comparator, exValue);\n          if (!(collection.length && result === exValue)) {\n            return result;\n          }\n        }\n        return baseExtremum(collection, iteratee, comparator, exValue);\n      };\n    }\n\n    /**\n     * Creates a `_.find` or `_.findLast` function.\n     *\n     * @private\n     * @param {Function} eachFunc The function to iterate over a collection.\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Function} Returns the new find function.\n     */\n    function createFind(eachFunc, fromRight) {\n      return function(collection, predicate, thisArg) {\n        predicate = getCallback(predicate, thisArg, 3);\n        if (isArray(collection)) {\n          var index = baseFindIndex(collection, predicate, fromRight);\n          return index > -1 ? collection[index] : undefined;\n        }\n        return baseFind(collection, predicate, eachFunc);\n      };\n    }\n\n    /**\n     * Creates a `_.findIndex` or `_.findLastIndex` function.\n     *\n     * @private\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Function} Returns the new find function.\n     */\n    function createFindIndex(fromRight) {\n      return function(array, predicate, thisArg) {\n        if (!(array && array.length)) {\n          return -1;\n        }\n        predicate = getCallback(predicate, thisArg, 3);\n        return baseFindIndex(array, predicate, fromRight);\n      };\n    }\n\n    /**\n     * Creates a `_.findKey` or `_.findLastKey` function.\n     *\n     * @private\n     * @param {Function} objectFunc The function to iterate over an object.\n     * @returns {Function} Returns the new find function.\n     */\n    function createFindKey(objectFunc) {\n      return function(object, predicate, thisArg) {\n        predicate = getCallback(predicate, thisArg, 3);\n        return baseFind(object, predicate, objectFunc, true);\n      };\n    }\n\n    /**\n     * Creates a `_.flow` or `_.flowRight` function.\n     *\n     * @private\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Function} Returns the new flow function.\n     */\n    function createFlow(fromRight) {\n      return function() {\n        var wrapper,\n            length = arguments.length,\n            index = fromRight ? length : -1,\n            leftIndex = 0,\n            funcs = Array(length);\n\n        while ((fromRight ? index-- : ++index < length)) {\n          var func = funcs[leftIndex++] = arguments[index];\n          if (typeof func != 'function') {\n            throw new TypeError(FUNC_ERROR_TEXT);\n          }\n          if (!wrapper && LodashWrapper.prototype.thru && getFuncName(func) == 'wrapper') {\n            wrapper = new LodashWrapper([], true);\n          }\n        }\n        index = wrapper ? -1 : length;\n        while (++index < length) {\n          func = funcs[index];\n\n          var funcName = getFuncName(func),\n              data = funcName == 'wrapper' ? getData(func) : undefined;\n\n          if (data && isLaziable(data[0]) && data[1] == (ARY_FLAG | CURRY_FLAG | PARTIAL_FLAG | REARG_FLAG) && !data[4].length && data[9] == 1) {\n            wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);\n          } else {\n            wrapper = (func.length == 1 && isLaziable(func)) ? wrapper[funcName]() : wrapper.thru(func);\n          }\n        }\n        return function() {\n          var args = arguments,\n              value = args[0];\n\n          if (wrapper && args.length == 1 && isArray(value) && value.length >= LARGE_ARRAY_SIZE) {\n            return wrapper.plant(value).value();\n          }\n          var index = 0,\n              result = length ? funcs[index].apply(this, args) : value;\n\n          while (++index < length) {\n            result = funcs[index].call(this, result);\n          }\n          return result;\n        };\n      };\n    }\n\n    /**\n     * Creates a function for `_.forEach` or `_.forEachRight`.\n     *\n     * @private\n     * @param {Function} arrayFunc The function to iterate over an array.\n     * @param {Function} eachFunc The function to iterate over a collection.\n     * @returns {Function} Returns the new each function.\n     */\n    function createForEach(arrayFunc, eachFunc) {\n      return function(collection, iteratee, thisArg) {\n        return (typeof iteratee == 'function' && thisArg === undefined && isArray(collection))\n          ? arrayFunc(collection, iteratee)\n          : eachFunc(collection, bindCallback(iteratee, thisArg, 3));\n      };\n    }\n\n    /**\n     * Creates a function for `_.forIn` or `_.forInRight`.\n     *\n     * @private\n     * @param {Function} objectFunc The function to iterate over an object.\n     * @returns {Function} Returns the new each function.\n     */\n    function createForIn(objectFunc) {\n      return function(object, iteratee, thisArg) {\n        if (typeof iteratee != 'function' || thisArg !== undefined) {\n          iteratee = bindCallback(iteratee, thisArg, 3);\n        }\n        return objectFunc(object, iteratee, keysIn);\n      };\n    }\n\n    /**\n     * Creates a function for `_.forOwn` or `_.forOwnRight`.\n     *\n     * @private\n     * @param {Function} objectFunc The function to iterate over an object.\n     * @returns {Function} Returns the new each function.\n     */\n    function createForOwn(objectFunc) {\n      return function(object, iteratee, thisArg) {\n        if (typeof iteratee != 'function' || thisArg !== undefined) {\n          iteratee = bindCallback(iteratee, thisArg, 3);\n        }\n        return objectFunc(object, iteratee);\n      };\n    }\n\n    /**\n     * Creates a function for `_.mapKeys` or `_.mapValues`.\n     *\n     * @private\n     * @param {boolean} [isMapKeys] Specify mapping keys instead of values.\n     * @returns {Function} Returns the new map function.\n     */\n    function createObjectMapper(isMapKeys) {\n      return function(object, iteratee, thisArg) {\n        var result = {};\n        iteratee = getCallback(iteratee, thisArg, 3);\n\n        baseForOwn(object, function(value, key, object) {\n          var mapped = iteratee(value, key, object);\n          key = isMapKeys ? mapped : key;\n          value = isMapKeys ? value : mapped;\n          result[key] = value;\n        });\n        return result;\n      };\n    }\n\n    /**\n     * Creates a function for `_.padLeft` or `_.padRight`.\n     *\n     * @private\n     * @param {boolean} [fromRight] Specify padding from the right.\n     * @returns {Function} Returns the new pad function.\n     */\n    function createPadDir(fromRight) {\n      return function(string, length, chars) {\n        string = baseToString(string);\n        return (fromRight ? string : '') + createPadding(string, length, chars) + (fromRight ? '' : string);\n      };\n    }\n\n    /**\n     * Creates a `_.partial` or `_.partialRight` function.\n     *\n     * @private\n     * @param {boolean} flag The partial bit flag.\n     * @returns {Function} Returns the new partial function.\n     */\n    function createPartial(flag) {\n      var partialFunc = restParam(function(func, partials) {\n        var holders = replaceHolders(partials, partialFunc.placeholder);\n        return createWrapper(func, flag, undefined, partials, holders);\n      });\n      return partialFunc;\n    }\n\n    /**\n     * Creates a function for `_.reduce` or `_.reduceRight`.\n     *\n     * @private\n     * @param {Function} arrayFunc The function to iterate over an array.\n     * @param {Function} eachFunc The function to iterate over a collection.\n     * @returns {Function} Returns the new each function.\n     */\n    function createReduce(arrayFunc, eachFunc) {\n      return function(collection, iteratee, accumulator, thisArg) {\n        var initFromArray = arguments.length < 3;\n        return (typeof iteratee == 'function' && thisArg === undefined && isArray(collection))\n          ? arrayFunc(collection, iteratee, accumulator, initFromArray)\n          : baseReduce(collection, getCallback(iteratee, thisArg, 4), accumulator, initFromArray, eachFunc);\n      };\n    }\n\n    /**\n     * Creates a function that wraps `func` and invokes it with optional `this`\n     * binding of, partial application, and currying.\n     *\n     * @private\n     * @param {Function|string} func The function or method name to reference.\n     * @param {number} bitmask The bitmask of flags. See `createWrapper` for more details.\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @param {Array} [partials] The arguments to prepend to those provided to the new function.\n     * @param {Array} [holders] The `partials` placeholder indexes.\n     * @param {Array} [partialsRight] The arguments to append to those provided to the new function.\n     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.\n     * @param {Array} [argPos] The argument positions of the new function.\n     * @param {number} [ary] The arity cap of `func`.\n     * @param {number} [arity] The arity of `func`.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createHybridWrapper(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {\n      var isAry = bitmask & ARY_FLAG,\n          isBind = bitmask & BIND_FLAG,\n          isBindKey = bitmask & BIND_KEY_FLAG,\n          isCurry = bitmask & CURRY_FLAG,\n          isCurryBound = bitmask & CURRY_BOUND_FLAG,\n          isCurryRight = bitmask & CURRY_RIGHT_FLAG,\n          Ctor = isBindKey ? undefined : createCtorWrapper(func);\n\n      function wrapper() {\n        // Avoid `arguments` object use disqualifying optimizations by\n        // converting it to an array before providing it to other functions.\n        var length = arguments.length,\n            index = length,\n            args = Array(length);\n\n        while (index--) {\n          args[index] = arguments[index];\n        }\n        if (partials) {\n          args = composeArgs(args, partials, holders);\n        }\n        if (partialsRight) {\n          args = composeArgsRight(args, partialsRight, holdersRight);\n        }\n        if (isCurry || isCurryRight) {\n          var placeholder = wrapper.placeholder,\n              argsHolders = replaceHolders(args, placeholder);\n\n          length -= argsHolders.length;\n          if (length < arity) {\n            var newArgPos = argPos ? arrayCopy(argPos) : undefined,\n                newArity = nativeMax(arity - length, 0),\n                newsHolders = isCurry ? argsHolders : undefined,\n                newHoldersRight = isCurry ? undefined : argsHolders,\n                newPartials = isCurry ? args : undefined,\n                newPartialsRight = isCurry ? undefined : args;\n\n            bitmask |= (isCurry ? PARTIAL_FLAG : PARTIAL_RIGHT_FLAG);\n            bitmask &= ~(isCurry ? PARTIAL_RIGHT_FLAG : PARTIAL_FLAG);\n\n            if (!isCurryBound) {\n              bitmask &= ~(BIND_FLAG | BIND_KEY_FLAG);\n            }\n            var newData = [func, bitmask, thisArg, newPartials, newsHolders, newPartialsRight, newHoldersRight, newArgPos, ary, newArity],\n                result = createHybridWrapper.apply(undefined, newData);\n\n            if (isLaziable(func)) {\n              setData(result, newData);\n            }\n            result.placeholder = placeholder;\n            return result;\n          }\n        }\n        var thisBinding = isBind ? thisArg : this,\n            fn = isBindKey ? thisBinding[func] : func;\n\n        if (argPos) {\n          args = reorder(args, argPos);\n        }\n        if (isAry && ary < args.length) {\n          args.length = ary;\n        }\n        if (this && this !== root && this instanceof wrapper) {\n          fn = Ctor || createCtorWrapper(func);\n        }\n        return fn.apply(thisBinding, args);\n      }\n      return wrapper;\n    }\n\n    /**\n     * Creates the padding required for `string` based on the given `length`.\n     * The `chars` string is truncated if the number of characters exceeds `length`.\n     *\n     * @private\n     * @param {string} string The string to create padding for.\n     * @param {number} [length=0] The padding length.\n     * @param {string} [chars=' '] The string used as padding.\n     * @returns {string} Returns the pad for `string`.\n     */\n    function createPadding(string, length, chars) {\n      var strLength = string.length;\n      length = +length;\n\n      if (strLength >= length || !nativeIsFinite(length)) {\n        return '';\n      }\n      var padLength = length - strLength;\n      chars = chars == null ? ' ' : (chars + '');\n      return repeat(chars, nativeCeil(padLength / chars.length)).slice(0, padLength);\n    }\n\n    /**\n     * Creates a function that wraps `func` and invokes it with the optional `this`\n     * binding of `thisArg` and the `partials` prepended to those provided to\n     * the wrapper.\n     *\n     * @private\n     * @param {Function} func The function to partially apply arguments to.\n     * @param {number} bitmask The bitmask of flags. See `createWrapper` for more details.\n     * @param {*} thisArg The `this` binding of `func`.\n     * @param {Array} partials The arguments to prepend to those provided to the new function.\n     * @returns {Function} Returns the new bound function.\n     */\n    function createPartialWrapper(func, bitmask, thisArg, partials) {\n      var isBind = bitmask & BIND_FLAG,\n          Ctor = createCtorWrapper(func);\n\n      function wrapper() {\n        // Avoid `arguments` object use disqualifying optimizations by\n        // converting it to an array before providing it `func`.\n        var argsIndex = -1,\n            argsLength = arguments.length,\n            leftIndex = -1,\n            leftLength = partials.length,\n            args = Array(leftLength + argsLength);\n\n        while (++leftIndex < leftLength) {\n          args[leftIndex] = partials[leftIndex];\n        }\n        while (argsLength--) {\n          args[leftIndex++] = arguments[++argsIndex];\n        }\n        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;\n        return fn.apply(isBind ? thisArg : this, args);\n      }\n      return wrapper;\n    }\n\n    /**\n     * Creates a `_.ceil`, `_.floor`, or `_.round` function.\n     *\n     * @private\n     * @param {string} methodName The name of the `Math` method to use when rounding.\n     * @returns {Function} Returns the new round function.\n     */\n    function createRound(methodName) {\n      var func = Math[methodName];\n      return function(number, precision) {\n        precision = precision === undefined ? 0 : (+precision || 0);\n        if (precision) {\n          precision = pow(10, precision);\n          return func(number * precision) / precision;\n        }\n        return func(number);\n      };\n    }\n\n    /**\n     * Creates a `_.sortedIndex` or `_.sortedLastIndex` function.\n     *\n     * @private\n     * @param {boolean} [retHighest] Specify returning the highest qualified index.\n     * @returns {Function} Returns the new index function.\n     */\n    function createSortedIndex(retHighest) {\n      return function(array, value, iteratee, thisArg) {\n        var callback = getCallback(iteratee);\n        return (iteratee == null && callback === baseCallback)\n          ? binaryIndex(array, value, retHighest)\n          : binaryIndexBy(array, value, callback(iteratee, thisArg, 1), retHighest);\n      };\n    }\n\n    /**\n     * Creates a function that either curries or invokes `func` with optional\n     * `this` binding and partially applied arguments.\n     *\n     * @private\n     * @param {Function|string} func The function or method name to reference.\n     * @param {number} bitmask The bitmask of flags.\n     *  The bitmask may be composed of the following flags:\n     *     1 - `_.bind`\n     *     2 - `_.bindKey`\n     *     4 - `_.curry` or `_.curryRight` of a bound function\n     *     8 - `_.curry`\n     *    16 - `_.curryRight`\n     *    32 - `_.partial`\n     *    64 - `_.partialRight`\n     *   128 - `_.rearg`\n     *   256 - `_.ary`\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @param {Array} [partials] The arguments to be partially applied.\n     * @param {Array} [holders] The `partials` placeholder indexes.\n     * @param {Array} [argPos] The argument positions of the new function.\n     * @param {number} [ary] The arity cap of `func`.\n     * @param {number} [arity] The arity of `func`.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createWrapper(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {\n      var isBindKey = bitmask & BIND_KEY_FLAG;\n      if (!isBindKey && typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      var length = partials ? partials.length : 0;\n      if (!length) {\n        bitmask &= ~(PARTIAL_FLAG | PARTIAL_RIGHT_FLAG);\n        partials = holders = undefined;\n      }\n      length -= (holders ? holders.length : 0);\n      if (bitmask & PARTIAL_RIGHT_FLAG) {\n        var partialsRight = partials,\n            holdersRight = holders;\n\n        partials = holders = undefined;\n      }\n      var data = isBindKey ? undefined : getData(func),\n          newData = [func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity];\n\n      if (data) {\n        mergeData(newData, data);\n        bitmask = newData[1];\n        arity = newData[9];\n      }\n      newData[9] = arity == null\n        ? (isBindKey ? 0 : func.length)\n        : (nativeMax(arity - length, 0) || 0);\n\n      if (bitmask == BIND_FLAG) {\n        var result = createBindWrapper(newData[0], newData[2]);\n      } else if ((bitmask == PARTIAL_FLAG || bitmask == (BIND_FLAG | PARTIAL_FLAG)) && !newData[4].length) {\n        result = createPartialWrapper.apply(undefined, newData);\n      } else {\n        result = createHybridWrapper.apply(undefined, newData);\n      }\n      var setter = data ? baseSetData : setData;\n      return setter(result, newData);\n    }\n\n    /**\n     * A specialized version of `baseIsEqualDeep` for arrays with support for\n     * partial deep comparisons.\n     *\n     * @private\n     * @param {Array} array The array to compare.\n     * @param {Array} other The other array to compare.\n     * @param {Function} equalFunc The function to determine equivalents of values.\n     * @param {Function} [customizer] The function to customize comparing arrays.\n     * @param {boolean} [isLoose] Specify performing partial comparisons.\n     * @param {Array} [stackA] Tracks traversed `value` objects.\n     * @param {Array} [stackB] Tracks traversed `other` objects.\n     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n     */\n    function equalArrays(array, other, equalFunc, customizer, isLoose, stackA, stackB) {\n      var index = -1,\n          arrLength = array.length,\n          othLength = other.length;\n\n      if (arrLength != othLength && !(isLoose && othLength > arrLength)) {\n        return false;\n      }\n      // Ignore non-index properties.\n      while (++index < arrLength) {\n        var arrValue = array[index],\n            othValue = other[index],\n            result = customizer ? customizer(isLoose ? othValue : arrValue, isLoose ? arrValue : othValue, index) : undefined;\n\n        if (result !== undefined) {\n          if (result) {\n            continue;\n          }\n          return false;\n        }\n        // Recursively compare arrays (susceptible to call stack limits).\n        if (isLoose) {\n          if (!arraySome(other, function(othValue) {\n                return arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB);\n              })) {\n            return false;\n          }\n        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB))) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    /**\n     * A specialized version of `baseIsEqualDeep` for comparing objects of\n     * the same `toStringTag`.\n     *\n     * **Note:** This function only supports comparing values with tags of\n     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n     *\n     * @private\n     * @param {Object} object The object to compare.\n     * @param {Object} other The other object to compare.\n     * @param {string} tag The `toStringTag` of the objects to compare.\n     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n     */\n    function equalByTag(object, other, tag) {\n      switch (tag) {\n        case boolTag:\n        case dateTag:\n          // Coerce dates and booleans to numbers, dates to milliseconds and booleans\n          // to `1` or `0` treating invalid dates coerced to `NaN` as not equal.\n          return +object == +other;\n\n        case errorTag:\n          return object.name == other.name && object.message == other.message;\n\n        case numberTag:\n          // Treat `NaN` vs. `NaN` as equal.\n          return (object != +object)\n            ? other != +other\n            : object == +other;\n\n        case regexpTag:\n        case stringTag:\n          // Coerce regexes to strings and treat strings primitives and string\n          // objects as equal. See https://es5.github.io/#x15.10.6.4 for more details.\n          return object == (other + '');\n      }\n      return false;\n    }\n\n    /**\n     * A specialized version of `baseIsEqualDeep` for objects with support for\n     * partial deep comparisons.\n     *\n     * @private\n     * @param {Object} object The object to compare.\n     * @param {Object} other The other object to compare.\n     * @param {Function} equalFunc The function to determine equivalents of values.\n     * @param {Function} [customizer] The function to customize comparing values.\n     * @param {boolean} [isLoose] Specify performing partial comparisons.\n     * @param {Array} [stackA] Tracks traversed `value` objects.\n     * @param {Array} [stackB] Tracks traversed `other` objects.\n     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n     */\n    function equalObjects(object, other, equalFunc, customizer, isLoose, stackA, stackB) {\n      var objProps = keys(object),\n          objLength = objProps.length,\n          othProps = keys(other),\n          othLength = othProps.length;\n\n      if (objLength != othLength && !isLoose) {\n        return false;\n      }\n      var index = objLength;\n      while (index--) {\n        var key = objProps[index];\n        if (!(isLoose ? key in other : hasOwnProperty.call(other, key))) {\n          return false;\n        }\n      }\n      var skipCtor = isLoose;\n      while (++index < objLength) {\n        key = objProps[index];\n        var objValue = object[key],\n            othValue = other[key],\n            result = customizer ? customizer(isLoose ? othValue : objValue, isLoose? objValue : othValue, key) : undefined;\n\n        // Recursively compare objects (susceptible to call stack limits).\n        if (!(result === undefined ? equalFunc(objValue, othValue, customizer, isLoose, stackA, stackB) : result)) {\n          return false;\n        }\n        skipCtor || (skipCtor = key == 'constructor');\n      }\n      if (!skipCtor) {\n        var objCtor = object.constructor,\n            othCtor = other.constructor;\n\n        // Non `Object` object instances with different constructors are not equal.\n        if (objCtor != othCtor &&\n            ('constructor' in object && 'constructor' in other) &&\n            !(typeof objCtor == 'function' && objCtor instanceof objCtor &&\n              typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    /**\n     * Gets the appropriate \"callback\" function. If the `_.callback` method is\n     * customized this function returns the custom method, otherwise it returns\n     * the `baseCallback` function. If arguments are provided the chosen function\n     * is invoked with them and its result is returned.\n     *\n     * @private\n     * @returns {Function} Returns the chosen function or its result.\n     */\n    function getCallback(func, thisArg, argCount) {\n      var result = lodash.callback || callback;\n      result = result === callback ? baseCallback : result;\n      return argCount ? result(func, thisArg, argCount) : result;\n    }\n\n    /**\n     * Gets metadata for `func`.\n     *\n     * @private\n     * @param {Function} func The function to query.\n     * @returns {*} Returns the metadata for `func`.\n     */\n    var getData = !metaMap ? noop : function(func) {\n      return metaMap.get(func);\n    };\n\n    /**\n     * Gets the name of `func`.\n     *\n     * @private\n     * @param {Function} func The function to query.\n     * @returns {string} Returns the function name.\n     */\n    function getFuncName(func) {\n      var result = func.name,\n          array = realNames[result],\n          length = array ? array.length : 0;\n\n      while (length--) {\n        var data = array[length],\n            otherFunc = data.func;\n        if (otherFunc == null || otherFunc == func) {\n          return data.name;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Gets the appropriate \"indexOf\" function. If the `_.indexOf` method is\n     * customized this function returns the custom method, otherwise it returns\n     * the `baseIndexOf` function. If arguments are provided the chosen function\n     * is invoked with them and its result is returned.\n     *\n     * @private\n     * @returns {Function|number} Returns the chosen function or its result.\n     */\n    function getIndexOf(collection, target, fromIndex) {\n      var result = lodash.indexOf || indexOf;\n      result = result === indexOf ? baseIndexOf : result;\n      return collection ? result(collection, target, fromIndex) : result;\n    }\n\n    /**\n     * Gets the \"length\" property value of `object`.\n     *\n     * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)\n     * that affects Safari on at least iOS 8.1-8.3 ARM64.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {*} Returns the \"length\" value.\n     */\n    var getLength = baseProperty('length');\n\n    /**\n     * Gets the propery names, values, and compare flags of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the match data of `object`.\n     */\n    function getMatchData(object) {\n      var result = pairs(object),\n          length = result.length;\n\n      while (length--) {\n        result[length][2] = isStrictComparable(result[length][1]);\n      }\n      return result;\n    }\n\n    /**\n     * Gets the native function at `key` of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {string} key The key of the method to get.\n     * @returns {*} Returns the function if it's native, else `undefined`.\n     */\n    function getNative(object, key) {\n      var value = object == null ? undefined : object[key];\n      return isNative(value) ? value : undefined;\n    }\n\n    /**\n     * Gets the view, applying any `transforms` to the `start` and `end` positions.\n     *\n     * @private\n     * @param {number} start The start of the view.\n     * @param {number} end The end of the view.\n     * @param {Array} transforms The transformations to apply to the view.\n     * @returns {Object} Returns an object containing the `start` and `end`\n     *  positions of the view.\n     */\n    function getView(start, end, transforms) {\n      var index = -1,\n          length = transforms.length;\n\n      while (++index < length) {\n        var data = transforms[index],\n            size = data.size;\n\n        switch (data.type) {\n          case 'drop':      start += size; break;\n          case 'dropRight': end -= size; break;\n          case 'take':      end = nativeMin(end, start + size); break;\n          case 'takeRight': start = nativeMax(start, end - size); break;\n        }\n      }\n      return { 'start': start, 'end': end };\n    }\n\n    /**\n     * Initializes an array clone.\n     *\n     * @private\n     * @param {Array} array The array to clone.\n     * @returns {Array} Returns the initialized clone.\n     */\n    function initCloneArray(array) {\n      var length = array.length,\n          result = new array.constructor(length);\n\n      // Add array properties assigned by `RegExp#exec`.\n      if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {\n        result.index = array.index;\n        result.input = array.input;\n      }\n      return result;\n    }\n\n    /**\n     * Initializes an object clone.\n     *\n     * @private\n     * @param {Object} object The object to clone.\n     * @returns {Object} Returns the initialized clone.\n     */\n    function initCloneObject(object) {\n      var Ctor = object.constructor;\n      if (!(typeof Ctor == 'function' && Ctor instanceof Ctor)) {\n        Ctor = Object;\n      }\n      return new Ctor;\n    }\n\n    /**\n     * Initializes an object clone based on its `toStringTag`.\n     *\n     * **Note:** This function only supports cloning values with tags of\n     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n     *\n     * @private\n     * @param {Object} object The object to clone.\n     * @param {string} tag The `toStringTag` of the object to clone.\n     * @param {boolean} [isDeep] Specify a deep clone.\n     * @returns {Object} Returns the initialized clone.\n     */\n    function initCloneByTag(object, tag, isDeep) {\n      var Ctor = object.constructor;\n      switch (tag) {\n        case arrayBufferTag:\n          return bufferClone(object);\n\n        case boolTag:\n        case dateTag:\n          return new Ctor(+object);\n\n        case float32Tag: case float64Tag:\n        case int8Tag: case int16Tag: case int32Tag:\n        case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:\n          var buffer = object.buffer;\n          return new Ctor(isDeep ? bufferClone(buffer) : buffer, object.byteOffset, object.length);\n\n        case numberTag:\n        case stringTag:\n          return new Ctor(object);\n\n        case regexpTag:\n          var result = new Ctor(object.source, reFlags.exec(object));\n          result.lastIndex = object.lastIndex;\n      }\n      return result;\n    }\n\n    /**\n     * Invokes the method at `path` on `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path of the method to invoke.\n     * @param {Array} args The arguments to invoke the method with.\n     * @returns {*} Returns the result of the invoked method.\n     */\n    function invokePath(object, path, args) {\n      if (object != null && !isKey(path, object)) {\n        path = toPath(path);\n        object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));\n        path = last(path);\n      }\n      var func = object == null ? object : object[path];\n      return func == null ? undefined : func.apply(object, args);\n    }\n\n    /**\n     * Checks if `value` is array-like.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n     */\n    function isArrayLike(value) {\n      return value != null && isLength(getLength(value));\n    }\n\n    /**\n     * Checks if `value` is a valid array-like index.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n     */\n    function isIndex(value, length) {\n      value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;\n      length = length == null ? MAX_SAFE_INTEGER : length;\n      return value > -1 && value % 1 == 0 && value < length;\n    }\n\n    /**\n     * Checks if the provided arguments are from an iteratee call.\n     *\n     * @private\n     * @param {*} value The potential iteratee value argument.\n     * @param {*} index The potential iteratee index or key argument.\n     * @param {*} object The potential iteratee object argument.\n     * @returns {boolean} Returns `true` if the arguments are from an iteratee call, else `false`.\n     */\n    function isIterateeCall(value, index, object) {\n      if (!isObject(object)) {\n        return false;\n      }\n      var type = typeof index;\n      if (type == 'number'\n          ? (isArrayLike(object) && isIndex(index, object.length))\n          : (type == 'string' && index in object)) {\n        var other = object[index];\n        return value === value ? (value === other) : (other !== other);\n      }\n      return false;\n    }\n\n    /**\n     * Checks if `value` is a property name and not a property path.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @param {Object} [object] The object to query keys on.\n     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n     */\n    function isKey(value, object) {\n      var type = typeof value;\n      if ((type == 'string' && reIsPlainProp.test(value)) || type == 'number') {\n        return true;\n      }\n      if (isArray(value)) {\n        return false;\n      }\n      var result = !reIsDeepProp.test(value);\n      return result || (object != null && value in toObject(object));\n    }\n\n    /**\n     * Checks if `func` has a lazy counterpart.\n     *\n     * @private\n     * @param {Function} func The function to check.\n     * @returns {boolean} Returns `true` if `func` has a lazy counterpart, else `false`.\n     */\n    function isLaziable(func) {\n      var funcName = getFuncName(func);\n      if (!(funcName in LazyWrapper.prototype)) {\n        return false;\n      }\n      var other = lodash[funcName];\n      if (func === other) {\n        return true;\n      }\n      var data = getData(other);\n      return !!data && func === data[0];\n    }\n\n    /**\n     * Checks if `value` is a valid array-like length.\n     *\n     * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n     */\n    function isLength(value) {\n      return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n    }\n\n    /**\n     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` if suitable for strict\n     *  equality comparisons, else `false`.\n     */\n    function isStrictComparable(value) {\n      return value === value && !isObject(value);\n    }\n\n    /**\n     * Merges the function metadata of `source` into `data`.\n     *\n     * Merging metadata reduces the number of wrappers required to invoke a function.\n     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`\n     * may be applied regardless of execution order. Methods like `_.ary` and `_.rearg`\n     * augment function arguments, making the order in which they are executed important,\n     * preventing the merging of metadata. However, we make an exception for a safe\n     * common case where curried functions have `_.ary` and or `_.rearg` applied.\n     *\n     * @private\n     * @param {Array} data The destination metadata.\n     * @param {Array} source The source metadata.\n     * @returns {Array} Returns `data`.\n     */\n    function mergeData(data, source) {\n      var bitmask = data[1],\n          srcBitmask = source[1],\n          newBitmask = bitmask | srcBitmask,\n          isCommon = newBitmask < ARY_FLAG;\n\n      var isCombo =\n        (srcBitmask == ARY_FLAG && bitmask == CURRY_FLAG) ||\n        (srcBitmask == ARY_FLAG && bitmask == REARG_FLAG && data[7].length <= source[8]) ||\n        (srcBitmask == (ARY_FLAG | REARG_FLAG) && bitmask == CURRY_FLAG);\n\n      // Exit early if metadata can't be merged.\n      if (!(isCommon || isCombo)) {\n        return data;\n      }\n      // Use source `thisArg` if available.\n      if (srcBitmask & BIND_FLAG) {\n        data[2] = source[2];\n        // Set when currying a bound function.\n        newBitmask |= (bitmask & BIND_FLAG) ? 0 : CURRY_BOUND_FLAG;\n      }\n      // Compose partial arguments.\n      var value = source[3];\n      if (value) {\n        var partials = data[3];\n        data[3] = partials ? composeArgs(partials, value, source[4]) : arrayCopy(value);\n        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : arrayCopy(source[4]);\n      }\n      // Compose partial right arguments.\n      value = source[5];\n      if (value) {\n        partials = data[5];\n        data[5] = partials ? composeArgsRight(partials, value, source[6]) : arrayCopy(value);\n        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : arrayCopy(source[6]);\n      }\n      // Use source `argPos` if available.\n      value = source[7];\n      if (value) {\n        data[7] = arrayCopy(value);\n      }\n      // Use source `ary` if it's smaller.\n      if (srcBitmask & ARY_FLAG) {\n        data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);\n      }\n      // Use source `arity` if one is not provided.\n      if (data[9] == null) {\n        data[9] = source[9];\n      }\n      // Use source `func` and merge bitmasks.\n      data[0] = source[0];\n      data[1] = newBitmask;\n\n      return data;\n    }\n\n    /**\n     * Used by `_.defaultsDeep` to customize its `_.merge` use.\n     *\n     * @private\n     * @param {*} objectValue The destination object property value.\n     * @param {*} sourceValue The source object property value.\n     * @returns {*} Returns the value to assign to the destination object.\n     */\n    function mergeDefaults(objectValue, sourceValue) {\n      return objectValue === undefined ? sourceValue : merge(objectValue, sourceValue, mergeDefaults);\n    }\n\n    /**\n     * A specialized version of `_.pick` which picks `object` properties specified\n     * by `props`.\n     *\n     * @private\n     * @param {Object} object The source object.\n     * @param {string[]} props The property names to pick.\n     * @returns {Object} Returns the new object.\n     */\n    function pickByArray(object, props) {\n      object = toObject(object);\n\n      var index = -1,\n          length = props.length,\n          result = {};\n\n      while (++index < length) {\n        var key = props[index];\n        if (key in object) {\n          result[key] = object[key];\n        }\n      }\n      return result;\n    }\n\n    /**\n     * A specialized version of `_.pick` which picks `object` properties `predicate`\n     * returns truthy for.\n     *\n     * @private\n     * @param {Object} object The source object.\n     * @param {Function} predicate The function invoked per iteration.\n     * @returns {Object} Returns the new object.\n     */\n    function pickByCallback(object, predicate) {\n      var result = {};\n      baseForIn(object, function(value, key, object) {\n        if (predicate(value, key, object)) {\n          result[key] = value;\n        }\n      });\n      return result;\n    }\n\n    /**\n     * Reorder `array` according to the specified indexes where the element at\n     * the first index is assigned as the first element, the element at\n     * the second index is assigned as the second element, and so on.\n     *\n     * @private\n     * @param {Array} array The array to reorder.\n     * @param {Array} indexes The arranged array indexes.\n     * @returns {Array} Returns `array`.\n     */\n    function reorder(array, indexes) {\n      var arrLength = array.length,\n          length = nativeMin(indexes.length, arrLength),\n          oldArray = arrayCopy(array);\n\n      while (length--) {\n        var index = indexes[length];\n        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;\n      }\n      return array;\n    }\n\n    /**\n     * Sets metadata for `func`.\n     *\n     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short\n     * period of time, it will trip its breaker and transition to an identity function\n     * to avoid garbage collection pauses in V8. See [V8 issue 2070](https://code.google.com/p/v8/issues/detail?id=2070)\n     * for more details.\n     *\n     * @private\n     * @param {Function} func The function to associate metadata with.\n     * @param {*} data The metadata.\n     * @returns {Function} Returns `func`.\n     */\n    var setData = (function() {\n      var count = 0,\n          lastCalled = 0;\n\n      return function(key, value) {\n        var stamp = now(),\n            remaining = HOT_SPAN - (stamp - lastCalled);\n\n        lastCalled = stamp;\n        if (remaining > 0) {\n          if (++count >= HOT_COUNT) {\n            return key;\n          }\n        } else {\n          count = 0;\n        }\n        return baseSetData(key, value);\n      };\n    }());\n\n    /**\n     * A fallback implementation of `Object.keys` which creates an array of the\n     * own enumerable property names of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names.\n     */\n    function shimKeys(object) {\n      var props = keysIn(object),\n          propsLength = props.length,\n          length = propsLength && object.length;\n\n      var allowIndexes = !!length && isLength(length) &&\n        (isArray(object) || isArguments(object));\n\n      var index = -1,\n          result = [];\n\n      while (++index < propsLength) {\n        var key = props[index];\n        if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {\n          result.push(key);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Converts `value` to an array-like object if it's not one.\n     *\n     * @private\n     * @param {*} value The value to process.\n     * @returns {Array|Object} Returns the array-like object.\n     */\n    function toIterable(value) {\n      if (value == null) {\n        return [];\n      }\n      if (!isArrayLike(value)) {\n        return values(value);\n      }\n      return isObject(value) ? value : Object(value);\n    }\n\n    /**\n     * Converts `value` to an object if it's not one.\n     *\n     * @private\n     * @param {*} value The value to process.\n     * @returns {Object} Returns the object.\n     */\n    function toObject(value) {\n      return isObject(value) ? value : Object(value);\n    }\n\n    /**\n     * Converts `value` to property path array if it's not one.\n     *\n     * @private\n     * @param {*} value The value to process.\n     * @returns {Array} Returns the property path array.\n     */\n    function toPath(value) {\n      if (isArray(value)) {\n        return value;\n      }\n      var result = [];\n      baseToString(value).replace(rePropName, function(match, number, quote, string) {\n        result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));\n      });\n      return result;\n    }\n\n    /**\n     * Creates a clone of `wrapper`.\n     *\n     * @private\n     * @param {Object} wrapper The wrapper to clone.\n     * @returns {Object} Returns the cloned wrapper.\n     */\n    function wrapperClone(wrapper) {\n      return wrapper instanceof LazyWrapper\n        ? wrapper.clone()\n        : new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__, arrayCopy(wrapper.__actions__));\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates an array of elements split into groups the length of `size`.\n     * If `collection` can't be split evenly, the final chunk will be the remaining\n     * elements.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to process.\n     * @param {number} [size=1] The length of each chunk.\n     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n     * @returns {Array} Returns the new array containing chunks.\n     * @example\n     *\n     * _.chunk(['a', 'b', 'c', 'd'], 2);\n     * // => [['a', 'b'], ['c', 'd']]\n     *\n     * _.chunk(['a', 'b', 'c', 'd'], 3);\n     * // => [['a', 'b', 'c'], ['d']]\n     */\n    function chunk(array, size, guard) {\n      if (guard ? isIterateeCall(array, size, guard) : size == null) {\n        size = 1;\n      } else {\n        size = nativeMax(nativeFloor(size) || 1, 1);\n      }\n      var index = 0,\n          length = array ? array.length : 0,\n          resIndex = -1,\n          result = Array(nativeCeil(length / size));\n\n      while (index < length) {\n        result[++resIndex] = baseSlice(array, index, (index += size));\n      }\n      return result;\n    }\n\n    /**\n     * Creates an array with all falsey values removed. The values `false`, `null`,\n     * `0`, `\"\"`, `undefined`, and `NaN` are falsey.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to compact.\n     * @returns {Array} Returns the new array of filtered values.\n     * @example\n     *\n     * _.compact([0, 1, false, 2, '', 3]);\n     * // => [1, 2, 3]\n     */\n    function compact(array) {\n      var index = -1,\n          length = array ? array.length : 0,\n          resIndex = -1,\n          result = [];\n\n      while (++index < length) {\n        var value = array[index];\n        if (value) {\n          result[++resIndex] = value;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Creates an array of unique `array` values not included in the other\n     * provided arrays using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)\n     * for equality comparisons.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {...Array} [values] The arrays of values to exclude.\n     * @returns {Array} Returns the new array of filtered values.\n     * @example\n     *\n     * _.difference([1, 2, 3], [4, 2]);\n     * // => [1, 3]\n     */\n    var difference = restParam(function(array, values) {\n      return (isObjectLike(array) && isArrayLike(array))\n        ? baseDifference(array, baseFlatten(values, false, true))\n        : [];\n    });\n\n    /**\n     * Creates a slice of `array` with `n` elements dropped from the beginning.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {number} [n=1] The number of elements to drop.\n     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.drop([1, 2, 3]);\n     * // => [2, 3]\n     *\n     * _.drop([1, 2, 3], 2);\n     * // => [3]\n     *\n     * _.drop([1, 2, 3], 5);\n     * // => []\n     *\n     * _.drop([1, 2, 3], 0);\n     * // => [1, 2, 3]\n     */\n    function drop(array, n, guard) {\n      var length = array ? array.length : 0;\n      if (!length) {\n        return [];\n      }\n      if (guard ? isIterateeCall(array, n, guard) : n == null) {\n        n = 1;\n      }\n      return baseSlice(array, n < 0 ? 0 : n);\n    }\n\n    /**\n     * Creates a slice of `array` with `n` elements dropped from the end.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {number} [n=1] The number of elements to drop.\n     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.dropRight([1, 2, 3]);\n     * // => [1, 2]\n     *\n     * _.dropRight([1, 2, 3], 2);\n     * // => [1]\n     *\n     * _.dropRight([1, 2, 3], 5);\n     * // => []\n     *\n     * _.dropRight([1, 2, 3], 0);\n     * // => [1, 2, 3]\n     */\n    function dropRight(array, n, guard) {\n      var length = array ? array.length : 0;\n      if (!length) {\n        return [];\n      }\n      if (guard ? isIterateeCall(array, n, guard) : n == null) {\n        n = 1;\n      }\n      n = length - (+n || 0);\n      return baseSlice(array, 0, n < 0 ? 0 : n);\n    }\n\n    /**\n     * Creates a slice of `array` excluding elements dropped from the end.\n     * Elements are dropped until `predicate` returns falsey. The predicate is\n     * bound to `thisArg` and invoked with three arguments: (value, index, array).\n     *\n     * If a property name is provided for `predicate` the created `_.property`\n     * style callback returns the property value of the given element.\n     *\n     * If a value is also provided for `thisArg` the created `_.matchesProperty`\n     * style callback returns `true` for elements that have a matching property\n     * value, else `false`.\n     *\n     * If an object is provided for `predicate` the created `_.matches` style\n     * callback returns `true` for elements that match the properties of the given\n     * object, else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {Function|Object|string} [predicate=_.identity] The function invoked\n     *  per iteration.\n     * @param {*} [thisArg] The `this` binding of `predicate`.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.dropRightWhile([1, 2, 3], function(n) {\n     *   return n > 1;\n     * });\n     * // => [1]\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': true },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': false }\n     * ];\n     *\n     * // using the `_.matches` callback shorthand\n     * _.pluck(_.dropRightWhile(users, { 'user': 'pebbles', 'active': false }), 'user');\n     * // => ['barney', 'fred']\n     *\n     * // using the `_.matchesProperty` callback shorthand\n     * _.pluck(_.dropRightWhile(users, 'active', false), 'user');\n     * // => ['barney']\n     *\n     * // using the `_.property` callback shorthand\n     * _.pluck(_.dropRightWhile(users, 'active'), 'user');\n     * // => ['barney', 'fred', 'pebbles']\n     */\n    function dropRightWhile(array, predicate, thisArg) {\n      return (array && array.length)\n        ? baseWhile(array, getCallback(predicate, thisArg, 3), true, true)\n        : [];\n    }\n\n    /**\n     * Creates a slice of `array` excluding elements dropped from the beginning.\n     * Elements are dropped until `predicate` returns falsey. The predicate is\n     * bound to `thisArg` and invoked with three arguments: (value, index, array).\n     *\n     * If a property name is provided for `predicate` the created `_.property`\n     * style callback returns the property value of the given element.\n     *\n     * If a value is also provided for `thisArg` the created `_.matchesProperty`\n     * style callback returns `true` for elements that have a matching property\n     * value, else `false`.\n     *\n     * If an object is provided for `predicate` the created `_.matches` style\n     * callback returns `true` for elements that have the properties of the given\n     * object, else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {Function|Object|string} [predicate=_.identity] The function invoked\n     *  per iteration.\n     * @param {*} [thisArg] The `this` binding of `predicate`.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.dropWhile([1, 2, 3], function(n) {\n     *   return n < 3;\n     * });\n     * // => [3]\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': false },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': true }\n     * ];\n     *\n     * // using the `_.matches` callback shorthand\n     * _.pluck(_.dropWhile(users, { 'user': 'barney', 'active': false }), 'user');\n     * // => ['fred', 'pebbles']\n     *\n     * // using the `_.matchesProperty` callback shorthand\n     * _.pluck(_.dropWhile(users, 'active', false), 'user');\n     * // => ['pebbles']\n     *\n     * // using the `_.property` callback shorthand\n     * _.pluck(_.dropWhile(users, 'active'), 'user');\n     * // => ['barney', 'fred', 'pebbles']\n     */\n    function dropWhile(array, predicate, thisArg) {\n      return (array && array.length)\n        ? baseWhile(array, getCallback(predicate, thisArg, 3), true)\n        : [];\n    }\n\n    /**\n     * Fills elements of `array` with `value` from `start` up to, but not\n     * including, `end`.\n     *\n     * **Note:** This method mutates `array`.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to fill.\n     * @param {*} value The value to fill `array` with.\n     * @param {number} [start=0] The start position.\n     * @param {number} [end=array.length] The end position.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = [1, 2, 3];\n     *\n     * _.fill(array, 'a');\n     * console.log(array);\n     * // => ['a', 'a', 'a']\n     *\n     * _.fill(Array(3), 2);\n     * // => [2, 2, 2]\n     *\n     * _.fill([4, 6, 8], '*', 1, 2);\n     * // => [4, '*', 8]\n     */\n    function fill(array, value, start, end) {\n      var length = array ? array.length : 0;\n      if (!length) {\n        return [];\n      }\n      if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {\n        start = 0;\n        end = length;\n      }\n      return baseFill(array, value, start, end);\n    }\n\n    /**\n     * This method is like `_.find` except that it returns the index of the first\n     * element `predicate` returns truthy for instead of the element itself.\n     *\n     * If a property name is provided for `predicate` the created `_.property`\n     * style callback returns the property value of the given element.\n     *\n     * If a value is also provided for `thisArg` the created `_.matchesProperty`\n     * style callback returns `true` for elements that have a matching property\n     * value, else `false`.\n     *\n     * If an object is provided for `predicate` the created `_.matches` style\n     * callback returns `true` for elements that have the properties of the given\n     * object, else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to search.\n     * @param {Function|Object|string} [predicate=_.identity] The function invoked\n     *  per iteration.\n     * @param {*} [thisArg] The `this` binding of `predicate`.\n     * @returns {number} Returns the index of the found element, else `-1`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': false },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': true }\n     * ];\n     *\n     * _.findIndex(users, function(chr) {\n     *   return chr.user == 'barney';\n     * });\n     * // => 0\n     *\n     * // using the `_.matches` callback shorthand\n     * _.findIndex(users, { 'user': 'fred', 'active': false });\n     * // => 1\n     *\n     * // using the `_.matchesProperty` callback shorthand\n     * _.findIndex(users, 'active', false);\n     * // => 0\n     *\n     * // using the `_.property` callback shorthand\n     * _.findIndex(users, 'active');\n     * // => 2\n     */\n    var findIndex = createFindIndex();\n\n    /**\n     * This method is like `_.findIndex` except that it iterates over elements\n     * of `collection` from right to left.\n     *\n     * If a property name is provided for `predicate` the created `_.property`\n     * style callback returns the property value of the given element.\n     *\n     * If a value is also provided for `thisArg` the created `_.matchesProperty`\n     * style callback returns `true` for elements that have a matching property\n     * value, else `false`.\n     *\n     * If an object is provided for `predicate` the created `_.matches` style\n     * callback returns `true` for elements that have the properties of the given\n     * object, else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to search.\n     * @param {Function|Object|string} [predicate=_.identity] The function invoked\n     *  per iteration.\n     * @param {*} [thisArg] The `this` binding of `predicate`.\n     * @returns {number} Returns the index of the found element, else `-1`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': true },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': false }\n     * ];\n     *\n     * _.findLastIndex(users, function(chr) {\n     *   return chr.user == 'pebbles';\n     * });\n     * // => 2\n     *\n     * // using the `_.matches` callback shorthand\n     * _.findLastIndex(users, { 'user': 'barney', 'active': true });\n     * // => 0\n     *\n     * // using the `_.matchesProperty` callback shorthand\n     * _.findLastIndex(users, 'active', false);\n     * // => 2\n     *\n     * // using the `_.property` callback shorthand\n     * _.findLastIndex(users, 'active');\n     * // => 0\n     */\n    var findLastIndex = createFindIndex(true);\n\n    /**\n     * Gets the first element of `array`.\n     *\n     * @static\n     * @memberOf _\n     * @alias head\n     * @category Array\n     * @param {Array} array The array to query.\n     * @returns {*} Returns the first element of `array`.\n     * @example\n     *\n     * _.first([1, 2, 3]);\n     * // => 1\n     *\n     * _.first([]);\n     * // => undefined\n     */\n    function first(array) {\n      return array ? array[0] : undefined;\n    }\n\n    /**\n     * Flattens a nested array. If `isDeep` is `true` the array is recursively\n     * flattened, otherwise it is only flattened a single level.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to flatten.\n     * @param {boolean} [isDeep] Specify a deep flatten.\n     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * _.flatten([1, [2, 3, [4]]]);\n     * // => [1, 2, 3, [4]]\n     *\n     * // using `isDeep`\n     * _.flatten([1, [2, 3, [4]]], true);\n     * // => [1, 2, 3, 4]\n     */\n    function flatten(array, isDeep, guard) {\n      var length = array ? array.length : 0;\n      if (guard && isIterateeCall(array, isDeep, guard)) {\n        isDeep = false;\n      }\n      return length ? baseFlatten(array, isDeep) : [];\n    }\n\n    /**\n     * Recursively flattens a nested array.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to recursively flatten.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * _.flattenDeep([1, [2, 3, [4]]]);\n     * // => [1, 2, 3, 4]\n     */\n    function flattenDeep(array) {\n      var length = array ? array.length : 0;\n      return length ? baseFlatten(array, true) : [];\n    }\n\n    /**\n     * Gets the index at which the first occurrence of `value` is found in `array`\n     * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)\n     * for equality comparisons. If `fromIndex` is negative, it is used as the offset\n     * from the end of `array`. If `array` is sorted providing `true` for `fromIndex`\n     * performs a faster binary search.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to search.\n     * @param {*} value The value to search for.\n     * @param {boolean|number} [fromIndex=0] The index to search from or `true`\n     *  to perform a binary search on a sorted array.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     * @example\n     *\n     * _.indexOf([1, 2, 1, 2], 2);\n     * // => 1\n     *\n     * // using `fromIndex`\n     * _.indexOf([1, 2, 1, 2], 2, 2);\n     * // => 3\n     *\n     * // performing a binary search\n     * _.indexOf([1, 1, 2, 2], 2, true);\n     * // => 2\n     */\n    function indexOf(array, value, fromIndex) {\n      var length = array ? array.length : 0;\n      if (!length) {\n        return -1;\n      }\n      if (typeof fromIndex == 'number') {\n        fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : fromIndex;\n      } else if (fromIndex) {\n        var index = binaryIndex(array, value);\n        if (index < length &&\n            (value === value ? (value === array[index]) : (array[index] !== array[index]))) {\n          return index;\n        }\n        return -1;\n      }\n      return baseIndexOf(array, value, fromIndex || 0);\n    }\n\n    /**\n     * Gets all but the last element of `array`.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to query.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.initial([1, 2, 3]);\n     * // => [1, 2]\n     */\n    function initial(array) {\n      return dropRight(array, 1);\n    }\n\n    /**\n     * Creates an array of unique values that are included in all of the provided\n     * arrays using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)\n     * for equality comparisons.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @returns {Array} Returns the new array of shared values.\n     * @example\n     * _.intersection([1, 2], [4, 2], [2, 1]);\n     * // => [2]\n     */\n    var intersection = restParam(function(arrays) {\n      var othLength = arrays.length,\n          othIndex = othLength,\n          caches = Array(length),\n          indexOf = getIndexOf(),\n          isCommon = indexOf == baseIndexOf,\n          result = [];\n\n      while (othIndex--) {\n        var value = arrays[othIndex] = isArrayLike(value = arrays[othIndex]) ? value : [];\n        caches[othIndex] = (isCommon && value.length >= 120) ? createCache(othIndex && value) : null;\n      }\n      var array = arrays[0],\n          index = -1,\n          length = array ? array.length : 0,\n          seen = caches[0];\n\n      outer:\n      while (++index < length) {\n        value = array[index];\n        if ((seen ? cacheIndexOf(seen, value) : indexOf(result, value, 0)) < 0) {\n          var othIndex = othLength;\n          while (--othIndex) {\n            var cache = caches[othIndex];\n            if ((cache ? cacheIndexOf(cache, value) : indexOf(arrays[othIndex], value, 0)) < 0) {\n              continue outer;\n            }\n          }\n          if (seen) {\n            seen.push(value);\n          }\n          result.push(value);\n        }\n      }\n      return result;\n    });\n\n    /**\n     * Gets the last element of `array`.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to query.\n     * @returns {*} Returns the last element of `array`.\n     * @example\n     *\n     * _.last([1, 2, 3]);\n     * // => 3\n     */\n    function last(array) {\n      var length = array ? array.length : 0;\n      return length ? array[length - 1] : undefined;\n    }\n\n    /**\n     * This method is like `_.indexOf` except that it iterates over elements of\n     * `array` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to search.\n     * @param {*} value The value to search for.\n     * @param {boolean|number} [fromIndex=array.length-1] The index to search from\n     *  or `true` to perform a binary search on a sorted array.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     * @example\n     *\n     * _.lastIndexOf([1, 2, 1, 2], 2);\n     * // => 3\n     *\n     * // using `fromIndex`\n     * _.lastIndexOf([1, 2, 1, 2], 2, 2);\n     * // => 1\n     *\n     * // performing a binary search\n     * _.lastIndexOf([1, 1, 2, 2], 2, true);\n     * // => 3\n     */\n    function lastIndexOf(array, value, fromIndex) {\n      var length = array ? array.length : 0;\n      if (!length) {\n        return -1;\n      }\n      var index = length;\n      if (typeof fromIndex == 'number') {\n        index = (fromIndex < 0 ? nativeMax(length + fromIndex, 0) : nativeMin(fromIndex || 0, length - 1)) + 1;\n      } else if (fromIndex) {\n        index = binaryIndex(array, value, true) - 1;\n        var other = array[index];\n        if (value === value ? (value === other) : (other !== other)) {\n          return index;\n        }\n        return -1;\n      }\n      if (value !== value) {\n        return indexOfNaN(array, index, true);\n      }\n      while (index--) {\n        if (array[index] === value) {\n          return index;\n        }\n      }\n      return -1;\n    }\n\n    /**\n     * Removes all provided values from `array` using\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)\n     * for equality comparisons.\n     *\n     * **Note:** Unlike `_.without`, this method mutates `array`.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {...*} [values] The values to remove.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = [1, 2, 3, 1, 2, 3];\n     *\n     * _.pull(array, 2, 3);\n     * console.log(array);\n     * // => [1, 1]\n     */\n    function pull() {\n      var args = arguments,\n          array = args[0];\n\n      if (!(array && array.length)) {\n        return array;\n      }\n      var index = 0,\n          indexOf = getIndexOf(),\n          length = args.length;\n\n      while (++index < length) {\n        var fromIndex = 0,\n            value = args[index];\n\n        while ((fromIndex = indexOf(array, value, fromIndex)) > -1) {\n          splice.call(array, fromIndex, 1);\n        }\n      }\n      return array;\n    }\n\n    /**\n     * Removes elements from `array` corresponding to the given indexes and returns\n     * an array of the removed elements. Indexes may be specified as an array of\n     * indexes or as individual arguments.\n     *\n     * **Note:** Unlike `_.at`, this method mutates `array`.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {...(number|number[])} [indexes] The indexes of elements to remove,\n     *  specified as individual indexes or arrays of indexes.\n     * @returns {Array} Returns the new array of removed elements.\n     * @example\n     *\n     * var array = [5, 10, 15, 20];\n     * var evens = _.pullAt(array, 1, 3);\n     *\n     * console.log(array);\n     * // => [5, 15]\n     *\n     * console.log(evens);\n     * // => [10, 20]\n     */\n    var pullAt = restParam(function(array, indexes) {\n      indexes = baseFlatten(indexes);\n\n      var result = baseAt(array, indexes);\n      basePullAt(array, indexes.sort(baseCompareAscending));\n      return result;\n    });\n\n    /**\n     * Removes all elements from `array` that `predicate` returns truthy for\n     * and returns an array of the removed elements. The predicate is bound to\n     * `thisArg` and invoked with three arguments: (value, index, array).\n     *\n     * If a property name is provided for `predicate` the created `_.property`\n     * style callback returns the property value of the given element.\n     *\n     * If a value is also provided for `thisArg` the created `_.matchesProperty`\n     * style callback returns `true` for elements that have a matching property\n     * value, else `false`.\n     *\n     * If an object is provided for `predicate` the created `_.matches` style\n     * callback returns `true` for elements that have the properties of the given\n     * object, else `false`.\n     *\n     * **Note:** Unlike `_.filter`, this method mutates `array`.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {Function|Object|string} [predicate=_.identity] The function invoked\n     *  per iteration.\n     * @param {*} [thisArg] The `this` binding of `predicate`.\n     * @returns {Array} Returns the new array of removed elements.\n     * @example\n     *\n     * var array = [1, 2, 3, 4];\n     * var evens = _.remove(array, function(n) {\n     *   return n % 2 == 0;\n     * });\n     *\n     * console.log(array);\n     * // => [1, 3]\n     *\n     * console.log(evens);\n     * // => [2, 4]\n     */\n    function remove(array, predicate, thisArg) {\n      var result = [];\n      if (!(array && array.length)) {\n        return result;\n      }\n      var index = -1,\n          indexes = [],\n          length = array.length;\n\n      predicate = getCallback(predicate, thisArg, 3);\n      while (++index < length) {\n        var value = array[index];\n        if (predicate(value, index, array)) {\n          result.push(value);\n          indexes.push(index);\n        }\n      }\n      basePullAt(array, indexes);\n      return result;\n    }\n\n    /**\n     * Gets all but the first element of `array`.\n     *\n     * @static\n     * @memberOf _\n     * @alias tail\n     * @category Array\n     * @param {Array} array The array to query.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.rest([1, 2, 3]);\n     * // => [2, 3]\n     */\n    function rest(array) {\n      return drop(array, 1);\n    }\n\n    /**\n     * Creates a slice of `array` from `start` up to, but not including, `end`.\n     *\n     * **Note:** This method is used instead of `Array#slice` to support node\n     * lists in IE < 9 and to ensure dense arrays are returned.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to slice.\n     * @param {number} [start=0] The start position.\n     * @param {number} [end=array.length] The end position.\n     * @returns {Array} Returns the slice of `array`.\n     */\n    function slice(array, start, end) {\n      var length = array ? array.length : 0;\n      if (!length) {\n        return [];\n      }\n      if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {\n        start = 0;\n        end = length;\n      }\n      return baseSlice(array, start, end);\n    }\n\n    /**\n     * Uses a binary search to determine the lowest index at which `value` should\n     * be inserted into `array` in order to maintain its sort order. If an iteratee\n     * function is provided it is invoked for `value` and each element of `array`\n     * to compute their sort ranking. The iteratee is bound to `thisArg` and\n     * invoked with one argument; (value).\n     *\n     * If a property name is provided for `iteratee` the created `_.property`\n     * style callback returns the property value of the given element.\n     *\n     * If a value is also provided for `thisArg` the created `_.matchesProperty`\n     * style callback returns `true` for elements that have a matching property\n     * value, else `false`.\n     *\n     * If an object is provided for `iteratee` the created `_.matches` style\n     * callback returns `true` for elements that have the properties of the given\n     * object, else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @param {Function|Object|string} [iteratee=_.identity] The function invoked\n     *  per iteration.\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     * @example\n     *\n     * _.sortedIndex([30, 50], 40);\n     * // => 1\n     *\n     * _.sortedIndex([4, 4, 5, 5], 5);\n     * // => 2\n     *\n     * var dict = { 'data': { 'thirty': 30, 'forty': 40, 'fifty': 50 } };\n     *\n     * // using an iteratee function\n     * _.sortedIndex(['thirty', 'fifty'], 'forty', function(word) {\n     *   return this.data[word];\n     * }, dict);\n     * // => 1\n     *\n     * // using the `_.property` callback shorthand\n     * _.sortedIndex([{ 'x': 30 }, { 'x': 50 }], { 'x': 40 }, 'x');\n     * // => 1\n     */\n    var sortedIndex = createSortedIndex();\n\n    /**\n     * This method is like `_.sortedIndex` except that it returns the highest\n     * index at which `value` should be inserted into `array` in order to\n     * maintain its sort order.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @param {Function|Object|string} [iteratee=_.identity] The function invoked\n     *  per iteration.\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     * @example\n     *\n     * _.sortedLastIndex([4, 4, 5, 5], 5);\n     * // => 4\n     */\n    var sortedLastIndex = createSortedIndex(true);\n\n    /**\n     * Creates a slice of `array` with `n` elements taken from the beginning.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {number} [n=1] The number of elements to take.\n     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.take([1, 2, 3]);\n     * // => [1]\n     *\n     * _.take([1, 2, 3], 2);\n     * // => [1, 2]\n     *\n     * _.take([1, 2, 3], 5);\n     * // => [1, 2, 3]\n     *\n     * _.take([1, 2, 3], 0);\n     * // => []\n     */\n    function take(array, n, guard) {\n      var length = array ? array.length : 0;\n      if (!length) {\n        return [];\n      }\n      if (guard ? isIterateeCall(array, n, guard) : n == null) {\n        n = 1;\n      }\n      return baseSlice(array, 0, n < 0 ? 0 : n);\n    }\n\n    /**\n     * Creates a slice of `array` with `n` elements taken from the end.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {number} [n=1] The number of elements to take.\n     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.takeRight([1, 2, 3]);\n     * // => [3]\n     *\n     * _.takeRight([1, 2, 3], 2);\n     * // => [2, 3]\n     *\n     * _.takeRight([1, 2, 3], 5);\n     * // => [1, 2, 3]\n     *\n     * _.takeRight([1, 2, 3], 0);\n     * // => []\n     */\n    function takeRight(array, n, guard) {\n      var length = array ? array.length : 0;\n      if (!length) {\n        return [];\n      }\n      if (guard ? isIterateeCall(array, n, guard) : n == null) {\n        n = 1;\n      }\n      n = length - (+n || 0);\n      return baseSlice(array, n < 0 ? 0 : n);\n    }\n\n    /**\n     * Creates a slice of `array` with elements taken from the end. Elements are\n     * taken until `predicate` returns falsey. The predicate is bound to `thisArg`\n     * and invoked with three arguments: (value, index, array).\n     *\n     * If a property name is provided for `predicate` the created `_.property`\n     * style callback returns the property value of the given element.\n     *\n     * If a value is also provided for `thisArg` the created `_.matchesProperty`\n     * style callback returns `true` for elements that have a matching property\n     * value, else `false`.\n     *\n     * If an object is provided for `predicate` the created `_.matches` style\n     * callback returns `true` for elements that have the properties of the given\n     * object, else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {Function|Object|string} [predicate=_.identity] The function invoked\n     *  per iteration.\n     * @param {*} [thisArg] The `this` binding of `predicate`.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.takeRightWhile([1, 2, 3], function(n) {\n     *   return n > 1;\n     * });\n     * // => [2, 3]\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': true },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': false }\n     * ];\n     *\n     * // using the `_.matches` callback shorthand\n     * _.pluck(_.takeRightWhile(users, { 'user': 'pebbles', 'active': false }), 'user');\n     * // => ['pebbles']\n     *\n     * // using the `_.matchesProperty` callback shorthand\n     * _.pluck(_.takeRightWhile(users, 'active', false), 'user');\n     * // => ['fred', 'pebbles']\n     *\n     * // using the `_.property` callback shorthand\n     * _.pluck(_.takeRightWhile(users, 'active'), 'user');\n     * // => []\n     */\n    function takeRightWhile(array, predicate, thisArg) {\n      return (array && array.length)\n        ? baseWhile(array, getCallback(predicate, thisArg, 3), false, true)\n        : [];\n    }\n\n    /**\n     * Creates a slice of `array` with elements taken from the beginning. Elements\n     * are taken until `predicate` returns falsey. The predicate is bound to\n     * `thisArg` and invoked with three arguments: (value, index, array).\n     *\n     * If a property name is provided for `predicate` the created `_.property`\n     * style callback returns the property value of the given element.\n     *\n     * If a value is also provided for `thisArg` the created `_.matchesProperty`\n     * style callback returns `true` for elements that have a matching property\n     * value, else `false`.\n     *\n     * If an object is provided for `predicate` the created `_.matches` style\n     * callback returns `true` for elements that have the properties of the given\n     * object, else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {Function|Object|string} [predicate=_.identity] The function invoked\n     *  per iteration.\n     * @param {*} [thisArg] The `this` binding of `predicate`.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.takeWhile([1, 2, 3], function(n) {\n     *   return n < 3;\n     * });\n     * // => [1, 2]\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': false },\n     *   { 'user': 'fred',    'active': false},\n     *   { 'user': 'pebbles', 'active': true }\n     * ];\n     *\n     * // using the `_.matches` callback shorthand\n     * _.pluck(_.takeWhile(users, { 'user': 'barney', 'active': false }), 'user');\n     * // => ['barney']\n     *\n     * // using the `_.matchesProperty` callback shorthand\n     * _.pluck(_.takeWhile(users, 'active', false), 'user');\n     * // => ['barney', 'fred']\n     *\n     * // using the `_.property` callback shorthand\n     * _.pluck(_.takeWhile(users, 'active'), 'user');\n     * // => []\n     */\n    function takeWhile(array, predicate, thisArg) {\n      return (array && array.length)\n        ? baseWhile(array, getCallback(predicate, thisArg, 3))\n        : [];\n    }\n\n    /**\n     * Creates an array of unique values, in order, from all of the provided arrays\n     * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)\n     * for equality comparisons.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @returns {Array} Returns the new array of combined values.\n     * @example\n     *\n     * _.union([1, 2], [4, 2], [2, 1]);\n     * // => [1, 2, 4]\n     */\n    var union = restParam(function(arrays) {\n      return baseUniq(baseFlatten(arrays, false, true));\n    });\n\n    /**\n     * Creates a duplicate-free version of an array, using\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)\n     * for equality comparisons, in which only the first occurence of each element\n     * is kept. Providing `true` for `isSorted` performs a faster search algorithm\n     * for sorted arrays. If an iteratee function is provided it is invoked for\n     * each element in the array to generate the criterion by which uniqueness\n     * is computed. The `iteratee` is bound to `thisArg` and invoked with three\n     * arguments: (value, index, array).\n     *\n     * If a property name is provided for `iteratee` the created `_.property`\n     * style callback returns the property value of the given element.\n     *\n     * If a value is also provided for `thisArg` the created `_.matchesProperty`\n     * style callback returns `true` for elements that have a matching property\n     * value, else `false`.\n     *\n     * If an object is provided for `iteratee` the created `_.matches` style\n     * callback returns `true` for elements that have the properties of the given\n     * object, else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @alias unique\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {boolean} [isSorted] Specify the array is sorted.\n     * @param {Function|Object|string} [iteratee] The function invoked per iteration.\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\n     * @returns {Array} Returns the new duplicate-value-free array.\n     * @example\n     *\n     * _.uniq([2, 1, 2]);\n     * // => [2, 1]\n     *\n     * // using `isSorted`\n     * _.uniq([1, 1, 2], true);\n     * // => [1, 2]\n     *\n     * // using an iteratee function\n     * _.uniq([1, 2.5, 1.5, 2], function(n) {\n     *   return this.floor(n);\n     * }, Math);\n     * // => [1, 2.5]\n     *\n     * // using the `_.property` callback shorthand\n     * _.uniq([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');\n     * // => [{ 'x': 1 }, { 'x': 2 }]\n     */\n    function uniq(array, isSorted, iteratee, thisArg) {\n      var length = array ? array.length : 0;\n      if (!length) {\n        return [];\n      }\n      if (isSorted != null && typeof isSorted != 'boolean') {\n        thisArg = iteratee;\n        iteratee = isIterateeCall(array, isSorted, thisArg) ? undefined : isSorted;\n        isSorted = false;\n      }\n      var callback = getCallback();\n      if (!(iteratee == null && callback === baseCallback)) {\n        iteratee = callback(iteratee, thisArg, 3);\n      }\n      return (isSorted && getIndexOf() == baseIndexOf)\n        ? sortedUniq(array, iteratee)\n        : baseUniq(array, iteratee);\n    }\n\n    /**\n     * This method is like `_.zip` except that it accepts an array of grouped\n     * elements and creates an array regrouping the elements to their pre-zip\n     * configuration.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array of grouped elements to process.\n     * @returns {Array} Returns the new array of regrouped elements.\n     * @example\n     *\n     * var zipped = _.zip(['fred', 'barney'], [30, 40], [true, false]);\n     * // => [['fred', 30, true], ['barney', 40, false]]\n     *\n     * _.unzip(zipped);\n     * // => [['fred', 'barney'], [30, 40], [true, false]]\n     */\n    function unzip(array) {\n      if (!(array && array.length)) {\n        return [];\n      }\n      var index = -1,\n          length = 0;\n\n      array = arrayFilter(array, function(group) {\n        if (isArrayLike(group)) {\n          length = nativeMax(group.length, length);\n          return true;\n        }\n      });\n      var result = Array(length);\n      while (++index < length) {\n        result[index] = arrayMap(array, baseProperty(index));\n      }\n      return result;\n    }\n\n    /**\n     * This method is like `_.unzip` except that it accepts an iteratee to specify\n     * how regrouped values should be combined. The `iteratee` is bound to `thisArg`\n     * and invoked with four arguments: (accumulator, value, index, group).\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array of grouped elements to process.\n     * @param {Function} [iteratee] The function to combine regrouped values.\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\n     * @returns {Array} Returns the new array of regrouped elements.\n     * @example\n     *\n     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);\n     * // => [[1, 10, 100], [2, 20, 200]]\n     *\n     * _.unzipWith(zipped, _.add);\n     * // => [3, 30, 300]\n     */\n    function unzipWith(array, iteratee, thisArg) {\n      var length = array ? array.length : 0;\n      if (!length) {\n        return [];\n      }\n      var result = unzip(array);\n      if (iteratee == null) {\n        return result;\n      }\n      iteratee = bindCallback(iteratee, thisArg, 4);\n      return arrayMap(result, function(group) {\n        return arrayReduce(group, iteratee, undefined, true);\n      });\n    }\n\n    /**\n     * Creates an array excluding all provided values using\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)\n     * for equality comparisons.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to filter.\n     * @param {...*} [values] The values to exclude.\n     * @returns {Array} Returns the new array of filtered values.\n     * @example\n     *\n     * _.without([1, 2, 1, 3], 1, 2);\n     * // => [3]\n     */\n    var without = restParam(function(array, values) {\n      return isArrayLike(array)\n        ? baseDifference(array, values)\n        : [];\n    });\n\n    /**\n     * Creates an array of unique values that is the [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)\n     * of the provided arrays.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @returns {Array} Returns the new array of values.\n     * @example\n     *\n     * _.xor([1, 2], [4, 2]);\n     * // => [1, 4]\n     */\n    function xor() {\n      var index = -1,\n          length = arguments.length;\n\n      while (++index < length) {\n        var array = arguments[index];\n        if (isArrayLike(array)) {\n          var result = result\n            ? arrayPush(baseDifference(result, array), baseDifference(array, result))\n            : array;\n        }\n      }\n      return result ? baseUniq(result) : [];\n    }\n\n    /**\n     * Creates an array of grouped elements, the first of which contains the first\n     * elements of the given arrays, the second of which contains the second elements\n     * of the given arrays, and so on.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {...Array} [arrays] The arrays to process.\n     * @returns {Array} Returns the new array of grouped elements.\n     * @example\n     *\n     * _.zip(['fred', 'barney'], [30, 40], [true, false]);\n     * // => [['fred', 30, true], ['barney', 40, false]]\n     */\n    var zip = restParam(unzip);\n\n    /**\n     * The inverse of `_.pairs`; this method returns an object composed from arrays\n     * of property names and values. Provide either a single two dimensional array,\n     * e.g. `[[key1, value1], [key2, value2]]` or two arrays, one of property names\n     * and one of corresponding values.\n     *\n     * @static\n     * @memberOf _\n     * @alias object\n     * @category Array\n     * @param {Array} props The property names.\n     * @param {Array} [values=[]] The property values.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * _.zipObject([['fred', 30], ['barney', 40]]);\n     * // => { 'fred': 30, 'barney': 40 }\n     *\n     * _.zipObject(['fred', 'barney'], [30, 40]);\n     * // => { 'fred': 30, 'barney': 40 }\n     */\n    function zipObject(props, values) {\n      var index = -1,\n          length = props ? props.length : 0,\n          result = {};\n\n      if (length && !values && !isArray(props[0])) {\n        values = [];\n      }\n      while (++index < length) {\n        var key = props[index];\n        if (values) {\n          result[key] = values[index];\n        } else if (key) {\n          result[key[0]] = key[1];\n        }\n      }\n      return result;\n    }\n\n    /**\n     * This method is like `_.zip` except that it accepts an iteratee to specify\n     * how grouped values should be combined. The `iteratee` is bound to `thisArg`\n     * and invoked with four arguments: (accumulator, value, index, group).\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {...Array} [arrays] The arrays to process.\n     * @param {Function} [iteratee] The function to combine grouped values.\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\n     * @returns {Array} Returns the new array of grouped elements.\n     * @example\n     *\n     * _.zipWith([1, 2], [10, 20], [100, 200], _.add);\n     * // => [111, 222]\n     */\n    var zipWith = restParam(function(arrays) {\n      var length = arrays.length,\n          iteratee = length > 2 ? arrays[length - 2] : undefined,\n          thisArg = length > 1 ? arrays[length - 1] : undefined;\n\n      if (length > 2 && typeof iteratee == 'function') {\n        length -= 2;\n      } else {\n        iteratee = (length > 1 && typeof thisArg == 'function') ? (--length, thisArg) : undefined;\n        thisArg = undefined;\n      }\n      arrays.length = length;\n      return unzipWith(arrays, iteratee, thisArg);\n    });\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a `lodash` object that wraps `value` with explicit method\n     * chaining enabled.\n     *\n     * @static\n     * @memberOf _\n     * @category Chain\n     * @param {*} value The value to wrap.\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'age': 36 },\n     *   { 'user': 'fred',    'age': 40 },\n     *   { 'user': 'pebbles', 'age': 1 }\n     * ];\n     *\n     * var youngest = _.chain(users)\n     *   .sortBy('age')\n     *   .map(function(chr) {\n     *     return chr.user + ' is ' + chr.age;\n     *   })\n     *   .first()\n     *   .value();\n     * // => 'pebbles is 1'\n     */\n    function chain(value) {\n      var result = lodash(value);\n      result.__chain__ = true;\n      return result;\n    }\n\n    /**\n     * This method invokes `interceptor` and returns `value`. The interceptor is\n     * bound to `thisArg` and invoked with one argument; (value). The purpose of\n     * this method is to \"tap into\" a method chain in order to perform operations\n     * on intermediate results within the chain.\n     *\n     * @static\n     * @memberOf _\n     * @category Chain\n     * @param {*} value The value to provide to `interceptor`.\n     * @param {Function} interceptor The function to invoke.\n     * @param {*} [thisArg] The `this` binding of `interceptor`.\n     * @returns {*} Returns `value`.\n     * @example\n     *\n     * _([1, 2, 3])\n     *  .tap(function(array) {\n     *    array.pop();\n     *  })\n     *  .reverse()\n     *  .value();\n     * // => [2, 1]\n     */\n    function tap(value, interceptor, thisArg) {\n      interceptor.call(thisArg, value);\n      return value;\n    }\n\n    /**\n     * This method is like `_.tap` except that it returns the result of `interceptor`.\n     *\n     * @static\n     * @memberOf _\n     * @category Chain\n     * @param {*} value The value to provide to `interceptor`.\n     * @param {Function} interceptor The function to invoke.\n     * @param {*} [thisArg] The `this` binding of `interceptor`.\n     * @returns {*} Returns the result of `interceptor`.\n     * @example\n     *\n     * _('  abc  ')\n     *  .chain()\n     *  .trim()\n     *  .thru(function(value) {\n     *    return [value];\n     *  })\n     *  .value();\n     * // => ['abc']\n     */\n    function thru(value, interceptor, thisArg) {\n      return interceptor.call(thisArg, value);\n    }\n\n    /**\n     * Enables explicit method chaining on the wrapper object.\n     *\n     * @name chain\n     * @memberOf _\n     * @category Chain\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36 },\n     *   { 'user': 'fred',   'age': 40 }\n     * ];\n     *\n     * // without explicit chaining\n     * _(users).first();\n     * // => { 'user': 'barney', 'age': 36 }\n     *\n     * // with explicit chaining\n     * _(users).chain()\n     *   .first()\n     *   .pick('user')\n     *   .value();\n     * // => { 'user': 'barney' }\n     */\n    function wrapperChain() {\n      return chain(this);\n    }\n\n    /**\n     * Executes the chained sequence and returns the wrapped result.\n     *\n     * @name commit\n     * @memberOf _\n     * @category Chain\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var array = [1, 2];\n     * var wrapped = _(array).push(3);\n     *\n     * console.log(array);\n     * // => [1, 2]\n     *\n     * wrapped = wrapped.commit();\n     * console.log(array);\n     * // => [1, 2, 3]\n     *\n     * wrapped.last();\n     * // => 3\n     *\n     * console.log(array);\n     * // => [1, 2, 3]\n     */\n    function wrapperCommit() {\n      return new LodashWrapper(this.value(), this.__chain__);\n    }\n\n    /**\n     * Creates a new array joining a wrapped array with any additional arrays\n     * and/or values.\n     *\n     * @name concat\n     * @memberOf _\n     * @category Chain\n     * @param {...*} [values] The values to concatenate.\n     * @returns {Array} Returns the new concatenated array.\n     * @example\n     *\n     * var array = [1];\n     * var wrapped = _(array).concat(2, [3], [[4]]);\n     *\n     * console.log(wrapped.value());\n     * // => [1, 2, 3, [4]]\n     *\n     * console.log(array);\n     * // => [1]\n     */\n    var wrapperConcat = restParam(function(values) {\n      values = baseFlatten(values);\n      return this.thru(function(array) {\n        return arrayConcat(isArray(array) ? array : [toObject(array)], values);\n      });\n    });\n\n    /**\n     * Creates a clone of the chained sequence planting `value` as the wrapped value.\n     *\n     * @name plant\n     * @memberOf _\n     * @category Chain\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var array = [1, 2];\n     * var wrapped = _(array).map(function(value) {\n     *   return Math.pow(value, 2);\n     * });\n     *\n     * var other = [3, 4];\n     * var otherWrapped = wrapped.plant(other);\n     *\n     * otherWrapped.value();\n     * // => [9, 16]\n     *\n     * wrapped.value();\n     * // => [1, 4]\n     */\n    function wrapperPlant(value) {\n      var result,\n          parent = this;\n\n      while (parent instanceof baseLodash) {\n        var clone = wrapperClone(parent);\n        if (result) {\n          previous.__wrapped__ = clone;\n        } else {\n          result = clone;\n        }\n        var previous = clone;\n        parent = parent.__wrapped__;\n      }\n      previous.__wrapped__ = value;\n      return result;\n    }\n\n    /**\n     * Reverses the wrapped array so the first element becomes the last, the\n     * second element becomes the second to last, and so on.\n     *\n     * **Note:** This method mutates the wrapped array.\n     *\n     * @name reverse\n     * @memberOf _\n     * @category Chain\n     * @returns {Object} Returns the new reversed `lodash` wrapper instance.\n     * @example\n     *\n     * var array = [1, 2, 3];\n     *\n     * _(array).reverse().value()\n     * // => [3, 2, 1]\n     *\n     * console.log(array);\n     * // => [3, 2, 1]\n     */\n    function wrapperReverse() {\n      var value = this.__wrapped__;\n\n      var interceptor = function(value) {\n        return (wrapped && wrapped.__dir__ < 0) ? value : value.reverse();\n      };\n      if (value instanceof LazyWrapper) {\n        var wrapped = value;\n        if (this.__actions__.length) {\n          wrapped = new LazyWrapper(this);\n        }\n        wrapped = wrapped.reverse();\n        wrapped.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined });\n        return new LodashWrapper(wrapped, this.__chain__);\n      }\n      return this.thru(interceptor);\n    }\n\n    /**\n     * Produces the result of coercing the unwrapped value to a string.\n     *\n     * @name toString\n     * @memberOf _\n     * @category Chain\n     * @returns {string} Returns the coerced string value.\n     * @example\n     *\n     * _([1, 2, 3]).toString();\n     * // => '1,2,3'\n     */\n    function wrapperToString() {\n      return (this.value() + '');\n    }\n\n    /**\n     * Executes the chained sequence to extract the unwrapped value.\n     *\n     * @name value\n     * @memberOf _\n     * @alias run, toJSON, valueOf\n     * @category Chain\n     * @returns {*} Returns the resolved unwrapped value.\n     * @example\n     *\n     * _([1, 2, 3]).value();\n     * // => [1, 2, 3]\n     */\n    function wrapperValue() {\n      return baseWrapperValue(this.__wrapped__, this.__actions__);\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates an array of elements corresponding to the given keys, or indexes,\n     * of `collection`. Keys may be specified as individual arguments or as arrays\n     * of keys.\n     *\n     * @static\n     * @memberOf _\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {...(number|number[]|string|string[])} [props] The property names\n     *  or indexes of elements to pick, specified individually or in arrays.\n     * @returns {Array} Returns the new array of picked elements.\n     * @example\n     *\n     * _.at(['a', 'b', 'c'], [0, 2]);\n     * // => ['a', 'c']\n     *\n     * _.at(['barney', 'fred', 'pebbles'], 0, 2);\n     * // => ['barney', 'pebbles']\n     */\n    var at = restParam(function(collection, props) {\n      return baseAt(collection, baseFlatten(props));\n    });\n\n    /**\n     * Creates an object composed of keys generated from the results of running\n     * each element of `collection` through `iteratee`. The corresponding value\n     * of each key is the number of times the key was returned by `iteratee`.\n     * The `iteratee` is bound to `thisArg` and invoked with three arguments:\n     * (value, index|key, collection).\n     *\n     * If a property name is provided for `iteratee` the created `_.property`\n     * style callback returns the property value of the given element.\n     *\n     * If a value is also provided for `thisArg` the created `_.matchesProperty`\n     * style callback returns `true` for elements that have a matching property\n     * value, else `false`.\n     *\n     * If an object is provided for `iteratee` the created `_.matches` style\n     * callback returns `true` for elements that have the properties of the given\n     * object, else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [iteratee=_.identity] The function invoked\n     *  per iteration.\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\n     * @returns {Object} Returns the composed aggregate object.\n     * @example\n     *\n     * _.countBy([4.3, 6.1, 6.4], function(n) {\n     *   return Math.floor(n);\n     * });\n     * // => { '4': 1, '6': 2 }\n     *\n     * _.countBy([4.3, 6.1, 6.4], function(n) {\n     *   return this.floor(n);\n     * }, Math);\n     * // => { '4': 1, '6': 2 }\n     *\n     * _.countBy(['one', 'two', 'three'], 'length');\n     * // => { '3': 2, '5': 1 }\n     */\n    var countBy = createAggregator(function(result, value, key) {\n      hasOwnProperty.call(result, key) ? ++result[key] : (result[key] = 1);\n    });\n\n    /**\n     * Checks if `predicate` returns truthy for **all** elements of `collection`.\n     * The predicate is bound to `thisArg` and invoked with three arguments:\n     * (value, index|key, collection).\n     *\n     * If a property name is provided for `predicate` the created `_.property`\n     * style callback returns the property value of the given element.\n     *\n     * If a value is also provided for `thisArg` the created `_.matchesProperty`\n     * style callback returns `true` for elements that have a matching property\n     * value, else `false`.\n     *\n     * If an object is provided for `predicate` the created `_.matches` style\n     * callback returns `true` for elements that have the properties of the given\n     * object, else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @alias all\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [predicate=_.identity] The function invoked\n     *  per iteration.\n     * @param {*} [thisArg] The `this` binding of `predicate`.\n     * @returns {boolean} Returns `true` if all elements pass the predicate check,\n     *  else `false`.\n     * @example\n     *\n     * _.every([true, 1, null, 'yes'], Boolean);\n     * // => false\n     *\n     * var users = [\n     *   { 'user': 'barney', 'active': false },\n     *   { 'user': 'fred',   'active': false }\n     * ];\n     *\n     * // using the `_.matches` callback shorthand\n     * _.every(users, { 'user': 'barney', 'active': false });\n     * // => false\n     *\n     * // using the `_.matchesProperty` callback shorthand\n     * _.every(users, 'active', false);\n     * // => true\n     *\n     * // using the `_.property` callback shorthand\n     * _.every(users, 'active');\n     * // => false\n     */\n    function every(collection, predicate, thisArg) {\n      var func = isArray(collection) ? arrayEvery : baseEvery;\n      if (thisArg && isIterateeCall(collection, predicate, thisArg)) {\n        predicate = undefined;\n      }\n      if (typeof predicate != 'function' || thisArg !== undefined) {\n        predicate = getCallback(predicate, thisArg, 3);\n      }\n      return func(collection, predicate);\n    }\n\n    /**\n     * Iterates over elements of `collection`, returning an array of all elements\n     * `predicate` returns truthy for. The predicate is bound to `thisArg` and\n     * invoked with three arguments: (value, index|key, collection).\n     *\n     * If a property name is provided for `predicate` the created `_.property`\n     * style callback returns the property value of the given element.\n     *\n     * If a value is also provided for `thisArg` the created `_.matchesProperty`\n     * style callback returns `true` for elements that have a matching property\n     * value, else `false`.\n     *\n     * If an object is provided for `predicate` the created `_.matches` style\n     * callback returns `true` for elements that have the properties of the given\n     * object, else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @alias select\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [predicate=_.identity] The function invoked\n     *  per iteration.\n     * @param {*} [thisArg] The `this` binding of `predicate`.\n     * @returns {Array} Returns the new filtered array.\n     * @example\n     *\n     * _.filter([4, 5, 6], function(n) {\n     *   return n % 2 == 0;\n     * });\n     * // => [4, 6]\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36, 'active': true },\n     *   { 'user': 'fred',   'age': 40, 'active': false }\n     * ];\n     *\n     * // using the `_.matches` callback shorthand\n     * _.pluck(_.filter(users, { 'age': 36, 'active': true }), 'user');\n     * // => ['barney']\n     *\n     * // using the `_.matchesProperty` callback shorthand\n     * _.pluck(_.filter(users, 'active', false), 'user');\n     * // => ['fred']\n     *\n     * // using the `_.property` callback shorthand\n     * _.pluck(_.filter(users, 'active'), 'user');\n     * // => ['barney']\n     */\n    function filter(collection, predicate, thisArg) {\n      var func = isArray(collection) ? arrayFilter : baseFilter;\n      predicate = getCallback(predicate, thisArg, 3);\n      return func(collection, predicate);\n    }\n\n    /**\n     * Iterates over elements of `collection`, returning the first element\n     * `predicate` returns truthy for. The predicate is bound to `thisArg` and\n     * invoked with three arguments: (value, index|key, collection).\n     *\n     * If a property name is provided for `predicate` the created `_.property`\n     * style callback returns the property value of the given element.\n     *\n     * If a value is also provided for `thisArg` the created `_.matchesProperty`\n     * style callback returns `true` for elements that have a matching property\n     * value, else `false`.\n     *\n     * If an object is provided for `predicate` the created `_.matches` style\n     * callback returns `true` for elements that have the properties of the given\n     * object, else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @alias detect\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to search.\n     * @param {Function|Object|string} [predicate=_.identity] The function invoked\n     *  per iteration.\n     * @param {*} [thisArg] The `this` binding of `predicate`.\n     * @returns {*} Returns the matched element, else `undefined`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'age': 36, 'active': true },\n     *   { 'user': 'fred',    'age': 40, 'active': false },\n     *   { 'user': 'pebbles', 'age': 1,  'active': true }\n     * ];\n     *\n     * _.result(_.find(users, function(chr) {\n     *   return chr.age < 40;\n     * }), 'user');\n     * // => 'barney'\n     *\n     * // using the `_.matches` callback shorthand\n     * _.result(_.find(users, { 'age': 1, 'active': true }), 'user');\n     * // => 'pebbles'\n     *\n     * // using the `_.matchesProperty` callback shorthand\n     * _.result(_.find(users, 'active', false), 'user');\n     * // => 'fred'\n     *\n     * // using the `_.property` callback shorthand\n     * _.result(_.find(users, 'active'), 'user');\n     * // => 'barney'\n     */\n    var find = createFind(baseEach);\n\n    /**\n     * This method is like `_.find` except that it iterates over elements of\n     * `collection` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to search.\n     * @param {Function|Object|string} [predicate=_.identity] The function invoked\n     *  per iteration.\n     * @param {*} [thisArg] The `this` binding of `predicate`.\n     * @returns {*} Returns the matched element, else `undefined`.\n     * @example\n     *\n     * _.findLast([1, 2, 3, 4], function(n) {\n     *   return n % 2 == 1;\n     * });\n     * // => 3\n     */\n    var findLast = createFind(baseEachRight, true);\n\n    /**\n     * Performs a deep comparison between each element in `collection` and the\n     * source object, returning the first element that has equivalent property\n     * values.\n     *\n     * **Note:** This method supports comparing arrays, booleans, `Date` objects,\n     * numbers, `Object` objects, regexes, and strings. Objects are compared by\n     * their own, not inherited, enumerable properties. For comparing a single\n     * own or inherited property value see `_.matchesProperty`.\n     *\n     * @static\n     * @memberOf _\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to search.\n     * @param {Object} source The object of property values to match.\n     * @returns {*} Returns the matched element, else `undefined`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36, 'active': true },\n     *   { 'user': 'fred',   'age': 40, 'active': false }\n     * ];\n     *\n     * _.result(_.findWhere(users, { 'age': 36, 'active': true }), 'user');\n     * // => 'barney'\n     *\n     * _.result(_.findWhere(users, { 'age': 40, 'active': false }), 'user');\n     * // => 'fred'\n     */\n    function findWhere(collection, source) {\n      return find(collection, baseMatches(source));\n    }\n\n    /**\n     * Iterates over elements of `collection` invoking `iteratee` for each element.\n     * The `iteratee` is bound to `thisArg` and invoked with three arguments:\n     * (value, index|key, collection). Iteratee functions may exit iteration early\n     * by explicitly returning `false`.\n     *\n     * **Note:** As with other \"Collections\" methods, objects with a \"length\" property\n     * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`\n     * may be used for object iteration.\n     *\n     * @static\n     * @memberOf _\n     * @alias each\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\n     * @returns {Array|Object|string} Returns `collection`.\n     * @example\n     *\n     * _([1, 2]).forEach(function(n) {\n     *   console.log(n);\n     * }).value();\n     * // => logs each value from left to right and returns the array\n     *\n     * _.forEach({ 'a': 1, 'b': 2 }, function(n, key) {\n     *   console.log(n, key);\n     * });\n     * // => logs each value-key pair and returns the object (iteration order is not guaranteed)\n     */\n    var forEach = createForEach(arrayEach, baseEach);\n\n    /**\n     * This method is like `_.forEach` except that it iterates over elements of\n     * `collection` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @alias eachRight\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\n     * @returns {Array|Object|string} Returns `collection`.\n     * @example\n     *\n     * _([1, 2]).forEachRight(function(n) {\n     *   console.log(n);\n     * }).value();\n     * // => logs each value from right to left and returns the array\n     */\n    var forEachRight = createForEach(arrayEachRight, baseEachRight);\n\n    /**\n     * Creates an object composed of keys generated from the results of running\n     * each element of `collection` through `iteratee`. The corresponding value\n     * of each key is an array of the elements responsible for generating the key.\n     * The `iteratee` is bound to `thisArg` and invoked with three arguments:\n     * (value, index|key, collection).\n     *\n     * If a property name is provided for `iteratee` the created `_.property`\n     * style callback returns the property value of the given element.\n     *\n     * If a value is also provided for `thisArg` the created `_.matchesProperty`\n     * style callback returns `true` for elements that have a matching property\n     * value, else `false`.\n     *\n     * If an object is provided for `iteratee` the created `_.matches` style\n     * callback returns `true` for elements that have the properties of the given\n     * object, else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [iteratee=_.identity] The function invoked\n     *  per iteration.\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\n     * @returns {Object} Returns the composed aggregate object.\n     * @example\n     *\n     * _.groupBy([4.2, 6.1, 6.4], function(n) {\n     *   return Math.floor(n);\n     * });\n     * // => { '4': [4.2], '6': [6.1, 6.4] }\n     *\n     * _.groupBy([4.2, 6.1, 6.4], function(n) {\n     *   return this.floor(n);\n     * }, Math);\n     * // => { '4': [4.2], '6': [6.1, 6.4] }\n     *\n     * // using the `_.property` callback shorthand\n     * _.groupBy(['one', 'two', 'three'], 'length');\n     * // => { '3': ['one', 'two'], '5': ['three'] }\n     */\n    var groupBy = createAggregator(function(result, value, key) {\n      if (hasOwnProperty.call(result, key)) {\n        result[key].push(value);\n      } else {\n        result[key] = [value];\n      }\n    });\n\n    /**\n     * Checks if `value` is in `collection` using\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)\n     * for equality comparisons. If `fromIndex` is negative, it is used as the offset\n     * from the end of `collection`.\n     *\n     * @static\n     * @memberOf _\n     * @alias contains, include\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to search.\n     * @param {*} target The value to search for.\n     * @param {number} [fromIndex=0] The index to search from.\n     * @param- {Object} [guard] Enables use as a callback for functions like `_.reduce`.\n     * @returns {boolean} Returns `true` if a matching element is found, else `false`.\n     * @example\n     *\n     * _.includes([1, 2, 3], 1);\n     * // => true\n     *\n     * _.includes([1, 2, 3], 1, 2);\n     * // => false\n     *\n     * _.includes({ 'user': 'fred', 'age': 40 }, 'fred');\n     * // => true\n     *\n     * _.includes('pebbles', 'eb');\n     * // => true\n     */\n    function includes(collection, target, fromIndex, guard) {\n      var length = collection ? getLength(collection) : 0;\n      if (!isLength(length)) {\n        collection = values(collection);\n        length = collection.length;\n      }\n      if (typeof fromIndex != 'number' || (guard && isIterateeCall(target, fromIndex, guard))) {\n        fromIndex = 0;\n      } else {\n        fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : (fromIndex || 0);\n      }\n      return (typeof collection == 'string' || !isArray(collection) && isString(collection))\n        ? (fromIndex <= length && collection.indexOf(target, fromIndex) > -1)\n        : (!!length && getIndexOf(collection, target, fromIndex) > -1);\n    }\n\n    /**\n     * Creates an object composed of keys generated from the results of running\n     * each element of `collection` through `iteratee`. The corresponding value\n     * of each key is the last element responsible for generating the key. The\n     * iteratee function is bound to `thisArg` and invoked with three arguments:\n     * (value, index|key, collection).\n     *\n     * If a property name is provided for `iteratee` the created `_.property`\n     * style callback returns the property value of the given element.\n     *\n     * If a value is also provided for `thisArg` the created `_.matchesProperty`\n     * style callback returns `true` for elements that have a matching property\n     * value, else `false`.\n     *\n     * If an object is provided for `iteratee` the created `_.matches` style\n     * callback returns `true` for elements that have the properties of the given\n     * object, else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [iteratee=_.identity] The function invoked\n     *  per iteration.\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\n     * @returns {Object} Returns the composed aggregate object.\n     * @example\n     *\n     * var keyData = [\n     *   { 'dir': 'left', 'code': 97 },\n     *   { 'dir': 'right', 'code': 100 }\n     * ];\n     *\n     * _.indexBy(keyData, 'dir');\n     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }\n     *\n     * _.indexBy(keyData, function(object) {\n     *   return String.fromCharCode(object.code);\n     * });\n     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }\n     *\n     * _.indexBy(keyData, function(object) {\n     *   return this.fromCharCode(object.code);\n     * }, String);\n     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }\n     */\n    var indexBy = createAggregator(function(result, value, key) {\n      result[key] = value;\n    });\n\n    /**\n     * Invokes the method at `path` of each element in `collection`, returning\n     * an array of the results of each invoked method. Any additional arguments\n     * are provided to each invoked method. If `methodName` is a function it is\n     * invoked for, and `this` bound to, each element in `collection`.\n     *\n     * @static\n     * @memberOf _\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Array|Function|string} path The path of the method to invoke or\n     *  the function invoked per iteration.\n     * @param {...*} [args] The arguments to invoke the method with.\n     * @returns {Array} Returns the array of results.\n     * @example\n     *\n     * _.invoke([[5, 1, 7], [3, 2, 1]], 'sort');\n     * // => [[1, 5, 7], [1, 2, 3]]\n     *\n     * _.invoke([123, 456], String.prototype.split, '');\n     * // => [['1', '2', '3'], ['4', '5', '6']]\n     */\n    var invoke = restParam(function(collection, path, args) {\n      var index = -1,\n          isFunc = typeof path == 'function',\n          isProp = isKey(path),\n          result = isArrayLike(collection) ? Array(collection.length) : [];\n\n      baseEach(collection, function(value) {\n        var func = isFunc ? path : ((isProp && value != null) ? value[path] : undefined);\n        result[++index] = func ? func.apply(value, args) : invokePath(value, path, args);\n      });\n      return result;\n    });\n\n    /**\n     * Creates an array of values by running each element in `collection` through\n     * `iteratee`. The `iteratee` is bound to `thisArg` and invoked with three\n     * arguments: (value, index|key, collection).\n     *\n     * If a property name is provided for `iteratee` the created `_.property`\n     * style callback returns the property value of the given element.\n     *\n     * If a value is also provided for `thisArg` the created `_.matchesProperty`\n     * style callback returns `true` for elements that have a matching property\n     * value, else `false`.\n     *\n     * If an object is provided for `iteratee` the created `_.matches` style\n     * callback returns `true` for elements that have the properties of the given\n     * object, else `false`.\n     *\n     * Many lodash methods are guarded to work as iteratees for methods like\n     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.\n     *\n     * The guarded methods are:\n     * `ary`, `callback`, `chunk`, `clone`, `create`, `curry`, `curryRight`,\n     * `drop`, `dropRight`, `every`, `fill`, `flatten`, `invert`, `max`, `min`,\n     * `parseInt`, `slice`, `sortBy`, `take`, `takeRight`, `template`, `trim`,\n     * `trimLeft`, `trimRight`, `trunc`, `random`, `range`, `sample`, `some`,\n     * `sum`, `uniq`, and `words`\n     *\n     * @static\n     * @memberOf _\n     * @alias collect\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [iteratee=_.identity] The function invoked\n     *  per iteration.\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\n     * @returns {Array} Returns the new mapped array.\n     * @example\n     *\n     * function timesThree(n) {\n     *   return n * 3;\n     * }\n     *\n     * _.map([1, 2], timesThree);\n     * // => [3, 6]\n     *\n     * _.map({ 'a': 1, 'b': 2 }, timesThree);\n     * // => [3, 6] (iteration order is not guaranteed)\n     *\n     * var users = [\n     *   { 'user': 'barney' },\n     *   { 'user': 'fred' }\n     * ];\n     *\n     * // using the `_.property` callback shorthand\n     * _.map(users, 'user');\n     * // => ['barney', 'fred']\n     */\n    function map(collection, iteratee, thisArg) {\n      var func = isArray(collection) ? arrayMap : baseMap;\n      iteratee = getCallback(iteratee, thisArg, 3);\n      return func(collection, iteratee);\n    }\n\n    /**\n     * Creates an array of elements split into two groups, the first of which\n     * contains elements `predicate` returns truthy for, while the second of which\n     * contains elements `predicate` returns falsey for. The predicate is bound\n     * to `thisArg` and invoked with three arguments: (value, index|key, collection).\n     *\n     * If a property name is provided for `predicate` the created `_.property`\n     * style callback returns the property value of the given element.\n     *\n     * If a value is also provided for `thisArg` the created `_.matchesProperty`\n     * style callback returns `true` for elements that have a matching property\n     * value, else `false`.\n     *\n     * If an object is provided for `predicate` the created `_.matches` style\n     * callback returns `true` for elements that have the properties of the given\n     * object, else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [predicate=_.identity] The function invoked\n     *  per iteration.\n     * @param {*} [thisArg] The `this` binding of `predicate`.\n     * @returns {Array} Returns the array of grouped elements.\n     * @example\n     *\n     * _.partition([1, 2, 3], function(n) {\n     *   return n % 2;\n     * });\n     * // => [[1, 3], [2]]\n     *\n     * _.partition([1.2, 2.3, 3.4], function(n) {\n     *   return this.floor(n) % 2;\n     * }, Math);\n     * // => [[1.2, 3.4], [2.3]]\n     *\n     * var users = [\n     *   { 'user': 'barney',  'age': 36, 'active': false },\n     *   { 'user': 'fred',    'age': 40, 'active': true },\n     *   { 'user': 'pebbles', 'age': 1,  'active': false }\n     * ];\n     *\n     * var mapper = function(array) {\n     *   return _.pluck(array, 'user');\n     * };\n     *\n     * // using the `_.matches` callback shorthand\n     * _.map(_.partition(users, { 'age': 1, 'active': false }), mapper);\n     * // => [['pebbles'], ['barney', 'fred']]\n     *\n     * // using the `_.matchesProperty` callback shorthand\n     * _.map(_.partition(users, 'active', false), mapper);\n     * // => [['barney', 'pebbles'], ['fred']]\n     *\n     * // using the `_.property` callback shorthand\n     * _.map(_.partition(users, 'active'), mapper);\n     * // => [['fred'], ['barney', 'pebbles']]\n     */\n    var partition = createAggregator(function(result, value, key) {\n      result[key ? 0 : 1].push(value);\n    }, function() { return [[], []]; });\n\n    /**\n     * Gets the property value of `path` from all elements in `collection`.\n     *\n     * @static\n     * @memberOf _\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Array|string} path The path of the property to pluck.\n     * @returns {Array} Returns the property values.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36 },\n     *   { 'user': 'fred',   'age': 40 }\n     * ];\n     *\n     * _.pluck(users, 'user');\n     * // => ['barney', 'fred']\n     *\n     * var userIndex = _.indexBy(users, 'user');\n     * _.pluck(userIndex, 'age');\n     * // => [36, 40] (iteration order is not guaranteed)\n     */\n    function pluck(collection, path) {\n      return map(collection, property(path));\n    }\n\n    /**\n     * Reduces `collection` to a value which is the accumulated result of running\n     * each element in `collection` through `iteratee`, where each successive\n     * invocation is supplied the return value of the previous. If `accumulator`\n     * is not provided the first element of `collection` is used as the initial\n     * value. The `iteratee` is bound to `thisArg` and invoked with four arguments:\n     * (accumulator, value, index|key, collection).\n     *\n     * Many lodash methods are guarded to work as iteratees for methods like\n     * `_.reduce`, `_.reduceRight`, and `_.transform`.\n     *\n     * The guarded methods are:\n     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `sortByAll`,\n     * and `sortByOrder`\n     *\n     * @static\n     * @memberOf _\n     * @alias foldl, inject\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {*} [accumulator] The initial value.\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\n     * @returns {*} Returns the accumulated value.\n     * @example\n     *\n     * _.reduce([1, 2], function(total, n) {\n     *   return total + n;\n     * });\n     * // => 3\n     *\n     * _.reduce({ 'a': 1, 'b': 2 }, function(result, n, key) {\n     *   result[key] = n * 3;\n     *   return result;\n     * }, {});\n     * // => { 'a': 3, 'b': 6 } (iteration order is not guaranteed)\n     */\n    var reduce = createReduce(arrayReduce, baseEach);\n\n    /**\n     * This method is like `_.reduce` except that it iterates over elements of\n     * `collection` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @alias foldr\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {*} [accumulator] The initial value.\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\n     * @returns {*} Returns the accumulated value.\n     * @example\n     *\n     * var array = [[0, 1], [2, 3], [4, 5]];\n     *\n     * _.reduceRight(array, function(flattened, other) {\n     *   return flattened.concat(other);\n     * }, []);\n     * // => [4, 5, 2, 3, 0, 1]\n     */\n    var reduceRight = createReduce(arrayReduceRight, baseEachRight);\n\n    /**\n     * The opposite of `_.filter`; this method returns the elements of `collection`\n     * that `predicate` does **not** return truthy for.\n     *\n     * @static\n     * @memberOf _\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [predicate=_.identity] The function invoked\n     *  per iteration.\n     * @param {*} [thisArg] The `this` binding of `predicate`.\n     * @returns {Array} Returns the new filtered array.\n     * @example\n     *\n     * _.reject([1, 2, 3, 4], function(n) {\n     *   return n % 2 == 0;\n     * });\n     * // => [1, 3]\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36, 'active': false },\n     *   { 'user': 'fred',   'age': 40, 'active': true }\n     * ];\n     *\n     * // using the `_.matches` callback shorthand\n     * _.pluck(_.reject(users, { 'age': 40, 'active': true }), 'user');\n     * // => ['barney']\n     *\n     * // using the `_.matchesProperty` callback shorthand\n     * _.pluck(_.reject(users, 'active', false), 'user');\n     * // => ['fred']\n     *\n     * // using the `_.property` callback shorthand\n     * _.pluck(_.reject(users, 'active'), 'user');\n     * // => ['barney']\n     */\n    function reject(collection, predicate, thisArg) {\n      var func = isArray(collection) ? arrayFilter : baseFilter;\n      predicate = getCallback(predicate, thisArg, 3);\n      return func(collection, function(value, index, collection) {\n        return !predicate(value, index, collection);\n      });\n    }\n\n    /**\n     * Gets a random element or `n` random elements from a collection.\n     *\n     * @static\n     * @memberOf _\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to sample.\n     * @param {number} [n] The number of elements to sample.\n     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n     * @returns {*} Returns the random sample(s).\n     * @example\n     *\n     * _.sample([1, 2, 3, 4]);\n     * // => 2\n     *\n     * _.sample([1, 2, 3, 4], 2);\n     * // => [3, 1]\n     */\n    function sample(collection, n, guard) {\n      if (guard ? isIterateeCall(collection, n, guard) : n == null) {\n        collection = toIterable(collection);\n        var length = collection.length;\n        return length > 0 ? collection[baseRandom(0, length - 1)] : undefined;\n      }\n      var index = -1,\n          result = toArray(collection),\n          length = result.length,\n          lastIndex = length - 1;\n\n      n = nativeMin(n < 0 ? 0 : (+n || 0), length);\n      while (++index < n) {\n        var rand = baseRandom(index, lastIndex),\n            value = result[rand];\n\n        result[rand] = result[index];\n        result[index] = value;\n      }\n      result.length = n;\n      return result;\n    }\n\n    /**\n     * Creates an array of shuffled values, using a version of the\n     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).\n     *\n     * @static\n     * @memberOf _\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to shuffle.\n     * @returns {Array} Returns the new shuffled array.\n     * @example\n     *\n     * _.shuffle([1, 2, 3, 4]);\n     * // => [4, 1, 3, 2]\n     */\n    function shuffle(collection) {\n      return sample(collection, POSITIVE_INFINITY);\n    }\n\n    /**\n     * Gets the size of `collection` by returning its length for array-like\n     * values or the number of own enumerable properties for objects.\n     *\n     * @static\n     * @memberOf _\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to inspect.\n     * @returns {number} Returns the size of `collection`.\n     * @example\n     *\n     * _.size([1, 2, 3]);\n     * // => 3\n     *\n     * _.size({ 'a': 1, 'b': 2 });\n     * // => 2\n     *\n     * _.size('pebbles');\n     * // => 7\n     */\n    function size(collection) {\n      var length = collection ? getLength(collection) : 0;\n      return isLength(length) ? length : keys(collection).length;\n    }\n\n    /**\n     * Checks if `predicate` returns truthy for **any** element of `collection`.\n     * The function returns as soon as it finds a passing value and does not iterate\n     * over the entire collection. The predicate is bound to `thisArg` and invoked\n     * with three arguments: (value, index|key, collection).\n     *\n     * If a property name is provided for `predicate` the created `_.property`\n     * style callback returns the property value of the given element.\n     *\n     * If a value is also provided for `thisArg` the created `_.matchesProperty`\n     * style callback returns `true` for elements that have a matching property\n     * value, else `false`.\n     *\n     * If an object is provided for `predicate` the created `_.matches` style\n     * callback returns `true` for elements that have the properties of the given\n     * object, else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @alias any\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [predicate=_.identity] The function invoked\n     *  per iteration.\n     * @param {*} [thisArg] The `this` binding of `predicate`.\n     * @returns {boolean} Returns `true` if any element passes the predicate check,\n     *  else `false`.\n     * @example\n     *\n     * _.some([null, 0, 'yes', false], Boolean);\n     * // => true\n     *\n     * var users = [\n     *   { 'user': 'barney', 'active': true },\n     *   { 'user': 'fred',   'active': false }\n     * ];\n     *\n     * // using the `_.matches` callback shorthand\n     * _.some(users, { 'user': 'barney', 'active': false });\n     * // => false\n     *\n     * // using the `_.matchesProperty` callback shorthand\n     * _.some(users, 'active', false);\n     * // => true\n     *\n     * // using the `_.property` callback shorthand\n     * _.some(users, 'active');\n     * // => true\n     */\n    function some(collection, predicate, thisArg) {\n      var func = isArray(collection) ? arraySome : baseSome;\n      if (thisArg && isIterateeCall(collection, predicate, thisArg)) {\n        predicate = undefined;\n      }\n      if (typeof predicate != 'function' || thisArg !== undefined) {\n        predicate = getCallback(predicate, thisArg, 3);\n      }\n      return func(collection, predicate);\n    }\n\n    /**\n     * Creates an array of elements, sorted in ascending order by the results of\n     * running each element in a collection through `iteratee`. This method performs\n     * a stable sort, that is, it preserves the original sort order of equal elements.\n     * The `iteratee` is bound to `thisArg` and invoked with three arguments:\n     * (value, index|key, collection).\n     *\n     * If a property name is provided for `iteratee` the created `_.property`\n     * style callback returns the property value of the given element.\n     *\n     * If a value is also provided for `thisArg` the created `_.matchesProperty`\n     * style callback returns `true` for elements that have a matching property\n     * value, else `false`.\n     *\n     * If an object is provided for `iteratee` the created `_.matches` style\n     * callback returns `true` for elements that have the properties of the given\n     * object, else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [iteratee=_.identity] The function invoked\n     *  per iteration.\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\n     * @returns {Array} Returns the new sorted array.\n     * @example\n     *\n     * _.sortBy([1, 2, 3], function(n) {\n     *   return Math.sin(n);\n     * });\n     * // => [3, 1, 2]\n     *\n     * _.sortBy([1, 2, 3], function(n) {\n     *   return this.sin(n);\n     * }, Math);\n     * // => [3, 1, 2]\n     *\n     * var users = [\n     *   { 'user': 'fred' },\n     *   { 'user': 'pebbles' },\n     *   { 'user': 'barney' }\n     * ];\n     *\n     * // using the `_.property` callback shorthand\n     * _.pluck(_.sortBy(users, 'user'), 'user');\n     * // => ['barney', 'fred', 'pebbles']\n     */\n    function sortBy(collection, iteratee, thisArg) {\n      if (collection == null) {\n        return [];\n      }\n      if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {\n        iteratee = undefined;\n      }\n      var index = -1;\n      iteratee = getCallback(iteratee, thisArg, 3);\n\n      var result = baseMap(collection, function(value, key, collection) {\n        return { 'criteria': iteratee(value, key, collection), 'index': ++index, 'value': value };\n      });\n      return baseSortBy(result, compareAscending);\n    }\n\n    /**\n     * This method is like `_.sortBy` except that it can sort by multiple iteratees\n     * or property names.\n     *\n     * If a property name is provided for an iteratee the created `_.property`\n     * style callback returns the property value of the given element.\n     *\n     * If an object is provided for an iteratee the created `_.matches` style\n     * callback returns `true` for elements that have the properties of the given\n     * object, else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {...(Function|Function[]|Object|Object[]|string|string[])} iteratees\n     *  The iteratees to sort by, specified as individual values or arrays of values.\n     * @returns {Array} Returns the new sorted array.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'fred',   'age': 48 },\n     *   { 'user': 'barney', 'age': 36 },\n     *   { 'user': 'fred',   'age': 42 },\n     *   { 'user': 'barney', 'age': 34 }\n     * ];\n     *\n     * _.map(_.sortByAll(users, ['user', 'age']), _.values);\n     * // => [['barney', 34], ['barney', 36], ['fred', 42], ['fred', 48]]\n     *\n     * _.map(_.sortByAll(users, 'user', function(chr) {\n     *   return Math.floor(chr.age / 10);\n     * }), _.values);\n     * // => [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 42]]\n     */\n    var sortByAll = restParam(function(collection, iteratees) {\n      if (collection == null) {\n        return [];\n      }\n      var guard = iteratees[2];\n      if (guard && isIterateeCall(iteratees[0], iteratees[1], guard)) {\n        iteratees.length = 1;\n      }\n      return baseSortByOrder(collection, baseFlatten(iteratees), []);\n    });\n\n    /**\n     * This method is like `_.sortByAll` except that it allows specifying the\n     * sort orders of the iteratees to sort by. If `orders` is unspecified, all\n     * values are sorted in ascending order. Otherwise, a value is sorted in\n     * ascending order if its corresponding order is \"asc\", and descending if \"desc\".\n     *\n     * If a property name is provided for an iteratee the created `_.property`\n     * style callback returns the property value of the given element.\n     *\n     * If an object is provided for an iteratee the created `_.matches` style\n     * callback returns `true` for elements that have the properties of the given\n     * object, else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.\n     * @param {boolean[]} [orders] The sort orders of `iteratees`.\n     * @param- {Object} [guard] Enables use as a callback for functions like `_.reduce`.\n     * @returns {Array} Returns the new sorted array.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'fred',   'age': 48 },\n     *   { 'user': 'barney', 'age': 34 },\n     *   { 'user': 'fred',   'age': 42 },\n     *   { 'user': 'barney', 'age': 36 }\n     * ];\n     *\n     * // sort by `user` in ascending order and by `age` in descending order\n     * _.map(_.sortByOrder(users, ['user', 'age'], ['asc', 'desc']), _.values);\n     * // => [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 42]]\n     */\n    function sortByOrder(collection, iteratees, orders, guard) {\n      if (collection == null) {\n        return [];\n      }\n      if (guard && isIterateeCall(iteratees, orders, guard)) {\n        orders = undefined;\n      }\n      if (!isArray(iteratees)) {\n        iteratees = iteratees == null ? [] : [iteratees];\n      }\n      if (!isArray(orders)) {\n        orders = orders == null ? [] : [orders];\n      }\n      return baseSortByOrder(collection, iteratees, orders);\n    }\n\n    /**\n     * Performs a deep comparison between each element in `collection` and the\n     * source object, returning an array of all elements that have equivalent\n     * property values.\n     *\n     * **Note:** This method supports comparing arrays, booleans, `Date` objects,\n     * numbers, `Object` objects, regexes, and strings. Objects are compared by\n     * their own, not inherited, enumerable properties. For comparing a single\n     * own or inherited property value see `_.matchesProperty`.\n     *\n     * @static\n     * @memberOf _\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to search.\n     * @param {Object} source The object of property values to match.\n     * @returns {Array} Returns the new filtered array.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36, 'active': false, 'pets': ['hoppy'] },\n     *   { 'user': 'fred',   'age': 40, 'active': true, 'pets': ['baby puss', 'dino'] }\n     * ];\n     *\n     * _.pluck(_.where(users, { 'age': 36, 'active': false }), 'user');\n     * // => ['barney']\n     *\n     * _.pluck(_.where(users, { 'pets': ['dino'] }), 'user');\n     * // => ['fred']\n     */\n    function where(collection, source) {\n      return filter(collection, baseMatches(source));\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Gets the number of milliseconds that have elapsed since the Unix epoch\n     * (1 January 1970 00:00:00 UTC).\n     *\n     * @static\n     * @memberOf _\n     * @category Date\n     * @example\n     *\n     * _.defer(function(stamp) {\n     *   console.log(_.now() - stamp);\n     * }, _.now());\n     * // => logs the number of milliseconds it took for the deferred function to be invoked\n     */\n    var now = nativeNow || function() {\n      return new Date().getTime();\n    };\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * The opposite of `_.before`; this method creates a function that invokes\n     * `func` once it is called `n` or more times.\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {number} n The number of calls before `func` is invoked.\n     * @param {Function} func The function to restrict.\n     * @returns {Function} Returns the new restricted function.\n     * @example\n     *\n     * var saves = ['profile', 'settings'];\n     *\n     * var done = _.after(saves.length, function() {\n     *   console.log('done saving!');\n     * });\n     *\n     * _.forEach(saves, function(type) {\n     *   asyncSave({ 'type': type, 'complete': done });\n     * });\n     * // => logs 'done saving!' after the two async saves have completed\n     */\n    function after(n, func) {\n      if (typeof func != 'function') {\n        if (typeof n == 'function') {\n          var temp = n;\n          n = func;\n          func = temp;\n        } else {\n          throw new TypeError(FUNC_ERROR_TEXT);\n        }\n      }\n      n = nativeIsFinite(n = +n) ? n : 0;\n      return function() {\n        if (--n < 1) {\n          return func.apply(this, arguments);\n        }\n      };\n    }\n\n    /**\n     * Creates a function that accepts up to `n` arguments ignoring any\n     * additional arguments.\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {Function} func The function to cap arguments for.\n     * @param {number} [n=func.length] The arity cap.\n     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * _.map(['6', '8', '10'], _.ary(parseInt, 1));\n     * // => [6, 8, 10]\n     */\n    function ary(func, n, guard) {\n      if (guard && isIterateeCall(func, n, guard)) {\n        n = undefined;\n      }\n      n = (func && n == null) ? func.length : nativeMax(+n || 0, 0);\n      return createWrapper(func, ARY_FLAG, undefined, undefined, undefined, undefined, n);\n    }\n\n    /**\n     * Creates a function that invokes `func`, with the `this` binding and arguments\n     * of the created function, while it is called less than `n` times. Subsequent\n     * calls to the created function return the result of the last `func` invocation.\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {number} n The number of calls at which `func` is no longer invoked.\n     * @param {Function} func The function to restrict.\n     * @returns {Function} Returns the new restricted function.\n     * @example\n     *\n     * jQuery('#add').on('click', _.before(5, addContactToList));\n     * // => allows adding up to 4 contacts to the list\n     */\n    function before(n, func) {\n      var result;\n      if (typeof func != 'function') {\n        if (typeof n == 'function') {\n          var temp = n;\n          n = func;\n          func = temp;\n        } else {\n          throw new TypeError(FUNC_ERROR_TEXT);\n        }\n      }\n      return function() {\n        if (--n > 0) {\n          result = func.apply(this, arguments);\n        }\n        if (n <= 1) {\n          func = undefined;\n        }\n        return result;\n      };\n    }\n\n    /**\n     * Creates a function that invokes `func` with the `this` binding of `thisArg`\n     * and prepends any additional `_.bind` arguments to those provided to the\n     * bound function.\n     *\n     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,\n     * may be used as a placeholder for partially applied arguments.\n     *\n     * **Note:** Unlike native `Function#bind` this method does not set the \"length\"\n     * property of bound functions.\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {Function} func The function to bind.\n     * @param {*} thisArg The `this` binding of `func`.\n     * @param {...*} [partials] The arguments to be partially applied.\n     * @returns {Function} Returns the new bound function.\n     * @example\n     *\n     * var greet = function(greeting, punctuation) {\n     *   return greeting + ' ' + this.user + punctuation;\n     * };\n     *\n     * var object = { 'user': 'fred' };\n     *\n     * var bound = _.bind(greet, object, 'hi');\n     * bound('!');\n     * // => 'hi fred!'\n     *\n     * // using placeholders\n     * var bound = _.bind(greet, object, _, '!');\n     * bound('hi');\n     * // => 'hi fred!'\n     */\n    var bind = restParam(function(func, thisArg, partials) {\n      var bitmask = BIND_FLAG;\n      if (partials.length) {\n        var holders = replaceHolders(partials, bind.placeholder);\n        bitmask |= PARTIAL_FLAG;\n      }\n      return createWrapper(func, bitmask, thisArg, partials, holders);\n    });\n\n    /**\n     * Binds methods of an object to the object itself, overwriting the existing\n     * method. Method names may be specified as individual arguments or as arrays\n     * of method names. If no method names are provided all enumerable function\n     * properties, own and inherited, of `object` are bound.\n     *\n     * **Note:** This method does not set the \"length\" property of bound functions.\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {Object} object The object to bind and assign the bound methods to.\n     * @param {...(string|string[])} [methodNames] The object method names to bind,\n     *  specified as individual method names or arrays of method names.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var view = {\n     *   'label': 'docs',\n     *   'onClick': function() {\n     *     console.log('clicked ' + this.label);\n     *   }\n     * };\n     *\n     * _.bindAll(view);\n     * jQuery('#docs').on('click', view.onClick);\n     * // => logs 'clicked docs' when the element is clicked\n     */\n    var bindAll = restParam(function(object, methodNames) {\n      methodNames = methodNames.length ? baseFlatten(methodNames) : functions(object);\n\n      var index = -1,\n          length = methodNames.length;\n\n      while (++index < length) {\n        var key = methodNames[index];\n        object[key] = createWrapper(object[key], BIND_FLAG, object);\n      }\n      return object;\n    });\n\n    /**\n     * Creates a function that invokes the method at `object[key]` and prepends\n     * any additional `_.bindKey` arguments to those provided to the bound function.\n     *\n     * This method differs from `_.bind` by allowing bound functions to reference\n     * methods that may be redefined or don't yet exist.\n     * See [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)\n     * for more details.\n     *\n     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic\n     * builds, may be used as a placeholder for partially applied arguments.\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {Object} object The object the method belongs to.\n     * @param {string} key The key of the method.\n     * @param {...*} [partials] The arguments to be partially applied.\n     * @returns {Function} Returns the new bound function.\n     * @example\n     *\n     * var object = {\n     *   'user': 'fred',\n     *   'greet': function(greeting, punctuation) {\n     *     return greeting + ' ' + this.user + punctuation;\n     *   }\n     * };\n     *\n     * var bound = _.bindKey(object, 'greet', 'hi');\n     * bound('!');\n     * // => 'hi fred!'\n     *\n     * object.greet = function(greeting, punctuation) {\n     *   return greeting + 'ya ' + this.user + punctuation;\n     * };\n     *\n     * bound('!');\n     * // => 'hiya fred!'\n     *\n     * // using placeholders\n     * var bound = _.bindKey(object, 'greet', _, '!');\n     * bound('hi');\n     * // => 'hiya fred!'\n     */\n    var bindKey = restParam(function(object, key, partials) {\n      var bitmask = BIND_FLAG | BIND_KEY_FLAG;\n      if (partials.length) {\n        var holders = replaceHolders(partials, bindKey.placeholder);\n        bitmask |= PARTIAL_FLAG;\n      }\n      return createWrapper(key, bitmask, object, partials, holders);\n    });\n\n    /**\n     * Creates a function that accepts one or more arguments of `func` that when\n     * called either invokes `func` returning its result, if all `func` arguments\n     * have been provided, or returns a function that accepts one or more of the\n     * remaining `func` arguments, and so on. The arity of `func` may be specified\n     * if `func.length` is not sufficient.\n     *\n     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,\n     * may be used as a placeholder for provided arguments.\n     *\n     * **Note:** This method does not set the \"length\" property of curried functions.\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {Function} func The function to curry.\n     * @param {number} [arity=func.length] The arity of `func`.\n     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n     * @returns {Function} Returns the new curried function.\n     * @example\n     *\n     * var abc = function(a, b, c) {\n     *   return [a, b, c];\n     * };\n     *\n     * var curried = _.curry(abc);\n     *\n     * curried(1)(2)(3);\n     * // => [1, 2, 3]\n     *\n     * curried(1, 2)(3);\n     * // => [1, 2, 3]\n     *\n     * curried(1, 2, 3);\n     * // => [1, 2, 3]\n     *\n     * // using placeholders\n     * curried(1)(_, 3)(2);\n     * // => [1, 2, 3]\n     */\n    var curry = createCurry(CURRY_FLAG);\n\n    /**\n     * This method is like `_.curry` except that arguments are applied to `func`\n     * in the manner of `_.partialRight` instead of `_.partial`.\n     *\n     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic\n     * builds, may be used as a placeholder for provided arguments.\n     *\n     * **Note:** This method does not set the \"length\" property of curried functions.\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {Function} func The function to curry.\n     * @param {number} [arity=func.length] The arity of `func`.\n     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n     * @returns {Function} Returns the new curried function.\n     * @example\n     *\n     * var abc = function(a, b, c) {\n     *   return [a, b, c];\n     * };\n     *\n     * var curried = _.curryRight(abc);\n     *\n     * curried(3)(2)(1);\n     * // => [1, 2, 3]\n     *\n     * curried(2, 3)(1);\n     * // => [1, 2, 3]\n     *\n     * curried(1, 2, 3);\n     * // => [1, 2, 3]\n     *\n     * // using placeholders\n     * curried(3)(1, _)(2);\n     * // => [1, 2, 3]\n     */\n    var curryRight = createCurry(CURRY_RIGHT_FLAG);\n\n    /**\n     * Creates a debounced function that delays invoking `func` until after `wait`\n     * milliseconds have elapsed since the last time the debounced function was\n     * invoked. The debounced function comes with a `cancel` method to cancel\n     * delayed invocations. Provide an options object to indicate that `func`\n     * should be invoked on the leading and/or trailing edge of the `wait` timeout.\n     * Subsequent calls to the debounced function return the result of the last\n     * `func` invocation.\n     *\n     * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked\n     * on the trailing edge of the timeout only if the the debounced function is\n     * invoked more than once during the `wait` timeout.\n     *\n     * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)\n     * for details over the differences between `_.debounce` and `_.throttle`.\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {Function} func The function to debounce.\n     * @param {number} [wait=0] The number of milliseconds to delay.\n     * @param {Object} [options] The options object.\n     * @param {boolean} [options.leading=false] Specify invoking on the leading\n     *  edge of the timeout.\n     * @param {number} [options.maxWait] The maximum time `func` is allowed to be\n     *  delayed before it is invoked.\n     * @param {boolean} [options.trailing=true] Specify invoking on the trailing\n     *  edge of the timeout.\n     * @returns {Function} Returns the new debounced function.\n     * @example\n     *\n     * // avoid costly calculations while the window size is in flux\n     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n     *\n     * // invoke `sendMail` when the click event is fired, debouncing subsequent calls\n     * jQuery('#postbox').on('click', _.debounce(sendMail, 300, {\n     *   'leading': true,\n     *   'trailing': false\n     * }));\n     *\n     * // ensure `batchLog` is invoked once after 1 second of debounced calls\n     * var source = new EventSource('/stream');\n     * jQuery(source).on('message', _.debounce(batchLog, 250, {\n     *   'maxWait': 1000\n     * }));\n     *\n     * // cancel a debounced call\n     * var todoChanges = _.debounce(batchLog, 1000);\n     * Object.observe(models.todo, todoChanges);\n     *\n     * Object.observe(models, function(changes) {\n     *   if (_.find(changes, { 'user': 'todo', 'type': 'delete'})) {\n     *     todoChanges.cancel();\n     *   }\n     * }, ['delete']);\n     *\n     * // ...at some point `models.todo` is changed\n     * models.todo.completed = true;\n     *\n     * // ...before 1 second has passed `models.todo` is deleted\n     * // which cancels the debounced `todoChanges` call\n     * delete models.todo;\n     */\n    function debounce(func, wait, options) {\n      var args,\n          maxTimeoutId,\n          result,\n          stamp,\n          thisArg,\n          timeoutId,\n          trailingCall,\n          lastCalled = 0,\n          maxWait = false,\n          trailing = true;\n\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      wait = wait < 0 ? 0 : (+wait || 0);\n      if (options === true) {\n        var leading = true;\n        trailing = false;\n      } else if (isObject(options)) {\n        leading = !!options.leading;\n        maxWait = 'maxWait' in options && nativeMax(+options.maxWait || 0, wait);\n        trailing = 'trailing' in options ? !!options.trailing : trailing;\n      }\n\n      function cancel() {\n        if (timeoutId) {\n          clearTimeout(timeoutId);\n        }\n        if (maxTimeoutId) {\n          clearTimeout(maxTimeoutId);\n        }\n        lastCalled = 0;\n        maxTimeoutId = timeoutId = trailingCall = undefined;\n      }\n\n      function complete(isCalled, id) {\n        if (id) {\n          clearTimeout(id);\n        }\n        maxTimeoutId = timeoutId = trailingCall = undefined;\n        if (isCalled) {\n          lastCalled = now();\n          result = func.apply(thisArg, args);\n          if (!timeoutId && !maxTimeoutId) {\n            args = thisArg = undefined;\n          }\n        }\n      }\n\n      function delayed() {\n        var remaining = wait - (now() - stamp);\n        if (remaining <= 0 || remaining > wait) {\n          complete(trailingCall, maxTimeoutId);\n        } else {\n          timeoutId = setTimeout(delayed, remaining);\n        }\n      }\n\n      function maxDelayed() {\n        complete(trailing, timeoutId);\n      }\n\n      function debounced() {\n        args = arguments;\n        stamp = now();\n        thisArg = this;\n        trailingCall = trailing && (timeoutId || !leading);\n\n        if (maxWait === false) {\n          var leadingCall = leading && !timeoutId;\n        } else {\n          if (!maxTimeoutId && !leading) {\n            lastCalled = stamp;\n          }\n          var remaining = maxWait - (stamp - lastCalled),\n              isCalled = remaining <= 0 || remaining > maxWait;\n\n          if (isCalled) {\n            if (maxTimeoutId) {\n              maxTimeoutId = clearTimeout(maxTimeoutId);\n            }\n            lastCalled = stamp;\n            result = func.apply(thisArg, args);\n          }\n          else if (!maxTimeoutId) {\n            maxTimeoutId = setTimeout(maxDelayed, remaining);\n          }\n        }\n        if (isCalled && timeoutId) {\n          timeoutId = clearTimeout(timeoutId);\n        }\n        else if (!timeoutId && wait !== maxWait) {\n          timeoutId = setTimeout(delayed, wait);\n        }\n        if (leadingCall) {\n          isCalled = true;\n          result = func.apply(thisArg, args);\n        }\n        if (isCalled && !timeoutId && !maxTimeoutId) {\n          args = thisArg = undefined;\n        }\n        return result;\n      }\n      debounced.cancel = cancel;\n      return debounced;\n    }\n\n    /**\n     * Defers invoking the `func` until the current call stack has cleared. Any\n     * additional arguments are provided to `func` when it is invoked.\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {Function} func The function to defer.\n     * @param {...*} [args] The arguments to invoke the function with.\n     * @returns {number} Returns the timer id.\n     * @example\n     *\n     * _.defer(function(text) {\n     *   console.log(text);\n     * }, 'deferred');\n     * // logs 'deferred' after one or more milliseconds\n     */\n    var defer = restParam(function(func, args) {\n      return baseDelay(func, 1, args);\n    });\n\n    /**\n     * Invokes `func` after `wait` milliseconds. Any additional arguments are\n     * provided to `func` when it is invoked.\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {Function} func The function to delay.\n     * @param {number} wait The number of milliseconds to delay invocation.\n     * @param {...*} [args] The arguments to invoke the function with.\n     * @returns {number} Returns the timer id.\n     * @example\n     *\n     * _.delay(function(text) {\n     *   console.log(text);\n     * }, 1000, 'later');\n     * // => logs 'later' after one second\n     */\n    var delay = restParam(function(func, wait, args) {\n      return baseDelay(func, wait, args);\n    });\n\n    /**\n     * Creates a function that returns the result of invoking the provided\n     * functions with the `this` binding of the created function, where each\n     * successive invocation is supplied the return value of the previous.\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {...Function} [funcs] Functions to invoke.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * var addSquare = _.flow(_.add, square);\n     * addSquare(1, 2);\n     * // => 9\n     */\n    var flow = createFlow();\n\n    /**\n     * This method is like `_.flow` except that it creates a function that\n     * invokes the provided functions from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @alias backflow, compose\n     * @category Function\n     * @param {...Function} [funcs] Functions to invoke.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * var addSquare = _.flowRight(square, _.add);\n     * addSquare(1, 2);\n     * // => 9\n     */\n    var flowRight = createFlow(true);\n\n    /**\n     * Creates a function that memoizes the result of `func`. If `resolver` is\n     * provided it determines the cache key for storing the result based on the\n     * arguments provided to the memoized function. By default, the first argument\n     * provided to the memoized function is coerced to a string and used as the\n     * cache key. The `func` is invoked with the `this` binding of the memoized\n     * function.\n     *\n     * **Note:** The cache is exposed as the `cache` property on the memoized\n     * function. Its creation may be customized by replacing the `_.memoize.Cache`\n     * constructor with one whose instances implement the [`Map`](http://ecma-international.org/ecma-262/6.0/#sec-properties-of-the-map-prototype-object)\n     * method interface of `get`, `has`, and `set`.\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {Function} func The function to have its output memoized.\n     * @param {Function} [resolver] The function to resolve the cache key.\n     * @returns {Function} Returns the new memoizing function.\n     * @example\n     *\n     * var upperCase = _.memoize(function(string) {\n     *   return string.toUpperCase();\n     * });\n     *\n     * upperCase('fred');\n     * // => 'FRED'\n     *\n     * // modifying the result cache\n     * upperCase.cache.set('fred', 'BARNEY');\n     * upperCase('fred');\n     * // => 'BARNEY'\n     *\n     * // replacing `_.memoize.Cache`\n     * var object = { 'user': 'fred' };\n     * var other = { 'user': 'barney' };\n     * var identity = _.memoize(_.identity);\n     *\n     * identity(object);\n     * // => { 'user': 'fred' }\n     * identity(other);\n     * // => { 'user': 'fred' }\n     *\n     * _.memoize.Cache = WeakMap;\n     * var identity = _.memoize(_.identity);\n     *\n     * identity(object);\n     * // => { 'user': 'fred' }\n     * identity(other);\n     * // => { 'user': 'barney' }\n     */\n    function memoize(func, resolver) {\n      if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      var memoized = function() {\n        var args = arguments,\n            key = resolver ? resolver.apply(this, args) : args[0],\n            cache = memoized.cache;\n\n        if (cache.has(key)) {\n          return cache.get(key);\n        }\n        var result = func.apply(this, args);\n        memoized.cache = cache.set(key, result);\n        return result;\n      };\n      memoized.cache = new memoize.Cache;\n      return memoized;\n    }\n\n    /**\n     * Creates a function that runs each argument through a corresponding\n     * transform function.\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {Function} func The function to wrap.\n     * @param {...(Function|Function[])} [transforms] The functions to transform\n     * arguments, specified as individual functions or arrays of functions.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * function doubled(n) {\n     *   return n * 2;\n     * }\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * var modded = _.modArgs(function(x, y) {\n     *   return [x, y];\n     * }, square, doubled);\n     *\n     * modded(1, 2);\n     * // => [1, 4]\n     *\n     * modded(5, 10);\n     * // => [25, 20]\n     */\n    var modArgs = restParam(function(func, transforms) {\n      transforms = baseFlatten(transforms);\n      if (typeof func != 'function' || !arrayEvery(transforms, baseIsFunction)) {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      var length = transforms.length;\n      return restParam(function(args) {\n        var index = nativeMin(args.length, length);\n        while (index--) {\n          args[index] = transforms[index](args[index]);\n        }\n        return func.apply(this, args);\n      });\n    });\n\n    /**\n     * Creates a function that negates the result of the predicate `func`. The\n     * `func` predicate is invoked with the `this` binding and arguments of the\n     * created function.\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {Function} predicate The predicate to negate.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * function isEven(n) {\n     *   return n % 2 == 0;\n     * }\n     *\n     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));\n     * // => [1, 3, 5]\n     */\n    function negate(predicate) {\n      if (typeof predicate != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      return function() {\n        return !predicate.apply(this, arguments);\n      };\n    }\n\n    /**\n     * Creates a function that is restricted to invoking `func` once. Repeat calls\n     * to the function return the value of the first call. The `func` is invoked\n     * with the `this` binding and arguments of the created function.\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {Function} func The function to restrict.\n     * @returns {Function} Returns the new restricted function.\n     * @example\n     *\n     * var initialize = _.once(createApplication);\n     * initialize();\n     * initialize();\n     * // `initialize` invokes `createApplication` once\n     */\n    function once(func) {\n      return before(2, func);\n    }\n\n    /**\n     * Creates a function that invokes `func` with `partial` arguments prepended\n     * to those provided to the new function. This method is like `_.bind` except\n     * it does **not** alter the `this` binding.\n     *\n     * The `_.partial.placeholder` value, which defaults to `_` in monolithic\n     * builds, may be used as a placeholder for partially applied arguments.\n     *\n     * **Note:** This method does not set the \"length\" property of partially\n     * applied functions.\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {Function} func The function to partially apply arguments to.\n     * @param {...*} [partials] The arguments to be partially applied.\n     * @returns {Function} Returns the new partially applied function.\n     * @example\n     *\n     * var greet = function(greeting, name) {\n     *   return greeting + ' ' + name;\n     * };\n     *\n     * var sayHelloTo = _.partial(greet, 'hello');\n     * sayHelloTo('fred');\n     * // => 'hello fred'\n     *\n     * // using placeholders\n     * var greetFred = _.partial(greet, _, 'fred');\n     * greetFred('hi');\n     * // => 'hi fred'\n     */\n    var partial = createPartial(PARTIAL_FLAG);\n\n    /**\n     * This method is like `_.partial` except that partially applied arguments\n     * are appended to those provided to the new function.\n     *\n     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic\n     * builds, may be used as a placeholder for partially applied arguments.\n     *\n     * **Note:** This method does not set the \"length\" property of partially\n     * applied functions.\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {Function} func The function to partially apply arguments to.\n     * @param {...*} [partials] The arguments to be partially applied.\n     * @returns {Function} Returns the new partially applied function.\n     * @example\n     *\n     * var greet = function(greeting, name) {\n     *   return greeting + ' ' + name;\n     * };\n     *\n     * var greetFred = _.partialRight(greet, 'fred');\n     * greetFred('hi');\n     * // => 'hi fred'\n     *\n     * // using placeholders\n     * var sayHelloTo = _.partialRight(greet, 'hello', _);\n     * sayHelloTo('fred');\n     * // => 'hello fred'\n     */\n    var partialRight = createPartial(PARTIAL_RIGHT_FLAG);\n\n    /**\n     * Creates a function that invokes `func` with arguments arranged according\n     * to the specified indexes where the argument value at the first index is\n     * provided as the first argument, the argument value at the second index is\n     * provided as the second argument, and so on.\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {Function} func The function to rearrange arguments for.\n     * @param {...(number|number[])} indexes The arranged argument indexes,\n     *  specified as individual indexes or arrays of indexes.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var rearged = _.rearg(function(a, b, c) {\n     *   return [a, b, c];\n     * }, 2, 0, 1);\n     *\n     * rearged('b', 'c', 'a')\n     * // => ['a', 'b', 'c']\n     *\n     * var map = _.rearg(_.map, [1, 0]);\n     * map(function(n) {\n     *   return n * 3;\n     * }, [1, 2, 3]);\n     * // => [3, 6, 9]\n     */\n    var rearg = restParam(function(func, indexes) {\n      return createWrapper(func, REARG_FLAG, undefined, undefined, undefined, baseFlatten(indexes));\n    });\n\n    /**\n     * Creates a function that invokes `func` with the `this` binding of the\n     * created function and arguments from `start` and beyond provided as an array.\n     *\n     * **Note:** This method is based on the [rest parameter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters).\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {Function} func The function to apply a rest parameter to.\n     * @param {number} [start=func.length-1] The start position of the rest parameter.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var say = _.restParam(function(what, names) {\n     *   return what + ' ' + _.initial(names).join(', ') +\n     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);\n     * });\n     *\n     * say('hello', 'fred', 'barney', 'pebbles');\n     * // => 'hello fred, barney, & pebbles'\n     */\n    function restParam(func, start) {\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      start = nativeMax(start === undefined ? (func.length - 1) : (+start || 0), 0);\n      return function() {\n        var args = arguments,\n            index = -1,\n            length = nativeMax(args.length - start, 0),\n            rest = Array(length);\n\n        while (++index < length) {\n          rest[index] = args[start + index];\n        }\n        switch (start) {\n          case 0: return func.call(this, rest);\n          case 1: return func.call(this, args[0], rest);\n          case 2: return func.call(this, args[0], args[1], rest);\n        }\n        var otherArgs = Array(start + 1);\n        index = -1;\n        while (++index < start) {\n          otherArgs[index] = args[index];\n        }\n        otherArgs[start] = rest;\n        return func.apply(this, otherArgs);\n      };\n    }\n\n    /**\n     * Creates a function that invokes `func` with the `this` binding of the created\n     * function and an array of arguments much like [`Function#apply`](https://es5.github.io/#x15.3.4.3).\n     *\n     * **Note:** This method is based on the [spread operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator).\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {Function} func The function to spread arguments over.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var say = _.spread(function(who, what) {\n     *   return who + ' says ' + what;\n     * });\n     *\n     * say(['fred', 'hello']);\n     * // => 'fred says hello'\n     *\n     * // with a Promise\n     * var numbers = Promise.all([\n     *   Promise.resolve(40),\n     *   Promise.resolve(36)\n     * ]);\n     *\n     * numbers.then(_.spread(function(x, y) {\n     *   return x + y;\n     * }));\n     * // => a Promise of 76\n     */\n    function spread(func) {\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      return function(array) {\n        return func.apply(this, array);\n      };\n    }\n\n    /**\n     * Creates a throttled function that only invokes `func` at most once per\n     * every `wait` milliseconds. The throttled function comes with a `cancel`\n     * method to cancel delayed invocations. Provide an options object to indicate\n     * that `func` should be invoked on the leading and/or trailing edge of the\n     * `wait` timeout. Subsequent calls to the throttled function return the\n     * result of the last `func` call.\n     *\n     * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked\n     * on the trailing edge of the timeout only if the the throttled function is\n     * invoked more than once during the `wait` timeout.\n     *\n     * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)\n     * for details over the differences between `_.throttle` and `_.debounce`.\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {Function} func The function to throttle.\n     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.\n     * @param {Object} [options] The options object.\n     * @param {boolean} [options.leading=true] Specify invoking on the leading\n     *  edge of the timeout.\n     * @param {boolean} [options.trailing=true] Specify invoking on the trailing\n     *  edge of the timeout.\n     * @returns {Function} Returns the new throttled function.\n     * @example\n     *\n     * // avoid excessively updating the position while scrolling\n     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));\n     *\n     * // invoke `renewToken` when the click event is fired, but not more than once every 5 minutes\n     * jQuery('.interactive').on('click', _.throttle(renewToken, 300000, {\n     *   'trailing': false\n     * }));\n     *\n     * // cancel a trailing throttled call\n     * jQuery(window).on('popstate', throttled.cancel);\n     */\n    function throttle(func, wait, options) {\n      var leading = true,\n          trailing = true;\n\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      if (options === false) {\n        leading = false;\n      } else if (isObject(options)) {\n        leading = 'leading' in options ? !!options.leading : leading;\n        trailing = 'trailing' in options ? !!options.trailing : trailing;\n      }\n      return debounce(func, wait, { 'leading': leading, 'maxWait': +wait, 'trailing': trailing });\n    }\n\n    /**\n     * Creates a function that provides `value` to the wrapper function as its\n     * first argument. Any additional arguments provided to the function are\n     * appended to those provided to the wrapper function. The wrapper is invoked\n     * with the `this` binding of the created function.\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {*} value The value to wrap.\n     * @param {Function} wrapper The wrapper function.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var p = _.wrap(_.escape, function(func, text) {\n     *   return '<p>' + func(text) + '</p>';\n     * });\n     *\n     * p('fred, barney, & pebbles');\n     * // => '<p>fred, barney, &amp; pebbles</p>'\n     */\n    function wrap(value, wrapper) {\n      wrapper = wrapper == null ? identity : wrapper;\n      return createWrapper(wrapper, PARTIAL_FLAG, undefined, [value], []);\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a clone of `value`. If `isDeep` is `true` nested objects are cloned,\n     * otherwise they are assigned by reference. If `customizer` is provided it is\n     * invoked to produce the cloned values. If `customizer` returns `undefined`\n     * cloning is handled by the method instead. The `customizer` is bound to\n     * `thisArg` and invoked with two argument; (value [, index|key, object]).\n     *\n     * **Note:** This method is loosely based on the\n     * [structured clone algorithm](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm).\n     * The enumerable properties of `arguments` objects and objects created by\n     * constructors other than `Object` are cloned to plain `Object` objects. An\n     * empty object is returned for uncloneable values such as functions, DOM nodes,\n     * Maps, Sets, and WeakMaps.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to clone.\n     * @param {boolean} [isDeep] Specify a deep clone.\n     * @param {Function} [customizer] The function to customize cloning values.\n     * @param {*} [thisArg] The `this` binding of `customizer`.\n     * @returns {*} Returns the cloned value.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney' },\n     *   { 'user': 'fred' }\n     * ];\n     *\n     * var shallow = _.clone(users);\n     * shallow[0] === users[0];\n     * // => true\n     *\n     * var deep = _.clone(users, true);\n     * deep[0] === users[0];\n     * // => false\n     *\n     * // using a customizer callback\n     * var el = _.clone(document.body, function(value) {\n     *   if (_.isElement(value)) {\n     *     return value.cloneNode(false);\n     *   }\n     * });\n     *\n     * el === document.body\n     * // => false\n     * el.nodeName\n     * // => BODY\n     * el.childNodes.length;\n     * // => 0\n     */\n    function clone(value, isDeep, customizer, thisArg) {\n      if (isDeep && typeof isDeep != 'boolean' && isIterateeCall(value, isDeep, customizer)) {\n        isDeep = false;\n      }\n      else if (typeof isDeep == 'function') {\n        thisArg = customizer;\n        customizer = isDeep;\n        isDeep = false;\n      }\n      return typeof customizer == 'function'\n        ? baseClone(value, isDeep, bindCallback(customizer, thisArg, 1))\n        : baseClone(value, isDeep);\n    }\n\n    /**\n     * Creates a deep clone of `value`. If `customizer` is provided it is invoked\n     * to produce the cloned values. If `customizer` returns `undefined` cloning\n     * is handled by the method instead. The `customizer` is bound to `thisArg`\n     * and invoked with two argument; (value [, index|key, object]).\n     *\n     * **Note:** This method is loosely based on the\n     * [structured clone algorithm](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm).\n     * The enumerable properties of `arguments` objects and objects created by\n     * constructors other than `Object` are cloned to plain `Object` objects. An\n     * empty object is returned for uncloneable values such as functions, DOM nodes,\n     * Maps, Sets, and WeakMaps.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to deep clone.\n     * @param {Function} [customizer] The function to customize cloning values.\n     * @param {*} [thisArg] The `this` binding of `customizer`.\n     * @returns {*} Returns the deep cloned value.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney' },\n     *   { 'user': 'fred' }\n     * ];\n     *\n     * var deep = _.cloneDeep(users);\n     * deep[0] === users[0];\n     * // => false\n     *\n     * // using a customizer callback\n     * var el = _.cloneDeep(document.body, function(value) {\n     *   if (_.isElement(value)) {\n     *     return value.cloneNode(true);\n     *   }\n     * });\n     *\n     * el === document.body\n     * // => false\n     * el.nodeName\n     * // => BODY\n     * el.childNodes.length;\n     * // => 20\n     */\n    function cloneDeep(value, customizer, thisArg) {\n      return typeof customizer == 'function'\n        ? baseClone(value, true, bindCallback(customizer, thisArg, 1))\n        : baseClone(value, true);\n    }\n\n    /**\n     * Checks if `value` is greater than `other`.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is greater than `other`, else `false`.\n     * @example\n     *\n     * _.gt(3, 1);\n     * // => true\n     *\n     * _.gt(3, 3);\n     * // => false\n     *\n     * _.gt(1, 3);\n     * // => false\n     */\n    function gt(value, other) {\n      return value > other;\n    }\n\n    /**\n     * Checks if `value` is greater than or equal to `other`.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is greater than or equal to `other`, else `false`.\n     * @example\n     *\n     * _.gte(3, 1);\n     * // => true\n     *\n     * _.gte(3, 3);\n     * // => true\n     *\n     * _.gte(1, 3);\n     * // => false\n     */\n    function gte(value, other) {\n      return value >= other;\n    }\n\n    /**\n     * Checks if `value` is classified as an `arguments` object.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n     * @example\n     *\n     * _.isArguments(function() { return arguments; }());\n     * // => true\n     *\n     * _.isArguments([1, 2, 3]);\n     * // => false\n     */\n    function isArguments(value) {\n      return isObjectLike(value) && isArrayLike(value) &&\n        hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');\n    }\n\n    /**\n     * Checks if `value` is classified as an `Array` object.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n     * @example\n     *\n     * _.isArray([1, 2, 3]);\n     * // => true\n     *\n     * _.isArray(function() { return arguments; }());\n     * // => false\n     */\n    var isArray = nativeIsArray || function(value) {\n      return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag;\n    };\n\n    /**\n     * Checks if `value` is classified as a boolean primitive or object.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n     * @example\n     *\n     * _.isBoolean(false);\n     * // => true\n     *\n     * _.isBoolean(null);\n     * // => false\n     */\n    function isBoolean(value) {\n      return value === true || value === false || (isObjectLike(value) && objToString.call(value) == boolTag);\n    }\n\n    /**\n     * Checks if `value` is classified as a `Date` object.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n     * @example\n     *\n     * _.isDate(new Date);\n     * // => true\n     *\n     * _.isDate('Mon April 23 2012');\n     * // => false\n     */\n    function isDate(value) {\n      return isObjectLike(value) && objToString.call(value) == dateTag;\n    }\n\n    /**\n     * Checks if `value` is a DOM element.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.\n     * @example\n     *\n     * _.isElement(document.body);\n     * // => true\n     *\n     * _.isElement('<body>');\n     * // => false\n     */\n    function isElement(value) {\n      return !!value && value.nodeType === 1 && isObjectLike(value) && !isPlainObject(value);\n    }\n\n    /**\n     * Checks if `value` is empty. A value is considered empty unless it is an\n     * `arguments` object, array, string, or jQuery-like collection with a length\n     * greater than `0` or an object with own enumerable properties.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {Array|Object|string} value The value to inspect.\n     * @returns {boolean} Returns `true` if `value` is empty, else `false`.\n     * @example\n     *\n     * _.isEmpty(null);\n     * // => true\n     *\n     * _.isEmpty(true);\n     * // => true\n     *\n     * _.isEmpty(1);\n     * // => true\n     *\n     * _.isEmpty([1, 2, 3]);\n     * // => false\n     *\n     * _.isEmpty({ 'a': 1 });\n     * // => false\n     */\n    function isEmpty(value) {\n      if (value == null) {\n        return true;\n      }\n      if (isArrayLike(value) && (isArray(value) || isString(value) || isArguments(value) ||\n          (isObjectLike(value) && isFunction(value.splice)))) {\n        return !value.length;\n      }\n      return !keys(value).length;\n    }\n\n    /**\n     * Performs a deep comparison between two values to determine if they are\n     * equivalent. If `customizer` is provided it is invoked to compare values.\n     * If `customizer` returns `undefined` comparisons are handled by the method\n     * instead. The `customizer` is bound to `thisArg` and invoked with three\n     * arguments: (value, other [, index|key]).\n     *\n     * **Note:** This method supports comparing arrays, booleans, `Date` objects,\n     * numbers, `Object` objects, regexes, and strings. Objects are compared by\n     * their own, not inherited, enumerable properties. Functions and DOM nodes\n     * are **not** supported. Provide a customizer function to extend support\n     * for comparing other values.\n     *\n     * @static\n     * @memberOf _\n     * @alias eq\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @param {Function} [customizer] The function to customize value comparisons.\n     * @param {*} [thisArg] The `this` binding of `customizer`.\n     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n     * @example\n     *\n     * var object = { 'user': 'fred' };\n     * var other = { 'user': 'fred' };\n     *\n     * object == other;\n     * // => false\n     *\n     * _.isEqual(object, other);\n     * // => true\n     *\n     * // using a customizer callback\n     * var array = ['hello', 'goodbye'];\n     * var other = ['hi', 'goodbye'];\n     *\n     * _.isEqual(array, other, function(value, other) {\n     *   if (_.every([value, other], RegExp.prototype.test, /^h(?:i|ello)$/)) {\n     *     return true;\n     *   }\n     * });\n     * // => true\n     */\n    function isEqual(value, other, customizer, thisArg) {\n      customizer = typeof customizer == 'function' ? bindCallback(customizer, thisArg, 3) : undefined;\n      var result = customizer ? customizer(value, other) : undefined;\n      return  result === undefined ? baseIsEqual(value, other, customizer) : !!result;\n    }\n\n    /**\n     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,\n     * `SyntaxError`, `TypeError`, or `URIError` object.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.\n     * @example\n     *\n     * _.isError(new Error);\n     * // => true\n     *\n     * _.isError(Error);\n     * // => false\n     */\n    function isError(value) {\n      return isObjectLike(value) && typeof value.message == 'string' && objToString.call(value) == errorTag;\n    }\n\n    /**\n     * Checks if `value` is a finite primitive number.\n     *\n     * **Note:** This method is based on [`Number.isFinite`](http://ecma-international.org/ecma-262/6.0/#sec-number.isfinite).\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.\n     * @example\n     *\n     * _.isFinite(10);\n     * // => true\n     *\n     * _.isFinite('10');\n     * // => false\n     *\n     * _.isFinite(true);\n     * // => false\n     *\n     * _.isFinite(Object(10));\n     * // => false\n     *\n     * _.isFinite(Infinity);\n     * // => false\n     */\n    function isFinite(value) {\n      return typeof value == 'number' && nativeIsFinite(value);\n    }\n\n    /**\n     * Checks if `value` is classified as a `Function` object.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n     * @example\n     *\n     * _.isFunction(_);\n     * // => true\n     *\n     * _.isFunction(/abc/);\n     * // => false\n     */\n    function isFunction(value) {\n      // The use of `Object#toString` avoids issues with the `typeof` operator\n      // in older versions of Chrome and Safari which return 'function' for regexes\n      // and Safari 8 equivalents which return 'object' for typed array constructors.\n      return isObject(value) && objToString.call(value) == funcTag;\n    }\n\n    /**\n     * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.\n     * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n     * @example\n     *\n     * _.isObject({});\n     * // => true\n     *\n     * _.isObject([1, 2, 3]);\n     * // => true\n     *\n     * _.isObject(1);\n     * // => false\n     */\n    function isObject(value) {\n      // Avoid a V8 JIT bug in Chrome 19-20.\n      // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n      var type = typeof value;\n      return !!value && (type == 'object' || type == 'function');\n    }\n\n    /**\n     * Performs a deep comparison between `object` and `source` to determine if\n     * `object` contains equivalent property values. If `customizer` is provided\n     * it is invoked to compare values. If `customizer` returns `undefined`\n     * comparisons are handled by the method instead. The `customizer` is bound\n     * to `thisArg` and invoked with three arguments: (value, other, index|key).\n     *\n     * **Note:** This method supports comparing properties of arrays, booleans,\n     * `Date` objects, numbers, `Object` objects, regexes, and strings. Functions\n     * and DOM nodes are **not** supported. Provide a customizer function to extend\n     * support for comparing other values.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {Object} object The object to inspect.\n     * @param {Object} source The object of property values to match.\n     * @param {Function} [customizer] The function to customize value comparisons.\n     * @param {*} [thisArg] The `this` binding of `customizer`.\n     * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n     * @example\n     *\n     * var object = { 'user': 'fred', 'age': 40 };\n     *\n     * _.isMatch(object, { 'age': 40 });\n     * // => true\n     *\n     * _.isMatch(object, { 'age': 36 });\n     * // => false\n     *\n     * // using a customizer callback\n     * var object = { 'greeting': 'hello' };\n     * var source = { 'greeting': 'hi' };\n     *\n     * _.isMatch(object, source, function(value, other) {\n     *   return _.every([value, other], RegExp.prototype.test, /^h(?:i|ello)$/) || undefined;\n     * });\n     * // => true\n     */\n    function isMatch(object, source, customizer, thisArg) {\n      customizer = typeof customizer == 'function' ? bindCallback(customizer, thisArg, 3) : undefined;\n      return baseIsMatch(object, getMatchData(source), customizer);\n    }\n\n    /**\n     * Checks if `value` is `NaN`.\n     *\n     * **Note:** This method is not the same as [`isNaN`](https://es5.github.io/#x15.1.2.4)\n     * which returns `true` for `undefined` and other non-numeric values.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.\n     * @example\n     *\n     * _.isNaN(NaN);\n     * // => true\n     *\n     * _.isNaN(new Number(NaN));\n     * // => true\n     *\n     * isNaN(undefined);\n     * // => true\n     *\n     * _.isNaN(undefined);\n     * // => false\n     */\n    function isNaN(value) {\n      // An `NaN` primitive is the only value that is not equal to itself.\n      // Perform the `toStringTag` check first to avoid errors with some host objects in IE.\n      return isNumber(value) && value != +value;\n    }\n\n    /**\n     * Checks if `value` is a native function.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a native function, else `false`.\n     * @example\n     *\n     * _.isNative(Array.prototype.push);\n     * // => true\n     *\n     * _.isNative(_);\n     * // => false\n     */\n    function isNative(value) {\n      if (value == null) {\n        return false;\n      }\n      if (isFunction(value)) {\n        return reIsNative.test(fnToString.call(value));\n      }\n      return isObjectLike(value) && reIsHostCtor.test(value);\n    }\n\n    /**\n     * Checks if `value` is `null`.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.\n     * @example\n     *\n     * _.isNull(null);\n     * // => true\n     *\n     * _.isNull(void 0);\n     * // => false\n     */\n    function isNull(value) {\n      return value === null;\n    }\n\n    /**\n     * Checks if `value` is classified as a `Number` primitive or object.\n     *\n     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are classified\n     * as numbers, use the `_.isFinite` method.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n     * @example\n     *\n     * _.isNumber(8.4);\n     * // => true\n     *\n     * _.isNumber(NaN);\n     * // => true\n     *\n     * _.isNumber('8.4');\n     * // => false\n     */\n    function isNumber(value) {\n      return typeof value == 'number' || (isObjectLike(value) && objToString.call(value) == numberTag);\n    }\n\n    /**\n     * Checks if `value` is a plain object, that is, an object created by the\n     * `Object` constructor or one with a `[[Prototype]]` of `null`.\n     *\n     * **Note:** This method assumes objects created by the `Object` constructor\n     * have no inherited enumerable properties.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     * }\n     *\n     * _.isPlainObject(new Foo);\n     * // => false\n     *\n     * _.isPlainObject([1, 2, 3]);\n     * // => false\n     *\n     * _.isPlainObject({ 'x': 0, 'y': 0 });\n     * // => true\n     *\n     * _.isPlainObject(Object.create(null));\n     * // => true\n     */\n    function isPlainObject(value) {\n      var Ctor;\n\n      // Exit early for non `Object` objects.\n      if (!(isObjectLike(value) && objToString.call(value) == objectTag && !isArguments(value)) ||\n          (!hasOwnProperty.call(value, 'constructor') && (Ctor = value.constructor, typeof Ctor == 'function' && !(Ctor instanceof Ctor)))) {\n        return false;\n      }\n      // IE < 9 iterates inherited properties before own properties. If the first\n      // iterated property is an object's own property then there are no inherited\n      // enumerable properties.\n      var result;\n      // In most environments an object's own properties are iterated before\n      // its inherited properties. If the last iterated property is an object's\n      // own property then there are no inherited enumerable properties.\n      baseForIn(value, function(subValue, key) {\n        result = key;\n      });\n      return result === undefined || hasOwnProperty.call(value, result);\n    }\n\n    /**\n     * Checks if `value` is classified as a `RegExp` object.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n     * @example\n     *\n     * _.isRegExp(/abc/);\n     * // => true\n     *\n     * _.isRegExp('/abc/');\n     * // => false\n     */\n    function isRegExp(value) {\n      return isObject(value) && objToString.call(value) == regexpTag;\n    }\n\n    /**\n     * Checks if `value` is classified as a `String` primitive or object.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n     * @example\n     *\n     * _.isString('abc');\n     * // => true\n     *\n     * _.isString(1);\n     * // => false\n     */\n    function isString(value) {\n      return typeof value == 'string' || (isObjectLike(value) && objToString.call(value) == stringTag);\n    }\n\n    /**\n     * Checks if `value` is classified as a typed array.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n     * @example\n     *\n     * _.isTypedArray(new Uint8Array);\n     * // => true\n     *\n     * _.isTypedArray([]);\n     * // => false\n     */\n    function isTypedArray(value) {\n      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objToString.call(value)];\n    }\n\n    /**\n     * Checks if `value` is `undefined`.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.\n     * @example\n     *\n     * _.isUndefined(void 0);\n     * // => true\n     *\n     * _.isUndefined(null);\n     * // => false\n     */\n    function isUndefined(value) {\n      return value === undefined;\n    }\n\n    /**\n     * Checks if `value` is less than `other`.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is less than `other`, else `false`.\n     * @example\n     *\n     * _.lt(1, 3);\n     * // => true\n     *\n     * _.lt(3, 3);\n     * // => false\n     *\n     * _.lt(3, 1);\n     * // => false\n     */\n    function lt(value, other) {\n      return value < other;\n    }\n\n    /**\n     * Checks if `value` is less than or equal to `other`.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is less than or equal to `other`, else `false`.\n     * @example\n     *\n     * _.lte(1, 3);\n     * // => true\n     *\n     * _.lte(3, 3);\n     * // => true\n     *\n     * _.lte(3, 1);\n     * // => false\n     */\n    function lte(value, other) {\n      return value <= other;\n    }\n\n    /**\n     * Converts `value` to an array.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {Array} Returns the converted array.\n     * @example\n     *\n     * (function() {\n     *   return _.toArray(arguments).slice(1);\n     * }(1, 2, 3));\n     * // => [2, 3]\n     */\n    function toArray(value) {\n      var length = value ? getLength(value) : 0;\n      if (!isLength(length)) {\n        return values(value);\n      }\n      if (!length) {\n        return [];\n      }\n      return arrayCopy(value);\n    }\n\n    /**\n     * Converts `value` to a plain object flattening inherited enumerable\n     * properties of `value` to own properties of the plain object.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {Object} Returns the converted plain object.\n     * @example\n     *\n     * function Foo() {\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.assign({ 'a': 1 }, new Foo);\n     * // => { 'a': 1, 'b': 2 }\n     *\n     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));\n     * // => { 'a': 1, 'b': 2, 'c': 3 }\n     */\n    function toPlainObject(value) {\n      return baseCopy(value, keysIn(value));\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Recursively merges own enumerable properties of the source object(s), that\n     * don't resolve to `undefined` into the destination object. Subsequent sources\n     * overwrite property assignments of previous sources. If `customizer` is\n     * provided it is invoked to produce the merged values of the destination and\n     * source properties. If `customizer` returns `undefined` merging is handled\n     * by the method instead. The `customizer` is bound to `thisArg` and invoked\n     * with five arguments: (objectValue, sourceValue, key, object, source).\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} [sources] The source objects.\n     * @param {Function} [customizer] The function to customize assigned values.\n     * @param {*} [thisArg] The `this` binding of `customizer`.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var users = {\n     *   'data': [{ 'user': 'barney' }, { 'user': 'fred' }]\n     * };\n     *\n     * var ages = {\n     *   'data': [{ 'age': 36 }, { 'age': 40 }]\n     * };\n     *\n     * _.merge(users, ages);\n     * // => { 'data': [{ 'user': 'barney', 'age': 36 }, { 'user': 'fred', 'age': 40 }] }\n     *\n     * // using a customizer callback\n     * var object = {\n     *   'fruits': ['apple'],\n     *   'vegetables': ['beet']\n     * };\n     *\n     * var other = {\n     *   'fruits': ['banana'],\n     *   'vegetables': ['carrot']\n     * };\n     *\n     * _.merge(object, other, function(a, b) {\n     *   if (_.isArray(a)) {\n     *     return a.concat(b);\n     *   }\n     * });\n     * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot'] }\n     */\n    var merge = createAssigner(baseMerge);\n\n    /**\n     * Assigns own enumerable properties of source object(s) to the destination\n     * object. Subsequent sources overwrite property assignments of previous sources.\n     * If `customizer` is provided it is invoked to produce the assigned values.\n     * The `customizer` is bound to `thisArg` and invoked with five arguments:\n     * (objectValue, sourceValue, key, object, source).\n     *\n     * **Note:** This method mutates `object` and is based on\n     * [`Object.assign`](http://ecma-international.org/ecma-262/6.0/#sec-object.assign).\n     *\n     * @static\n     * @memberOf _\n     * @alias extend\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} [sources] The source objects.\n     * @param {Function} [customizer] The function to customize assigned values.\n     * @param {*} [thisArg] The `this` binding of `customizer`.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * _.assign({ 'user': 'barney' }, { 'age': 40 }, { 'user': 'fred' });\n     * // => { 'user': 'fred', 'age': 40 }\n     *\n     * // using a customizer callback\n     * var defaults = _.partialRight(_.assign, function(value, other) {\n     *   return _.isUndefined(value) ? other : value;\n     * });\n     *\n     * defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });\n     * // => { 'user': 'barney', 'age': 36 }\n     */\n    var assign = createAssigner(function(object, source, customizer) {\n      return customizer\n        ? assignWith(object, source, customizer)\n        : baseAssign(object, source);\n    });\n\n    /**\n     * Creates an object that inherits from the given `prototype` object. If a\n     * `properties` object is provided its own enumerable properties are assigned\n     * to the created object.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} prototype The object to inherit from.\n     * @param {Object} [properties] The properties to assign to the object.\n     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * function Shape() {\n     *   this.x = 0;\n     *   this.y = 0;\n     * }\n     *\n     * function Circle() {\n     *   Shape.call(this);\n     * }\n     *\n     * Circle.prototype = _.create(Shape.prototype, {\n     *   'constructor': Circle\n     * });\n     *\n     * var circle = new Circle;\n     * circle instanceof Circle;\n     * // => true\n     *\n     * circle instanceof Shape;\n     * // => true\n     */\n    function create(prototype, properties, guard) {\n      var result = baseCreate(prototype);\n      if (guard && isIterateeCall(prototype, properties, guard)) {\n        properties = undefined;\n      }\n      return properties ? baseAssign(result, properties) : result;\n    }\n\n    /**\n     * Assigns own enumerable properties of source object(s) to the destination\n     * object for all destination properties that resolve to `undefined`. Once a\n     * property is set, additional values of the same property are ignored.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} [sources] The source objects.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * _.defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });\n     * // => { 'user': 'barney', 'age': 36 }\n     */\n    var defaults = createDefaults(assign, assignDefaults);\n\n    /**\n     * This method is like `_.defaults` except that it recursively assigns\n     * default properties.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} [sources] The source objects.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * _.defaultsDeep({ 'user': { 'name': 'barney' } }, { 'user': { 'name': 'fred', 'age': 36 } });\n     * // => { 'user': { 'name': 'barney', 'age': 36 } }\n     *\n     */\n    var defaultsDeep = createDefaults(merge, mergeDefaults);\n\n    /**\n     * This method is like `_.find` except that it returns the key of the first\n     * element `predicate` returns truthy for instead of the element itself.\n     *\n     * If a property name is provided for `predicate` the created `_.property`\n     * style callback returns the property value of the given element.\n     *\n     * If a value is also provided for `thisArg` the created `_.matchesProperty`\n     * style callback returns `true` for elements that have a matching property\n     * value, else `false`.\n     *\n     * If an object is provided for `predicate` the created `_.matches` style\n     * callback returns `true` for elements that have the properties of the given\n     * object, else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to search.\n     * @param {Function|Object|string} [predicate=_.identity] The function invoked\n     *  per iteration.\n     * @param {*} [thisArg] The `this` binding of `predicate`.\n     * @returns {string|undefined} Returns the key of the matched element, else `undefined`.\n     * @example\n     *\n     * var users = {\n     *   'barney':  { 'age': 36, 'active': true },\n     *   'fred':    { 'age': 40, 'active': false },\n     *   'pebbles': { 'age': 1,  'active': true }\n     * };\n     *\n     * _.findKey(users, function(chr) {\n     *   return chr.age < 40;\n     * });\n     * // => 'barney' (iteration order is not guaranteed)\n     *\n     * // using the `_.matches` callback shorthand\n     * _.findKey(users, { 'age': 1, 'active': true });\n     * // => 'pebbles'\n     *\n     * // using the `_.matchesProperty` callback shorthand\n     * _.findKey(users, 'active', false);\n     * // => 'fred'\n     *\n     * // using the `_.property` callback shorthand\n     * _.findKey(users, 'active');\n     * // => 'barney'\n     */\n    var findKey = createFindKey(baseForOwn);\n\n    /**\n     * This method is like `_.findKey` except that it iterates over elements of\n     * a collection in the opposite order.\n     *\n     * If a property name is provided for `predicate` the created `_.property`\n     * style callback returns the property value of the given element.\n     *\n     * If a value is also provided for `thisArg` the created `_.matchesProperty`\n     * style callback returns `true` for elements that have a matching property\n     * value, else `false`.\n     *\n     * If an object is provided for `predicate` the created `_.matches` style\n     * callback returns `true` for elements that have the properties of the given\n     * object, else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to search.\n     * @param {Function|Object|string} [predicate=_.identity] The function invoked\n     *  per iteration.\n     * @param {*} [thisArg] The `this` binding of `predicate`.\n     * @returns {string|undefined} Returns the key of the matched element, else `undefined`.\n     * @example\n     *\n     * var users = {\n     *   'barney':  { 'age': 36, 'active': true },\n     *   'fred':    { 'age': 40, 'active': false },\n     *   'pebbles': { 'age': 1,  'active': true }\n     * };\n     *\n     * _.findLastKey(users, function(chr) {\n     *   return chr.age < 40;\n     * });\n     * // => returns `pebbles` assuming `_.findKey` returns `barney`\n     *\n     * // using the `_.matches` callback shorthand\n     * _.findLastKey(users, { 'age': 36, 'active': true });\n     * // => 'barney'\n     *\n     * // using the `_.matchesProperty` callback shorthand\n     * _.findLastKey(users, 'active', false);\n     * // => 'fred'\n     *\n     * // using the `_.property` callback shorthand\n     * _.findLastKey(users, 'active');\n     * // => 'pebbles'\n     */\n    var findLastKey = createFindKey(baseForOwnRight);\n\n    /**\n     * Iterates over own and inherited enumerable properties of an object invoking\n     * `iteratee` for each property. The `iteratee` is bound to `thisArg` and invoked\n     * with three arguments: (value, key, object). Iteratee functions may exit\n     * iteration early by explicitly returning `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.forIn(new Foo, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => logs 'a', 'b', and 'c' (iteration order is not guaranteed)\n     */\n    var forIn = createForIn(baseFor);\n\n    /**\n     * This method is like `_.forIn` except that it iterates over properties of\n     * `object` in the opposite order.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.forInRight(new Foo, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => logs 'c', 'b', and 'a' assuming `_.forIn ` logs 'a', 'b', and 'c'\n     */\n    var forInRight = createForIn(baseForRight);\n\n    /**\n     * Iterates over own enumerable properties of an object invoking `iteratee`\n     * for each property. The `iteratee` is bound to `thisArg` and invoked with\n     * three arguments: (value, key, object). Iteratee functions may exit iteration\n     * early by explicitly returning `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.forOwn(new Foo, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => logs 'a' and 'b' (iteration order is not guaranteed)\n     */\n    var forOwn = createForOwn(baseForOwn);\n\n    /**\n     * This method is like `_.forOwn` except that it iterates over properties of\n     * `object` in the opposite order.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.forOwnRight(new Foo, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => logs 'b' and 'a' assuming `_.forOwn` logs 'a' and 'b'\n     */\n    var forOwnRight = createForOwn(baseForOwnRight);\n\n    /**\n     * Creates an array of function property names from all enumerable properties,\n     * own and inherited, of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @alias methods\n     * @category Object\n     * @param {Object} object The object to inspect.\n     * @returns {Array} Returns the new array of property names.\n     * @example\n     *\n     * _.functions(_);\n     * // => ['after', 'ary', 'assign', ...]\n     */\n    function functions(object) {\n      return baseFunctions(object, keysIn(object));\n    }\n\n    /**\n     * Gets the property value at `path` of `object`. If the resolved value is\n     * `undefined` the `defaultValue` is used in its place.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path of the property to get.\n     * @param {*} [defaultValue] The value returned if the resolved value is `undefined`.\n     * @returns {*} Returns the resolved value.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n     *\n     * _.get(object, 'a[0].b.c');\n     * // => 3\n     *\n     * _.get(object, ['a', '0', 'b', 'c']);\n     * // => 3\n     *\n     * _.get(object, 'a.b.c', 'default');\n     * // => 'default'\n     */\n    function get(object, path, defaultValue) {\n      var result = object == null ? undefined : baseGet(object, toPath(path), path + '');\n      return result === undefined ? defaultValue : result;\n    }\n\n    /**\n     * Checks if `path` is a direct property.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path to check.\n     * @returns {boolean} Returns `true` if `path` is a direct property, else `false`.\n     * @example\n     *\n     * var object = { 'a': { 'b': { 'c': 3 } } };\n     *\n     * _.has(object, 'a');\n     * // => true\n     *\n     * _.has(object, 'a.b.c');\n     * // => true\n     *\n     * _.has(object, ['a', 'b', 'c']);\n     * // => true\n     */\n    function has(object, path) {\n      if (object == null) {\n        return false;\n      }\n      var result = hasOwnProperty.call(object, path);\n      if (!result && !isKey(path)) {\n        path = toPath(path);\n        object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));\n        if (object == null) {\n          return false;\n        }\n        path = last(path);\n        result = hasOwnProperty.call(object, path);\n      }\n      return result || (isLength(object.length) && isIndex(path, object.length) &&\n        (isArray(object) || isArguments(object)));\n    }\n\n    /**\n     * Creates an object composed of the inverted keys and values of `object`.\n     * If `object` contains duplicate values, subsequent values overwrite property\n     * assignments of previous values unless `multiValue` is `true`.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to invert.\n     * @param {boolean} [multiValue] Allow multiple values per key.\n     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n     * @returns {Object} Returns the new inverted object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': 2, 'c': 1 };\n     *\n     * _.invert(object);\n     * // => { '1': 'c', '2': 'b' }\n     *\n     * // with `multiValue`\n     * _.invert(object, true);\n     * // => { '1': ['a', 'c'], '2': ['b'] }\n     */\n    function invert(object, multiValue, guard) {\n      if (guard && isIterateeCall(object, multiValue, guard)) {\n        multiValue = undefined;\n      }\n      var index = -1,\n          props = keys(object),\n          length = props.length,\n          result = {};\n\n      while (++index < length) {\n        var key = props[index],\n            value = object[key];\n\n        if (multiValue) {\n          if (hasOwnProperty.call(result, value)) {\n            result[value].push(key);\n          } else {\n            result[value] = [key];\n          }\n        }\n        else {\n          result[value] = key;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Creates an array of the own enumerable property names of `object`.\n     *\n     * **Note:** Non-object values are coerced to objects. See the\n     * [ES spec](http://ecma-international.org/ecma-262/6.0/#sec-object.keys)\n     * for more details.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.keys(new Foo);\n     * // => ['a', 'b'] (iteration order is not guaranteed)\n     *\n     * _.keys('hi');\n     * // => ['0', '1']\n     */\n    var keys = !nativeKeys ? shimKeys : function(object) {\n      var Ctor = object == null ? undefined : object.constructor;\n      if ((typeof Ctor == 'function' && Ctor.prototype === object) ||\n          (typeof object != 'function' && isArrayLike(object))) {\n        return shimKeys(object);\n      }\n      return isObject(object) ? nativeKeys(object) : [];\n    };\n\n    /**\n     * Creates an array of the own and inherited enumerable property names of `object`.\n     *\n     * **Note:** Non-object values are coerced to objects.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.keysIn(new Foo);\n     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\n     */\n    function keysIn(object) {\n      if (object == null) {\n        return [];\n      }\n      if (!isObject(object)) {\n        object = Object(object);\n      }\n      var length = object.length;\n      length = (length && isLength(length) &&\n        (isArray(object) || isArguments(object)) && length) || 0;\n\n      var Ctor = object.constructor,\n          index = -1,\n          isProto = typeof Ctor == 'function' && Ctor.prototype === object,\n          result = Array(length),\n          skipIndexes = length > 0;\n\n      while (++index < length) {\n        result[index] = (index + '');\n      }\n      for (var key in object) {\n        if (!(skipIndexes && isIndex(key, length)) &&\n            !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {\n          result.push(key);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The opposite of `_.mapValues`; this method creates an object with the\n     * same values as `object` and keys generated by running each own enumerable\n     * property of `object` through `iteratee`.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function|Object|string} [iteratee=_.identity] The function invoked\n     *  per iteration.\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\n     * @returns {Object} Returns the new mapped object.\n     * @example\n     *\n     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {\n     *   return key + value;\n     * });\n     * // => { 'a1': 1, 'b2': 2 }\n     */\n    var mapKeys = createObjectMapper(true);\n\n    /**\n     * Creates an object with the same keys as `object` and values generated by\n     * running each own enumerable property of `object` through `iteratee`. The\n     * iteratee function is bound to `thisArg` and invoked with three arguments:\n     * (value, key, object).\n     *\n     * If a property name is provided for `iteratee` the created `_.property`\n     * style callback returns the property value of the given element.\n     *\n     * If a value is also provided for `thisArg` the created `_.matchesProperty`\n     * style callback returns `true` for elements that have a matching property\n     * value, else `false`.\n     *\n     * If an object is provided for `iteratee` the created `_.matches` style\n     * callback returns `true` for elements that have the properties of the given\n     * object, else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function|Object|string} [iteratee=_.identity] The function invoked\n     *  per iteration.\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\n     * @returns {Object} Returns the new mapped object.\n     * @example\n     *\n     * _.mapValues({ 'a': 1, 'b': 2 }, function(n) {\n     *   return n * 3;\n     * });\n     * // => { 'a': 3, 'b': 6 }\n     *\n     * var users = {\n     *   'fred':    { 'user': 'fred',    'age': 40 },\n     *   'pebbles': { 'user': 'pebbles', 'age': 1 }\n     * };\n     *\n     * // using the `_.property` callback shorthand\n     * _.mapValues(users, 'age');\n     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)\n     */\n    var mapValues = createObjectMapper();\n\n    /**\n     * The opposite of `_.pick`; this method creates an object composed of the\n     * own and inherited enumerable properties of `object` that are not omitted.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The source object.\n     * @param {Function|...(string|string[])} [predicate] The function invoked per\n     *  iteration or property names to omit, specified as individual property\n     *  names or arrays of property names.\n     * @param {*} [thisArg] The `this` binding of `predicate`.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * var object = { 'user': 'fred', 'age': 40 };\n     *\n     * _.omit(object, 'age');\n     * // => { 'user': 'fred' }\n     *\n     * _.omit(object, _.isNumber);\n     * // => { 'user': 'fred' }\n     */\n    var omit = restParam(function(object, props) {\n      if (object == null) {\n        return {};\n      }\n      if (typeof props[0] != 'function') {\n        var props = arrayMap(baseFlatten(props), String);\n        return pickByArray(object, baseDifference(keysIn(object), props));\n      }\n      var predicate = bindCallback(props[0], props[1], 3);\n      return pickByCallback(object, function(value, key, object) {\n        return !predicate(value, key, object);\n      });\n    });\n\n    /**\n     * Creates a two dimensional array of the key-value pairs for `object`,\n     * e.g. `[[key1, value1], [key2, value2]]`.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the new array of key-value pairs.\n     * @example\n     *\n     * _.pairs({ 'barney': 36, 'fred': 40 });\n     * // => [['barney', 36], ['fred', 40]] (iteration order is not guaranteed)\n     */\n    function pairs(object) {\n      object = toObject(object);\n\n      var index = -1,\n          props = keys(object),\n          length = props.length,\n          result = Array(length);\n\n      while (++index < length) {\n        var key = props[index];\n        result[index] = [key, object[key]];\n      }\n      return result;\n    }\n\n    /**\n     * Creates an object composed of the picked `object` properties. Property\n     * names may be specified as individual arguments or as arrays of property\n     * names. If `predicate` is provided it is invoked for each property of `object`\n     * picking the properties `predicate` returns truthy for. The predicate is\n     * bound to `thisArg` and invoked with three arguments: (value, key, object).\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The source object.\n     * @param {Function|...(string|string[])} [predicate] The function invoked per\n     *  iteration or property names to pick, specified as individual property\n     *  names or arrays of property names.\n     * @param {*} [thisArg] The `this` binding of `predicate`.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * var object = { 'user': 'fred', 'age': 40 };\n     *\n     * _.pick(object, 'user');\n     * // => { 'user': 'fred' }\n     *\n     * _.pick(object, _.isString);\n     * // => { 'user': 'fred' }\n     */\n    var pick = restParam(function(object, props) {\n      if (object == null) {\n        return {};\n      }\n      return typeof props[0] == 'function'\n        ? pickByCallback(object, bindCallback(props[0], props[1], 3))\n        : pickByArray(object, baseFlatten(props));\n    });\n\n    /**\n     * This method is like `_.get` except that if the resolved value is a function\n     * it is invoked with the `this` binding of its parent object and its result\n     * is returned.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path of the property to resolve.\n     * @param {*} [defaultValue] The value returned if the resolved value is `undefined`.\n     * @returns {*} Returns the resolved value.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };\n     *\n     * _.result(object, 'a[0].b.c1');\n     * // => 3\n     *\n     * _.result(object, 'a[0].b.c2');\n     * // => 4\n     *\n     * _.result(object, 'a.b.c', 'default');\n     * // => 'default'\n     *\n     * _.result(object, 'a.b.c', _.constant('default'));\n     * // => 'default'\n     */\n    function result(object, path, defaultValue) {\n      var result = object == null ? undefined : object[path];\n      if (result === undefined) {\n        if (object != null && !isKey(path, object)) {\n          path = toPath(path);\n          object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));\n          result = object == null ? undefined : object[last(path)];\n        }\n        result = result === undefined ? defaultValue : result;\n      }\n      return isFunction(result) ? result.call(object) : result;\n    }\n\n    /**\n     * Sets the property value of `path` on `object`. If a portion of `path`\n     * does not exist it is created.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to augment.\n     * @param {Array|string} path The path of the property to set.\n     * @param {*} value The value to set.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n     *\n     * _.set(object, 'a[0].b.c', 4);\n     * console.log(object.a[0].b.c);\n     * // => 4\n     *\n     * _.set(object, 'x[0].y.z', 5);\n     * console.log(object.x[0].y.z);\n     * // => 5\n     */\n    function set(object, path, value) {\n      if (object == null) {\n        return object;\n      }\n      var pathKey = (path + '');\n      path = (object[pathKey] != null || isKey(path, object)) ? [pathKey] : toPath(path);\n\n      var index = -1,\n          length = path.length,\n          lastIndex = length - 1,\n          nested = object;\n\n      while (nested != null && ++index < length) {\n        var key = path[index];\n        if (isObject(nested)) {\n          if (index == lastIndex) {\n            nested[key] = value;\n          } else if (nested[key] == null) {\n            nested[key] = isIndex(path[index + 1]) ? [] : {};\n          }\n        }\n        nested = nested[key];\n      }\n      return object;\n    }\n\n    /**\n     * An alternative to `_.reduce`; this method transforms `object` to a new\n     * `accumulator` object which is the result of running each of its own enumerable\n     * properties through `iteratee`, with each invocation potentially mutating\n     * the `accumulator` object. The `iteratee` is bound to `thisArg` and invoked\n     * with four arguments: (accumulator, value, key, object). Iteratee functions\n     * may exit iteration early by explicitly returning `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Array|Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {*} [accumulator] The custom accumulator value.\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\n     * @returns {*} Returns the accumulated value.\n     * @example\n     *\n     * _.transform([2, 3, 4], function(result, n) {\n     *   result.push(n *= n);\n     *   return n % 2 == 0;\n     * });\n     * // => [4, 9]\n     *\n     * _.transform({ 'a': 1, 'b': 2 }, function(result, n, key) {\n     *   result[key] = n * 3;\n     * });\n     * // => { 'a': 3, 'b': 6 }\n     */\n    function transform(object, iteratee, accumulator, thisArg) {\n      var isArr = isArray(object) || isTypedArray(object);\n      iteratee = getCallback(iteratee, thisArg, 4);\n\n      if (accumulator == null) {\n        if (isArr || isObject(object)) {\n          var Ctor = object.constructor;\n          if (isArr) {\n            accumulator = isArray(object) ? new Ctor : [];\n          } else {\n            accumulator = baseCreate(isFunction(Ctor) ? Ctor.prototype : undefined);\n          }\n        } else {\n          accumulator = {};\n        }\n      }\n      (isArr ? arrayEach : baseForOwn)(object, function(value, index, object) {\n        return iteratee(accumulator, value, index, object);\n      });\n      return accumulator;\n    }\n\n    /**\n     * Creates an array of the own enumerable property values of `object`.\n     *\n     * **Note:** Non-object values are coerced to objects.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property values.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.values(new Foo);\n     * // => [1, 2] (iteration order is not guaranteed)\n     *\n     * _.values('hi');\n     * // => ['h', 'i']\n     */\n    function values(object) {\n      return baseValues(object, keys(object));\n    }\n\n    /**\n     * Creates an array of the own and inherited enumerable property values\n     * of `object`.\n     *\n     * **Note:** Non-object values are coerced to objects.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property values.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.valuesIn(new Foo);\n     * // => [1, 2, 3] (iteration order is not guaranteed)\n     */\n    function valuesIn(object) {\n      return baseValues(object, keysIn(object));\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Checks if `n` is between `start` and up to but not including, `end`. If\n     * `end` is not specified it is set to `start` with `start` then set to `0`.\n     *\n     * @static\n     * @memberOf _\n     * @category Number\n     * @param {number} n The number to check.\n     * @param {number} [start=0] The start of the range.\n     * @param {number} end The end of the range.\n     * @returns {boolean} Returns `true` if `n` is in the range, else `false`.\n     * @example\n     *\n     * _.inRange(3, 2, 4);\n     * // => true\n     *\n     * _.inRange(4, 8);\n     * // => true\n     *\n     * _.inRange(4, 2);\n     * // => false\n     *\n     * _.inRange(2, 2);\n     * // => false\n     *\n     * _.inRange(1.2, 2);\n     * // => true\n     *\n     * _.inRange(5.2, 4);\n     * // => false\n     */\n    function inRange(value, start, end) {\n      start = +start || 0;\n      if (end === undefined) {\n        end = start;\n        start = 0;\n      } else {\n        end = +end || 0;\n      }\n      return value >= nativeMin(start, end) && value < nativeMax(start, end);\n    }\n\n    /**\n     * Produces a random number between `min` and `max` (inclusive). If only one\n     * argument is provided a number between `0` and the given number is returned.\n     * If `floating` is `true`, or either `min` or `max` are floats, a floating-point\n     * number is returned instead of an integer.\n     *\n     * @static\n     * @memberOf _\n     * @category Number\n     * @param {number} [min=0] The minimum possible value.\n     * @param {number} [max=1] The maximum possible value.\n     * @param {boolean} [floating] Specify returning a floating-point number.\n     * @returns {number} Returns the random number.\n     * @example\n     *\n     * _.random(0, 5);\n     * // => an integer between 0 and 5\n     *\n     * _.random(5);\n     * // => also an integer between 0 and 5\n     *\n     * _.random(5, true);\n     * // => a floating-point number between 0 and 5\n     *\n     * _.random(1.2, 5.2);\n     * // => a floating-point number between 1.2 and 5.2\n     */\n    function random(min, max, floating) {\n      if (floating && isIterateeCall(min, max, floating)) {\n        max = floating = undefined;\n      }\n      var noMin = min == null,\n          noMax = max == null;\n\n      if (floating == null) {\n        if (noMax && typeof min == 'boolean') {\n          floating = min;\n          min = 1;\n        }\n        else if (typeof max == 'boolean') {\n          floating = max;\n          noMax = true;\n        }\n      }\n      if (noMin && noMax) {\n        max = 1;\n        noMax = false;\n      }\n      min = +min || 0;\n      if (noMax) {\n        max = min;\n        min = 0;\n      } else {\n        max = +max || 0;\n      }\n      if (floating || min % 1 || max % 1) {\n        var rand = nativeRandom();\n        return nativeMin(min + (rand * (max - min + parseFloat('1e-' + ((rand + '').length - 1)))), max);\n      }\n      return baseRandom(min, max);\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the camel cased string.\n     * @example\n     *\n     * _.camelCase('Foo Bar');\n     * // => 'fooBar'\n     *\n     * _.camelCase('--foo-bar');\n     * // => 'fooBar'\n     *\n     * _.camelCase('__foo_bar__');\n     * // => 'fooBar'\n     */\n    var camelCase = createCompounder(function(result, word, index) {\n      word = word.toLowerCase();\n      return result + (index ? (word.charAt(0).toUpperCase() + word.slice(1)) : word);\n    });\n\n    /**\n     * Capitalizes the first character of `string`.\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to capitalize.\n     * @returns {string} Returns the capitalized string.\n     * @example\n     *\n     * _.capitalize('fred');\n     * // => 'Fred'\n     */\n    function capitalize(string) {\n      string = baseToString(string);\n      return string && (string.charAt(0).toUpperCase() + string.slice(1));\n    }\n\n    /**\n     * Deburrs `string` by converting [latin-1 supplementary letters](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)\n     * to basic latin letters and removing [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to deburr.\n     * @returns {string} Returns the deburred string.\n     * @example\n     *\n     * _.deburr('déjà vu');\n     * // => 'deja vu'\n     */\n    function deburr(string) {\n      string = baseToString(string);\n      return string && string.replace(reLatin1, deburrLetter).replace(reComboMark, '');\n    }\n\n    /**\n     * Checks if `string` ends with the given target string.\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to search.\n     * @param {string} [target] The string to search for.\n     * @param {number} [position=string.length] The position to search from.\n     * @returns {boolean} Returns `true` if `string` ends with `target`, else `false`.\n     * @example\n     *\n     * _.endsWith('abc', 'c');\n     * // => true\n     *\n     * _.endsWith('abc', 'b');\n     * // => false\n     *\n     * _.endsWith('abc', 'b', 2);\n     * // => true\n     */\n    function endsWith(string, target, position) {\n      string = baseToString(string);\n      target = (target + '');\n\n      var length = string.length;\n      position = position === undefined\n        ? length\n        : nativeMin(position < 0 ? 0 : (+position || 0), length);\n\n      position -= target.length;\n      return position >= 0 && string.indexOf(target, position) == position;\n    }\n\n    /**\n     * Converts the characters \"&\", \"<\", \">\", '\"', \"'\", and \"\\`\", in `string` to\n     * their corresponding HTML entities.\n     *\n     * **Note:** No other characters are escaped. To escape additional characters\n     * use a third-party library like [_he_](https://mths.be/he).\n     *\n     * Though the \">\" character is escaped for symmetry, characters like\n     * \">\" and \"/\" don't need escaping in HTML and have no special meaning\n     * unless they're part of a tag or unquoted attribute value.\n     * See [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)\n     * (under \"semi-related fun fact\") for more details.\n     *\n     * Backticks are escaped because in Internet Explorer < 9, they can break out\n     * of attribute values or HTML comments. See [#59](https://html5sec.org/#59),\n     * [#102](https://html5sec.org/#102), [#108](https://html5sec.org/#108), and\n     * [#133](https://html5sec.org/#133) of the [HTML5 Security Cheatsheet](https://html5sec.org/)\n     * for more details.\n     *\n     * When working with HTML you should always [quote attribute values](http://wonko.com/post/html-escaping)\n     * to reduce XSS vectors.\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to escape.\n     * @returns {string} Returns the escaped string.\n     * @example\n     *\n     * _.escape('fred, barney, & pebbles');\n     * // => 'fred, barney, &amp; pebbles'\n     */\n    function escape(string) {\n      // Reset `lastIndex` because in IE < 9 `String#replace` does not.\n      string = baseToString(string);\n      return (string && reHasUnescapedHtml.test(string))\n        ? string.replace(reUnescapedHtml, escapeHtmlChar)\n        : string;\n    }\n\n    /**\n     * Escapes the `RegExp` special characters \"\\\", \"/\", \"^\", \"$\", \".\", \"|\", \"?\",\n     * \"*\", \"+\", \"(\", \")\", \"[\", \"]\", \"{\" and \"}\" in `string`.\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to escape.\n     * @returns {string} Returns the escaped string.\n     * @example\n     *\n     * _.escapeRegExp('[lodash](https://lodash.com/)');\n     * // => '\\[lodash\\]\\(https:\\/\\/lodash\\.com\\/\\)'\n     */\n    function escapeRegExp(string) {\n      string = baseToString(string);\n      return (string && reHasRegExpChars.test(string))\n        ? string.replace(reRegExpChars, escapeRegExpChar)\n        : (string || '(?:)');\n    }\n\n    /**\n     * Converts `string` to [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the kebab cased string.\n     * @example\n     *\n     * _.kebabCase('Foo Bar');\n     * // => 'foo-bar'\n     *\n     * _.kebabCase('fooBar');\n     * // => 'foo-bar'\n     *\n     * _.kebabCase('__foo_bar__');\n     * // => 'foo-bar'\n     */\n    var kebabCase = createCompounder(function(result, word, index) {\n      return result + (index ? '-' : '') + word.toLowerCase();\n    });\n\n    /**\n     * Pads `string` on the left and right sides if it's shorter than `length`.\n     * Padding characters are truncated if they can't be evenly divided by `length`.\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to pad.\n     * @param {number} [length=0] The padding length.\n     * @param {string} [chars=' '] The string used as padding.\n     * @returns {string} Returns the padded string.\n     * @example\n     *\n     * _.pad('abc', 8);\n     * // => '  abc   '\n     *\n     * _.pad('abc', 8, '_-');\n     * // => '_-abc_-_'\n     *\n     * _.pad('abc', 3);\n     * // => 'abc'\n     */\n    function pad(string, length, chars) {\n      string = baseToString(string);\n      length = +length;\n\n      var strLength = string.length;\n      if (strLength >= length || !nativeIsFinite(length)) {\n        return string;\n      }\n      var mid = (length - strLength) / 2,\n          leftLength = nativeFloor(mid),\n          rightLength = nativeCeil(mid);\n\n      chars = createPadding('', rightLength, chars);\n      return chars.slice(0, leftLength) + string + chars;\n    }\n\n    /**\n     * Pads `string` on the left side if it's shorter than `length`. Padding\n     * characters are truncated if they exceed `length`.\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to pad.\n     * @param {number} [length=0] The padding length.\n     * @param {string} [chars=' '] The string used as padding.\n     * @returns {string} Returns the padded string.\n     * @example\n     *\n     * _.padLeft('abc', 6);\n     * // => '   abc'\n     *\n     * _.padLeft('abc', 6, '_-');\n     * // => '_-_abc'\n     *\n     * _.padLeft('abc', 3);\n     * // => 'abc'\n     */\n    var padLeft = createPadDir();\n\n    /**\n     * Pads `string` on the right side if it's shorter than `length`. Padding\n     * characters are truncated if they exceed `length`.\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to pad.\n     * @param {number} [length=0] The padding length.\n     * @param {string} [chars=' '] The string used as padding.\n     * @returns {string} Returns the padded string.\n     * @example\n     *\n     * _.padRight('abc', 6);\n     * // => 'abc   '\n     *\n     * _.padRight('abc', 6, '_-');\n     * // => 'abc_-_'\n     *\n     * _.padRight('abc', 3);\n     * // => 'abc'\n     */\n    var padRight = createPadDir(true);\n\n    /**\n     * Converts `string` to an integer of the specified radix. If `radix` is\n     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a hexadecimal,\n     * in which case a `radix` of `16` is used.\n     *\n     * **Note:** This method aligns with the [ES5 implementation](https://es5.github.io/#E)\n     * of `parseInt`.\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} string The string to convert.\n     * @param {number} [radix] The radix to interpret `value` by.\n     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n     * @returns {number} Returns the converted integer.\n     * @example\n     *\n     * _.parseInt('08');\n     * // => 8\n     *\n     * _.map(['6', '08', '10'], _.parseInt);\n     * // => [6, 8, 10]\n     */\n    function parseInt(string, radix, guard) {\n      // Firefox < 21 and Opera < 15 follow ES3 for `parseInt`.\n      // Chrome fails to trim leading <BOM> whitespace characters.\n      // See https://code.google.com/p/v8/issues/detail?id=3109 for more details.\n      if (guard ? isIterateeCall(string, radix, guard) : radix == null) {\n        radix = 0;\n      } else if (radix) {\n        radix = +radix;\n      }\n      string = trim(string);\n      return nativeParseInt(string, radix || (reHasHexPrefix.test(string) ? 16 : 10));\n    }\n\n    /**\n     * Repeats the given string `n` times.\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to repeat.\n     * @param {number} [n=0] The number of times to repeat the string.\n     * @returns {string} Returns the repeated string.\n     * @example\n     *\n     * _.repeat('*', 3);\n     * // => '***'\n     *\n     * _.repeat('abc', 2);\n     * // => 'abcabc'\n     *\n     * _.repeat('abc', 0);\n     * // => ''\n     */\n    function repeat(string, n) {\n      var result = '';\n      string = baseToString(string);\n      n = +n;\n      if (n < 1 || !string || !nativeIsFinite(n)) {\n        return result;\n      }\n      // Leverage the exponentiation by squaring algorithm for a faster repeat.\n      // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.\n      do {\n        if (n % 2) {\n          result += string;\n        }\n        n = nativeFloor(n / 2);\n        string += string;\n      } while (n);\n\n      return result;\n    }\n\n    /**\n     * Converts `string` to [snake case](https://en.wikipedia.org/wiki/Snake_case).\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the snake cased string.\n     * @example\n     *\n     * _.snakeCase('Foo Bar');\n     * // => 'foo_bar'\n     *\n     * _.snakeCase('fooBar');\n     * // => 'foo_bar'\n     *\n     * _.snakeCase('--foo-bar');\n     * // => 'foo_bar'\n     */\n    var snakeCase = createCompounder(function(result, word, index) {\n      return result + (index ? '_' : '') + word.toLowerCase();\n    });\n\n    /**\n     * Converts `string` to [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the start cased string.\n     * @example\n     *\n     * _.startCase('--foo-bar');\n     * // => 'Foo Bar'\n     *\n     * _.startCase('fooBar');\n     * // => 'Foo Bar'\n     *\n     * _.startCase('__foo_bar__');\n     * // => 'Foo Bar'\n     */\n    var startCase = createCompounder(function(result, word, index) {\n      return result + (index ? ' ' : '') + (word.charAt(0).toUpperCase() + word.slice(1));\n    });\n\n    /**\n     * Checks if `string` starts with the given target string.\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to search.\n     * @param {string} [target] The string to search for.\n     * @param {number} [position=0] The position to search from.\n     * @returns {boolean} Returns `true` if `string` starts with `target`, else `false`.\n     * @example\n     *\n     * _.startsWith('abc', 'a');\n     * // => true\n     *\n     * _.startsWith('abc', 'b');\n     * // => false\n     *\n     * _.startsWith('abc', 'b', 1);\n     * // => true\n     */\n    function startsWith(string, target, position) {\n      string = baseToString(string);\n      position = position == null\n        ? 0\n        : nativeMin(position < 0 ? 0 : (+position || 0), string.length);\n\n      return string.lastIndexOf(target, position) == position;\n    }\n\n    /**\n     * Creates a compiled template function that can interpolate data properties\n     * in \"interpolate\" delimiters, HTML-escape interpolated data properties in\n     * \"escape\" delimiters, and execute JavaScript in \"evaluate\" delimiters. Data\n     * properties may be accessed as free variables in the template. If a setting\n     * object is provided it takes precedence over `_.templateSettings` values.\n     *\n     * **Note:** In the development build `_.template` utilizes\n     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)\n     * for easier debugging.\n     *\n     * For more information on precompiling templates see\n     * [lodash's custom builds documentation](https://lodash.com/custom-builds).\n     *\n     * For more information on Chrome extension sandboxes see\n     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The template string.\n     * @param {Object} [options] The options object.\n     * @param {RegExp} [options.escape] The HTML \"escape\" delimiter.\n     * @param {RegExp} [options.evaluate] The \"evaluate\" delimiter.\n     * @param {Object} [options.imports] An object to import into the template as free variables.\n     * @param {RegExp} [options.interpolate] The \"interpolate\" delimiter.\n     * @param {string} [options.sourceURL] The sourceURL of the template's compiled source.\n     * @param {string} [options.variable] The data object variable name.\n     * @param- {Object} [otherOptions] Enables the legacy `options` param signature.\n     * @returns {Function} Returns the compiled template function.\n     * @example\n     *\n     * // using the \"interpolate\" delimiter to create a compiled template\n     * var compiled = _.template('hello <%= user %>!');\n     * compiled({ 'user': 'fred' });\n     * // => 'hello fred!'\n     *\n     * // using the HTML \"escape\" delimiter to escape data property values\n     * var compiled = _.template('<b><%- value %></b>');\n     * compiled({ 'value': '<script>' });\n     * // => '<b>&lt;script&gt;</b>'\n     *\n     * // using the \"evaluate\" delimiter to execute JavaScript and generate HTML\n     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');\n     * compiled({ 'users': ['fred', 'barney'] });\n     * // => '<li>fred</li><li>barney</li>'\n     *\n     * // using the internal `print` function in \"evaluate\" delimiters\n     * var compiled = _.template('<% print(\"hello \" + user); %>!');\n     * compiled({ 'user': 'barney' });\n     * // => 'hello barney!'\n     *\n     * // using the ES delimiter as an alternative to the default \"interpolate\" delimiter\n     * var compiled = _.template('hello ${ user }!');\n     * compiled({ 'user': 'pebbles' });\n     * // => 'hello pebbles!'\n     *\n     * // using custom template delimiters\n     * _.templateSettings.interpolate = /{{([\\s\\S]+?)}}/g;\n     * var compiled = _.template('hello {{ user }}!');\n     * compiled({ 'user': 'mustache' });\n     * // => 'hello mustache!'\n     *\n     * // using backslashes to treat delimiters as plain text\n     * var compiled = _.template('<%= \"\\\\<%- value %\\\\>\" %>');\n     * compiled({ 'value': 'ignored' });\n     * // => '<%- value %>'\n     *\n     * // using the `imports` option to import `jQuery` as `jq`\n     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';\n     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });\n     * compiled({ 'users': ['fred', 'barney'] });\n     * // => '<li>fred</li><li>barney</li>'\n     *\n     * // using the `sourceURL` option to specify a custom sourceURL for the template\n     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });\n     * compiled(data);\n     * // => find the source of \"greeting.jst\" under the Sources tab or Resources panel of the web inspector\n     *\n     * // using the `variable` option to ensure a with-statement isn't used in the compiled template\n     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });\n     * compiled.source;\n     * // => function(data) {\n     * //   var __t, __p = '';\n     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';\n     * //   return __p;\n     * // }\n     *\n     * // using the `source` property to inline compiled templates for meaningful\n     * // line numbers in error messages and a stack trace\n     * fs.writeFileSync(path.join(cwd, 'jst.js'), '\\\n     *   var JST = {\\\n     *     \"main\": ' + _.template(mainText).source + '\\\n     *   };\\\n     * ');\n     */\n    function template(string, options, otherOptions) {\n      // Based on John Resig's `tmpl` implementation (http://ejohn.org/blog/javascript-micro-templating/)\n      // and Laura Doktorova's doT.js (https://github.com/olado/doT).\n      var settings = lodash.templateSettings;\n\n      if (otherOptions && isIterateeCall(string, options, otherOptions)) {\n        options = otherOptions = undefined;\n      }\n      string = baseToString(string);\n      options = assignWith(baseAssign({}, otherOptions || options), settings, assignOwnDefaults);\n\n      var imports = assignWith(baseAssign({}, options.imports), settings.imports, assignOwnDefaults),\n          importsKeys = keys(imports),\n          importsValues = baseValues(imports, importsKeys);\n\n      var isEscaping,\n          isEvaluating,\n          index = 0,\n          interpolate = options.interpolate || reNoMatch,\n          source = \"__p += '\";\n\n      // Compile the regexp to match each delimiter.\n      var reDelimiters = RegExp(\n        (options.escape || reNoMatch).source + '|' +\n        interpolate.source + '|' +\n        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +\n        (options.evaluate || reNoMatch).source + '|$'\n      , 'g');\n\n      // Use a sourceURL for easier debugging.\n      var sourceURL = '//# sourceURL=' +\n        ('sourceURL' in options\n          ? options.sourceURL\n          : ('lodash.templateSources[' + (++templateCounter) + ']')\n        ) + '\\n';\n\n      string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {\n        interpolateValue || (interpolateValue = esTemplateValue);\n\n        // Escape characters that can't be included in string literals.\n        source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);\n\n        // Replace delimiters with snippets.\n        if (escapeValue) {\n          isEscaping = true;\n          source += \"' +\\n__e(\" + escapeValue + \") +\\n'\";\n        }\n        if (evaluateValue) {\n          isEvaluating = true;\n          source += \"';\\n\" + evaluateValue + \";\\n__p += '\";\n        }\n        if (interpolateValue) {\n          source += \"' +\\n((__t = (\" + interpolateValue + \")) == null ? '' : __t) +\\n'\";\n        }\n        index = offset + match.length;\n\n        // The JS engine embedded in Adobe products requires returning the `match`\n        // string in order to produce the correct `offset` value.\n        return match;\n      });\n\n      source += \"';\\n\";\n\n      // If `variable` is not specified wrap a with-statement around the generated\n      // code to add the data object to the top of the scope chain.\n      var variable = options.variable;\n      if (!variable) {\n        source = 'with (obj) {\\n' + source + '\\n}\\n';\n      }\n      // Cleanup code by stripping empty strings.\n      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)\n        .replace(reEmptyStringMiddle, '$1')\n        .replace(reEmptyStringTrailing, '$1;');\n\n      // Frame code as the function body.\n      source = 'function(' + (variable || 'obj') + ') {\\n' +\n        (variable\n          ? ''\n          : 'obj || (obj = {});\\n'\n        ) +\n        \"var __t, __p = ''\" +\n        (isEscaping\n           ? ', __e = _.escape'\n           : ''\n        ) +\n        (isEvaluating\n          ? ', __j = Array.prototype.join;\\n' +\n            \"function print() { __p += __j.call(arguments, '') }\\n\"\n          : ';\\n'\n        ) +\n        source +\n        'return __p\\n}';\n\n      var result = attempt(function() {\n        return Function(importsKeys, sourceURL + 'return ' + source).apply(undefined, importsValues);\n      });\n\n      // Provide the compiled function's source by its `toString` method or\n      // the `source` property as a convenience for inlining compiled templates.\n      result.source = source;\n      if (isError(result)) {\n        throw result;\n      }\n      return result;\n    }\n\n    /**\n     * Removes leading and trailing whitespace or specified characters from `string`.\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to trim.\n     * @param {string} [chars=whitespace] The characters to trim.\n     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n     * @returns {string} Returns the trimmed string.\n     * @example\n     *\n     * _.trim('  abc  ');\n     * // => 'abc'\n     *\n     * _.trim('-_-abc-_-', '_-');\n     * // => 'abc'\n     *\n     * _.map(['  foo  ', '  bar  '], _.trim);\n     * // => ['foo', 'bar']\n     */\n    function trim(string, chars, guard) {\n      var value = string;\n      string = baseToString(string);\n      if (!string) {\n        return string;\n      }\n      if (guard ? isIterateeCall(value, chars, guard) : chars == null) {\n        return string.slice(trimmedLeftIndex(string), trimmedRightIndex(string) + 1);\n      }\n      chars = (chars + '');\n      return string.slice(charsLeftIndex(string, chars), charsRightIndex(string, chars) + 1);\n    }\n\n    /**\n     * Removes leading whitespace or specified characters from `string`.\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to trim.\n     * @param {string} [chars=whitespace] The characters to trim.\n     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n     * @returns {string} Returns the trimmed string.\n     * @example\n     *\n     * _.trimLeft('  abc  ');\n     * // => 'abc  '\n     *\n     * _.trimLeft('-_-abc-_-', '_-');\n     * // => 'abc-_-'\n     */\n    function trimLeft(string, chars, guard) {\n      var value = string;\n      string = baseToString(string);\n      if (!string) {\n        return string;\n      }\n      if (guard ? isIterateeCall(value, chars, guard) : chars == null) {\n        return string.slice(trimmedLeftIndex(string));\n      }\n      return string.slice(charsLeftIndex(string, (chars + '')));\n    }\n\n    /**\n     * Removes trailing whitespace or specified characters from `string`.\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to trim.\n     * @param {string} [chars=whitespace] The characters to trim.\n     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n     * @returns {string} Returns the trimmed string.\n     * @example\n     *\n     * _.trimRight('  abc  ');\n     * // => '  abc'\n     *\n     * _.trimRight('-_-abc-_-', '_-');\n     * // => '-_-abc'\n     */\n    function trimRight(string, chars, guard) {\n      var value = string;\n      string = baseToString(string);\n      if (!string) {\n        return string;\n      }\n      if (guard ? isIterateeCall(value, chars, guard) : chars == null) {\n        return string.slice(0, trimmedRightIndex(string) + 1);\n      }\n      return string.slice(0, charsRightIndex(string, (chars + '')) + 1);\n    }\n\n    /**\n     * Truncates `string` if it's longer than the given maximum string length.\n     * The last characters of the truncated string are replaced with the omission\n     * string which defaults to \"...\".\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to truncate.\n     * @param {Object|number} [options] The options object or maximum string length.\n     * @param {number} [options.length=30] The maximum string length.\n     * @param {string} [options.omission='...'] The string to indicate text is omitted.\n     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.\n     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n     * @returns {string} Returns the truncated string.\n     * @example\n     *\n     * _.trunc('hi-diddly-ho there, neighborino');\n     * // => 'hi-diddly-ho there, neighbo...'\n     *\n     * _.trunc('hi-diddly-ho there, neighborino', 24);\n     * // => 'hi-diddly-ho there, n...'\n     *\n     * _.trunc('hi-diddly-ho there, neighborino', {\n     *   'length': 24,\n     *   'separator': ' '\n     * });\n     * // => 'hi-diddly-ho there,...'\n     *\n     * _.trunc('hi-diddly-ho there, neighborino', {\n     *   'length': 24,\n     *   'separator': /,? +/\n     * });\n     * // => 'hi-diddly-ho there...'\n     *\n     * _.trunc('hi-diddly-ho there, neighborino', {\n     *   'omission': ' [...]'\n     * });\n     * // => 'hi-diddly-ho there, neig [...]'\n     */\n    function trunc(string, options, guard) {\n      if (guard && isIterateeCall(string, options, guard)) {\n        options = undefined;\n      }\n      var length = DEFAULT_TRUNC_LENGTH,\n          omission = DEFAULT_TRUNC_OMISSION;\n\n      if (options != null) {\n        if (isObject(options)) {\n          var separator = 'separator' in options ? options.separator : separator;\n          length = 'length' in options ? (+options.length || 0) : length;\n          omission = 'omission' in options ? baseToString(options.omission) : omission;\n        } else {\n          length = +options || 0;\n        }\n      }\n      string = baseToString(string);\n      if (length >= string.length) {\n        return string;\n      }\n      var end = length - omission.length;\n      if (end < 1) {\n        return omission;\n      }\n      var result = string.slice(0, end);\n      if (separator == null) {\n        return result + omission;\n      }\n      if (isRegExp(separator)) {\n        if (string.slice(end).search(separator)) {\n          var match,\n              newEnd,\n              substring = string.slice(0, end);\n\n          if (!separator.global) {\n            separator = RegExp(separator.source, (reFlags.exec(separator) || '') + 'g');\n          }\n          separator.lastIndex = 0;\n          while ((match = separator.exec(substring))) {\n            newEnd = match.index;\n          }\n          result = result.slice(0, newEnd == null ? end : newEnd);\n        }\n      } else if (string.indexOf(separator, end) != end) {\n        var index = result.lastIndexOf(separator);\n        if (index > -1) {\n          result = result.slice(0, index);\n        }\n      }\n      return result + omission;\n    }\n\n    /**\n     * The inverse of `_.escape`; this method converts the HTML entities\n     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, `&#39;`, and `&#96;` in `string` to their\n     * corresponding characters.\n     *\n     * **Note:** No other HTML entities are unescaped. To unescape additional HTML\n     * entities use a third-party library like [_he_](https://mths.be/he).\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to unescape.\n     * @returns {string} Returns the unescaped string.\n     * @example\n     *\n     * _.unescape('fred, barney, &amp; pebbles');\n     * // => 'fred, barney, & pebbles'\n     */\n    function unescape(string) {\n      string = baseToString(string);\n      return (string && reHasEscapedHtml.test(string))\n        ? string.replace(reEscapedHtml, unescapeHtmlChar)\n        : string;\n    }\n\n    /**\n     * Splits `string` into an array of its words.\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to inspect.\n     * @param {RegExp|string} [pattern] The pattern to match words.\n     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n     * @returns {Array} Returns the words of `string`.\n     * @example\n     *\n     * _.words('fred, barney, & pebbles');\n     * // => ['fred', 'barney', 'pebbles']\n     *\n     * _.words('fred, barney, & pebbles', /[^, ]+/g);\n     * // => ['fred', 'barney', '&', 'pebbles']\n     */\n    function words(string, pattern, guard) {\n      if (guard && isIterateeCall(string, pattern, guard)) {\n        pattern = undefined;\n      }\n      string = baseToString(string);\n      return string.match(pattern || reWords) || [];\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Attempts to invoke `func`, returning either the result or the caught error\n     * object. Any additional arguments are provided to `func` when it is invoked.\n     *\n     * @static\n     * @memberOf _\n     * @category Utility\n     * @param {Function} func The function to attempt.\n     * @returns {*} Returns the `func` result or error object.\n     * @example\n     *\n     * // avoid throwing errors for invalid selectors\n     * var elements = _.attempt(function(selector) {\n     *   return document.querySelectorAll(selector);\n     * }, '>_>');\n     *\n     * if (_.isError(elements)) {\n     *   elements = [];\n     * }\n     */\n    var attempt = restParam(function(func, args) {\n      try {\n        return func.apply(undefined, args);\n      } catch(e) {\n        return isError(e) ? e : new Error(e);\n      }\n    });\n\n    /**\n     * Creates a function that invokes `func` with the `this` binding of `thisArg`\n     * and arguments of the created function. If `func` is a property name the\n     * created callback returns the property value for a given element. If `func`\n     * is an object the created callback returns `true` for elements that contain\n     * the equivalent object properties, otherwise it returns `false`.\n     *\n     * @static\n     * @memberOf _\n     * @alias iteratee\n     * @category Utility\n     * @param {*} [func=_.identity] The value to convert to a callback.\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.\n     * @returns {Function} Returns the callback.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36 },\n     *   { 'user': 'fred',   'age': 40 }\n     * ];\n     *\n     * // wrap to create custom callback shorthands\n     * _.callback = _.wrap(_.callback, function(callback, func, thisArg) {\n     *   var match = /^(.+?)__([gl]t)(.+)$/.exec(func);\n     *   if (!match) {\n     *     return callback(func, thisArg);\n     *   }\n     *   return function(object) {\n     *     return match[2] == 'gt'\n     *       ? object[match[1]] > match[3]\n     *       : object[match[1]] < match[3];\n     *   };\n     * });\n     *\n     * _.filter(users, 'age__gt36');\n     * // => [{ 'user': 'fred', 'age': 40 }]\n     */\n    function callback(func, thisArg, guard) {\n      if (guard && isIterateeCall(func, thisArg, guard)) {\n        thisArg = undefined;\n      }\n      return isObjectLike(func)\n        ? matches(func)\n        : baseCallback(func, thisArg);\n    }\n\n    /**\n     * Creates a function that returns `value`.\n     *\n     * @static\n     * @memberOf _\n     * @category Utility\n     * @param {*} value The value to return from the new function.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var object = { 'user': 'fred' };\n     * var getter = _.constant(object);\n     *\n     * getter() === object;\n     * // => true\n     */\n    function constant(value) {\n      return function() {\n        return value;\n      };\n    }\n\n    /**\n     * This method returns the first argument provided to it.\n     *\n     * @static\n     * @memberOf _\n     * @category Utility\n     * @param {*} value Any value.\n     * @returns {*} Returns `value`.\n     * @example\n     *\n     * var object = { 'user': 'fred' };\n     *\n     * _.identity(object) === object;\n     * // => true\n     */\n    function identity(value) {\n      return value;\n    }\n\n    /**\n     * Creates a function that performs a deep comparison between a given object\n     * and `source`, returning `true` if the given object has equivalent property\n     * values, else `false`.\n     *\n     * **Note:** This method supports comparing arrays, booleans, `Date` objects,\n     * numbers, `Object` objects, regexes, and strings. Objects are compared by\n     * their own, not inherited, enumerable properties. For comparing a single\n     * own or inherited property value see `_.matchesProperty`.\n     *\n     * @static\n     * @memberOf _\n     * @category Utility\n     * @param {Object} source The object of property values to match.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36, 'active': true },\n     *   { 'user': 'fred',   'age': 40, 'active': false }\n     * ];\n     *\n     * _.filter(users, _.matches({ 'age': 40, 'active': false }));\n     * // => [{ 'user': 'fred', 'age': 40, 'active': false }]\n     */\n    function matches(source) {\n      return baseMatches(baseClone(source, true));\n    }\n\n    /**\n     * Creates a function that compares the property value of `path` on a given\n     * object to `value`.\n     *\n     * **Note:** This method supports comparing arrays, booleans, `Date` objects,\n     * numbers, `Object` objects, regexes, and strings. Objects are compared by\n     * their own, not inherited, enumerable properties.\n     *\n     * @static\n     * @memberOf _\n     * @category Utility\n     * @param {Array|string} path The path of the property to get.\n     * @param {*} srcValue The value to match.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney' },\n     *   { 'user': 'fred' }\n     * ];\n     *\n     * _.find(users, _.matchesProperty('user', 'fred'));\n     * // => { 'user': 'fred' }\n     */\n    function matchesProperty(path, srcValue) {\n      return baseMatchesProperty(path, baseClone(srcValue, true));\n    }\n\n    /**\n     * Creates a function that invokes the method at `path` on a given object.\n     * Any additional arguments are provided to the invoked method.\n     *\n     * @static\n     * @memberOf _\n     * @category Utility\n     * @param {Array|string} path The path of the method to invoke.\n     * @param {...*} [args] The arguments to invoke the method with.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var objects = [\n     *   { 'a': { 'b': { 'c': _.constant(2) } } },\n     *   { 'a': { 'b': { 'c': _.constant(1) } } }\n     * ];\n     *\n     * _.map(objects, _.method('a.b.c'));\n     * // => [2, 1]\n     *\n     * _.invoke(_.sortBy(objects, _.method(['a', 'b', 'c'])), 'a.b.c');\n     * // => [1, 2]\n     */\n    var method = restParam(function(path, args) {\n      return function(object) {\n        return invokePath(object, path, args);\n      };\n    });\n\n    /**\n     * The opposite of `_.method`; this method creates a function that invokes\n     * the method at a given path on `object`. Any additional arguments are\n     * provided to the invoked method.\n     *\n     * @static\n     * @memberOf _\n     * @category Utility\n     * @param {Object} object The object to query.\n     * @param {...*} [args] The arguments to invoke the method with.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var array = _.times(3, _.constant),\n     *     object = { 'a': array, 'b': array, 'c': array };\n     *\n     * _.map(['a[2]', 'c[0]'], _.methodOf(object));\n     * // => [2, 0]\n     *\n     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));\n     * // => [2, 0]\n     */\n    var methodOf = restParam(function(object, args) {\n      return function(path) {\n        return invokePath(object, path, args);\n      };\n    });\n\n    /**\n     * Adds all own enumerable function properties of a source object to the\n     * destination object. If `object` is a function then methods are added to\n     * its prototype as well.\n     *\n     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to\n     * avoid conflicts caused by modifying the original.\n     *\n     * @static\n     * @memberOf _\n     * @category Utility\n     * @param {Function|Object} [object=lodash] The destination object.\n     * @param {Object} source The object of functions to add.\n     * @param {Object} [options] The options object.\n     * @param {boolean} [options.chain=true] Specify whether the functions added\n     *  are chainable.\n     * @returns {Function|Object} Returns `object`.\n     * @example\n     *\n     * function vowels(string) {\n     *   return _.filter(string, function(v) {\n     *     return /[aeiou]/i.test(v);\n     *   });\n     * }\n     *\n     * _.mixin({ 'vowels': vowels });\n     * _.vowels('fred');\n     * // => ['e']\n     *\n     * _('fred').vowels().value();\n     * // => ['e']\n     *\n     * _.mixin({ 'vowels': vowels }, { 'chain': false });\n     * _('fred').vowels();\n     * // => ['e']\n     */\n    function mixin(object, source, options) {\n      if (options == null) {\n        var isObj = isObject(source),\n            props = isObj ? keys(source) : undefined,\n            methodNames = (props && props.length) ? baseFunctions(source, props) : undefined;\n\n        if (!(methodNames ? methodNames.length : isObj)) {\n          methodNames = false;\n          options = source;\n          source = object;\n          object = this;\n        }\n      }\n      if (!methodNames) {\n        methodNames = baseFunctions(source, keys(source));\n      }\n      var chain = true,\n          index = -1,\n          isFunc = isFunction(object),\n          length = methodNames.length;\n\n      if (options === false) {\n        chain = false;\n      } else if (isObject(options) && 'chain' in options) {\n        chain = options.chain;\n      }\n      while (++index < length) {\n        var methodName = methodNames[index],\n            func = source[methodName];\n\n        object[methodName] = func;\n        if (isFunc) {\n          object.prototype[methodName] = (function(func) {\n            return function() {\n              var chainAll = this.__chain__;\n              if (chain || chainAll) {\n                var result = object(this.__wrapped__),\n                    actions = result.__actions__ = arrayCopy(this.__actions__);\n\n                actions.push({ 'func': func, 'args': arguments, 'thisArg': object });\n                result.__chain__ = chainAll;\n                return result;\n              }\n              return func.apply(object, arrayPush([this.value()], arguments));\n            };\n          }(func));\n        }\n      }\n      return object;\n    }\n\n    /**\n     * Reverts the `_` variable to its previous value and returns a reference to\n     * the `lodash` function.\n     *\n     * @static\n     * @memberOf _\n     * @category Utility\n     * @returns {Function} Returns the `lodash` function.\n     * @example\n     *\n     * var lodash = _.noConflict();\n     */\n    function noConflict() {\n      root._ = oldDash;\n      return this;\n    }\n\n    /**\n     * A no-operation function that returns `undefined` regardless of the\n     * arguments it receives.\n     *\n     * @static\n     * @memberOf _\n     * @category Utility\n     * @example\n     *\n     * var object = { 'user': 'fred' };\n     *\n     * _.noop(object) === undefined;\n     * // => true\n     */\n    function noop() {\n      // No operation performed.\n    }\n\n    /**\n     * Creates a function that returns the property value at `path` on a\n     * given object.\n     *\n     * @static\n     * @memberOf _\n     * @category Utility\n     * @param {Array|string} path The path of the property to get.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var objects = [\n     *   { 'a': { 'b': { 'c': 2 } } },\n     *   { 'a': { 'b': { 'c': 1 } } }\n     * ];\n     *\n     * _.map(objects, _.property('a.b.c'));\n     * // => [2, 1]\n     *\n     * _.pluck(_.sortBy(objects, _.property(['a', 'b', 'c'])), 'a.b.c');\n     * // => [1, 2]\n     */\n    function property(path) {\n      return isKey(path) ? baseProperty(path) : basePropertyDeep(path);\n    }\n\n    /**\n     * The opposite of `_.property`; this method creates a function that returns\n     * the property value at a given path on `object`.\n     *\n     * @static\n     * @memberOf _\n     * @category Utility\n     * @param {Object} object The object to query.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var array = [0, 1, 2],\n     *     object = { 'a': array, 'b': array, 'c': array };\n     *\n     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));\n     * // => [2, 0]\n     *\n     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));\n     * // => [2, 0]\n     */\n    function propertyOf(object) {\n      return function(path) {\n        return baseGet(object, toPath(path), path + '');\n      };\n    }\n\n    /**\n     * Creates an array of numbers (positive and/or negative) progressing from\n     * `start` up to, but not including, `end`. If `end` is not specified it is\n     * set to `start` with `start` then set to `0`. If `end` is less than `start`\n     * a zero-length range is created unless a negative `step` is specified.\n     *\n     * @static\n     * @memberOf _\n     * @category Utility\n     * @param {number} [start=0] The start of the range.\n     * @param {number} end The end of the range.\n     * @param {number} [step=1] The value to increment or decrement by.\n     * @returns {Array} Returns the new array of numbers.\n     * @example\n     *\n     * _.range(4);\n     * // => [0, 1, 2, 3]\n     *\n     * _.range(1, 5);\n     * // => [1, 2, 3, 4]\n     *\n     * _.range(0, 20, 5);\n     * // => [0, 5, 10, 15]\n     *\n     * _.range(0, -4, -1);\n     * // => [0, -1, -2, -3]\n     *\n     * _.range(1, 4, 0);\n     * // => [1, 1, 1]\n     *\n     * _.range(0);\n     * // => []\n     */\n    function range(start, end, step) {\n      if (step && isIterateeCall(start, end, step)) {\n        end = step = undefined;\n      }\n      start = +start || 0;\n      step = step == null ? 1 : (+step || 0);\n\n      if (end == null) {\n        end = start;\n        start = 0;\n      } else {\n        end = +end || 0;\n      }\n      // Use `Array(length)` so engines like Chakra and V8 avoid slower modes.\n      // See https://youtu.be/XAqIpGU8ZZk#t=17m25s for more details.\n      var index = -1,\n          length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),\n          result = Array(length);\n\n      while (++index < length) {\n        result[index] = start;\n        start += step;\n      }\n      return result;\n    }\n\n    /**\n     * Invokes the iteratee function `n` times, returning an array of the results\n     * of each invocation. The `iteratee` is bound to `thisArg` and invoked with\n     * one argument; (index).\n     *\n     * @static\n     * @memberOf _\n     * @category Utility\n     * @param {number} n The number of times to invoke `iteratee`.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\n     * @returns {Array} Returns the array of results.\n     * @example\n     *\n     * var diceRolls = _.times(3, _.partial(_.random, 1, 6, false));\n     * // => [3, 6, 4]\n     *\n     * _.times(3, function(n) {\n     *   mage.castSpell(n);\n     * });\n     * // => invokes `mage.castSpell(n)` three times with `n` of `0`, `1`, and `2`\n     *\n     * _.times(3, function(n) {\n     *   this.cast(n);\n     * }, mage);\n     * // => also invokes `mage.castSpell(n)` three times\n     */\n    function times(n, iteratee, thisArg) {\n      n = nativeFloor(n);\n\n      // Exit early to avoid a JSC JIT bug in Safari 8\n      // where `Array(0)` is treated as `Array(1)`.\n      if (n < 1 || !nativeIsFinite(n)) {\n        return [];\n      }\n      var index = -1,\n          result = Array(nativeMin(n, MAX_ARRAY_LENGTH));\n\n      iteratee = bindCallback(iteratee, thisArg, 1);\n      while (++index < n) {\n        if (index < MAX_ARRAY_LENGTH) {\n          result[index] = iteratee(index);\n        } else {\n          iteratee(index);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Generates a unique ID. If `prefix` is provided the ID is appended to it.\n     *\n     * @static\n     * @memberOf _\n     * @category Utility\n     * @param {string} [prefix] The value to prefix the ID with.\n     * @returns {string} Returns the unique ID.\n     * @example\n     *\n     * _.uniqueId('contact_');\n     * // => 'contact_104'\n     *\n     * _.uniqueId();\n     * // => '105'\n     */\n    function uniqueId(prefix) {\n      var id = ++idCounter;\n      return baseToString(prefix) + id;\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Adds two numbers.\n     *\n     * @static\n     * @memberOf _\n     * @category Math\n     * @param {number} augend The first number to add.\n     * @param {number} addend The second number to add.\n     * @returns {number} Returns the sum.\n     * @example\n     *\n     * _.add(6, 4);\n     * // => 10\n     */\n    function add(augend, addend) {\n      return (+augend || 0) + (+addend || 0);\n    }\n\n    /**\n     * Calculates `n` rounded up to `precision`.\n     *\n     * @static\n     * @memberOf _\n     * @category Math\n     * @param {number} n The number to round up.\n     * @param {number} [precision=0] The precision to round up to.\n     * @returns {number} Returns the rounded up number.\n     * @example\n     *\n     * _.ceil(4.006);\n     * // => 5\n     *\n     * _.ceil(6.004, 2);\n     * // => 6.01\n     *\n     * _.ceil(6040, -2);\n     * // => 6100\n     */\n    var ceil = createRound('ceil');\n\n    /**\n     * Calculates `n` rounded down to `precision`.\n     *\n     * @static\n     * @memberOf _\n     * @category Math\n     * @param {number} n The number to round down.\n     * @param {number} [precision=0] The precision to round down to.\n     * @returns {number} Returns the rounded down number.\n     * @example\n     *\n     * _.floor(4.006);\n     * // => 4\n     *\n     * _.floor(0.046, 2);\n     * // => 0.04\n     *\n     * _.floor(4060, -2);\n     * // => 4000\n     */\n    var floor = createRound('floor');\n\n    /**\n     * Gets the maximum value of `collection`. If `collection` is empty or falsey\n     * `-Infinity` is returned. If an iteratee function is provided it is invoked\n     * for each value in `collection` to generate the criterion by which the value\n     * is ranked. The `iteratee` is bound to `thisArg` and invoked with three\n     * arguments: (value, index, collection).\n     *\n     * If a property name is provided for `iteratee` the created `_.property`\n     * style callback returns the property value of the given element.\n     *\n     * If a value is also provided for `thisArg` the created `_.matchesProperty`\n     * style callback returns `true` for elements that have a matching property\n     * value, else `false`.\n     *\n     * If an object is provided for `iteratee` the created `_.matches` style\n     * callback returns `true` for elements that have the properties of the given\n     * object, else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Math\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [iteratee] The function invoked per iteration.\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\n     * @returns {*} Returns the maximum value.\n     * @example\n     *\n     * _.max([4, 2, 8, 6]);\n     * // => 8\n     *\n     * _.max([]);\n     * // => -Infinity\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36 },\n     *   { 'user': 'fred',   'age': 40 }\n     * ];\n     *\n     * _.max(users, function(chr) {\n     *   return chr.age;\n     * });\n     * // => { 'user': 'fred', 'age': 40 }\n     *\n     * // using the `_.property` callback shorthand\n     * _.max(users, 'age');\n     * // => { 'user': 'fred', 'age': 40 }\n     */\n    var max = createExtremum(gt, NEGATIVE_INFINITY);\n\n    /**\n     * Gets the minimum value of `collection`. If `collection` is empty or falsey\n     * `Infinity` is returned. If an iteratee function is provided it is invoked\n     * for each value in `collection` to generate the criterion by which the value\n     * is ranked. The `iteratee` is bound to `thisArg` and invoked with three\n     * arguments: (value, index, collection).\n     *\n     * If a property name is provided for `iteratee` the created `_.property`\n     * style callback returns the property value of the given element.\n     *\n     * If a value is also provided for `thisArg` the created `_.matchesProperty`\n     * style callback returns `true` for elements that have a matching property\n     * value, else `false`.\n     *\n     * If an object is provided for `iteratee` the created `_.matches` style\n     * callback returns `true` for elements that have the properties of the given\n     * object, else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Math\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [iteratee] The function invoked per iteration.\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\n     * @returns {*} Returns the minimum value.\n     * @example\n     *\n     * _.min([4, 2, 8, 6]);\n     * // => 2\n     *\n     * _.min([]);\n     * // => Infinity\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36 },\n     *   { 'user': 'fred',   'age': 40 }\n     * ];\n     *\n     * _.min(users, function(chr) {\n     *   return chr.age;\n     * });\n     * // => { 'user': 'barney', 'age': 36 }\n     *\n     * // using the `_.property` callback shorthand\n     * _.min(users, 'age');\n     * // => { 'user': 'barney', 'age': 36 }\n     */\n    var min = createExtremum(lt, POSITIVE_INFINITY);\n\n    /**\n     * Calculates `n` rounded to `precision`.\n     *\n     * @static\n     * @memberOf _\n     * @category Math\n     * @param {number} n The number to round.\n     * @param {number} [precision=0] The precision to round to.\n     * @returns {number} Returns the rounded number.\n     * @example\n     *\n     * _.round(4.006);\n     * // => 4\n     *\n     * _.round(4.006, 2);\n     * // => 4.01\n     *\n     * _.round(4060, -2);\n     * // => 4100\n     */\n    var round = createRound('round');\n\n    /**\n     * Gets the sum of the values in `collection`.\n     *\n     * @static\n     * @memberOf _\n     * @category Math\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [iteratee] The function invoked per iteration.\n     * @param {*} [thisArg] The `this` binding of `iteratee`.\n     * @returns {number} Returns the sum.\n     * @example\n     *\n     * _.sum([4, 6]);\n     * // => 10\n     *\n     * _.sum({ 'a': 4, 'b': 6 });\n     * // => 10\n     *\n     * var objects = [\n     *   { 'n': 4 },\n     *   { 'n': 6 }\n     * ];\n     *\n     * _.sum(objects, function(object) {\n     *   return object.n;\n     * });\n     * // => 10\n     *\n     * // using the `_.property` callback shorthand\n     * _.sum(objects, 'n');\n     * // => 10\n     */\n    function sum(collection, iteratee, thisArg) {\n      if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {\n        iteratee = undefined;\n      }\n      iteratee = getCallback(iteratee, thisArg, 3);\n      return iteratee.length == 1\n        ? arraySum(isArray(collection) ? collection : toIterable(collection), iteratee)\n        : baseSum(collection, iteratee);\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    // Ensure wrappers are instances of `baseLodash`.\n    lodash.prototype = baseLodash.prototype;\n\n    LodashWrapper.prototype = baseCreate(baseLodash.prototype);\n    LodashWrapper.prototype.constructor = LodashWrapper;\n\n    LazyWrapper.prototype = baseCreate(baseLodash.prototype);\n    LazyWrapper.prototype.constructor = LazyWrapper;\n\n    // Add functions to the `Map` cache.\n    MapCache.prototype['delete'] = mapDelete;\n    MapCache.prototype.get = mapGet;\n    MapCache.prototype.has = mapHas;\n    MapCache.prototype.set = mapSet;\n\n    // Add functions to the `Set` cache.\n    SetCache.prototype.push = cachePush;\n\n    // Assign cache to `_.memoize`.\n    memoize.Cache = MapCache;\n\n    // Add functions that return wrapped values when chaining.\n    lodash.after = after;\n    lodash.ary = ary;\n    lodash.assign = assign;\n    lodash.at = at;\n    lodash.before = before;\n    lodash.bind = bind;\n    lodash.bindAll = bindAll;\n    lodash.bindKey = bindKey;\n    lodash.callback = callback;\n    lodash.chain = chain;\n    lodash.chunk = chunk;\n    lodash.compact = compact;\n    lodash.constant = constant;\n    lodash.countBy = countBy;\n    lodash.create = create;\n    lodash.curry = curry;\n    lodash.curryRight = curryRight;\n    lodash.debounce = debounce;\n    lodash.defaults = defaults;\n    lodash.defaultsDeep = defaultsDeep;\n    lodash.defer = defer;\n    lodash.delay = delay;\n    lodash.difference = difference;\n    lodash.drop = drop;\n    lodash.dropRight = dropRight;\n    lodash.dropRightWhile = dropRightWhile;\n    lodash.dropWhile = dropWhile;\n    lodash.fill = fill;\n    lodash.filter = filter;\n    lodash.flatten = flatten;\n    lodash.flattenDeep = flattenDeep;\n    lodash.flow = flow;\n    lodash.flowRight = flowRight;\n    lodash.forEach = forEach;\n    lodash.forEachRight = forEachRight;\n    lodash.forIn = forIn;\n    lodash.forInRight = forInRight;\n    lodash.forOwn = forOwn;\n    lodash.forOwnRight = forOwnRight;\n    lodash.functions = functions;\n    lodash.groupBy = groupBy;\n    lodash.indexBy = indexBy;\n    lodash.initial = initial;\n    lodash.intersection = intersection;\n    lodash.invert = invert;\n    lodash.invoke = invoke;\n    lodash.keys = keys;\n    lodash.keysIn = keysIn;\n    lodash.map = map;\n    lodash.mapKeys = mapKeys;\n    lodash.mapValues = mapValues;\n    lodash.matches = matches;\n    lodash.matchesProperty = matchesProperty;\n    lodash.memoize = memoize;\n    lodash.merge = merge;\n    lodash.method = method;\n    lodash.methodOf = methodOf;\n    lodash.mixin = mixin;\n    lodash.modArgs = modArgs;\n    lodash.negate = negate;\n    lodash.omit = omit;\n    lodash.once = once;\n    lodash.pairs = pairs;\n    lodash.partial = partial;\n    lodash.partialRight = partialRight;\n    lodash.partition = partition;\n    lodash.pick = pick;\n    lodash.pluck = pluck;\n    lodash.property = property;\n    lodash.propertyOf = propertyOf;\n    lodash.pull = pull;\n    lodash.pullAt = pullAt;\n    lodash.range = range;\n    lodash.rearg = rearg;\n    lodash.reject = reject;\n    lodash.remove = remove;\n    lodash.rest = rest;\n    lodash.restParam = restParam;\n    lodash.set = set;\n    lodash.shuffle = shuffle;\n    lodash.slice = slice;\n    lodash.sortBy = sortBy;\n    lodash.sortByAll = sortByAll;\n    lodash.sortByOrder = sortByOrder;\n    lodash.spread = spread;\n    lodash.take = take;\n    lodash.takeRight = takeRight;\n    lodash.takeRightWhile = takeRightWhile;\n    lodash.takeWhile = takeWhile;\n    lodash.tap = tap;\n    lodash.throttle = throttle;\n    lodash.thru = thru;\n    lodash.times = times;\n    lodash.toArray = toArray;\n    lodash.toPlainObject = toPlainObject;\n    lodash.transform = transform;\n    lodash.union = union;\n    lodash.uniq = uniq;\n    lodash.unzip = unzip;\n    lodash.unzipWith = unzipWith;\n    lodash.values = values;\n    lodash.valuesIn = valuesIn;\n    lodash.where = where;\n    lodash.without = without;\n    lodash.wrap = wrap;\n    lodash.xor = xor;\n    lodash.zip = zip;\n    lodash.zipObject = zipObject;\n    lodash.zipWith = zipWith;\n\n    // Add aliases.\n    lodash.backflow = flowRight;\n    lodash.collect = map;\n    lodash.compose = flowRight;\n    lodash.each = forEach;\n    lodash.eachRight = forEachRight;\n    lodash.extend = assign;\n    lodash.iteratee = callback;\n    lodash.methods = functions;\n    lodash.object = zipObject;\n    lodash.select = filter;\n    lodash.tail = rest;\n    lodash.unique = uniq;\n\n    // Add functions to `lodash.prototype`.\n    mixin(lodash, lodash);\n\n    /*------------------------------------------------------------------------*/\n\n    // Add functions that return unwrapped values when chaining.\n    lodash.add = add;\n    lodash.attempt = attempt;\n    lodash.camelCase = camelCase;\n    lodash.capitalize = capitalize;\n    lodash.ceil = ceil;\n    lodash.clone = clone;\n    lodash.cloneDeep = cloneDeep;\n    lodash.deburr = deburr;\n    lodash.endsWith = endsWith;\n    lodash.escape = escape;\n    lodash.escapeRegExp = escapeRegExp;\n    lodash.every = every;\n    lodash.find = find;\n    lodash.findIndex = findIndex;\n    lodash.findKey = findKey;\n    lodash.findLast = findLast;\n    lodash.findLastIndex = findLastIndex;\n    lodash.findLastKey = findLastKey;\n    lodash.findWhere = findWhere;\n    lodash.first = first;\n    lodash.floor = floor;\n    lodash.get = get;\n    lodash.gt = gt;\n    lodash.gte = gte;\n    lodash.has = has;\n    lodash.identity = identity;\n    lodash.includes = includes;\n    lodash.indexOf = indexOf;\n    lodash.inRange = inRange;\n    lodash.isArguments = isArguments;\n    lodash.isArray = isArray;\n    lodash.isBoolean = isBoolean;\n    lodash.isDate = isDate;\n    lodash.isElement = isElement;\n    lodash.isEmpty = isEmpty;\n    lodash.isEqual = isEqual;\n    lodash.isError = isError;\n    lodash.isFinite = isFinite;\n    lodash.isFunction = isFunction;\n    lodash.isMatch = isMatch;\n    lodash.isNaN = isNaN;\n    lodash.isNative = isNative;\n    lodash.isNull = isNull;\n    lodash.isNumber = isNumber;\n    lodash.isObject = isObject;\n    lodash.isPlainObject = isPlainObject;\n    lodash.isRegExp = isRegExp;\n    lodash.isString = isString;\n    lodash.isTypedArray = isTypedArray;\n    lodash.isUndefined = isUndefined;\n    lodash.kebabCase = kebabCase;\n    lodash.last = last;\n    lodash.lastIndexOf = lastIndexOf;\n    lodash.lt = lt;\n    lodash.lte = lte;\n    lodash.max = max;\n    lodash.min = min;\n    lodash.noConflict = noConflict;\n    lodash.noop = noop;\n    lodash.now = now;\n    lodash.pad = pad;\n    lodash.padLeft = padLeft;\n    lodash.padRight = padRight;\n    lodash.parseInt = parseInt;\n    lodash.random = random;\n    lodash.reduce = reduce;\n    lodash.reduceRight = reduceRight;\n    lodash.repeat = repeat;\n    lodash.result = result;\n    lodash.round = round;\n    lodash.runInContext = runInContext;\n    lodash.size = size;\n    lodash.snakeCase = snakeCase;\n    lodash.some = some;\n    lodash.sortedIndex = sortedIndex;\n    lodash.sortedLastIndex = sortedLastIndex;\n    lodash.startCase = startCase;\n    lodash.startsWith = startsWith;\n    lodash.sum = sum;\n    lodash.template = template;\n    lodash.trim = trim;\n    lodash.trimLeft = trimLeft;\n    lodash.trimRight = trimRight;\n    lodash.trunc = trunc;\n    lodash.unescape = unescape;\n    lodash.uniqueId = uniqueId;\n    lodash.words = words;\n\n    // Add aliases.\n    lodash.all = every;\n    lodash.any = some;\n    lodash.contains = includes;\n    lodash.eq = isEqual;\n    lodash.detect = find;\n    lodash.foldl = reduce;\n    lodash.foldr = reduceRight;\n    lodash.head = first;\n    lodash.include = includes;\n    lodash.inject = reduce;\n\n    mixin(lodash, (function() {\n      var source = {};\n      baseForOwn(lodash, function(func, methodName) {\n        if (!lodash.prototype[methodName]) {\n          source[methodName] = func;\n        }\n      });\n      return source;\n    }()), false);\n\n    /*------------------------------------------------------------------------*/\n\n    // Add functions capable of returning wrapped and unwrapped values when chaining.\n    lodash.sample = sample;\n\n    lodash.prototype.sample = function(n) {\n      if (!this.__chain__ && n == null) {\n        return sample(this.value());\n      }\n      return this.thru(function(value) {\n        return sample(value, n);\n      });\n    };\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * The semantic version number.\n     *\n     * @static\n     * @memberOf _\n     * @type string\n     */\n    lodash.VERSION = VERSION;\n\n    // Assign default placeholders.\n    arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {\n      lodash[methodName].placeholder = lodash;\n    });\n\n    // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.\n    arrayEach(['drop', 'take'], function(methodName, index) {\n      LazyWrapper.prototype[methodName] = function(n) {\n        var filtered = this.__filtered__;\n        if (filtered && !index) {\n          return new LazyWrapper(this);\n        }\n        n = n == null ? 1 : nativeMax(nativeFloor(n) || 0, 0);\n\n        var result = this.clone();\n        if (filtered) {\n          result.__takeCount__ = nativeMin(result.__takeCount__, n);\n        } else {\n          result.__views__.push({ 'size': n, 'type': methodName + (result.__dir__ < 0 ? 'Right' : '') });\n        }\n        return result;\n      };\n\n      LazyWrapper.prototype[methodName + 'Right'] = function(n) {\n        return this.reverse()[methodName](n).reverse();\n      };\n    });\n\n    // Add `LazyWrapper` methods that accept an `iteratee` value.\n    arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {\n      var type = index + 1,\n          isFilter = type != LAZY_MAP_FLAG;\n\n      LazyWrapper.prototype[methodName] = function(iteratee, thisArg) {\n        var result = this.clone();\n        result.__iteratees__.push({ 'iteratee': getCallback(iteratee, thisArg, 1), 'type': type });\n        result.__filtered__ = result.__filtered__ || isFilter;\n        return result;\n      };\n    });\n\n    // Add `LazyWrapper` methods for `_.first` and `_.last`.\n    arrayEach(['first', 'last'], function(methodName, index) {\n      var takeName = 'take' + (index ? 'Right' : '');\n\n      LazyWrapper.prototype[methodName] = function() {\n        return this[takeName](1).value()[0];\n      };\n    });\n\n    // Add `LazyWrapper` methods for `_.initial` and `_.rest`.\n    arrayEach(['initial', 'rest'], function(methodName, index) {\n      var dropName = 'drop' + (index ? '' : 'Right');\n\n      LazyWrapper.prototype[methodName] = function() {\n        return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);\n      };\n    });\n\n    // Add `LazyWrapper` methods for `_.pluck` and `_.where`.\n    arrayEach(['pluck', 'where'], function(methodName, index) {\n      var operationName = index ? 'filter' : 'map',\n          createCallback = index ? baseMatches : property;\n\n      LazyWrapper.prototype[methodName] = function(value) {\n        return this[operationName](createCallback(value));\n      };\n    });\n\n    LazyWrapper.prototype.compact = function() {\n      return this.filter(identity);\n    };\n\n    LazyWrapper.prototype.reject = function(predicate, thisArg) {\n      predicate = getCallback(predicate, thisArg, 1);\n      return this.filter(function(value) {\n        return !predicate(value);\n      });\n    };\n\n    LazyWrapper.prototype.slice = function(start, end) {\n      start = start == null ? 0 : (+start || 0);\n\n      var result = this;\n      if (result.__filtered__ && (start > 0 || end < 0)) {\n        return new LazyWrapper(result);\n      }\n      if (start < 0) {\n        result = result.takeRight(-start);\n      } else if (start) {\n        result = result.drop(start);\n      }\n      if (end !== undefined) {\n        end = (+end || 0);\n        result = end < 0 ? result.dropRight(-end) : result.take(end - start);\n      }\n      return result;\n    };\n\n    LazyWrapper.prototype.takeRightWhile = function(predicate, thisArg) {\n      return this.reverse().takeWhile(predicate, thisArg).reverse();\n    };\n\n    LazyWrapper.prototype.toArray = function() {\n      return this.take(POSITIVE_INFINITY);\n    };\n\n    // Add `LazyWrapper` methods to `lodash.prototype`.\n    baseForOwn(LazyWrapper.prototype, function(func, methodName) {\n      var checkIteratee = /^(?:filter|map|reject)|While$/.test(methodName),\n          retUnwrapped = /^(?:first|last)$/.test(methodName),\n          lodashFunc = lodash[retUnwrapped ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName];\n\n      if (!lodashFunc) {\n        return;\n      }\n      lodash.prototype[methodName] = function() {\n        var args = retUnwrapped ? [1] : arguments,\n            chainAll = this.__chain__,\n            value = this.__wrapped__,\n            isHybrid = !!this.__actions__.length,\n            isLazy = value instanceof LazyWrapper,\n            iteratee = args[0],\n            useLazy = isLazy || isArray(value);\n\n        if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {\n          // Avoid lazy use if the iteratee has a \"length\" value other than `1`.\n          isLazy = useLazy = false;\n        }\n        var interceptor = function(value) {\n          return (retUnwrapped && chainAll)\n            ? lodashFunc(value, 1)[0]\n            : lodashFunc.apply(undefined, arrayPush([value], args));\n        };\n\n        var action = { 'func': thru, 'args': [interceptor], 'thisArg': undefined },\n            onlyLazy = isLazy && !isHybrid;\n\n        if (retUnwrapped && !chainAll) {\n          if (onlyLazy) {\n            value = value.clone();\n            value.__actions__.push(action);\n            return func.call(value);\n          }\n          return lodashFunc.call(undefined, this.value())[0];\n        }\n        if (!retUnwrapped && useLazy) {\n          value = onlyLazy ? value : new LazyWrapper(this);\n          var result = func.apply(value, args);\n          result.__actions__.push(action);\n          return new LodashWrapper(result, chainAll);\n        }\n        return this.thru(interceptor);\n      };\n    });\n\n    // Add `Array` and `String` methods to `lodash.prototype`.\n    arrayEach(['join', 'pop', 'push', 'replace', 'shift', 'sort', 'splice', 'split', 'unshift'], function(methodName) {\n      var func = (/^(?:replace|split)$/.test(methodName) ? stringProto : arrayProto)[methodName],\n          chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',\n          retUnwrapped = /^(?:join|pop|replace|shift)$/.test(methodName);\n\n      lodash.prototype[methodName] = function() {\n        var args = arguments;\n        if (retUnwrapped && !this.__chain__) {\n          return func.apply(this.value(), args);\n        }\n        return this[chainName](function(value) {\n          return func.apply(value, args);\n        });\n      };\n    });\n\n    // Map minified function names to their real names.\n    baseForOwn(LazyWrapper.prototype, function(func, methodName) {\n      var lodashFunc = lodash[methodName];\n      if (lodashFunc) {\n        var key = lodashFunc.name,\n            names = realNames[key] || (realNames[key] = []);\n\n        names.push({ 'name': methodName, 'func': lodashFunc });\n      }\n    });\n\n    realNames[createHybridWrapper(undefined, BIND_KEY_FLAG).name] = [{ 'name': 'wrapper', 'func': undefined }];\n\n    // Add functions to the lazy wrapper.\n    LazyWrapper.prototype.clone = lazyClone;\n    LazyWrapper.prototype.reverse = lazyReverse;\n    LazyWrapper.prototype.value = lazyValue;\n\n    // Add chaining functions to the `lodash` wrapper.\n    lodash.prototype.chain = wrapperChain;\n    lodash.prototype.commit = wrapperCommit;\n    lodash.prototype.concat = wrapperConcat;\n    lodash.prototype.plant = wrapperPlant;\n    lodash.prototype.reverse = wrapperReverse;\n    lodash.prototype.toString = wrapperToString;\n    lodash.prototype.run = lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;\n\n    // Add function aliases to the `lodash` wrapper.\n    lodash.prototype.collect = lodash.prototype.map;\n    lodash.prototype.head = lodash.prototype.first;\n    lodash.prototype.select = lodash.prototype.filter;\n    lodash.prototype.tail = lodash.prototype.rest;\n\n    return lodash;\n  }\n\n  /*--------------------------------------------------------------------------*/\n\n  // Export lodash.\n  var _ = runInContext();\n\n  // Some AMD build optimizers like r.js check for condition patterns like the following:\n  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {\n    // Expose lodash to the global object when an AMD loader is present to avoid\n    // errors in cases where lodash is loaded by a script tag and not intended\n    // as an AMD module. See http://requirejs.org/docs/errors.html#mismatch for\n    // more details.\n    root._ = _;\n\n    // Define as an anonymous module so, through path mapping, it can be\n    // referenced as the \"underscore\" module.\n    define(function() {\n      return _;\n    });\n  }\n  // Check for `exports` after `define` in case a build optimizer adds an `exports` object.\n  else if (freeExports && freeModule) {\n    // Export for Node.js or RingoJS.\n    if (moduleExports) {\n      (freeModule.exports = _)._ = _;\n    }\n    // Export for Rhino with CommonJS support.\n    else {\n      freeExports._ = _;\n    }\n  }\n  else {\n    // Export for a browser or Rhino.\n    root._ = _;\n  }\n}.call(this));\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ub-virtualdom/~/lodash/index.js\n ** module id = 79\n ** module chunks = 0\n **/","var h = require(\"./virtual-hyperscript/index.js\")\n\nmodule.exports = h\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/virtual-dom/h.js\n ** module id = 80\n ** module chunks = 0\n **/","'use strict';\n\nvar isArray = require('x-is-array');\n\nvar VNode = require('../vnode/vnode.js');\nvar VText = require('../vnode/vtext.js');\nvar isVNode = require('../vnode/is-vnode');\nvar isVText = require('../vnode/is-vtext');\nvar isWidget = require('../vnode/is-widget');\nvar isHook = require('../vnode/is-vhook');\nvar isVThunk = require('../vnode/is-thunk');\n\nvar parseTag = require('./parse-tag.js');\nvar softSetHook = require('./hooks/soft-set-hook.js');\nvar evHook = require('./hooks/ev-hook.js');\n\nmodule.exports = h;\n\nfunction h(tagName, properties, children) {\n    var childNodes = [];\n    var tag, props, key, namespace;\n\n    if (!children && isChildren(properties)) {\n        children = properties;\n        props = {};\n    }\n\n    props = props || properties || {};\n    tag = parseTag(tagName, props);\n\n    // support keys\n    if (props.hasOwnProperty('key')) {\n        key = props.key;\n        props.key = undefined;\n    }\n\n    // support namespace\n    if (props.hasOwnProperty('namespace')) {\n        namespace = props.namespace;\n        props.namespace = undefined;\n    }\n\n    // fix cursor bug\n    if (tag === 'INPUT' &&\n        !namespace &&\n        props.hasOwnProperty('value') &&\n        props.value !== undefined &&\n        !isHook(props.value)\n    ) {\n        props.value = softSetHook(props.value);\n    }\n\n    transformProperties(props);\n\n    if (children !== undefined && children !== null) {\n        addChild(children, childNodes, tag, props);\n    }\n\n\n    return new VNode(tag, props, childNodes, key, namespace);\n}\n\nfunction addChild(c, childNodes, tag, props) {\n    if (typeof c === 'string') {\n        childNodes.push(new VText(c));\n    } else if (typeof c === 'number') {\n        childNodes.push(new VText(String(c)));\n    } else if (isChild(c)) {\n        childNodes.push(c);\n    } else if (isArray(c)) {\n        for (var i = 0; i < c.length; i++) {\n            addChild(c[i], childNodes, tag, props);\n        }\n    } else if (c === null || c === undefined) {\n        return;\n    } else {\n        throw UnexpectedVirtualElement({\n            foreignObject: c,\n            parentVnode: {\n                tagName: tag,\n                properties: props\n            }\n        });\n    }\n}\n\nfunction transformProperties(props) {\n    for (var propName in props) {\n        if (props.hasOwnProperty(propName)) {\n            var value = props[propName];\n\n            if (isHook(value)) {\n                continue;\n            }\n\n            if (propName.substr(0, 3) === 'ev-') {\n                // add ev-foo support\n                props[propName] = evHook(value);\n            }\n        }\n    }\n}\n\nfunction isChild(x) {\n    return isVNode(x) || isVText(x) || isWidget(x) || isVThunk(x);\n}\n\nfunction isChildren(x) {\n    return typeof x === 'string' || isArray(x) || isChild(x);\n}\n\nfunction UnexpectedVirtualElement(data) {\n    var err = new Error();\n\n    err.type = 'virtual-hyperscript.unexpected.virtual-element';\n    err.message = 'Unexpected virtual child passed to h().\\n' +\n        'Expected a VNode / Vthunk / VWidget / string but:\\n' +\n        'got:\\n' +\n        errorString(data.foreignObject) +\n        '.\\n' +\n        'The parent vnode is:\\n' +\n        errorString(data.parentVnode)\n        '\\n' +\n        'Suggested fix: change your `h(..., [ ... ])` callsite.';\n    err.foreignObject = data.foreignObject;\n    err.parentVnode = data.parentVnode;\n\n    return err;\n}\n\nfunction errorString(obj) {\n    try {\n        return JSON.stringify(obj, null, '    ');\n    } catch (e) {\n        return String(obj);\n    }\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/virtual-dom/virtual-hyperscript/index.js\n ** module id = 81\n ** module chunks = 0\n **/","var version = require(\"./version\")\nvar isVNode = require(\"./is-vnode\")\nvar isWidget = require(\"./is-widget\")\nvar isThunk = require(\"./is-thunk\")\nvar isVHook = require(\"./is-vhook\")\n\nmodule.exports = VirtualNode\n\nvar noProperties = {}\nvar noChildren = []\n\nfunction VirtualNode(tagName, properties, children, key, namespace) {\n    this.tagName = tagName\n    this.properties = properties || noProperties\n    this.children = children || noChildren\n    this.key = key != null ? String(key) : undefined\n    this.namespace = (typeof namespace === \"string\") ? namespace : null\n\n    var count = (children && children.length) || 0\n    var descendants = 0\n    var hasWidgets = false\n    var hasThunks = false\n    var descendantHooks = false\n    var hooks\n\n    for (var propName in properties) {\n        if (properties.hasOwnProperty(propName)) {\n            var property = properties[propName]\n            if (isVHook(property) && property.unhook) {\n                if (!hooks) {\n                    hooks = {}\n                }\n\n                hooks[propName] = property\n            }\n        }\n    }\n\n    for (var i = 0; i < count; i++) {\n        var child = children[i]\n        if (isVNode(child)) {\n            descendants += child.count || 0\n\n            if (!hasWidgets && child.hasWidgets) {\n                hasWidgets = true\n            }\n\n            if (!hasThunks && child.hasThunks) {\n                hasThunks = true\n            }\n\n            if (!descendantHooks && (child.hooks || child.descendantHooks)) {\n                descendantHooks = true\n            }\n        } else if (!hasWidgets && isWidget(child)) {\n            if (typeof child.destroy === \"function\") {\n                hasWidgets = true\n            }\n        } else if (!hasThunks && isThunk(child)) {\n            hasThunks = true;\n        }\n    }\n\n    this.count = count + descendants\n    this.hasWidgets = hasWidgets\n    this.hasThunks = hasThunks\n    this.hooks = hooks\n    this.descendantHooks = descendantHooks\n}\n\nVirtualNode.prototype.version = version\nVirtualNode.prototype.type = \"VirtualNode\"\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/virtual-dom/vnode/vnode.js\n ** module id = 82\n ** module chunks = 0\n **/","var version = require(\"./version\")\n\nmodule.exports = VirtualText\n\nfunction VirtualText(text) {\n    this.text = String(text)\n}\n\nVirtualText.prototype.version = version\nVirtualText.prototype.type = \"VirtualText\"\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/virtual-dom/vnode/vtext.js\n ** module id = 83\n ** module chunks = 0\n **/","'use strict';\n\nvar split = require('browser-split');\n\nvar classIdSplit = /([\\.#]?[a-zA-Z0-9\\u007F-\\uFFFF_:-]+)/;\nvar notClassId = /^\\.|#/;\n\nmodule.exports = parseTag;\n\nfunction parseTag(tag, props) {\n    if (!tag) {\n        return 'DIV';\n    }\n\n    var noId = !(props.hasOwnProperty('id'));\n\n    var tagParts = split(tag, classIdSplit);\n    var tagName = null;\n\n    if (notClassId.test(tagParts[1])) {\n        tagName = 'DIV';\n    }\n\n    var classes, part, type, i;\n\n    for (i = 0; i < tagParts.length; i++) {\n        part = tagParts[i];\n\n        if (!part) {\n            continue;\n        }\n\n        type = part.charAt(0);\n\n        if (!tagName) {\n            tagName = part;\n        } else if (type === '.') {\n            classes = classes || [];\n            classes.push(part.substring(1, part.length));\n        } else if (type === '#' && noId) {\n            props.id = part.substring(1, part.length);\n        }\n    }\n\n    if (classes) {\n        if (props.className) {\n            classes.push(props.className);\n        }\n\n        props.className = classes.join(' ');\n    }\n\n    return props.namespace ? tagName : tagName.toUpperCase();\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/virtual-dom/virtual-hyperscript/parse-tag.js\n ** module id = 84\n ** module chunks = 0\n **/","/*!\n * Cross-Browser Split 1.1.1\n * Copyright 2007-2012 Steven Levithan <stevenlevithan.com>\n * Available under the MIT License\n * ECMAScript compliant, uniform cross-browser split method\n */\n\n/**\n * Splits a string into an array of strings using a regex or string separator. Matches of the\n * separator are not included in the result array. However, if `separator` is a regex that contains\n * capturing groups, backreferences are spliced into the result each time `separator` is matched.\n * Fixes browser bugs compared to the native `String.prototype.split` and can be used reliably\n * cross-browser.\n * @param {String} str String to split.\n * @param {RegExp|String} separator Regex or string to use for separating the string.\n * @param {Number} [limit] Maximum number of items to include in the result array.\n * @returns {Array} Array of substrings.\n * @example\n *\n * // Basic use\n * split('a b c d', ' ');\n * // -> ['a', 'b', 'c', 'd']\n *\n * // With limit\n * split('a b c d', ' ', 2);\n * // -> ['a', 'b']\n *\n * // Backreferences in result array\n * split('..word1 word2..', /([a-z]+)(\\d+)/i);\n * // -> ['..', 'word', '1', ' ', 'word', '2', '..']\n */\nmodule.exports = (function split(undef) {\n\n  var nativeSplit = String.prototype.split,\n    compliantExecNpcg = /()??/.exec(\"\")[1] === undef,\n    // NPCG: nonparticipating capturing group\n    self;\n\n  self = function(str, separator, limit) {\n    // If `separator` is not a regex, use `nativeSplit`\n    if (Object.prototype.toString.call(separator) !== \"[object RegExp]\") {\n      return nativeSplit.call(str, separator, limit);\n    }\n    var output = [],\n      flags = (separator.ignoreCase ? \"i\" : \"\") + (separator.multiline ? \"m\" : \"\") + (separator.extended ? \"x\" : \"\") + // Proposed for ES6\n      (separator.sticky ? \"y\" : \"\"),\n      // Firefox 3+\n      lastLastIndex = 0,\n      // Make `global` and avoid `lastIndex` issues by working with a copy\n      separator = new RegExp(separator.source, flags + \"g\"),\n      separator2, match, lastIndex, lastLength;\n    str += \"\"; // Type-convert\n    if (!compliantExecNpcg) {\n      // Doesn't need flags gy, but they don't hurt\n      separator2 = new RegExp(\"^\" + separator.source + \"$(?!\\\\s)\", flags);\n    }\n    /* Values for `limit`, per the spec:\n     * If undefined: 4294967295 // Math.pow(2, 32) - 1\n     * If 0, Infinity, or NaN: 0\n     * If positive number: limit = Math.floor(limit); if (limit > 4294967295) limit -= 4294967296;\n     * If negative number: 4294967296 - Math.floor(Math.abs(limit))\n     * If other: Type-convert, then use the above rules\n     */\n    limit = limit === undef ? -1 >>> 0 : // Math.pow(2, 32) - 1\n    limit >>> 0; // ToUint32(limit)\n    while (match = separator.exec(str)) {\n      // `separator.lastIndex` is not reliable cross-browser\n      lastIndex = match.index + match[0].length;\n      if (lastIndex > lastLastIndex) {\n        output.push(str.slice(lastLastIndex, match.index));\n        // Fix browsers whose `exec` methods don't consistently return `undefined` for\n        // nonparticipating capturing groups\n        if (!compliantExecNpcg && match.length > 1) {\n          match[0].replace(separator2, function() {\n            for (var i = 1; i < arguments.length - 2; i++) {\n              if (arguments[i] === undef) {\n                match[i] = undef;\n              }\n            }\n          });\n        }\n        if (match.length > 1 && match.index < str.length) {\n          Array.prototype.push.apply(output, match.slice(1));\n        }\n        lastLength = match[0].length;\n        lastLastIndex = lastIndex;\n        if (output.length >= limit) {\n          break;\n        }\n      }\n      if (separator.lastIndex === match.index) {\n        separator.lastIndex++; // Avoid an infinite loop\n      }\n    }\n    if (lastLastIndex === str.length) {\n      if (lastLength || !separator.test(\"\")) {\n        output.push(\"\");\n      }\n    } else {\n      output.push(str.slice(lastLastIndex));\n    }\n    return output.length > limit ? output.slice(0, limit) : output;\n  };\n\n  return self;\n})();\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/browser-split/index.js\n ** module id = 85\n ** module chunks = 0\n **/","'use strict';\n\nmodule.exports = SoftSetHook;\n\nfunction SoftSetHook(value) {\n    if (!(this instanceof SoftSetHook)) {\n        return new SoftSetHook(value);\n    }\n\n    this.value = value;\n}\n\nSoftSetHook.prototype.hook = function (node, propertyName) {\n    if (node[propertyName] !== this.value) {\n        node[propertyName] = this.value;\n    }\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/virtual-dom/virtual-hyperscript/hooks/soft-set-hook.js\n ** module id = 86\n ** module chunks = 0\n **/","'use strict';\n\nvar EvStore = require('ev-store');\n\nmodule.exports = EvHook;\n\nfunction EvHook(value) {\n    if (!(this instanceof EvHook)) {\n        return new EvHook(value);\n    }\n\n    this.value = value;\n}\n\nEvHook.prototype.hook = function (node, propertyName) {\n    var es = EvStore(node);\n    var propName = propertyName.substr(3);\n\n    es[propName] = this.value;\n};\n\nEvHook.prototype.unhook = function(node, propertyName) {\n    var es = EvStore(node);\n    var propName = propertyName.substr(3);\n\n    es[propName] = undefined;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/virtual-dom/virtual-hyperscript/hooks/ev-hook.js\n ** module id = 87\n ** module chunks = 0\n **/","'use strict';\n\nvar OneVersionConstraint = require('individual/one-version');\n\nvar MY_VERSION = '7';\nOneVersionConstraint('ev-store', MY_VERSION);\n\nvar hashKey = '__EV_STORE_KEY@' + MY_VERSION;\n\nmodule.exports = EvStore;\n\nfunction EvStore(elem) {\n    var hash = elem[hashKey];\n\n    if (!hash) {\n        hash = elem[hashKey] = {};\n    }\n\n    return hash;\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ev-store/index.js\n ** module id = 88\n ** module chunks = 0\n **/","'use strict';\n\nvar Individual = require('./index.js');\n\nmodule.exports = OneVersion;\n\nfunction OneVersion(moduleName, version, defaultValue) {\n    var key = '__INDIVIDUAL_ONE_VERSION_' + moduleName;\n    var enforceKey = key + '_ENFORCE_SINGLETON';\n\n    var versionValue = Individual(enforceKey, version);\n\n    if (versionValue !== version) {\n        throw new Error('Can only have one copy of ' +\n            moduleName + '.\\n' +\n            'You already have version ' + versionValue +\n            ' installed.\\n' +\n            'This means you cannot install version ' + version);\n    }\n\n    return Individual(key, defaultValue);\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ev-store/~/individual/one-version.js\n ** module id = 89\n ** module chunks = 0\n **/","'use strict';\n\n/*global window, global*/\n\nvar root = typeof window !== 'undefined' ?\n    window : typeof global !== 'undefined' ?\n    global : {};\n\nmodule.exports = Individual;\n\nfunction Individual(key, value) {\n    if (key in root) {\n        return root[key];\n    }\n\n    root[key] = value;\n\n    return value;\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ev-store/~/individual/index.js\n ** module id = 90\n ** module chunks = 0\n **/","var Individual = require(\"individual\")\nvar cuid = require(\"cuid\")\nvar globalDocument = require(\"global/document\")\n\nvar DOMDelegator = require(\"./dom-delegator.js\")\n\nvar versionKey = \"13\"\nvar cacheKey = \"__DOM_DELEGATOR_CACHE@\" + versionKey\nvar cacheTokenKey = \"__DOM_DELEGATOR_CACHE_TOKEN@\" + versionKey\nvar delegatorCache = Individual(cacheKey, {\n    delegators: {}\n})\nvar commonEvents = [\n    \"blur\", \"change\", \"click\",  \"contextmenu\", \"dblclick\",\n    \"error\",\"focus\", \"focusin\", \"focusout\", \"input\", \"keydown\",\n    \"keypress\", \"keyup\", \"load\", \"mousedown\", \"mouseup\",\n    \"resize\", \"select\", \"submit\", \"touchcancel\",\n    \"touchend\", \"touchstart\", \"unload\"\n]\n\n/*  Delegator is a thin wrapper around a singleton `DOMDelegator`\n        instance.\n\n    Only one DOMDelegator should exist because we do not want\n        duplicate event listeners bound to the DOM.\n\n    `Delegator` will also `listenTo()` all events unless\n        every caller opts out of it\n*/\nmodule.exports = Delegator\n\nfunction Delegator(opts) {\n    opts = opts || {}\n    var document = opts.document || globalDocument\n\n    var cacheKey = document[cacheTokenKey]\n\n    if (!cacheKey) {\n        cacheKey =\n            document[cacheTokenKey] = cuid()\n    }\n\n    var delegator = delegatorCache.delegators[cacheKey]\n\n    if (!delegator) {\n        delegator = delegatorCache.delegators[cacheKey] =\n            new DOMDelegator(document)\n    }\n\n    if (opts.defaultEvents !== false) {\n        for (var i = 0; i < commonEvents.length; i++) {\n            delegator.listenTo(commonEvents[i])\n        }\n    }\n\n    return delegator\n}\n\nDelegator.allocateHandle = DOMDelegator.allocateHandle;\nDelegator.transformHandle = DOMDelegator.transformHandle;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/dom-delegator/index.js\n ** module id = 91\n ** module chunks = 0\n **/","var root = typeof window !== 'undefined' ?\n    window : typeof global !== 'undefined' ?\n    global : {};\n\nmodule.exports = Individual\n\nfunction Individual(key, value) {\n    if (root[key]) {\n        return root[key]\n    }\n\n    Object.defineProperty(root, key, {\n        value: value\n        , configurable: true\n    })\n\n    return value\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/individual/index.js\n ** module id = 92\n ** module chunks = 0\n **/","/**\n * cuid.js\n * Collision-resistant UID generator for browsers and node.\n * Sequential for fast db lookups and recency sorting.\n * Safe for element IDs and server-side lookups.\n *\n * Extracted from CLCTR\n *\n * Copyright (c) Eric Elliott 2012\n * MIT License\n */\n\n/*global window, navigator, document, require, process, module */\n(function (app) {\n  'use strict';\n  var namespace = 'cuid',\n    c = 0,\n    blockSize = 4,\n    base = 36,\n    discreteValues = Math.pow(base, blockSize),\n\n    pad = function pad(num, size) {\n      var s = \"000000000\" + num;\n      return s.substr(s.length-size);\n    },\n\n    randomBlock = function randomBlock() {\n      return pad((Math.random() *\n            discreteValues << 0)\n            .toString(base), blockSize);\n    },\n\n    safeCounter = function () {\n      c = (c < discreteValues) ? c : 0;\n      c++; // this is not subliminal\n      return c - 1;\n    },\n\n    api = function cuid() {\n      // Starting with a lowercase letter makes\n      // it HTML element ID friendly.\n      var letter = 'c', // hard-coded allows for sequential access\n\n        // timestamp\n        // warning: this exposes the exact date and time\n        // that the uid was created.\n        timestamp = (new Date().getTime()).toString(base),\n\n        // Prevent same-machine collisions.\n        counter,\n\n        // A few chars to generate distinct ids for different\n        // clients (so different computers are far less\n        // likely to generate the same id)\n        fingerprint = api.fingerprint(),\n\n        // Grab some more chars from Math.random()\n        random = randomBlock() + randomBlock();\n\n        counter = pad(safeCounter().toString(base), blockSize);\n\n      return  (letter + timestamp + counter + fingerprint + random);\n    };\n\n  api.slug = function slug() {\n    var date = new Date().getTime().toString(36),\n      counter,\n      print = api.fingerprint().slice(0,1) +\n        api.fingerprint().slice(-1),\n      random = randomBlock().slice(-2);\n\n      counter = safeCounter().toString(36).slice(-4);\n\n    return date.slice(-2) +\n      counter + print + random;\n  };\n\n  api.globalCount = function globalCount() {\n    // We want to cache the results of this\n    var cache = (function calc() {\n        var i,\n          count = 0;\n\n        for (i in window) {\n          count++;\n        }\n\n        return count;\n      }());\n\n    api.globalCount = function () { return cache; };\n    return cache;\n  };\n\n  api.fingerprint = function browserPrint() {\n    return pad((navigator.mimeTypes.length +\n      navigator.userAgent.length).toString(36) +\n      api.globalCount().toString(36), 4);\n  };\n\n  // don't change anything from here down.\n  if (app.register) {\n    app.register(namespace, api);\n  } else if (typeof module !== 'undefined') {\n    module.exports = api;\n  } else {\n    app[namespace] = api;\n  }\n\n}(this.applitude || this));\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cuid/dist/browser-cuid.js\n ** module id = 93\n ** module chunks = 0\n **/","var globalDocument = require(\"global/document\")\nvar EvStore = require(\"ev-store\")\nvar createStore = require(\"weakmap-shim/create-store\")\n\nvar addEvent = require(\"./add-event.js\")\nvar removeEvent = require(\"./remove-event.js\")\nvar ProxyEvent = require(\"./proxy-event.js\")\n\nvar HANDLER_STORE = createStore()\n\nmodule.exports = DOMDelegator\n\nfunction DOMDelegator(document) {\n    if (!(this instanceof DOMDelegator)) {\n        return new DOMDelegator(document);\n    }\n\n    document = document || globalDocument\n\n    this.target = document.documentElement\n    this.events = {}\n    this.rawEventListeners = {}\n    this.globalListeners = {}\n}\n\nDOMDelegator.prototype.addEventListener = addEvent\nDOMDelegator.prototype.removeEventListener = removeEvent\n\nDOMDelegator.allocateHandle =\n    function allocateHandle(func) {\n        var handle = new Handle()\n\n        HANDLER_STORE(handle).func = func;\n\n        return handle\n    }\n\nDOMDelegator.transformHandle =\n    function transformHandle(handle, broadcast) {\n        var func = HANDLER_STORE(handle).func\n\n        return this.allocateHandle(function (ev) {\n            broadcast(ev, func);\n        })\n    }\n\nDOMDelegator.prototype.addGlobalEventListener =\n    function addGlobalEventListener(eventName, fn) {\n        var listeners = this.globalListeners[eventName] || [];\n        if (listeners.indexOf(fn) === -1) {\n            listeners.push(fn)\n        }\n\n        this.globalListeners[eventName] = listeners;\n    }\n\nDOMDelegator.prototype.removeGlobalEventListener =\n    function removeGlobalEventListener(eventName, fn) {\n        var listeners = this.globalListeners[eventName] || [];\n\n        var index = listeners.indexOf(fn)\n        if (index !== -1) {\n            listeners.splice(index, 1)\n        }\n    }\n\nDOMDelegator.prototype.listenTo = function listenTo(eventName) {\n    if (!(eventName in this.events)) {\n        this.events[eventName] = 0;\n    }\n\n    this.events[eventName]++;\n\n    if (this.events[eventName] !== 1) {\n        return\n    }\n\n    var listener = this.rawEventListeners[eventName]\n    if (!listener) {\n        listener = this.rawEventListeners[eventName] =\n            createHandler(eventName, this)\n    }\n\n    this.target.addEventListener(eventName, listener, true)\n}\n\nDOMDelegator.prototype.unlistenTo = function unlistenTo(eventName) {\n    if (!(eventName in this.events)) {\n        this.events[eventName] = 0;\n    }\n\n    if (this.events[eventName] === 0) {\n        throw new Error(\"already unlistened to event.\");\n    }\n\n    this.events[eventName]--;\n\n    if (this.events[eventName] !== 0) {\n        return\n    }\n\n    var listener = this.rawEventListeners[eventName]\n\n    if (!listener) {\n        throw new Error(\"dom-delegator#unlistenTo: cannot \" +\n            \"unlisten to \" + eventName)\n    }\n\n    this.target.removeEventListener(eventName, listener, true)\n}\n\nfunction createHandler(eventName, delegator) {\n    var globalListeners = delegator.globalListeners;\n    var delegatorTarget = delegator.target;\n\n    return handler\n\n    function handler(ev) {\n        var globalHandlers = globalListeners[eventName] || []\n\n        if (globalHandlers.length > 0) {\n            var globalEvent = new ProxyEvent(ev);\n            globalEvent.currentTarget = delegatorTarget;\n            callListeners(globalHandlers, globalEvent)\n        }\n\n        findAndInvokeListeners(ev.target, ev, eventName)\n    }\n}\n\nfunction findAndInvokeListeners(elem, ev, eventName) {\n    var listener = getListener(elem, eventName)\n\n    if (listener && listener.handlers.length > 0) {\n        var listenerEvent = new ProxyEvent(ev);\n        listenerEvent.currentTarget = listener.currentTarget\n        callListeners(listener.handlers, listenerEvent)\n\n        if (listenerEvent._bubbles) {\n            var nextTarget = listener.currentTarget.parentNode\n            findAndInvokeListeners(nextTarget, ev, eventName)\n        }\n    }\n}\n\nfunction getListener(target, type) {\n    // terminate recursion if parent is `null`\n    if (target === null || typeof target === \"undefined\") {\n        return null\n    }\n\n    var events = EvStore(target)\n    // fetch list of handler fns for this event\n    var handler = events[type]\n    var allHandler = events.event\n\n    if (!handler && !allHandler) {\n        return getListener(target.parentNode, type)\n    }\n\n    var handlers = [].concat(handler || [], allHandler || [])\n    return new Listener(target, handlers)\n}\n\nfunction callListeners(handlers, ev) {\n    handlers.forEach(function (handler) {\n        if (typeof handler === \"function\") {\n            handler(ev)\n        } else if (typeof handler.handleEvent === \"function\") {\n            handler.handleEvent(ev)\n        } else if (handler.type === \"dom-delegator-handle\") {\n            HANDLER_STORE(handler).func(ev)\n        } else {\n            throw new Error(\"dom-delegator: unknown handler \" +\n                \"found: \" + JSON.stringify(handlers));\n        }\n    })\n}\n\nfunction Listener(target, handlers) {\n    this.currentTarget = target\n    this.handlers = handlers\n}\n\nfunction Handle() {\n    this.type = \"dom-delegator-handle\"\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/dom-delegator/dom-delegator.js\n ** module id = 94\n ** module chunks = 0\n **/","var hiddenStore = require('./hidden-store.js');\n\nmodule.exports = createStore;\n\nfunction createStore() {\n    var key = {};\n\n    return function (obj) {\n        if ((typeof obj !== 'object' || obj === null) &&\n            typeof obj !== 'function'\n        ) {\n            throw new Error('Weakmap-shim: Key must be object')\n        }\n\n        var store = obj.valueOf(key);\n        return store && store.identity === key ?\n            store : hiddenStore(obj, key);\n    };\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/weakmap-shim/create-store.js\n ** module id = 95\n ** module chunks = 0\n **/","module.exports = hiddenStore;\n\nfunction hiddenStore(obj, key) {\n    var store = { identity: key };\n    var valueOf = obj.valueOf;\n\n    Object.defineProperty(obj, \"valueOf\", {\n        value: function (value) {\n            return value !== key ?\n                valueOf.apply(this, arguments) : store;\n        },\n        writable: true\n    });\n\n    return store;\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/weakmap-shim/hidden-store.js\n ** module id = 96\n ** module chunks = 0\n **/","var EvStore = require(\"ev-store\")\n\nmodule.exports = addEvent\n\nfunction addEvent(target, type, handler) {\n    var events = EvStore(target)\n    var event = events[type]\n\n    if (!event) {\n        events[type] = handler\n    } else if (Array.isArray(event)) {\n        if (event.indexOf(handler) === -1) {\n            event.push(handler)\n        }\n    } else if (event !== handler) {\n        events[type] = [event, handler]\n    }\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/dom-delegator/add-event.js\n ** module id = 97\n ** module chunks = 0\n **/","var EvStore = require(\"ev-store\")\n\nmodule.exports = removeEvent\n\nfunction removeEvent(target, type, handler) {\n    var events = EvStore(target)\n    var event = events[type]\n\n    if (!event) {\n        return\n    } else if (Array.isArray(event)) {\n        var index = event.indexOf(handler)\n        if (index !== -1) {\n            event.splice(index, 1)\n        }\n    } else if (event === handler) {\n        events[type] = null\n    }\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/dom-delegator/remove-event.js\n ** module id = 98\n ** module chunks = 0\n **/","var inherits = require(\"inherits\")\n\nvar ALL_PROPS = [\n    \"altKey\", \"bubbles\", \"cancelable\", \"ctrlKey\",\n    \"eventPhase\", \"metaKey\", \"relatedTarget\", \"shiftKey\",\n    \"target\", \"timeStamp\", \"type\", \"view\", \"which\"\n]\nvar KEY_PROPS = [\"char\", \"charCode\", \"key\", \"keyCode\"]\nvar MOUSE_PROPS = [\n    \"button\", \"buttons\", \"clientX\", \"clientY\", \"layerX\",\n    \"layerY\", \"offsetX\", \"offsetY\", \"pageX\", \"pageY\",\n    \"screenX\", \"screenY\", \"toElement\"\n]\n\nvar rkeyEvent = /^key|input/\nvar rmouseEvent = /^(?:mouse|pointer|contextmenu)|click/\n\nmodule.exports = ProxyEvent\n\nfunction ProxyEvent(ev) {\n    if (!(this instanceof ProxyEvent)) {\n        return new ProxyEvent(ev)\n    }\n\n    if (rkeyEvent.test(ev.type)) {\n        return new KeyEvent(ev)\n    } else if (rmouseEvent.test(ev.type)) {\n        return new MouseEvent(ev)\n    }\n\n    for (var i = 0; i < ALL_PROPS.length; i++) {\n        var propKey = ALL_PROPS[i]\n        this[propKey] = ev[propKey]\n    }\n\n    this._rawEvent = ev\n    this._bubbles = false;\n}\n\nProxyEvent.prototype.preventDefault = function () {\n    this._rawEvent.preventDefault()\n}\n\nProxyEvent.prototype.startPropagation = function () {\n    this._bubbles = true;\n}\n\nfunction MouseEvent(ev) {\n    for (var i = 0; i < ALL_PROPS.length; i++) {\n        var propKey = ALL_PROPS[i]\n        this[propKey] = ev[propKey]\n    }\n\n    for (var j = 0; j < MOUSE_PROPS.length; j++) {\n        var mousePropKey = MOUSE_PROPS[j]\n        this[mousePropKey] = ev[mousePropKey]\n    }\n\n    this._rawEvent = ev\n}\n\ninherits(MouseEvent, ProxyEvent)\n\nfunction KeyEvent(ev) {\n    for (var i = 0; i < ALL_PROPS.length; i++) {\n        var propKey = ALL_PROPS[i]\n        this[propKey] = ev[propKey]\n    }\n\n    for (var j = 0; j < KEY_PROPS.length; j++) {\n        var keyPropKey = KEY_PROPS[j]\n        this[keyPropKey] = ev[keyPropKey]\n    }\n\n    this._rawEvent = ev\n}\n\ninherits(KeyEvent, ProxyEvent)\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/dom-delegator/proxy-event.js\n ** module id = 99\n ** module chunks = 0\n **/","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/inherits/inherits_browser.js\n ** module id = 100\n ** module chunks = 0\n **/","module.exports = require('./lodash.js');\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lodash/index.js\n ** module id = 101\n ** module chunks = 0\n **/","/**\n * @license\n * lodash 4.0.0 (Custom Build) <https://lodash.com/>\n * Build: `lodash -d -o ./lodash.js`\n * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <https://lodash.com/license>\n */\n;(function() {\n\n  /** Used as a safe reference for `undefined` in pre-ES5 environments. */\n  var undefined;\n\n  /** Used as the semantic version number. */\n  var VERSION = '4.0.0';\n\n  /** Used to compose bitmasks for wrapper metadata. */\n  var BIND_FLAG = 1,\n      BIND_KEY_FLAG = 2,\n      CURRY_BOUND_FLAG = 4,\n      CURRY_FLAG = 8,\n      CURRY_RIGHT_FLAG = 16,\n      PARTIAL_FLAG = 32,\n      PARTIAL_RIGHT_FLAG = 64,\n      ARY_FLAG = 128,\n      REARG_FLAG = 256,\n      FLIP_FLAG = 512;\n\n  /** Used to compose bitmasks for comparison styles. */\n  var UNORDERED_COMPARE_FLAG = 1,\n      PARTIAL_COMPARE_FLAG = 2;\n\n  /** Used as default options for `_.truncate`. */\n  var DEFAULT_TRUNC_LENGTH = 30,\n      DEFAULT_TRUNC_OMISSION = '...';\n\n  /** Used to detect hot functions by number of calls within a span of milliseconds. */\n  var HOT_COUNT = 150,\n      HOT_SPAN = 16;\n\n  /** Used as the size to enable large array optimizations. */\n  var LARGE_ARRAY_SIZE = 200;\n\n  /** Used to indicate the type of lazy iteratees. */\n  var LAZY_FILTER_FLAG = 1,\n      LAZY_MAP_FLAG = 2,\n      LAZY_WHILE_FLAG = 3;\n\n  /** Used as the `TypeError` message for \"Functions\" methods. */\n  var FUNC_ERROR_TEXT = 'Expected a function';\n\n  /** Used to stand-in for `undefined` hash values. */\n  var HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n  /** Used as references for various `Number` constants. */\n  var INFINITY = 1 / 0,\n      MAX_SAFE_INTEGER = 9007199254740991,\n      MAX_INTEGER = 1.7976931348623157e+308,\n      NAN = 0 / 0;\n\n  /** Used as references for the maximum length and index of an array. */\n  var MAX_ARRAY_LENGTH = 4294967295,\n      MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,\n      HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;\n\n  /** Used as the internal argument placeholder. */\n  var PLACEHOLDER = '__lodash_placeholder__';\n\n  /** `Object#toString` result references. */\n  var argsTag = '[object Arguments]',\n      arrayTag = '[object Array]',\n      boolTag = '[object Boolean]',\n      dateTag = '[object Date]',\n      errorTag = '[object Error]',\n      funcTag = '[object Function]',\n      genTag = '[object GeneratorFunction]',\n      mapTag = '[object Map]',\n      numberTag = '[object Number]',\n      objectTag = '[object Object]',\n      regexpTag = '[object RegExp]',\n      setTag = '[object Set]',\n      stringTag = '[object String]',\n      symbolTag = '[object Symbol]',\n      weakMapTag = '[object WeakMap]';\n\n  var arrayBufferTag = '[object ArrayBuffer]',\n      float32Tag = '[object Float32Array]',\n      float64Tag = '[object Float64Array]',\n      int8Tag = '[object Int8Array]',\n      int16Tag = '[object Int16Array]',\n      int32Tag = '[object Int32Array]',\n      uint8Tag = '[object Uint8Array]',\n      uint8ClampedTag = '[object Uint8ClampedArray]',\n      uint16Tag = '[object Uint16Array]',\n      uint32Tag = '[object Uint32Array]';\n\n  /** Used to match empty string literals in compiled template source. */\n  var reEmptyStringLeading = /\\b__p \\+= '';/g,\n      reEmptyStringMiddle = /\\b(__p \\+=) '' \\+/g,\n      reEmptyStringTrailing = /(__e\\(.*?\\)|\\b__t\\)) \\+\\n'';/g;\n\n  /** Used to match HTML entities and HTML characters. */\n  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39|#96);/g,\n      reUnescapedHtml = /[&<>\"'`]/g,\n      reHasEscapedHtml = RegExp(reEscapedHtml.source),\n      reHasUnescapedHtml = RegExp(reUnescapedHtml.source);\n\n  /** Used to match template delimiters. */\n  var reEscape = /<%-([\\s\\S]+?)%>/g,\n      reEvaluate = /<%([\\s\\S]+?)%>/g,\n      reInterpolate = /<%=([\\s\\S]+?)%>/g;\n\n  /** Used to match property names within property paths. */\n  var reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n      reIsPlainProp = /^\\w*$/,\n      rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]/g;\n\n  /** Used to match `RegExp` [syntax characters](http://ecma-international.org/ecma-262/6.0/#sec-patterns). */\n  var reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g,\n      reHasRegExpChar = RegExp(reRegExpChar.source);\n\n  /** Used to match leading and trailing whitespace. */\n  var reTrim = /^\\s+|\\s+$/g,\n      reTrimStart = /^\\s+/,\n      reTrimEnd = /\\s+$/;\n\n  /** Used to match backslashes in property paths. */\n  var reEscapeChar = /\\\\(\\\\)?/g;\n\n  /** Used to match [ES template delimiters](http://ecma-international.org/ecma-262/6.0/#sec-template-literal-lexical-components). */\n  var reEsTemplate = /\\$\\{([^\\\\}]*(?:\\\\.[^\\\\}]*)*)\\}/g;\n\n  /** Used to match `RegExp` flags from their coerced string values. */\n  var reFlags = /\\w*$/;\n\n  /** Used to detect hexadecimal string values. */\n  var reHasHexPrefix = /^0x/i;\n\n  /** Used to detect bad signed hexadecimal string values. */\n  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n  /** Used to detect binary string values. */\n  var reIsBinary = /^0b[01]+$/i;\n\n  /** Used to detect host constructors (Safari > 5). */\n  var reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n  /** Used to detect octal string values. */\n  var reIsOctal = /^0o[0-7]+$/i;\n\n  /** Used to detect unsigned integer values. */\n  var reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n  /** Used to match latin-1 supplementary letters (excluding mathematical operators). */\n  var reLatin1 = /[\\xc0-\\xd6\\xd8-\\xde\\xdf-\\xf6\\xf8-\\xff]/g;\n\n  /** Used to ensure capturing order of template delimiters. */\n  var reNoMatch = /($^)/;\n\n  /** Used to match unescaped characters in compiled string literals. */\n  var reUnescapedString = /['\\n\\r\\u2028\\u2029\\\\]/g;\n\n  /** Used to compose unicode character classes. */\n  var rsAstralRange = '\\\\ud800-\\\\udfff',\n      rsComboRange = '\\\\u0300-\\\\u036f\\\\ufe20-\\\\ufe23',\n      rsDingbatRange = '\\\\u2700-\\\\u27bf',\n      rsLowerRange = 'a-z\\\\xdf-\\\\xf6\\\\xf8-\\\\xff',\n      rsMathOpRange = '\\\\xac\\\\xb1\\\\xd7\\\\xf7',\n      rsNonCharRange = '\\\\x00-\\\\x2f\\\\x3a-\\\\x40\\\\x5b-\\\\x60\\\\x7b-\\\\xbf',\n      rsQuoteRange = '\\\\u2018\\\\u2019\\\\u201c\\\\u201d',\n      rsSpaceRange = ' \\\\t\\\\x0b\\\\f\\\\xa0\\\\ufeff\\\\n\\\\r\\\\u2028\\\\u2029\\\\u1680\\\\u180e\\\\u2000\\\\u2001\\\\u2002\\\\u2003\\\\u2004\\\\u2005\\\\u2006\\\\u2007\\\\u2008\\\\u2009\\\\u200a\\\\u202f\\\\u205f\\\\u3000',\n      rsUpperRange = 'A-Z\\\\xc0-\\\\xd6\\\\xd8-\\\\xde',\n      rsVarRange = '\\\\ufe0e\\\\ufe0f',\n      rsBreakRange = rsMathOpRange + rsNonCharRange + rsQuoteRange + rsSpaceRange;\n\n  /** Used to compose unicode capture groups. */\n  var rsAstral = '[' + rsAstralRange + ']',\n      rsBreak = '[' + rsBreakRange + ']',\n      rsCombo = '[' + rsComboRange + ']',\n      rsDigits = '\\\\d+',\n      rsDingbat = '[' + rsDingbatRange + ']',\n      rsLower = '[' + rsLowerRange + ']',\n      rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',\n      rsModifier = '(?:\\\\ud83c[\\\\udffb-\\\\udfff])',\n      rsNonAstral = '[^' + rsAstralRange + ']',\n      rsRegional = '(?:\\\\ud83c[\\\\udde6-\\\\uddff]){2}',\n      rsSurrPair = '[\\\\ud800-\\\\udbff][\\\\udc00-\\\\udfff]',\n      rsUpper = '[' + rsUpperRange + ']',\n      rsZWJ = '\\\\u200d';\n\n  /** Used to compose unicode regexes. */\n  var rsLowerMisc = '(?:' + rsLower + '|' + rsMisc + ')',\n      rsUpperMisc = '(?:' + rsUpper + '|' + rsMisc + ')',\n      reOptMod = rsModifier + '?',\n      rsOptVar = '[' + rsVarRange + ']?',\n      rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',\n      rsSeq = rsOptVar + reOptMod + rsOptJoin,\n      rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq,\n      rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';\n\n  /** Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks). */\n  var reComboMark = RegExp(rsCombo, 'g');\n\n  /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */\n  var reComplexSymbol = RegExp(rsSymbol + rsSeq, 'g');\n\n  /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */\n  var reHasComplexSymbol = RegExp('[' + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + ']');\n\n  /** Used to match non-compound words composed of alphanumeric characters. */\n  var reBasicWord = /[a-zA-Z0-9]+/g;\n\n  /** Used to match complex or compound words. */\n  var reComplexWord = RegExp([\n    rsUpper + '?' + rsLower + '+(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',\n    rsUpperMisc + '+(?=' + [rsBreak, rsUpper + rsLowerMisc, '$'].join('|') + ')',\n    rsUpper + '?' + rsLowerMisc + '+',\n    rsDigits + '(?:' + rsLowerMisc + '+)?',\n    rsEmoji\n  ].join('|'), 'g');\n\n  /** Used to detect strings that need a more robust regexp to match words. */\n  var reHasComplexWord = /[a-z][A-Z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;\n\n  /** Used to assign default `context` object properties. */\n  var contextProps = [\n    'Array', 'Date', 'Error', 'Float32Array', 'Float64Array', 'Function',\n    'Int8Array', 'Int16Array', 'Int32Array', 'Map', 'Math', 'Object',\n    'Reflect', 'RegExp', 'Set', 'String', 'Symbol', 'TypeError', 'Uint8Array',\n    'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap', '_',\n    'clearTimeout', 'isFinite', 'parseInt', 'setTimeout'\n  ];\n\n  /** Used to make template sourceURLs easier to identify. */\n  var templateCounter = -1;\n\n  /** Used to identify `toStringTag` values of typed arrays. */\n  var typedArrayTags = {};\n  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\n  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\n  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\n  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\n  typedArrayTags[uint32Tag] = true;\n  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =\n  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\n  typedArrayTags[dateTag] = typedArrayTags[errorTag] =\n  typedArrayTags[funcTag] = typedArrayTags[mapTag] =\n  typedArrayTags[numberTag] = typedArrayTags[objectTag] =\n  typedArrayTags[regexpTag] = typedArrayTags[setTag] =\n  typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;\n\n  /** Used to identify `toStringTag` values supported by `_.clone`. */\n  var cloneableTags = {};\n  cloneableTags[argsTag] = cloneableTags[arrayTag] =\n  cloneableTags[arrayBufferTag] = cloneableTags[boolTag] =\n  cloneableTags[dateTag] = cloneableTags[float32Tag] =\n  cloneableTags[float64Tag] = cloneableTags[int8Tag] =\n  cloneableTags[int16Tag] = cloneableTags[int32Tag] =\n  cloneableTags[mapTag] = cloneableTags[numberTag] =\n  cloneableTags[objectTag] = cloneableTags[regexpTag] =\n  cloneableTags[setTag] = cloneableTags[stringTag] =\n  cloneableTags[symbolTag] = cloneableTags[uint8Tag] =\n  cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] =\n  cloneableTags[uint32Tag] = true;\n  cloneableTags[errorTag] = cloneableTags[funcTag] =\n  cloneableTags[weakMapTag] = false;\n\n  /** Used to map latin-1 supplementary letters to basic latin letters. */\n  var deburredLetters = {\n    '\\xc0': 'A',  '\\xc1': 'A', '\\xc2': 'A', '\\xc3': 'A', '\\xc4': 'A', '\\xc5': 'A',\n    '\\xe0': 'a',  '\\xe1': 'a', '\\xe2': 'a', '\\xe3': 'a', '\\xe4': 'a', '\\xe5': 'a',\n    '\\xc7': 'C',  '\\xe7': 'c',\n    '\\xd0': 'D',  '\\xf0': 'd',\n    '\\xc8': 'E',  '\\xc9': 'E', '\\xca': 'E', '\\xcb': 'E',\n    '\\xe8': 'e',  '\\xe9': 'e', '\\xea': 'e', '\\xeb': 'e',\n    '\\xcC': 'I',  '\\xcd': 'I', '\\xce': 'I', '\\xcf': 'I',\n    '\\xeC': 'i',  '\\xed': 'i', '\\xee': 'i', '\\xef': 'i',\n    '\\xd1': 'N',  '\\xf1': 'n',\n    '\\xd2': 'O',  '\\xd3': 'O', '\\xd4': 'O', '\\xd5': 'O', '\\xd6': 'O', '\\xd8': 'O',\n    '\\xf2': 'o',  '\\xf3': 'o', '\\xf4': 'o', '\\xf5': 'o', '\\xf6': 'o', '\\xf8': 'o',\n    '\\xd9': 'U',  '\\xda': 'U', '\\xdb': 'U', '\\xdc': 'U',\n    '\\xf9': 'u',  '\\xfa': 'u', '\\xfb': 'u', '\\xfc': 'u',\n    '\\xdd': 'Y',  '\\xfd': 'y', '\\xff': 'y',\n    '\\xc6': 'Ae', '\\xe6': 'ae',\n    '\\xde': 'Th', '\\xfe': 'th',\n    '\\xdf': 'ss'\n  };\n\n  /** Used to map characters to HTML entities. */\n  var htmlEscapes = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#39;',\n    '`': '&#96;'\n  };\n\n  /** Used to map HTML entities to characters. */\n  var htmlUnescapes = {\n    '&amp;': '&',\n    '&lt;': '<',\n    '&gt;': '>',\n    '&quot;': '\"',\n    '&#39;': \"'\",\n    '&#96;': '`'\n  };\n\n  /** Used to determine if values are of the language type `Object`. */\n  var objectTypes = {\n    'function': true,\n    'object': true\n  };\n\n  /** Used to escape characters for inclusion in compiled string literals. */\n  var stringEscapes = {\n    '\\\\': '\\\\',\n    \"'\": \"'\",\n    '\\n': 'n',\n    '\\r': 'r',\n    '\\u2028': 'u2028',\n    '\\u2029': 'u2029'\n  };\n\n  /** Built-in method references without a dependency on `root`. */\n  var freeParseFloat = parseFloat,\n      freeParseInt = parseInt;\n\n  /** Detect free variable `exports`. */\n  var freeExports = (objectTypes[typeof exports] && exports && !exports.nodeType) ? exports : null;\n\n  /** Detect free variable `module`. */\n  var freeModule = (objectTypes[typeof module] && module && !module.nodeType) ? module : null;\n\n  /** Detect free variable `global` from Node.js. */\n  var freeGlobal = checkGlobal(freeExports && freeModule && typeof global == 'object' && global);\n\n  /** Detect free variable `self`. */\n  var freeSelf = checkGlobal(objectTypes[typeof self] && self);\n\n  /** Detect free variable `window`. */\n  var freeWindow = checkGlobal(objectTypes[typeof window] && window);\n\n  /** Detect the popular CommonJS extension `module.exports`. */\n  var moduleExports = (freeModule && freeModule.exports === freeExports) ? freeExports : null;\n\n  /** Detect `this` as the global object. */\n  var thisGlobal = checkGlobal(objectTypes[typeof this] && this);\n\n  /**\n   * Used as a reference to the global object.\n   *\n   * The `this` value is used if it's the global object to avoid Greasemonkey's\n   * restricted `window` object, otherwise the `window` object is used.\n   */\n  var root = freeGlobal || ((freeWindow !== (thisGlobal && thisGlobal.window)) && freeWindow) || freeSelf || thisGlobal || Function('return this')();\n\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * Adds the key-value `pair` to `map`.\n   *\n   * @private\n   * @param {Object} map The map to modify.\n   * @param {Array} pair The key-value pair to add.\n   * @returns {Object} Returns `map`.\n   */\n  function addMapEntry(map, pair) {\n    map.set(pair[0], pair[1]);\n    return map;\n  }\n\n  /**\n   * Adds `value` to `set`.\n   *\n   * @private\n   * @param {Object} set The set to modify.\n   * @param {*} value The value to add.\n   * @returns {Object} Returns `set`.\n   */\n  function addSetEntry(set, value) {\n    set.add(value);\n    return set;\n  }\n\n  /**\n   * A faster alternative to `Function#apply`, this function invokes `func`\n   * with the `this` binding of `thisArg` and the arguments of `args`.\n   *\n   * @private\n   * @param {Function} func The function to invoke.\n   * @param {*} thisArg The `this` binding of `func`.\n   * @param {...*} [args] The arguments to invoke `func` with.\n   * @returns {*} Returns the result of `func`.\n   */\n  function apply(func, thisArg, args) {\n    var length = args ? args.length : 0;\n    switch (length) {\n      case 0: return func.call(thisArg);\n      case 1: return func.call(thisArg, args[0]);\n      case 2: return func.call(thisArg, args[0], args[1]);\n      case 3: return func.call(thisArg, args[0], args[1], args[2]);\n    }\n    return func.apply(thisArg, args);\n  }\n\n  /**\n   * Creates a new array concatenating `array` with `other`.\n   *\n   * @private\n   * @param {Array} array The first array to concatenate.\n   * @param {Array} other The second array to concatenate.\n   * @returns {Array} Returns the new concatenated array.\n   */\n  function arrayConcat(array, other) {\n    var index = -1,\n        length = array.length,\n        othIndex = -1,\n        othLength = other.length,\n        result = Array(length + othLength);\n\n    while (++index < length) {\n      result[index] = array[index];\n    }\n    while (++othIndex < othLength) {\n      result[index++] = other[othIndex];\n    }\n    return result;\n  }\n\n  /**\n   * A specialized version of `_.forEach` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} array The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns `array`.\n   */\n  function arrayEach(array, iteratee) {\n    var index = -1,\n        length = array.length;\n\n    while (++index < length) {\n      if (iteratee(array[index], index, array) === false) {\n        break;\n      }\n    }\n    return array;\n  }\n\n  /**\n   * A specialized version of `_.forEachRight` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} array The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns `array`.\n   */\n  function arrayEachRight(array, iteratee) {\n    var length = array.length;\n\n    while (length--) {\n      if (iteratee(array[length], length, array) === false) {\n        break;\n      }\n    }\n    return array;\n  }\n\n  /**\n   * A specialized version of `_.every` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} array The array to iterate over.\n   * @param {Function} predicate The function invoked per iteration.\n   * @returns {boolean} Returns `true` if all elements pass the predicate check, else `false`.\n   */\n  function arrayEvery(array, predicate) {\n    var index = -1,\n        length = array.length;\n\n    while (++index < length) {\n      if (!predicate(array[index], index, array)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * A specialized version of `_.filter` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} array The array to iterate over.\n   * @param {Function} predicate The function invoked per iteration.\n   * @returns {Array} Returns the new filtered array.\n   */\n  function arrayFilter(array, predicate) {\n    var index = -1,\n        length = array.length,\n        resIndex = -1,\n        result = [];\n\n    while (++index < length) {\n      var value = array[index];\n      if (predicate(value, index, array)) {\n        result[++resIndex] = value;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * A specialized version of `_.includes` for arrays without support for\n   * specifying an index to search from.\n   *\n   * @private\n   * @param {Array} array The array to search.\n   * @param {*} target The value to search for.\n   * @returns {boolean} Returns `true` if `target` is found, else `false`.\n   */\n  function arrayIncludes(array, value) {\n    return !!array.length && baseIndexOf(array, value, 0) > -1;\n  }\n\n  /**\n   * A specialized version of `_.includesWith` for arrays without support for\n   * specifying an index to search from.\n   *\n   * @private\n   * @param {Array} array The array to search.\n   * @param {*} target The value to search for.\n   * @param {Function} comparator The comparator invoked per element.\n   * @returns {boolean} Returns `true` if `target` is found, else `false`.\n   */\n  function arrayIncludesWith(array, value, comparator) {\n    var index = -1,\n        length = array.length;\n\n    while (++index < length) {\n      if (comparator(value, array[index])) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * A specialized version of `_.map` for arrays without support for iteratee\n   * shorthands.\n   *\n   * @private\n   * @param {Array} array The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns the new mapped array.\n   */\n  function arrayMap(array, iteratee) {\n    var index = -1,\n        length = array.length,\n        result = Array(length);\n\n    while (++index < length) {\n      result[index] = iteratee(array[index], index, array);\n    }\n    return result;\n  }\n\n  /**\n   * Appends the elements of `values` to `array`.\n   *\n   * @private\n   * @param {Array} array The array to modify.\n   * @param {Array} values The values to append.\n   * @returns {Array} Returns `array`.\n   */\n  function arrayPush(array, values) {\n    var index = -1,\n        length = values.length,\n        offset = array.length;\n\n    while (++index < length) {\n      array[offset + index] = values[index];\n    }\n    return array;\n  }\n\n  /**\n   * A specialized version of `_.reduce` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} array The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @param {*} [accumulator] The initial value.\n   * @param {boolean} [initFromArray] Specify using the first element of `array` as the initial value.\n   * @returns {*} Returns the accumulated value.\n   */\n  function arrayReduce(array, iteratee, accumulator, initFromArray) {\n    var index = -1,\n        length = array.length;\n\n    if (initFromArray && length) {\n      accumulator = array[++index];\n    }\n    while (++index < length) {\n      accumulator = iteratee(accumulator, array[index], index, array);\n    }\n    return accumulator;\n  }\n\n  /**\n   * A specialized version of `_.reduceRight` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} array The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @param {*} [accumulator] The initial value.\n   * @param {boolean} [initFromArray] Specify using the last element of `array` as the initial value.\n   * @returns {*} Returns the accumulated value.\n   */\n  function arrayReduceRight(array, iteratee, accumulator, initFromArray) {\n    var length = array.length;\n    if (initFromArray && length) {\n      accumulator = array[--length];\n    }\n    while (length--) {\n      accumulator = iteratee(accumulator, array[length], length, array);\n    }\n    return accumulator;\n  }\n\n  /**\n   * A specialized version of `_.some` for arrays without support for iteratee\n   * shorthands.\n   *\n   * @private\n   * @param {Array} array The array to iterate over.\n   * @param {Function} predicate The function invoked per iteration.\n   * @returns {boolean} Returns `true` if any element passes the predicate check, else `false`.\n   */\n  function arraySome(array, predicate) {\n    var index = -1,\n        length = array.length;\n\n    while (++index < length) {\n      if (predicate(array[index], index, array)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * The base implementation of methods like `_.max` and `_.min` which accepts a\n   * `comparator` to determine the extremum value.\n   *\n   * @private\n   * @param {Array} array The array to iterate over.\n   * @param {Function} iteratee The iteratee invoked per iteration.\n   * @param {Function} comparator The comparator used to compare values.\n   * @returns {*} Returns the extremum value.\n   */\n  function baseExtremum(array, iteratee, comparator) {\n    var index = -1,\n        length = array.length;\n\n    while (++index < length) {\n      var value = array[index],\n          current = iteratee(value);\n\n      if (current != null && (computed === undefined\n            ? current === current\n            : comparator(current, computed)\n          )) {\n        var computed = current,\n            result = value;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * The base implementation of methods like `_.find` and `_.findKey`, without\n   * support for iteratee shorthands, which iterates over `collection` using\n   * the provided `eachFunc`.\n   *\n   * @private\n   * @param {Array|Object} collection The collection to search.\n   * @param {Function} predicate The function invoked per iteration.\n   * @param {Function} eachFunc The function to iterate over `collection`.\n   * @param {boolean} [retKey] Specify returning the key of the found element instead of the element itself.\n   * @returns {*} Returns the found element or its key, else `undefined`.\n   */\n  function baseFind(collection, predicate, eachFunc, retKey) {\n    var result;\n    eachFunc(collection, function(value, key, collection) {\n      if (predicate(value, key, collection)) {\n        result = retKey ? key : value;\n        return false;\n      }\n    });\n    return result;\n  }\n\n  /**\n   * The base implementation of `_.findIndex` and `_.findLastIndex` without\n   * support for iteratee shorthands.\n   *\n   * @private\n   * @param {Array} array The array to search.\n   * @param {Function} predicate The function invoked per iteration.\n   * @param {boolean} [fromRight] Specify iterating from right to left.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function baseFindIndex(array, predicate, fromRight) {\n    var length = array.length,\n        index = fromRight ? length : -1;\n\n    while ((fromRight ? index-- : ++index < length)) {\n      if (predicate(array[index], index, array)) {\n        return index;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.\n   *\n   * @private\n   * @param {Array} array The array to search.\n   * @param {*} value The value to search for.\n   * @param {number} fromIndex The index to search from.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function baseIndexOf(array, value, fromIndex) {\n    if (value !== value) {\n      return indexOfNaN(array, fromIndex);\n    }\n    var index = fromIndex - 1,\n        length = array.length;\n\n    while (++index < length) {\n      if (array[index] === value) {\n        return index;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * The base implementation of `_.reduce` and `_.reduceRight`, without support\n   * for iteratee shorthands, which iterates over `collection` using the provided\n   * `eachFunc`.\n   *\n   * @private\n   * @param {Array|Object} collection The collection to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @param {*} accumulator The initial value.\n   * @param {boolean} initFromCollection Specify using the first or last element of `collection` as the initial value.\n   * @param {Function} eachFunc The function to iterate over `collection`.\n   * @returns {*} Returns the accumulated value.\n   */\n  function baseReduce(collection, iteratee, accumulator, initFromCollection, eachFunc) {\n    eachFunc(collection, function(value, index, collection) {\n      accumulator = initFromCollection\n        ? (initFromCollection = false, value)\n        : iteratee(accumulator, value, index, collection);\n    });\n    return accumulator;\n  }\n\n  /**\n   * The base implementation of `_.sortBy` which uses `comparer` to define\n   * the sort order of `array` and replaces criteria objects with their\n   * corresponding values.\n   *\n   * @private\n   * @param {Array} array The array to sort.\n   * @param {Function} comparer The function to define sort order.\n   * @returns {Array} Returns `array`.\n   */\n  function baseSortBy(array, comparer) {\n    var length = array.length;\n\n    array.sort(comparer);\n    while (length--) {\n      array[length] = array[length].value;\n    }\n    return array;\n  }\n\n  /**\n   * The base implementation of `_.sum` without support for iteratee shorthands.\n   *\n   * @private\n   * @param {Array} array The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {number} Returns the sum.\n   */\n  function baseSum(array, iteratee) {\n    var result,\n        index = -1,\n        length = array.length;\n\n    while (++index < length) {\n      var current = iteratee(array[index]);\n      if (current !== undefined) {\n        result = result === undefined ? current : (result + current);\n      }\n    }\n    return result;\n  }\n\n  /**\n   * The base implementation of `_.times` without support for iteratee shorthands\n   * or max array length checks.\n   *\n   * @private\n   * @param {number} n The number of times to invoke `iteratee`.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns the array of results.\n   */\n  function baseTimes(n, iteratee) {\n    var index = -1,\n        result = Array(n);\n\n    while (++index < n) {\n      result[index] = iteratee(index);\n    }\n    return result;\n  }\n\n  /**\n   * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array\n   * of key-value pairs for `object` corresponding to the property names of `props`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @param {Array} props The property names to get values for.\n   * @returns {Object} Returns the new array of key-value pairs.\n   */\n  function baseToPairs(object, props) {\n    return arrayMap(props, function(key) {\n      return [key, object[key]];\n    });\n  }\n\n  /**\n   * The base implementation of `_.unary` without support for storing wrapper metadata.\n   *\n   * @private\n   * @param {Function} func The function to cap arguments for.\n   * @returns {Function} Returns the new function.\n   */\n  function baseUnary(func) {\n    return function(value) {\n      return func(value);\n    };\n  }\n\n  /**\n   * The base implementation of `_.values` and `_.valuesIn` which creates an\n   * array of `object` property values corresponding to the property names\n   * of `props`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @param {Array} props The property names to get values for.\n   * @returns {Object} Returns the array of property values.\n   */\n  function baseValues(object, props) {\n    return arrayMap(props, function(key) {\n      return object[key];\n    });\n  }\n\n  /**\n   * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol\n   * that is not found in the character symbols.\n   *\n   * @private\n   * @param {Array} strSymbols The string symbols to inspect.\n   * @param {Array} chrSymbols The character symbols to find.\n   * @returns {number} Returns the index of the first unmatched string symbol.\n   */\n  function charsStartIndex(strSymbols, chrSymbols) {\n    var index = -1,\n        length = strSymbols.length;\n\n    while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}\n    return index;\n  }\n\n  /**\n   * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol\n   * that is not found in the character symbols.\n   *\n   * @private\n   * @param {Array} strSymbols The string symbols to inspect.\n   * @param {Array} chrSymbols The character symbols to find.\n   * @returns {number} Returns the index of the last unmatched string symbol.\n   */\n  function charsEndIndex(strSymbols, chrSymbols) {\n    var index = strSymbols.length;\n\n    while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}\n    return index;\n  }\n\n  /**\n   * Checks if `value` is a global object.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {null|Object} Returns `value` if it's a global object, else `null`.\n   */\n  function checkGlobal(value) {\n    return (value && value.Object === Object) ? value : null;\n  }\n\n  /**\n   * Compares values to sort them in ascending order.\n   *\n   * @private\n   * @param {*} value The value to compare.\n   * @param {*} other The other value to compare.\n   * @returns {number} Returns the sort order indicator for `value`.\n   */\n  function compareAscending(value, other) {\n    if (value !== other) {\n      var valIsNull = value === null,\n          valIsUndef = value === undefined,\n          valIsReflexive = value === value;\n\n      var othIsNull = other === null,\n          othIsUndef = other === undefined,\n          othIsReflexive = other === other;\n\n      if ((value > other && !othIsNull) || !valIsReflexive ||\n          (valIsNull && !othIsUndef && othIsReflexive) ||\n          (valIsUndef && othIsReflexive)) {\n        return 1;\n      }\n      if ((value < other && !valIsNull) || !othIsReflexive ||\n          (othIsNull && !valIsUndef && valIsReflexive) ||\n          (othIsUndef && valIsReflexive)) {\n        return -1;\n      }\n    }\n    return 0;\n  }\n\n  /**\n   * Used by `_.orderBy` to compare multiple properties of a value to another\n   * and stable sort them.\n   *\n   * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,\n   * specify an order of \"desc\" for descending or \"asc\" for ascending sort order\n   * of corresponding values.\n   *\n   * @private\n   * @param {Object} object The object to compare.\n   * @param {Object} other The other object to compare.\n   * @param {boolean[]|string[]} orders The order to sort by for each property.\n   * @returns {number} Returns the sort order indicator for `object`.\n   */\n  function compareMultiple(object, other, orders) {\n    var index = -1,\n        objCriteria = object.criteria,\n        othCriteria = other.criteria,\n        length = objCriteria.length,\n        ordersLength = orders.length;\n\n    while (++index < length) {\n      var result = compareAscending(objCriteria[index], othCriteria[index]);\n      if (result) {\n        if (index >= ordersLength) {\n          return result;\n        }\n        var order = orders[index];\n        return result * (order == 'desc' ? -1 : 1);\n      }\n    }\n    // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications\n    // that causes it, under certain circumstances, to provide the same value for\n    // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247\n    // for more details.\n    //\n    // This also ensures a stable sort in V8 and other engines.\n    // See https://code.google.com/p/v8/issues/detail?id=90 for more details.\n    return object.index - other.index;\n  }\n\n  /**\n   * Used by `_.deburr` to convert latin-1 supplementary letters to basic latin letters.\n   *\n   * @private\n   * @param {string} letter The matched letter to deburr.\n   * @returns {string} Returns the deburred letter.\n   */\n  function deburrLetter(letter) {\n    return deburredLetters[letter];\n  }\n\n  /**\n   * Used by `_.escape` to convert characters to HTML entities.\n   *\n   * @private\n   * @param {string} chr The matched character to escape.\n   * @returns {string} Returns the escaped character.\n   */\n  function escapeHtmlChar(chr) {\n    return htmlEscapes[chr];\n  }\n\n  /**\n   * Used by `_.template` to escape characters for inclusion in compiled string literals.\n   *\n   * @private\n   * @param {string} chr The matched character to escape.\n   * @returns {string} Returns the escaped character.\n   */\n  function escapeStringChar(chr) {\n    return '\\\\' + stringEscapes[chr];\n  }\n\n  /**\n   * Gets the index at which the first occurrence of `NaN` is found in `array`.\n   *\n   * @private\n   * @param {Array} array The array to search.\n   * @param {number} fromIndex The index to search from.\n   * @param {boolean} [fromRight] Specify iterating from right to left.\n   * @returns {number} Returns the index of the matched `NaN`, else `-1`.\n   */\n  function indexOfNaN(array, fromIndex, fromRight) {\n    var length = array.length,\n        index = fromIndex + (fromRight ? 0 : -1);\n\n    while ((fromRight ? index-- : ++index < length)) {\n      var other = array[index];\n      if (other !== other) {\n        return index;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Checks if `value` is a host object in IE < 9.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a host object, else `false`.\n   */\n  function isHostObject(value) {\n    // Many host objects are `Object` objects that can coerce to strings\n    // despite having improperly defined `toString` methods.\n    var result = false;\n    if (value != null && typeof value.toString != 'function') {\n      try {\n        result = !!(value + '');\n      } catch (e) {}\n    }\n    return result;\n  }\n\n  /**\n   * Checks if `value` is a valid array-like index.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n   * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n   */\n  function isIndex(value, length) {\n    value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;\n    length = length == null ? MAX_SAFE_INTEGER : length;\n    return value > -1 && value % 1 == 0 && value < length;\n  }\n\n  /**\n   * Converts `iterator` to an array.\n   *\n   * @private\n   * @param {Object} iterator The iterator to convert.\n   * @returns {Array} Returns the converted array.\n   */\n  function iteratorToArray(iterator) {\n    var data,\n        result = [];\n\n    while (!(data = iterator.next()).done) {\n      result.push(data.value);\n    }\n    return result;\n  }\n\n  /**\n   * Converts `map` to an array.\n   *\n   * @private\n   * @param {Object} map The map to convert.\n   * @returns {Array} Returns the converted array.\n   */\n  function mapToArray(map) {\n    var index = -1,\n        result = Array(map.size);\n\n    map.forEach(function(value, key) {\n      result[++index] = [key, value];\n    });\n    return result;\n  }\n\n  /**\n   * Replaces all `placeholder` elements in `array` with an internal placeholder\n   * and returns an array of their indexes.\n   *\n   * @private\n   * @param {Array} array The array to modify.\n   * @param {*} placeholder The placeholder to replace.\n   * @returns {Array} Returns the new array of placeholder indexes.\n   */\n  function replaceHolders(array, placeholder) {\n    var index = -1,\n        length = array.length,\n        resIndex = -1,\n        result = [];\n\n    while (++index < length) {\n      if (array[index] === placeholder) {\n        array[index] = PLACEHOLDER;\n        result[++resIndex] = index;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Converts `set` to an array.\n   *\n   * @private\n   * @param {Object} set The set to convert.\n   * @returns {Array} Returns the converted array.\n   */\n  function setToArray(set) {\n    var index = -1,\n        result = Array(set.size);\n\n    set.forEach(function(value) {\n      result[++index] = value;\n    });\n    return result;\n  }\n\n  /**\n   * Gets the number of symbols in `string`.\n   *\n   * @param {string} string The string to inspect.\n   * @returns {number} Returns the string size.\n   */\n  function stringSize(string) {\n    if (!(string && reHasComplexSymbol.test(string))) {\n      return string.length;\n    }\n    var result = reComplexSymbol.lastIndex = 0;\n    while (reComplexSymbol.test(string)) {\n      result++;\n    }\n    return result;\n  }\n\n  /**\n   * Converts `string` to an array.\n   *\n   * @private\n   * @param {string} string The string to convert.\n   * @returns {Array} Returns the converted array.\n   */\n  function stringToArray(string) {\n    return string.match(reComplexSymbol);\n  }\n\n  /**\n   * Used by `_.unescape` to convert HTML entities to characters.\n   *\n   * @private\n   * @param {string} chr The matched character to unescape.\n   * @returns {string} Returns the unescaped character.\n   */\n  function unescapeHtmlChar(chr) {\n    return htmlUnescapes[chr];\n  }\n\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * Create a new pristine `lodash` function using the `context` object.\n   *\n   * @static\n   * @memberOf _\n   * @category Util\n   * @param {Object} [context=root] The context object.\n   * @returns {Function} Returns a new `lodash` function.\n   * @example\n   *\n   * _.mixin({ 'foo': _.constant('foo') });\n   *\n   * var lodash = _.runInContext();\n   * lodash.mixin({ 'bar': lodash.constant('bar') });\n   *\n   * _.isFunction(_.foo);\n   * // => true\n   * _.isFunction(_.bar);\n   * // => false\n   *\n   * lodash.isFunction(lodash.foo);\n   * // => false\n   * lodash.isFunction(lodash.bar);\n   * // => true\n   *\n   * // using `context` to mock `Date#getTime` use in `_.now`\n   * var mock = _.runInContext({\n   *   'Date': function() {\n   *     return { 'getTime': getTimeMock };\n   *   }\n   * });\n   *\n   * // or creating a suped-up `defer` in Node.js\n   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;\n   */\n  function runInContext(context) {\n    context = context ? _.defaults({}, context, _.pick(root, contextProps)) : root;\n\n    /** Built-in constructor references. */\n    var Date = context.Date,\n        Error = context.Error,\n        Math = context.Math,\n        RegExp = context.RegExp,\n        TypeError = context.TypeError;\n\n    /** Used for built-in method references. */\n    var arrayProto = context.Array.prototype,\n        objectProto = context.Object.prototype;\n\n    /** Used to resolve the decompiled source of functions. */\n    var funcToString = context.Function.prototype.toString;\n\n    /** Used to check objects for own properties. */\n    var hasOwnProperty = objectProto.hasOwnProperty;\n\n    /** Used to generate unique IDs. */\n    var idCounter = 0;\n\n    /** Used to infer the `Object` constructor. */\n    var objectCtorString = funcToString.call(Object);\n\n    /**\n     * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\n     * of values.\n     */\n    var objectToString = objectProto.toString;\n\n    /** Used to restore the original `_` reference in `_.noConflict`. */\n    var oldDash = root._;\n\n    /** Used to detect if a method is native. */\n    var reIsNative = RegExp('^' +\n      funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n      .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n    );\n\n    /** Built-in value references. */\n    var _Symbol = context.Symbol,\n        Reflect = context.Reflect,\n        Uint8Array = context.Uint8Array,\n        clearTimeout = context.clearTimeout,\n        enumerate = Reflect ? Reflect.enumerate : undefined,\n        getPrototypeOf = Object.getPrototypeOf,\n        getOwnPropertySymbols = Object.getOwnPropertySymbols,\n        iteratorSymbol = typeof (iteratorSymbol = _Symbol && _Symbol.iterator) == 'symbol' ? iteratorSymbol : undefined,\n        propertyIsEnumerable = objectProto.propertyIsEnumerable,\n        setTimeout = context.setTimeout,\n        splice = arrayProto.splice;\n\n    /* Built-in method references for those with the same name as other `lodash` methods. */\n    var nativeCeil = Math.ceil,\n        nativeFloor = Math.floor,\n        nativeIsFinite = context.isFinite,\n        nativeJoin = arrayProto.join,\n        nativeKeys = Object.keys,\n        nativeMax = Math.max,\n        nativeMin = Math.min,\n        nativeParseInt = context.parseInt,\n        nativeRandom = Math.random,\n        nativeReverse = arrayProto.reverse;\n\n    /* Built-in method references that are verified to be native. */\n    var Map = getNative(context, 'Map'),\n        Set = getNative(context, 'Set'),\n        WeakMap = getNative(context, 'WeakMap'),\n        nativeCreate = getNative(Object, 'create');\n\n    /** Used to store function metadata. */\n    var metaMap = WeakMap && new WeakMap;\n\n    /** Used to detect maps and sets. */\n    var mapCtorString = Map ? funcToString.call(Map) : '',\n        setCtorString = Set ? funcToString.call(Set) : '';\n\n    /** Used to convert symbols to primitives and strings. */\n    var symbolProto = _Symbol ? _Symbol.prototype : undefined,\n        symbolValueOf = _Symbol ? symbolProto.valueOf : undefined,\n        symbolToString = _Symbol ? symbolProto.toString : undefined;\n\n    /** Used to lookup unminified function names. */\n    var realNames = {};\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a `lodash` object which wraps `value` to enable implicit method\n     * chaining. Methods that operate on and return arrays, collections, and\n     * functions can be chained together. Methods that retrieve a single value or\n     * may return a primitive value will automatically end the chain sequence and\n     * return the unwrapped value. Otherwise, the value must be unwrapped with\n     * `_#value`.\n     *\n     * Explicit chaining, which must be unwrapped with `_#value` in all cases,\n     * may be enabled using `_.chain`.\n     *\n     * The execution of chained methods is lazy, that is, it's deferred until\n     * `_#value` is implicitly or explicitly called.\n     *\n     * Lazy evaluation allows several methods to support shortcut fusion. Shortcut\n     * fusion is an optimization to merge iteratee calls; this avoids the creation\n     * of intermediate arrays and can greatly reduce the number of iteratee executions.\n     * Sections of a chain sequence qualify for shortcut fusion if the section is\n     * applied to an array of at least two hundred elements and any iteratees\n     * accept only one argument. The heuristic for whether a section qualifies\n     * for shortcut fusion is subject to change.\n     *\n     * Chaining is supported in custom builds as long as the `_#value` method is\n     * directly or indirectly included in the build.\n     *\n     * In addition to lodash methods, wrappers have `Array` and `String` methods.\n     *\n     * The wrapper `Array` methods are:\n     * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`\n     *\n     * The wrapper `String` methods are:\n     * `replace` and `split`\n     *\n     * The wrapper methods that support shortcut fusion are:\n     * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,\n     * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,\n     * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`\n     *\n     * The chainable wrapper methods are:\n     * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`,\n     * `at`, `before`, `bind`, `bindAll`, `bindKey`, `chain`, `chunk`, `commit`,\n     * `compact`, `concat`, `conforms`,  `constant`, `countBy`, `create`, `curry`,\n     * `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`, `difference`,\n     * `differenceBy`, `differenceWith`,  `drop`, `dropRight`, `dropRightWhile`,\n     * `dropWhile`, `fill`, `filter`, `flatten`, `flattenDeep`, `flip`, `flow`,\n     * `flowRight`, `forEach`, `forEachRight`, `forIn`, `forInRight`, `forOwn`,\n     * `forOwnRight`, `fromPairs`, `functions`, `functionsIn`, `groupBy`, `initial`,\n     * `intersection`, `intersectionBy`, `intersectionWith`, invert`, `invokeMap`,\n     * `iteratee`, `keyBy`, `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`,\n     * `matches`, `matchesProperty`, `memoize`, `merge`, `mergeWith`, `method`,\n     * `methodOf`, `mixin`, `negate`, `nthArg`, `omit`, `omitBy`, `once`, `orderBy`,\n     * `over`, `overArgs`, `overEvery`, `overSome`, `partial`, `partialRight`,\n     * `partition`, `pick`, `pickBy`, `plant`, `property`, `propertyOf`, `pull`,\n     * `pullAll`, `pullAllBy`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`,\n     * `reject`, `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`,\n     * `shuffle`, `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`,\n     * `takeRight`, `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`,\n     * `toArray`, `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`,\n     * `unary`, `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`,\n     * `unset`, `unshift`, `unzip`, `unzipWith`, `values`, `valuesIn`, `without`,\n     * `wrap`, `xor`, `xorBy`, `xorWith`, `zip`, `zipObject`, and `zipWith`\n     *\n     * The wrapper methods that are **not** chainable by default are:\n     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,\n     * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `deburr`, `endsWith`, `eq`,\n     * `escape`, `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`,\n     * `findLast`, `findLastIndex`, `findLastKey`, `floor`, `get`, `gt`, `gte`,\n     * `has`, `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`,\n     * `invoke`, `isArguments`, `isArray`, `isArrayLike`, `isArrayLikeObject`,\n     * `isBoolean`, `isDate`, `isElement`, `isEmpty`, `isEqual`, `isEqualWith`,\n     * `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`, `isMatch`,\n     * `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`, `isNumber`,\n     * `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`, `isSafeInteger`,\n     * `isString`, `isUndefined`, `isTypedArray`, `join`, `kebabCase`, `last`,\n     * `lastIndexOf`, `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`,\n     * `mean`, `min`, `minBy`, `noConflict`, `noop`, `now`, `pad`, `padEnd`,\n     * `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`, `repeat`,\n     * `result`, `round`, `runInContext`, `sample`, `shift`, `size`, `snakeCase`,\n     * `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`, `sortedLastIndexBy`,\n     * `startCase`, `startsWith`, `subtract`, `sum`, sumBy`, `template`, `times`,\n     * `toLower`, `toInteger`, `toLength`, `toNumber`, `toSafeInteger`, toString`,\n     * `toUpper`, `trim`, `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`,\n     * `upperCase`, `upperFirst`, `value`, and `words`\n     *\n     * @name _\n     * @constructor\n     * @category Seq\n     * @param {*} value The value to wrap in a `lodash` instance.\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * var wrapped = _([1, 2, 3]);\n     *\n     * // returns an unwrapped value\n     * wrapped.reduce(_.add);\n     * // => 6\n     *\n     * // returns a wrapped value\n     * var squares = wrapped.map(square);\n     *\n     * _.isArray(squares);\n     * // => false\n     *\n     * _.isArray(squares.value());\n     * // => true\n     */\n    function lodash(value) {\n      if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {\n        if (value instanceof LodashWrapper) {\n          return value;\n        }\n        if (hasOwnProperty.call(value, '__wrapped__')) {\n          return wrapperClone(value);\n        }\n      }\n      return new LodashWrapper(value);\n    }\n\n    /**\n     * The function whose prototype all chaining wrappers inherit from.\n     *\n     * @private\n     */\n    function baseLodash() {\n      // No operation performed.\n    }\n\n    /**\n     * The base constructor for creating `lodash` wrapper objects.\n     *\n     * @private\n     * @param {*} value The value to wrap.\n     * @param {boolean} [chainAll] Enable chaining for all wrapper methods.\n     */\n    function LodashWrapper(value, chainAll) {\n      this.__wrapped__ = value;\n      this.__actions__ = [];\n      this.__chain__ = !!chainAll;\n      this.__index__ = 0;\n      this.__values__ = undefined;\n    }\n\n    /**\n     * By default, the template delimiters used by lodash are like those in\n     * embedded Ruby (ERB). Change the following template settings to use\n     * alternative delimiters.\n     *\n     * @static\n     * @memberOf _\n     * @type Object\n     */\n    lodash.templateSettings = {\n\n      /**\n       * Used to detect `data` property values to be HTML-escaped.\n       *\n       * @memberOf _.templateSettings\n       * @type RegExp\n       */\n      'escape': reEscape,\n\n      /**\n       * Used to detect code to be evaluated.\n       *\n       * @memberOf _.templateSettings\n       * @type RegExp\n       */\n      'evaluate': reEvaluate,\n\n      /**\n       * Used to detect `data` property values to inject.\n       *\n       * @memberOf _.templateSettings\n       * @type RegExp\n       */\n      'interpolate': reInterpolate,\n\n      /**\n       * Used to reference the data object in the template text.\n       *\n       * @memberOf _.templateSettings\n       * @type string\n       */\n      'variable': '',\n\n      /**\n       * Used to import variables into the compiled template.\n       *\n       * @memberOf _.templateSettings\n       * @type Object\n       */\n      'imports': {\n\n        /**\n         * A reference to the `lodash` function.\n         *\n         * @memberOf _.templateSettings.imports\n         * @type Function\n         */\n        '_': lodash\n      }\n    };\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.\n     *\n     * @private\n     * @param {*} value The value to wrap.\n     */\n    function LazyWrapper(value) {\n      this.__wrapped__ = value;\n      this.__actions__ = [];\n      this.__dir__ = 1;\n      this.__filtered__ = false;\n      this.__iteratees__ = [];\n      this.__takeCount__ = MAX_ARRAY_LENGTH;\n      this.__views__ = [];\n    }\n\n    /**\n     * Creates a clone of the lazy wrapper object.\n     *\n     * @private\n     * @name clone\n     * @memberOf LazyWrapper\n     * @returns {Object} Returns the cloned `LazyWrapper` object.\n     */\n    function lazyClone() {\n      var result = new LazyWrapper(this.__wrapped__);\n      result.__actions__ = copyArray(this.__actions__);\n      result.__dir__ = this.__dir__;\n      result.__filtered__ = this.__filtered__;\n      result.__iteratees__ = copyArray(this.__iteratees__);\n      result.__takeCount__ = this.__takeCount__;\n      result.__views__ = copyArray(this.__views__);\n      return result;\n    }\n\n    /**\n     * Reverses the direction of lazy iteration.\n     *\n     * @private\n     * @name reverse\n     * @memberOf LazyWrapper\n     * @returns {Object} Returns the new reversed `LazyWrapper` object.\n     */\n    function lazyReverse() {\n      if (this.__filtered__) {\n        var result = new LazyWrapper(this);\n        result.__dir__ = -1;\n        result.__filtered__ = true;\n      } else {\n        result = this.clone();\n        result.__dir__ *= -1;\n      }\n      return result;\n    }\n\n    /**\n     * Extracts the unwrapped value from its lazy wrapper.\n     *\n     * @private\n     * @name value\n     * @memberOf LazyWrapper\n     * @returns {*} Returns the unwrapped value.\n     */\n    function lazyValue() {\n      var array = this.__wrapped__.value(),\n          dir = this.__dir__,\n          isArr = isArray(array),\n          isRight = dir < 0,\n          arrLength = isArr ? array.length : 0,\n          view = getView(0, arrLength, this.__views__),\n          start = view.start,\n          end = view.end,\n          length = end - start,\n          index = isRight ? end : (start - 1),\n          iteratees = this.__iteratees__,\n          iterLength = iteratees.length,\n          resIndex = 0,\n          takeCount = nativeMin(length, this.__takeCount__);\n\n      if (!isArr || arrLength < LARGE_ARRAY_SIZE || (arrLength == length && takeCount == length)) {\n        return baseWrapperValue(array, this.__actions__);\n      }\n      var result = [];\n\n      outer:\n      while (length-- && resIndex < takeCount) {\n        index += dir;\n\n        var iterIndex = -1,\n            value = array[index];\n\n        while (++iterIndex < iterLength) {\n          var data = iteratees[iterIndex],\n              iteratee = data.iteratee,\n              type = data.type,\n              computed = iteratee(value);\n\n          if (type == LAZY_MAP_FLAG) {\n            value = computed;\n          } else if (!computed) {\n            if (type == LAZY_FILTER_FLAG) {\n              continue outer;\n            } else {\n              break outer;\n            }\n          }\n        }\n        result[resIndex++] = value;\n      }\n      return result;\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates an hash object.\n     *\n     * @private\n     * @returns {Object} Returns the new hash object.\n     */\n    function Hash() {}\n\n    /**\n     * Removes `key` and its value from the hash.\n     *\n     * @private\n     * @param {Object} hash The hash to modify.\n     * @param {string} key The key of the value to remove.\n     * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n     */\n    function hashDelete(hash, key) {\n      return hashHas(hash, key) && delete hash[key];\n    }\n\n    /**\n     * Gets the hash value for `key`.\n     *\n     * @private\n     * @param {Object} hash The hash to query.\n     * @param {string} key The key of the value to get.\n     * @returns {*} Returns the entry value.\n     */\n    function hashGet(hash, key) {\n      if (nativeCreate) {\n        var result = hash[key];\n        return result === HASH_UNDEFINED ? undefined : result;\n      }\n      return hasOwnProperty.call(hash, key) ? hash[key] : undefined;\n    }\n\n    /**\n     * Checks if a hash value for `key` exists.\n     *\n     * @private\n     * @param {Object} hash The hash to query.\n     * @param {string} key The key of the entry to check.\n     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n     */\n    function hashHas(hash, key) {\n      return nativeCreate ? hash[key] !== undefined : hasOwnProperty.call(hash, key);\n    }\n\n    /**\n     * Sets the hash `key` to `value`.\n     *\n     * @private\n     * @param {Object} hash The hash to modify.\n     * @param {string} key The key of the value to set.\n     * @param {*} value The value to set.\n     */\n    function hashSet(hash, key, value) {\n      hash[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a map cache object to store key-value pairs.\n     *\n     * @private\n     * @param {Array} [values] The values to cache.\n     */\n    function MapCache(values) {\n      var index = -1,\n          length = values ? values.length : 0;\n\n      this.clear();\n      while (++index < length) {\n        var entry = values[index];\n        this.set(entry[0], entry[1]);\n      }\n    }\n\n    /**\n     * Removes all key-value entries from the map.\n     *\n     * @private\n     * @name clear\n     * @memberOf MapCache\n     */\n    function mapClear() {\n      this.__data__ = { 'hash': new Hash, 'map': Map ? new Map : [], 'string': new Hash };\n    }\n\n    /**\n     * Removes `key` and its value from the map.\n     *\n     * @private\n     * @name delete\n     * @memberOf MapCache\n     * @param {string} key The key of the value to remove.\n     * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n     */\n    function mapDelete(key) {\n      var data = this.__data__;\n      if (isKeyable(key)) {\n        return hashDelete(typeof key == 'string' ? data.string : data.hash, key);\n      }\n      return Map ? data.map['delete'](key) : assocDelete(data.map, key);\n    }\n\n    /**\n     * Gets the map value for `key`.\n     *\n     * @private\n     * @name get\n     * @memberOf MapCache\n     * @param {string} key The key of the value to get.\n     * @returns {*} Returns the entry value.\n     */\n    function mapGet(key) {\n      var data = this.__data__;\n      if (isKeyable(key)) {\n        return hashGet(typeof key == 'string' ? data.string : data.hash, key);\n      }\n      return Map ? data.map.get(key) : assocGet(data.map, key);\n    }\n\n    /**\n     * Checks if a map value for `key` exists.\n     *\n     * @private\n     * @name has\n     * @memberOf MapCache\n     * @param {string} key The key of the entry to check.\n     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n     */\n    function mapHas(key) {\n      var data = this.__data__;\n      if (isKeyable(key)) {\n        return hashHas(typeof key == 'string' ? data.string : data.hash, key);\n      }\n      return Map ? data.map.has(key) : assocHas(data.map, key);\n    }\n\n    /**\n     * Sets the map `key` to `value`.\n     *\n     * @private\n     * @name set\n     * @memberOf MapCache\n     * @param {string} key The key of the value to set.\n     * @param {*} value The value to set.\n     * @returns {Object} Returns the map cache object.\n     */\n    function mapSet(key, value) {\n      var data = this.__data__;\n      if (isKeyable(key)) {\n        hashSet(typeof key == 'string' ? data.string : data.hash, key, value);\n      } else if (Map) {\n        data.map.set(key, value);\n      } else {\n        assocSet(data.map, key, value);\n      }\n      return this;\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     *\n     * Creates a set cache object to store unique values.\n     *\n     * @private\n     * @param {Array} [values] The values to cache.\n     */\n    function SetCache(values) {\n      var index = -1,\n          length = values ? values.length : 0;\n\n      this.__data__ = new MapCache;\n      while (++index < length) {\n        this.push(values[index]);\n      }\n    }\n\n    /**\n     * Checks if `value` is in `cache`.\n     *\n     * @private\n     * @param {Object} cache The set cache to search.\n     * @param {*} value The value to search for.\n     * @returns {number} Returns `true` if `value` is found, else `false`.\n     */\n    function cacheHas(cache, value) {\n      var map = cache.__data__;\n      if (isKeyable(value)) {\n        var data = map.__data__,\n            hash = typeof value == 'string' ? data.string : data.hash;\n\n        return hash[value] === HASH_UNDEFINED;\n      }\n      return map.has(value);\n    }\n\n    /**\n     * Adds `value` to the set cache.\n     *\n     * @private\n     * @name push\n     * @memberOf SetCache\n     * @param {*} value The value to cache.\n     */\n    function cachePush(value) {\n      var map = this.__data__;\n      if (isKeyable(value)) {\n        var data = map.__data__,\n            hash = typeof value == 'string' ? data.string : data.hash;\n\n        hash[value] = HASH_UNDEFINED;\n      }\n      else {\n        map.set(value, HASH_UNDEFINED);\n      }\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a stack cache object to store key-value pairs.\n     *\n     * @private\n     * @param {Array} [values] The values to cache.\n     */\n    function Stack(values) {\n      var index = -1,\n          length = values ? values.length : 0;\n\n      this.clear();\n      while (++index < length) {\n        var entry = values[index];\n        this.set(entry[0], entry[1]);\n      }\n    }\n\n    /**\n     * Removes all key-value entries from the stack.\n     *\n     * @private\n     * @name clear\n     * @memberOf Stack\n     */\n    function stackClear() {\n      this.__data__ = { 'array': [], 'map': null };\n    }\n\n    /**\n     * Removes `key` and its value from the stack.\n     *\n     * @private\n     * @name delete\n     * @memberOf Stack\n     * @param {string} key The key of the value to remove.\n     * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n     */\n    function stackDelete(key) {\n      var data = this.__data__,\n          array = data.array;\n\n      return array ? assocDelete(array, key) : data.map['delete'](key);\n    }\n\n    /**\n     * Gets the stack value for `key`.\n     *\n     * @private\n     * @name get\n     * @memberOf Stack\n     * @param {string} key The key of the value to get.\n     * @returns {*} Returns the entry value.\n     */\n    function stackGet(key) {\n      var data = this.__data__,\n          array = data.array;\n\n      return array ? assocGet(array, key) : data.map.get(key);\n    }\n\n    /**\n     * Checks if a stack value for `key` exists.\n     *\n     * @private\n     * @name has\n     * @memberOf Stack\n     * @param {string} key The key of the entry to check.\n     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n     */\n    function stackHas(key) {\n      var data = this.__data__,\n          array = data.array;\n\n      return array ? assocHas(array, key) : data.map.has(key);\n    }\n\n    /**\n     * Sets the stack `key` to `value`.\n     *\n     * @private\n     * @name set\n     * @memberOf Stack\n     * @param {string} key The key of the value to set.\n     * @param {*} value The value to set.\n     * @returns {Object} Returns the stack cache object.\n     */\n    function stackSet(key, value) {\n      var data = this.__data__,\n          array = data.array;\n\n      if (array) {\n        if (array.length < (LARGE_ARRAY_SIZE - 1)) {\n          assocSet(array, key, value);\n        } else {\n          data.array = null;\n          data.map = new MapCache(array);\n        }\n      }\n      var map = data.map;\n      if (map) {\n        map.set(key, value);\n      }\n      return this;\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Removes `key` and its value from the associative array.\n     *\n     * @private\n     * @param {Array} array The array to query.\n     * @param {string} key The key of the value to remove.\n     * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n     */\n    function assocDelete(array, key) {\n      var index = assocIndexOf(array, key);\n      if (index < 0) {\n        return false;\n      }\n      var lastIndex = array.length - 1;\n      if (index == lastIndex) {\n        array.pop();\n      } else {\n        splice.call(array, index, 1);\n      }\n      return true;\n    }\n\n    /**\n     * Gets the associative array value for `key`.\n     *\n     * @private\n     * @param {Array} array The array to query.\n     * @param {string} key The key of the value to get.\n     * @returns {*} Returns the entry value.\n     */\n    function assocGet(array, key) {\n      var index = assocIndexOf(array, key);\n      return index < 0 ? undefined : array[index][1];\n    }\n\n    /**\n     * Checks if an associative array value for `key` exists.\n     *\n     * @private\n     * @param {Array} array The array to query.\n     * @param {string} key The key of the entry to check.\n     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n     */\n    function assocHas(array, key) {\n      return assocIndexOf(array, key) > -1;\n    }\n\n    /**\n     * Gets the index at which the first occurrence of `key` is found in `array`\n     * of key-value pairs.\n     *\n     * @private\n     * @param {Array} array The array to search.\n     * @param {*} key The key to search for.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     */\n    function assocIndexOf(array, key) {\n      var length = array.length;\n      while (length--) {\n        if (eq(array[length][0], key)) {\n          return length;\n        }\n      }\n      return -1;\n    }\n\n    /**\n     * Sets the associative array `key` to `value`.\n     *\n     * @private\n     * @param {Array} array The array to modify.\n     * @param {string} key The key of the value to set.\n     * @param {*} value The value to set.\n     */\n    function assocSet(array, key, value) {\n      var index = assocIndexOf(array, key);\n      if (index < 0) {\n        array.push([key, value]);\n      } else {\n        array[index][1] = value;\n      }\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Used by `_.defaults` to customize its `_.assignIn` use.\n     *\n     * @private\n     * @param {*} objValue The destination value.\n     * @param {*} srcValue The source value.\n     * @param {string} key The key of the property to assign.\n     * @param {Object} object The parent object of `objValue`.\n     * @returns {*} Returns the value to assign.\n     */\n    function assignInDefaults(objValue, srcValue, key, object) {\n      if (objValue === undefined ||\n          (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {\n        return srcValue;\n      }\n      return objValue;\n    }\n\n    /**\n     * This function is like `assignValue` except that it doesn't assign `undefined` values.\n     *\n     * @private\n     * @param {Object} object The object to modify.\n     * @param {string} key The key of the property to assign.\n     * @param {*} value The value to assign.\n     */\n    function assignMergeValue(object, key, value) {\n      if ((value !== undefined && !eq(object[key], value)) ||\n          (typeof key == 'number' && value === undefined && !(key in object))) {\n        object[key] = value;\n      }\n    }\n\n    /**\n     * Assigns `value` to `key` of `object` if the existing value is not equivalent\n     * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)\n     * for equality comparisons.\n     *\n     * @private\n     * @param {Object} object The object to modify.\n     * @param {string} key The key of the property to assign.\n     * @param {*} value The value to assign.\n     */\n    function assignValue(object, key, value) {\n      var objValue = object[key];\n      if ((!eq(objValue, value) ||\n            (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) ||\n          (value === undefined && !(key in object))) {\n        object[key] = value;\n      }\n    }\n\n    /**\n     * The base implementation of `_.assign` without support for multiple sources\n     * or `customizer` functions.\n     *\n     * @private\n     * @param {Object} object The destination object.\n     * @param {Object} source The source object.\n     * @returns {Object} Returns `object`.\n     */\n    function baseAssign(object, source) {\n      return object && copyObject(source, keys(source), object);\n    }\n\n    /**\n     * The base implementation of `_.at` without support for individual paths.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {string[]} paths The property paths of elements to pick.\n     * @returns {Array} Returns the new array of picked elements.\n     */\n    function baseAt(object, paths) {\n      var index = -1,\n          isNil = object == null,\n          length = paths.length,\n          result = Array(length);\n\n      while (++index < length) {\n        result[index] = isNil ? undefined : get(object, paths[index]);\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.clamp` which doesn't coerce arguments to numbers.\n     *\n     * @private\n     * @param {number} number The number to clamp.\n     * @param {number} [lower] The lower bound.\n     * @param {number} upper The upper bound.\n     * @returns {number} Returns the clamped number.\n     */\n    function baseClamp(number, lower, upper) {\n      if (number === number) {\n        if (upper !== undefined) {\n          number = number <= upper ? number : upper;\n        }\n        if (lower !== undefined) {\n          number = number >= lower ? number : lower;\n        }\n      }\n      return number;\n    }\n\n    /**\n     * The base implementation of `_.clone` and `_.cloneDeep` which tracks\n     * traversed objects.\n     *\n     * @private\n     * @param {*} value The value to clone.\n     * @param {boolean} [isDeep] Specify a deep clone.\n     * @param {Function} [customizer] The function to customize cloning.\n     * @param {string} [key] The key of `value`.\n     * @param {Object} [object] The parent object of `value`.\n     * @param {Object} [stack] Tracks traversed objects and their clone counterparts.\n     * @returns {*} Returns the cloned value.\n     */\n    function baseClone(value, isDeep, customizer, key, object, stack) {\n      var result;\n      if (customizer) {\n        result = object ? customizer(value, key, object, stack) : customizer(value);\n      }\n      if (result !== undefined) {\n        return result;\n      }\n      if (!isObject(value)) {\n        return value;\n      }\n      var isArr = isArray(value);\n      if (isArr) {\n        result = initCloneArray(value);\n        if (!isDeep) {\n          return copyArray(value, result);\n        }\n      } else {\n        var tag = getTag(value),\n            isFunc = tag == funcTag || tag == genTag;\n\n        if (tag == objectTag || tag == argsTag || (isFunc && !object)) {\n          if (isHostObject(value)) {\n            return object ? value : {};\n          }\n          result = initCloneObject(isFunc ? {} : value);\n          if (!isDeep) {\n            return copySymbols(value, baseAssign(result, value));\n          }\n        } else {\n          return cloneableTags[tag]\n            ? initCloneByTag(value, tag, isDeep)\n            : (object ? value : {});\n        }\n      }\n      // Check for circular references and return its corresponding clone.\n      stack || (stack = new Stack);\n      var stacked = stack.get(value);\n      if (stacked) {\n        return stacked;\n      }\n      stack.set(value, result);\n\n      // Recursively populate clone (susceptible to call stack limits).\n      (isArr ? arrayEach : baseForOwn)(value, function(subValue, key) {\n        assignValue(result, key, baseClone(subValue, isDeep, customizer, key, value, stack));\n      });\n      return isArr ? result : copySymbols(value, result);\n    }\n\n    /**\n     * The base implementation of `_.conforms` which doesn't clone `source`.\n     *\n     * @private\n     * @param {Object} source The object of property predicates to conform to.\n     * @returns {Function} Returns the new function.\n     */\n    function baseConforms(source) {\n      var props = keys(source),\n          length = props.length;\n\n      return function(object) {\n        if (object == null) {\n          return !length;\n        }\n        var index = length;\n        while (index--) {\n          var key = props[index],\n              predicate = source[key],\n              value = object[key];\n\n          if ((value === undefined && !(key in Object(object))) || !predicate(value)) {\n            return false;\n          }\n        }\n        return true;\n      };\n    }\n\n    /**\n     * The base implementation of `_.create` without support for assigning\n     * properties to the created object.\n     *\n     * @private\n     * @param {Object} prototype The object to inherit from.\n     * @returns {Object} Returns the new object.\n     */\n    var baseCreate = (function() {\n      function object() {}\n      return function(prototype) {\n        if (isObject(prototype)) {\n          object.prototype = prototype;\n          var result = new object;\n          object.prototype = undefined;\n        }\n        return result || {};\n      };\n    }());\n\n    /**\n     * The base implementation of `_.delay` and `_.defer` which accepts an array\n     * of `func` arguments.\n     *\n     * @private\n     * @param {Function} func The function to delay.\n     * @param {number} wait The number of milliseconds to delay invocation.\n     * @param {Object} args The arguments provide to `func`.\n     * @returns {number} Returns the timer id.\n     */\n    function baseDelay(func, wait, args) {\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      return setTimeout(function() { func.apply(undefined, args); }, wait);\n    }\n\n    /**\n     * The base implementation of methods like `_.difference` without support for\n     * excluding multiple arrays or iteratee shorthands.\n     *\n     * @private\n     * @param {Array} array The array to inspect.\n     * @param {Array} values The values to exclude.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of filtered values.\n     */\n    function baseDifference(array, values, iteratee, comparator) {\n      var index = -1,\n          includes = arrayIncludes,\n          isCommon = true,\n          length = array.length,\n          result = [],\n          valuesLength = values.length;\n\n      if (!length) {\n        return result;\n      }\n      if (iteratee) {\n        values = arrayMap(values, baseUnary(iteratee));\n      }\n      if (comparator) {\n        includes = arrayIncludesWith;\n        isCommon = false;\n      }\n      else if (values.length >= LARGE_ARRAY_SIZE) {\n        includes = cacheHas;\n        isCommon = false;\n        values = new SetCache(values);\n      }\n      outer:\n      while (++index < length) {\n        var value = array[index],\n            computed = iteratee ? iteratee(value) : value;\n\n        if (isCommon && computed === computed) {\n          var valuesIndex = valuesLength;\n          while (valuesIndex--) {\n            if (values[valuesIndex] === computed) {\n              continue outer;\n            }\n          }\n          result.push(value);\n        }\n        else if (!includes(values, computed, comparator)) {\n          result.push(value);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.forEach` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Array|Object} Returns `collection`.\n     */\n    var baseEach = createBaseEach(baseForOwn);\n\n    /**\n     * The base implementation of `_.forEachRight` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Array|Object} Returns `collection`.\n     */\n    var baseEachRight = createBaseEach(baseForOwnRight, true);\n\n    /**\n     * The base implementation of `_.every` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} predicate The function invoked per iteration.\n     * @returns {boolean} Returns `true` if all elements pass the predicate check, else `false`\n     */\n    function baseEvery(collection, predicate) {\n      var result = true;\n      baseEach(collection, function(value, index, collection) {\n        result = !!predicate(value, index, collection);\n        return result;\n      });\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.fill` without an iteratee call guard.\n     *\n     * @private\n     * @param {Array} array The array to fill.\n     * @param {*} value The value to fill `array` with.\n     * @param {number} [start=0] The start position.\n     * @param {number} [end=array.length] The end position.\n     * @returns {Array} Returns `array`.\n     */\n    function baseFill(array, value, start, end) {\n      var length = array.length;\n\n      start = toInteger(start);\n      if (start < 0) {\n        start = -start > length ? 0 : (length + start);\n      }\n      end = (end === undefined || end > length) ? length : toInteger(end);\n      if (end < 0) {\n        end += length;\n      }\n      end = start > end ? 0 : toLength(end);\n      while (start < end) {\n        array[start++] = value;\n      }\n      return array;\n    }\n\n    /**\n     * The base implementation of `_.filter` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} predicate The function invoked per iteration.\n     * @returns {Array} Returns the new filtered array.\n     */\n    function baseFilter(collection, predicate) {\n      var result = [];\n      baseEach(collection, function(value, index, collection) {\n        if (predicate(value, index, collection)) {\n          result.push(value);\n        }\n      });\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.flatten` with support for restricting flattening.\n     *\n     * @private\n     * @param {Array} array The array to flatten.\n     * @param {boolean} [isDeep] Specify a deep flatten.\n     * @param {boolean} [isStrict] Restrict flattening to arrays-like objects.\n     * @param {Array} [result=[]] The initial result value.\n     * @returns {Array} Returns the new flattened array.\n     */\n    function baseFlatten(array, isDeep, isStrict, result) {\n      result || (result = []);\n\n      var index = -1,\n          length = array.length;\n\n      while (++index < length) {\n        var value = array[index];\n        if (isArrayLikeObject(value) &&\n            (isStrict || isArray(value) || isArguments(value))) {\n          if (isDeep) {\n            // Recursively flatten arrays (susceptible to call stack limits).\n            baseFlatten(value, isDeep, isStrict, result);\n          } else {\n            arrayPush(result, value);\n          }\n        } else if (!isStrict) {\n          result[result.length] = value;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `baseForIn` and `baseForOwn` which iterates\n     * over `object` properties returned by `keysFunc` invoking `iteratee` for\n     * each property. Iteratee functions may exit iteration early by explicitly\n     * returning `false`.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @param {Function} keysFunc The function to get the keys of `object`.\n     * @returns {Object} Returns `object`.\n     */\n    var baseFor = createBaseFor();\n\n    /**\n     * This function is like `baseFor` except that it iterates over properties\n     * in the opposite order.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @param {Function} keysFunc The function to get the keys of `object`.\n     * @returns {Object} Returns `object`.\n     */\n    var baseForRight = createBaseFor(true);\n\n    /**\n     * The base implementation of `_.forIn` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     */\n    function baseForIn(object, iteratee) {\n      return object == null ? object : baseFor(object, iteratee, keysIn);\n    }\n\n    /**\n     * The base implementation of `_.forOwn` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     */\n    function baseForOwn(object, iteratee) {\n      return object && baseFor(object, iteratee, keys);\n    }\n\n    /**\n     * The base implementation of `_.forOwnRight` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     */\n    function baseForOwnRight(object, iteratee) {\n      return object && baseForRight(object, iteratee, keys);\n    }\n\n    /**\n     * The base implementation of `_.functions` which creates an array of\n     * `object` function property names filtered from those provided.\n     *\n     * @private\n     * @param {Object} object The object to inspect.\n     * @param {Array} props The property names to filter.\n     * @returns {Array} Returns the new array of filtered property names.\n     */\n    function baseFunctions(object, props) {\n      return arrayFilter(props, function(key) {\n        return isFunction(object[key]);\n      });\n    }\n\n    /**\n     * The base implementation of `_.get` without support for default values.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path of the property to get.\n     * @returns {*} Returns the resolved value.\n     */\n    function baseGet(object, path) {\n      path = isKey(path, object) ? [path + ''] : baseToPath(path);\n\n      var index = 0,\n          length = path.length;\n\n      while (object != null && index < length) {\n        object = object[path[index++]];\n      }\n      return (index && index == length) ? object : undefined;\n    }\n\n    /**\n     * The base implementation of `_.has` without support for deep paths.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Array|string} key The key to check.\n     * @returns {boolean} Returns `true` if `key` exists, else `false`.\n     */\n    function baseHas(object, key) {\n      // Avoid a bug in IE 10-11 where objects with a [[Prototype]] of `null`,\n      // that are composed entirely of index properties, return `false` for\n      // `hasOwnProperty` checks of them.\n      return hasOwnProperty.call(object, key) ||\n        (typeof object == 'object' && key in object && getPrototypeOf(object) === null);\n    }\n\n    /**\n     * The base implementation of `_.hasIn` without support for deep paths.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Array|string} key The key to check.\n     * @returns {boolean} Returns `true` if `key` exists, else `false`.\n     */\n    function baseHasIn(object, key) {\n      return key in Object(object);\n    }\n\n    /**\n     * The base implementation of `_.inRange` which doesn't coerce arguments to numbers.\n     *\n     * @private\n     * @param {number} number The number to check.\n     * @param {number} start The start of the range.\n     * @param {number} end The end of the range.\n     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.\n     */\n    function baseInRange(number, start, end) {\n      return number >= nativeMin(start, end) && number < nativeMax(start, end);\n    }\n\n    /**\n     * The base implementation of methods like `_.intersection`, without support\n     * for iteratee shorthands, that accepts an array of arrays to inspect.\n     *\n     * @private\n     * @param {Array} arrays The arrays to inspect.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of shared values.\n     */\n    function baseIntersection(arrays, iteratee, comparator) {\n      var includes = comparator ? arrayIncludesWith : arrayIncludes,\n          othLength = arrays.length,\n          othIndex = othLength,\n          caches = Array(othLength),\n          result = [];\n\n      while (othIndex--) {\n        var array = arrays[othIndex];\n        if (othIndex && iteratee) {\n          array = arrayMap(array, baseUnary(iteratee));\n        }\n        caches[othIndex] = !comparator && (iteratee || array.length >= 120)\n          ? new SetCache(othIndex && array)\n          : undefined;\n      }\n      array = arrays[0];\n\n      var index = -1,\n          length = array.length,\n          seen = caches[0];\n\n      outer:\n      while (++index < length) {\n        var value = array[index],\n            computed = iteratee ? iteratee(value) : value;\n\n        if (!(seen ? cacheHas(seen, computed) : includes(result, computed, comparator))) {\n          var othIndex = othLength;\n          while (--othIndex) {\n            var cache = caches[othIndex];\n            if (!(cache ? cacheHas(cache, computed) : includes(arrays[othIndex], computed, comparator))) {\n              continue outer;\n            }\n          }\n          if (seen) {\n            seen.push(computed);\n          }\n          result.push(value);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.invoke` without support for individual\n     * method arguments.\n     *\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path of the method to invoke.\n     * @param {Array} args The arguments to invoke the method with.\n     * @returns {*} Returns the result of the invoked method.\n     */\n    function baseInvoke(object, path, args) {\n      if (!isKey(path, object)) {\n        path = baseToPath(path);\n        object = parent(object, path);\n        path = last(path);\n      }\n      var func = object == null ? object : object[path];\n      return func == null ? undefined : apply(func, object, args);\n    }\n\n    /**\n     * The base implementation of `_.isEqual` which supports partial comparisons\n     * and tracks traversed objects.\n     *\n     * @private\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @param {Function} [customizer] The function to customize comparisons.\n     * @param {boolean} [bitmask] The bitmask of comparison flags.\n     *  The bitmask may be composed of the following flags:\n     *     1 - Unordered comparison\n     *     2 - Partial comparison\n     * @param {Object} [stack] Tracks traversed `value` and `other` objects.\n     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n     */\n    function baseIsEqual(value, other, customizer, bitmask, stack) {\n      if (value === other) {\n        return true;\n      }\n      if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {\n        return value !== value && other !== other;\n      }\n      return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);\n    }\n\n    /**\n     * A specialized version of `baseIsEqual` for arrays and objects which performs\n     * deep comparisons and tracks traversed objects enabling objects with circular\n     * references to be compared.\n     *\n     * @private\n     * @param {Object} object The object to compare.\n     * @param {Object} other The other object to compare.\n     * @param {Function} equalFunc The function to determine equivalents of values.\n     * @param {Function} [customizer] The function to customize comparisons.\n     * @param {number} [bitmask] The bitmask of comparison flags. See `baseIsEqual` for more details.\n     * @param {Object} [stack] Tracks traversed `object` and `other` objects.\n     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n     */\n    function baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {\n      var objIsArr = isArray(object),\n          othIsArr = isArray(other),\n          objTag = arrayTag,\n          othTag = arrayTag;\n\n      if (!objIsArr) {\n        objTag = getTag(object);\n        if (objTag == argsTag) {\n          objTag = objectTag;\n        } else if (objTag != objectTag) {\n          objIsArr = isTypedArray(object);\n        }\n      }\n      if (!othIsArr) {\n        othTag = getTag(other);\n        if (othTag == argsTag) {\n          othTag = objectTag;\n        } else if (othTag != objectTag) {\n          othIsArr = isTypedArray(other);\n        }\n      }\n      var objIsObj = objTag == objectTag && !isHostObject(object),\n          othIsObj = othTag == objectTag && !isHostObject(other),\n          isSameTag = objTag == othTag;\n\n      if (isSameTag && !(objIsArr || objIsObj)) {\n        return equalByTag(object, other, objTag, equalFunc, customizer, bitmask);\n      }\n      var isPartial = bitmask & PARTIAL_COMPARE_FLAG;\n      if (!isPartial) {\n        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\n            othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\n        if (objIsWrapped || othIsWrapped) {\n          return equalFunc(objIsWrapped ? object.value() : object, othIsWrapped ? other.value() : other, customizer, bitmask, stack);\n        }\n      }\n      if (!isSameTag) {\n        return false;\n      }\n      stack || (stack = new Stack);\n      return (objIsArr ? equalArrays : equalObjects)(object, other, equalFunc, customizer, bitmask, stack);\n    }\n\n    /**\n     * The base implementation of `_.isMatch` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Object} object The object to inspect.\n     * @param {Object} source The object of property values to match.\n     * @param {Array} matchData The property names, values, and compare flags to match.\n     * @param {Function} [customizer] The function to customize comparisons.\n     * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n     */\n    function baseIsMatch(object, source, matchData, customizer) {\n      var index = matchData.length,\n          length = index,\n          noCustomizer = !customizer;\n\n      if (object == null) {\n        return !length;\n      }\n      object = Object(object);\n      while (index--) {\n        var data = matchData[index];\n        if ((noCustomizer && data[2])\n              ? data[1] !== object[data[0]]\n              : !(data[0] in object)\n            ) {\n          return false;\n        }\n      }\n      while (++index < length) {\n        data = matchData[index];\n        var key = data[0],\n            objValue = object[key],\n            srcValue = data[1];\n\n        if (noCustomizer && data[2]) {\n          if (objValue === undefined && !(key in object)) {\n            return false;\n          }\n        } else {\n          var stack = new Stack,\n              result = customizer ? customizer(objValue, srcValue, key, object, source, stack) : undefined;\n\n          if (!(result === undefined ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack) : result)) {\n            return false;\n          }\n        }\n      }\n      return true;\n    }\n\n    /**\n     * The base implementation of `_.iteratee`.\n     *\n     * @private\n     * @param {*} [value=_.identity] The value to convert to an iteratee.\n     * @returns {Function} Returns the iteratee.\n     */\n    function baseIteratee(value) {\n      var type = typeof value;\n      if (type == 'function') {\n        return value;\n      }\n      if (value == null) {\n        return identity;\n      }\n      if (type == 'object') {\n        return isArray(value)\n          ? baseMatchesProperty(value[0], value[1])\n          : baseMatches(value);\n      }\n      return property(value);\n    }\n\n    /**\n     * The base implementation of `_.keys` which doesn't skip the constructor\n     * property of prototypes or treat sparse arrays as dense.\n     *\n     * @private\n     * @type Function\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names.\n     */\n    function baseKeys(object) {\n      return nativeKeys(Object(object));\n    }\n\n    /**\n     * The base implementation of `_.keysIn` which doesn't skip the constructor\n     * property of prototypes or treat sparse arrays as dense.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names.\n     */\n    function baseKeysIn(object) {\n      object = object == null ? object : Object(object);\n\n      var result = [];\n      for (var key in object) {\n        result.push(key);\n      }\n      return result;\n    }\n\n    // Fallback for IE < 9 with es6-shim.\n    if (enumerate && !propertyIsEnumerable.call({ 'valueOf': 1 }, 'valueOf')) {\n      baseKeysIn = function(object) {\n        return iteratorToArray(enumerate(object));\n      };\n    }\n\n    /**\n     * The base implementation of `_.map` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Array} Returns the new mapped array.\n     */\n    function baseMap(collection, iteratee) {\n      var index = -1,\n          result = isArrayLike(collection) ? Array(collection.length) : [];\n\n      baseEach(collection, function(value, key, collection) {\n        result[++index] = iteratee(value, key, collection);\n      });\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.matches` which doesn't clone `source`.\n     *\n     * @private\n     * @param {Object} source The object of property values to match.\n     * @returns {Function} Returns the new function.\n     */\n    function baseMatches(source) {\n      var matchData = getMatchData(source);\n      if (matchData.length == 1 && matchData[0][2]) {\n        var key = matchData[0][0],\n            value = matchData[0][1];\n\n        return function(object) {\n          if (object == null) {\n            return false;\n          }\n          return object[key] === value &&\n            (value !== undefined || (key in Object(object)));\n        };\n      }\n      return function(object) {\n        return object === source || baseIsMatch(object, source, matchData);\n      };\n    }\n\n    /**\n     * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.\n     *\n     * @private\n     * @param {string} path The path of the property to get.\n     * @param {*} srcValue The value to match.\n     * @returns {Function} Returns the new function.\n     */\n    function baseMatchesProperty(path, srcValue) {\n      return function(object) {\n        var objValue = get(object, path);\n        return (objValue === undefined && objValue === srcValue)\n          ? hasIn(object, path)\n          : baseIsEqual(srcValue, objValue, undefined, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG);\n      };\n    }\n\n    /**\n     * The base implementation of `_.merge` without support for multiple sources.\n     *\n     * @private\n     * @param {Object} object The destination object.\n     * @param {Object} source The source object.\n     * @param {Function} [customizer] The function to customize merged values.\n     * @param {Object} [stack] Tracks traversed source values and their merged counterparts.\n     */\n    function baseMerge(object, source, customizer, stack) {\n      if (object === source) {\n        return;\n      }\n      var props = (isArray(source) || isTypedArray(source)) ? undefined : keysIn(source);\n      arrayEach(props || source, function(srcValue, key) {\n        if (props) {\n          key = srcValue;\n          srcValue = source[key];\n        }\n        if (isObject(srcValue)) {\n          stack || (stack = new Stack);\n          baseMergeDeep(object, source, key, baseMerge, customizer, stack);\n        }\n        else {\n          var newValue = customizer ? customizer(object[key], srcValue, (key + ''), object, source, stack) : undefined;\n          if (newValue === undefined) {\n            newValue = srcValue;\n          }\n          assignMergeValue(object, key, newValue);\n        }\n      });\n    }\n\n    /**\n     * A specialized version of `baseMerge` for arrays and objects which performs\n     * deep merges and tracks traversed objects enabling objects with circular\n     * references to be merged.\n     *\n     * @private\n     * @param {Object} object The destination object.\n     * @param {Object} source The source object.\n     * @param {string} key The key of the value to merge.\n     * @param {Function} mergeFunc The function to merge values.\n     * @param {Function} [customizer] The function to customize assigned values.\n     * @param {Object} [stack] Tracks traversed source values and their merged counterparts.\n     */\n    function baseMergeDeep(object, source, key, mergeFunc, customizer, stack) {\n      var objValue = object[key],\n          srcValue = source[key],\n          stacked = stack.get(srcValue) || stack.get(objValue);\n\n      if (stacked) {\n        assignMergeValue(object, key, stacked);\n        return;\n      }\n      var newValue = customizer ? customizer(objValue, srcValue, (key + ''), object, source, stack) : undefined,\n          isCommon = newValue === undefined;\n\n      if (isCommon) {\n        newValue = srcValue;\n        if (isArray(srcValue) || isTypedArray(srcValue)) {\n          newValue = isArray(objValue)\n            ? objValue\n            : ((isArrayLikeObject(objValue)) ? copyArray(objValue) : baseClone(srcValue));\n        }\n        else if (isPlainObject(srcValue) || isArguments(srcValue)) {\n          newValue = isArguments(objValue)\n            ? toPlainObject(objValue)\n            : (isObject(objValue) ? objValue : baseClone(srcValue));\n        }\n        else {\n          isCommon = isFunction(srcValue);\n        }\n      }\n      stack.set(srcValue, newValue);\n\n      if (isCommon) {\n        // Recursively merge objects and arrays (susceptible to call stack limits).\n        mergeFunc(newValue, srcValue, customizer, stack);\n      }\n      assignMergeValue(object, key, newValue);\n    }\n\n    /**\n     * The base implementation of `_.orderBy` without param guards.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.\n     * @param {string[]} orders The sort orders of `iteratees`.\n     * @returns {Array} Returns the new sorted array.\n     */\n    function baseOrderBy(collection, iteratees, orders) {\n      var index = -1,\n          toIteratee = getIteratee();\n\n      iteratees = arrayMap(iteratees.length ? iteratees : Array(1), function(iteratee) {\n        return toIteratee(iteratee);\n      });\n\n      var result = baseMap(collection, function(value, key, collection) {\n        var criteria = arrayMap(iteratees, function(iteratee) {\n          return iteratee(value);\n        });\n        return { 'criteria': criteria, 'index': ++index, 'value': value };\n      });\n\n      return baseSortBy(result, function(object, other) {\n        return compareMultiple(object, other, orders);\n      });\n    }\n\n    /**\n     * The base implementation of `_.pick` without support for individual\n     * property names.\n     *\n     * @private\n     * @param {Object} object The source object.\n     * @param {string[]} props The property names to pick.\n     * @returns {Object} Returns the new object.\n     */\n    function basePick(object, props) {\n      object = Object(object);\n      return arrayReduce(props, function(result, key) {\n        if (key in object) {\n          result[key] = object[key];\n        }\n        return result;\n      }, {});\n    }\n\n    /**\n     * The base implementation of  `_.pickBy` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Object} object The source object.\n     * @param {Function} predicate The function invoked per property.\n     * @returns {Object} Returns the new object.\n     */\n    function basePickBy(object, predicate) {\n      var result = {};\n      baseForIn(object, function(value, key) {\n        if (predicate(value)) {\n          result[key] = value;\n        }\n      });\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.property` without support for deep paths.\n     *\n     * @private\n     * @param {string} key The key of the property to get.\n     * @returns {Function} Returns the new function.\n     */\n    function baseProperty(key) {\n      return function(object) {\n        return object == null ? undefined : object[key];\n      };\n    }\n\n    /**\n     * A specialized version of `baseProperty` which supports deep paths.\n     *\n     * @private\n     * @param {Array|string} path The path of the property to get.\n     * @returns {Function} Returns the new function.\n     */\n    function basePropertyDeep(path) {\n      return function(object) {\n        return baseGet(object, path);\n      };\n    }\n\n    /**\n     * The base implementation of `_.pullAll`.\n     *\n     * @private\n     * @param {Array} array The array to modify.\n     * @param {Array} values The values to remove.\n     * @returns {Array} Returns `array`.\n     */\n    function basePullAll(array, values) {\n      return basePullAllBy(array, values);\n    }\n\n    /**\n     * The base implementation of `_.pullAllBy` without support for iteratee\n     * shorthands.\n     *\n     * @private\n     * @param {Array} array The array to modify.\n     * @param {Array} values The values to remove.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @returns {Array} Returns `array`.\n     */\n    function basePullAllBy(array, values, iteratee) {\n      var index = -1,\n          length = values.length,\n          seen = array;\n\n      if (iteratee) {\n        seen = arrayMap(array, function(value) { return iteratee(value); });\n      }\n      while (++index < length) {\n        var fromIndex = 0,\n            value = values[index],\n            computed = iteratee ? iteratee(value) : value;\n\n        while ((fromIndex = baseIndexOf(seen, computed, fromIndex)) > -1) {\n          if (seen !== array) {\n            splice.call(seen, fromIndex, 1);\n          }\n          splice.call(array, fromIndex, 1);\n        }\n      }\n      return array;\n    }\n\n    /**\n     * The base implementation of `_.pullAt` without support for individual\n     * indexes or capturing the removed elements.\n     *\n     * @private\n     * @param {Array} array The array to modify.\n     * @param {number[]} indexes The indexes of elements to remove.\n     * @returns {Array} Returns `array`.\n     */\n    function basePullAt(array, indexes) {\n      var length = array ? indexes.length : 0,\n          lastIndex = length - 1;\n\n      while (length--) {\n        var index = indexes[length];\n        if (lastIndex == length || index != previous) {\n          var previous = index;\n          if (isIndex(index)) {\n            splice.call(array, index, 1);\n          }\n          else if (!isKey(index, array)) {\n            var path = baseToPath(index),\n                object = parent(array, path);\n\n            if (object != null) {\n              delete object[last(path)];\n            }\n          }\n          else {\n            delete array[index];\n          }\n        }\n      }\n      return array;\n    }\n\n    /**\n     * The base implementation of `_.random` without support for returning\n     * floating-point numbers.\n     *\n     * @private\n     * @param {number} lower The lower bound.\n     * @param {number} upper The upper bound.\n     * @returns {number} Returns the random number.\n     */\n    function baseRandom(lower, upper) {\n      return lower + nativeFloor(nativeRandom() * (upper - lower + 1));\n    }\n\n    /**\n     * The base implementation of `_.range` and `_.rangeRight` which doesn't\n     * coerce arguments to numbers.\n     *\n     * @private\n     * @param {number} start The start of the range.\n     * @param {number} end The end of the range.\n     * @param {number} step The value to increment or decrement by.\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Array} Returns the new array of numbers.\n     */\n    function baseRange(start, end, step, fromRight) {\n      var index = -1,\n          length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),\n          result = Array(length);\n\n      while (length--) {\n        result[fromRight ? length : ++index] = start;\n        start += step;\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.set`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path of the property to set.\n     * @param {*} value The value to set.\n     * @param {Function} [customizer] The function to customize path creation.\n     * @returns {Object} Returns `object`.\n     */\n    function baseSet(object, path, value, customizer) {\n      path = isKey(path, object) ? [path + ''] : baseToPath(path);\n\n      var index = -1,\n          length = path.length,\n          lastIndex = length - 1,\n          nested = object;\n\n      while (nested != null && ++index < length) {\n        var key = path[index];\n        if (isObject(nested)) {\n          var newValue = value;\n          if (index != lastIndex) {\n            var objValue = nested[key];\n            newValue = customizer ? customizer(objValue, key, nested) : undefined;\n            if (newValue === undefined) {\n              newValue = objValue == null ? (isIndex(path[index + 1]) ? [] : {}) : objValue;\n            }\n          }\n          assignValue(nested, key, newValue);\n        }\n        nested = nested[key];\n      }\n      return object;\n    }\n\n    /**\n     * The base implementation of `setData` without support for hot loop detection.\n     *\n     * @private\n     * @param {Function} func The function to associate metadata with.\n     * @param {*} data The metadata.\n     * @returns {Function} Returns `func`.\n     */\n    var baseSetData = !metaMap ? identity : function(func, data) {\n      metaMap.set(func, data);\n      return func;\n    };\n\n    /**\n     * The base implementation of `_.slice` without an iteratee call guard.\n     *\n     * @private\n     * @param {Array} array The array to slice.\n     * @param {number} [start=0] The start position.\n     * @param {number} [end=array.length] The end position.\n     * @returns {Array} Returns the slice of `array`.\n     */\n    function baseSlice(array, start, end) {\n      var index = -1,\n          length = array.length;\n\n      if (start < 0) {\n        start = -start > length ? 0 : (length + start);\n      }\n      end = end > length ? length : end;\n      if (end < 0) {\n        end += length;\n      }\n      length = start > end ? 0 : ((end - start) >>> 0);\n      start >>>= 0;\n\n      var result = Array(length);\n      while (++index < length) {\n        result[index] = array[index + start];\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.some` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} predicate The function invoked per iteration.\n     * @returns {boolean} Returns `true` if any element passes the predicate check, else `false`.\n     */\n    function baseSome(collection, predicate) {\n      var result;\n\n      baseEach(collection, function(value, index, collection) {\n        result = predicate(value, index, collection);\n        return !result;\n      });\n      return !!result;\n    }\n\n    /**\n     * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which\n     * performs a binary search of `array` to determine the index at which `value`\n     * should be inserted into `array` in order to maintain its sort order.\n     *\n     * @private\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @param {boolean} [retHighest] Specify returning the highest qualified index.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     */\n    function baseSortedIndex(array, value, retHighest) {\n      var low = 0,\n          high = array ? array.length : low;\n\n      if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {\n        while (low < high) {\n          var mid = (low + high) >>> 1,\n              computed = array[mid];\n\n          if ((retHighest ? (computed <= value) : (computed < value)) && computed !== null) {\n            low = mid + 1;\n          } else {\n            high = mid;\n          }\n        }\n        return high;\n      }\n      return baseSortedIndexBy(array, value, identity, retHighest);\n    }\n\n    /**\n     * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`\n     * which invokes `iteratee` for `value` and each element of `array` to compute\n     * their sort ranking. The iteratee is invoked with one argument; (value).\n     *\n     * @private\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @param {Function} iteratee The iteratee invoked per element.\n     * @param {boolean} [retHighest] Specify returning the highest qualified index.\n     * @returns {number} Returns the index at which `value` should be inserted into `array`.\n     */\n    function baseSortedIndexBy(array, value, iteratee, retHighest) {\n      value = iteratee(value);\n\n      var low = 0,\n          high = array ? array.length : 0,\n          valIsNaN = value !== value,\n          valIsNull = value === null,\n          valIsUndef = value === undefined;\n\n      while (low < high) {\n        var mid = nativeFloor((low + high) / 2),\n            computed = iteratee(array[mid]),\n            isDef = computed !== undefined,\n            isReflexive = computed === computed;\n\n        if (valIsNaN) {\n          var setLow = isReflexive || retHighest;\n        } else if (valIsNull) {\n          setLow = isReflexive && isDef && (retHighest || computed != null);\n        } else if (valIsUndef) {\n          setLow = isReflexive && (retHighest || isDef);\n        } else if (computed == null) {\n          setLow = false;\n        } else {\n          setLow = retHighest ? (computed <= value) : (computed < value);\n        }\n        if (setLow) {\n          low = mid + 1;\n        } else {\n          high = mid;\n        }\n      }\n      return nativeMin(high, MAX_ARRAY_INDEX);\n    }\n\n    /**\n     * The base implementation of `_.sortedUniq`.\n     *\n     * @private\n     * @param {Array} array The array to inspect.\n     * @returns {Array} Returns the new duplicate free array.\n     */\n    function baseSortedUniq(array) {\n      return baseSortedUniqBy(array);\n    }\n\n    /**\n     * The base implementation of `_.sortedUniqBy` without support for iteratee\n     * shorthands.\n     *\n     * @private\n     * @param {Array} array The array to inspect.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @returns {Array} Returns the new duplicate free array.\n     */\n    function baseSortedUniqBy(array, iteratee) {\n      var index = 0,\n          length = array.length,\n          value = array[0],\n          computed = iteratee ? iteratee(value) : value,\n          seen = computed,\n          resIndex = 0,\n          result = [value];\n\n      while (++index < length) {\n        value = array[index],\n        computed = iteratee ? iteratee(value) : value;\n\n        if (!eq(computed, seen)) {\n          seen = computed;\n          result[++resIndex] = value;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.toPath` which only converts `value` to a\n     * path if it's not one.\n     *\n     * @private\n     * @param {*} value The value to process.\n     * @returns {Array} Returns the property path array.\n     */\n    function baseToPath(value) {\n      return isArray(value) ? value : stringToPath(value);\n    }\n\n    /**\n     * The base implementation of `_.uniqBy` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array} array The array to inspect.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new duplicate free array.\n     */\n    function baseUniq(array, iteratee, comparator) {\n      var index = -1,\n          includes = arrayIncludes,\n          length = array.length,\n          isCommon = true,\n          result = [],\n          seen = result;\n\n      if (comparator) {\n        isCommon = false;\n        includes = arrayIncludesWith;\n      }\n      else if (length >= LARGE_ARRAY_SIZE) {\n        var set = iteratee ? null : createSet(array);\n        if (set) {\n          return setToArray(set);\n        }\n        isCommon = false;\n        includes = cacheHas;\n        seen = new SetCache;\n      }\n      else {\n        seen = iteratee ? [] : result;\n      }\n      outer:\n      while (++index < length) {\n        var value = array[index],\n            computed = iteratee ? iteratee(value) : value;\n\n        if (isCommon && computed === computed) {\n          var seenIndex = seen.length;\n          while (seenIndex--) {\n            if (seen[seenIndex] === computed) {\n              continue outer;\n            }\n          }\n          if (iteratee) {\n            seen.push(computed);\n          }\n          result.push(value);\n        }\n        else if (!includes(seen, computed, comparator)) {\n          if (seen !== result) {\n            seen.push(computed);\n          }\n          result.push(value);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.unset`.\n     *\n     * @private\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to unset.\n     * @returns {boolean} Returns `true` if the property is deleted, else `false`.\n     */\n    function baseUnset(object, path) {\n      path = isKey(path, object) ? [path + ''] : baseToPath(path);\n      object = parent(object, path);\n      var key = last(path);\n      return (object != null && has(object, key)) ? delete object[key] : true;\n    }\n\n    /**\n     * The base implementation of methods like `_.dropWhile` and `_.takeWhile`\n     * without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array} array The array to query.\n     * @param {Function} predicate The function invoked per iteration.\n     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Array} Returns the slice of `array`.\n     */\n    function baseWhile(array, predicate, isDrop, fromRight) {\n      var length = array.length,\n          index = fromRight ? length : -1;\n\n      while ((fromRight ? index-- : ++index < length) &&\n        predicate(array[index], index, array)) {}\n\n      return isDrop\n        ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))\n        : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));\n    }\n\n    /**\n     * The base implementation of `wrapperValue` which returns the result of\n     * performing a sequence of actions on the unwrapped `value`, where each\n     * successive action is supplied the return value of the previous.\n     *\n     * @private\n     * @param {*} value The unwrapped value.\n     * @param {Array} actions Actions to perform to resolve the unwrapped value.\n     * @returns {*} Returns the resolved value.\n     */\n    function baseWrapperValue(value, actions) {\n      var result = value;\n      if (result instanceof LazyWrapper) {\n        result = result.value();\n      }\n      return arrayReduce(actions, function(result, action) {\n        return action.func.apply(action.thisArg, arrayPush([result], action.args));\n      }, result);\n    }\n\n    /**\n     * The base implementation of methods like `_.xor`, without support for\n     * iteratee shorthands, that accepts an array of arrays to inspect.\n     *\n     * @private\n     * @param {Array} arrays The arrays to inspect.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of values.\n     */\n    function baseXor(arrays, iteratee, comparator) {\n      var index = -1,\n          length = arrays.length;\n\n      while (++index < length) {\n        var result = result\n          ? arrayPush(\n              baseDifference(result, arrays[index], iteratee, comparator),\n              baseDifference(arrays[index], result, iteratee, comparator)\n            )\n          : arrays[index];\n      }\n      return (result && result.length) ? baseUniq(result, iteratee, comparator) : [];\n    }\n\n    /**\n     * Creates a clone of `buffer`.\n     *\n     * @private\n     * @param {ArrayBuffer} buffer The array buffer to clone.\n     * @returns {ArrayBuffer} Returns the cloned array buffer.\n     */\n    function cloneBuffer(buffer) {\n      var Ctor = buffer.constructor,\n          result = new Ctor(buffer.byteLength),\n          view = new Uint8Array(result);\n\n      view.set(new Uint8Array(buffer));\n      return result;\n    }\n\n    /**\n     * Creates a clone of `map`.\n     *\n     * @private\n     * @param {Object} map The map to clone.\n     * @returns {Object} Returns the cloned map.\n     */\n    function cloneMap(map) {\n      var Ctor = map.constructor;\n      return arrayReduce(mapToArray(map), addMapEntry, new Ctor);\n    }\n\n    /**\n     * Creates a clone of `regexp`.\n     *\n     * @private\n     * @param {Object} regexp The regexp to clone.\n     * @returns {Object} Returns the cloned regexp.\n     */\n    function cloneRegExp(regexp) {\n      var Ctor = regexp.constructor,\n          result = new Ctor(regexp.source, reFlags.exec(regexp));\n\n      result.lastIndex = regexp.lastIndex;\n      return result;\n    }\n\n    /**\n     * Creates a clone of `set`.\n     *\n     * @private\n     * @param {Object} set The set to clone.\n     * @returns {Object} Returns the cloned set.\n     */\n    function cloneSet(set) {\n      var Ctor = set.constructor;\n      return arrayReduce(setToArray(set), addSetEntry, new Ctor);\n    }\n\n    /**\n     * Creates a clone of the `symbol` object.\n     *\n     * @private\n     * @param {Object} symbol The symbol object to clone.\n     * @returns {Object} Returns the cloned symbol object.\n     */\n    function cloneSymbol(symbol) {\n      return _Symbol ? Object(symbolValueOf.call(symbol)) : {};\n    }\n\n    /**\n     * Creates a clone of `typedArray`.\n     *\n     * @private\n     * @param {Object} typedArray The typed array to clone.\n     * @param {boolean} [isDeep] Specify a deep clone.\n     * @returns {Object} Returns the cloned typed array.\n     */\n    function cloneTypedArray(typedArray, isDeep) {\n      var buffer = typedArray.buffer,\n          Ctor = typedArray.constructor;\n\n      return new Ctor(isDeep ? cloneBuffer(buffer) : buffer, typedArray.byteOffset, typedArray.length);\n    }\n\n    /**\n     * Creates an array that is the composition of partially applied arguments,\n     * placeholders, and provided arguments into a single array of arguments.\n     *\n     * @private\n     * @param {Array|Object} args The provided arguments.\n     * @param {Array} partials The arguments to prepend to those provided.\n     * @param {Array} holders The `partials` placeholder indexes.\n     * @returns {Array} Returns the new array of composed arguments.\n     */\n    function composeArgs(args, partials, holders) {\n      var holdersLength = holders.length,\n          argsIndex = -1,\n          argsLength = nativeMax(args.length - holdersLength, 0),\n          leftIndex = -1,\n          leftLength = partials.length,\n          result = Array(leftLength + argsLength);\n\n      while (++leftIndex < leftLength) {\n        result[leftIndex] = partials[leftIndex];\n      }\n      while (++argsIndex < holdersLength) {\n        result[holders[argsIndex]] = args[argsIndex];\n      }\n      while (argsLength--) {\n        result[leftIndex++] = args[argsIndex++];\n      }\n      return result;\n    }\n\n    /**\n     * This function is like `composeArgs` except that the arguments composition\n     * is tailored for `_.partialRight`.\n     *\n     * @private\n     * @param {Array|Object} args The provided arguments.\n     * @param {Array} partials The arguments to append to those provided.\n     * @param {Array} holders The `partials` placeholder indexes.\n     * @returns {Array} Returns the new array of composed arguments.\n     */\n    function composeArgsRight(args, partials, holders) {\n      var holdersIndex = -1,\n          holdersLength = holders.length,\n          argsIndex = -1,\n          argsLength = nativeMax(args.length - holdersLength, 0),\n          rightIndex = -1,\n          rightLength = partials.length,\n          result = Array(argsLength + rightLength);\n\n      while (++argsIndex < argsLength) {\n        result[argsIndex] = args[argsIndex];\n      }\n      var offset = argsIndex;\n      while (++rightIndex < rightLength) {\n        result[offset + rightIndex] = partials[rightIndex];\n      }\n      while (++holdersIndex < holdersLength) {\n        result[offset + holders[holdersIndex]] = args[argsIndex++];\n      }\n      return result;\n    }\n\n    /**\n     * Copies the values of `source` to `array`.\n     *\n     * @private\n     * @param {Array} source The array to copy values from.\n     * @param {Array} [array=[]] The array to copy values to.\n     * @returns {Array} Returns `array`.\n     */\n    function copyArray(source, array) {\n      var index = -1,\n          length = source.length;\n\n      array || (array = Array(length));\n      while (++index < length) {\n        array[index] = source[index];\n      }\n      return array;\n    }\n\n    /**\n     * Copies properties of `source` to `object`.\n     *\n     * @private\n     * @param {Object} source The object to copy properties from.\n     * @param {Array} props The property names to copy.\n     * @param {Object} [object={}] The object to copy properties to.\n     * @returns {Object} Returns `object`.\n     */\n    function copyObject(source, props, object) {\n      return copyObjectWith(source, props, object);\n    }\n\n    /**\n     * This function is like `copyObject` except that it accepts a function to\n     * customize copied values.\n     *\n     * @private\n     * @param {Object} source The object to copy properties from.\n     * @param {Array} props The property names to copy.\n     * @param {Object} [object={}] The object to copy properties to.\n     * @param {Function} [customizer] The function to customize copied values.\n     * @returns {Object} Returns `object`.\n     */\n    function copyObjectWith(source, props, object, customizer) {\n      object || (object = {});\n\n      var index = -1,\n          length = props.length;\n\n      while (++index < length) {\n        var key = props[index],\n            newValue = customizer ? customizer(object[key], source[key], key, object, source) : source[key];\n\n        assignValue(object, key, newValue);\n      }\n      return object;\n    }\n\n    /**\n     * Copies own symbol properties of `source` to `object`.\n     *\n     * @private\n     * @param {Object} source The object to copy symbols from.\n     * @param {Object} [object={}] The object to copy symbols to.\n     * @returns {Object} Returns `object`.\n     */\n    function copySymbols(source, object) {\n      return copyObject(source, getSymbols(source), object);\n    }\n\n    /**\n     * Creates a function like `_.groupBy`.\n     *\n     * @private\n     * @param {Function} setter The function to set keys and values of the accumulator object.\n     * @param {Function} [initializer] The function to initialize the accumulator object.\n     * @returns {Function} Returns the new aggregator function.\n     */\n    function createAggregator(setter, initializer) {\n      return function(collection, iteratee) {\n        var result = initializer ? initializer() : {};\n        iteratee = getIteratee(iteratee);\n\n        if (isArray(collection)) {\n          var index = -1,\n              length = collection.length;\n\n          while (++index < length) {\n            var value = collection[index];\n            setter(result, value, iteratee(value), collection);\n          }\n        } else {\n          baseEach(collection, function(value, key, collection) {\n            setter(result, value, iteratee(value), collection);\n          });\n        }\n        return result;\n      };\n    }\n\n    /**\n     * Creates a function like `_.assign`.\n     *\n     * @private\n     * @param {Function} assigner The function to assign values.\n     * @returns {Function} Returns the new assigner function.\n     */\n    function createAssigner(assigner) {\n      return rest(function(object, sources) {\n        var index = -1,\n            length = sources.length,\n            customizer = length > 1 ? sources[length - 1] : undefined,\n            guard = length > 2 ? sources[2] : undefined;\n\n        customizer = typeof customizer == 'function' ? (length--, customizer) : undefined;\n        if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n          customizer = length < 3 ? undefined : customizer;\n          length = 1;\n        }\n        object = Object(object);\n        while (++index < length) {\n          var source = sources[index];\n          if (source) {\n            assigner(object, source, customizer);\n          }\n        }\n        return object;\n      });\n    }\n\n    /**\n     * Creates a `baseEach` or `baseEachRight` function.\n     *\n     * @private\n     * @param {Function} eachFunc The function to iterate over a collection.\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Function} Returns the new base function.\n     */\n    function createBaseEach(eachFunc, fromRight) {\n      return function(collection, iteratee) {\n        if (collection == null) {\n          return collection;\n        }\n        if (!isArrayLike(collection)) {\n          return eachFunc(collection, iteratee);\n        }\n        var length = collection.length,\n            index = fromRight ? length : -1,\n            iterable = Object(collection);\n\n        while ((fromRight ? index-- : ++index < length)) {\n          if (iteratee(iterable[index], index, iterable) === false) {\n            break;\n          }\n        }\n        return collection;\n      };\n    }\n\n    /**\n     * Creates a base function for methods like `_.forIn`.\n     *\n     * @private\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Function} Returns the new base function.\n     */\n    function createBaseFor(fromRight) {\n      return function(object, iteratee, keysFunc) {\n        var index = -1,\n            iterable = Object(object),\n            props = keysFunc(object),\n            length = props.length;\n\n        while (length--) {\n          var key = props[fromRight ? length : ++index];\n          if (iteratee(iterable[key], key, iterable) === false) {\n            break;\n          }\n        }\n        return object;\n      };\n    }\n\n    /**\n     * Creates a function that wraps `func` to invoke it with the optional `this`\n     * binding of `thisArg`.\n     *\n     * @private\n     * @param {Function} func The function to wrap.\n     * @param {number} bitmask The bitmask of wrapper flags. See `createWrapper` for more details.\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createBaseWrapper(func, bitmask, thisArg) {\n      var isBind = bitmask & BIND_FLAG,\n          Ctor = createCtorWrapper(func);\n\n      function wrapper() {\n        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;\n        return fn.apply(isBind ? thisArg : this, arguments);\n      }\n      return wrapper;\n    }\n\n    /**\n     * Creates a function like `_.lowerFirst`.\n     *\n     * @private\n     * @param {string} methodName The name of the `String` case method to use.\n     * @returns {Function} Returns the new function.\n     */\n    function createCaseFirst(methodName) {\n      return function(string) {\n        string = toString(string);\n\n        var strSymbols = reHasComplexSymbol.test(string) ? stringToArray(string) : undefined,\n            chr = strSymbols ? strSymbols[0] : string.charAt(0),\n            trailing = strSymbols ? strSymbols.slice(1).join('') : string.slice(1);\n\n        return chr[methodName]() + trailing;\n      };\n    }\n\n    /**\n     * Creates a function like `_.camelCase`.\n     *\n     * @private\n     * @param {Function} callback The function to combine each word.\n     * @returns {Function} Returns the new compounder function.\n     */\n    function createCompounder(callback) {\n      return function(string) {\n        return arrayReduce(words(deburr(string)), callback, '');\n      };\n    }\n\n    /**\n     * Creates a function that produces an instance of `Ctor` regardless of\n     * whether it was invoked as part of a `new` expression or by `call` or `apply`.\n     *\n     * @private\n     * @param {Function} Ctor The constructor to wrap.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createCtorWrapper(Ctor) {\n      return function() {\n        // Use a `switch` statement to work with class constructors.\n        // See http://ecma-international.org/ecma-262/6.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist\n        // for more details.\n        var args = arguments;\n        switch (args.length) {\n          case 0: return new Ctor;\n          case 1: return new Ctor(args[0]);\n          case 2: return new Ctor(args[0], args[1]);\n          case 3: return new Ctor(args[0], args[1], args[2]);\n          case 4: return new Ctor(args[0], args[1], args[2], args[3]);\n          case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);\n          case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);\n          case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);\n        }\n        var thisBinding = baseCreate(Ctor.prototype),\n            result = Ctor.apply(thisBinding, args);\n\n        // Mimic the constructor's `return` behavior.\n        // See https://es5.github.io/#x13.2.2 for more details.\n        return isObject(result) ? result : thisBinding;\n      };\n    }\n\n    /**\n     * Creates a function that wraps `func` to enable currying.\n     *\n     * @private\n     * @param {Function} func The function to wrap.\n     * @param {number} bitmask The bitmask of wrapper flags. See `createWrapper` for more details.\n     * @param {number} arity The arity of `func`.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createCurryWrapper(func, bitmask, arity) {\n      var Ctor = createCtorWrapper(func);\n\n      function wrapper() {\n        var length = arguments.length,\n            index = length,\n            args = Array(length),\n            fn = (this && this !== root && this instanceof wrapper) ? Ctor : func,\n            placeholder = wrapper.placeholder;\n\n        while (index--) {\n          args[index] = arguments[index];\n        }\n        var holders = (length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder)\n          ? []\n          : replaceHolders(args, placeholder);\n\n        length -= holders.length;\n        return length < arity\n          ? createRecurryWrapper(func, bitmask, createHybridWrapper, placeholder, undefined, args, holders, undefined, undefined, arity - length)\n          : apply(fn, this, args);\n      }\n      return wrapper;\n    }\n\n    /**\n     * Creates a `_.flow` or `_.flowRight` function.\n     *\n     * @private\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Function} Returns the new flow function.\n     */\n    function createFlow(fromRight) {\n      return rest(function(funcs) {\n        funcs = baseFlatten(funcs);\n\n        var length = funcs.length,\n            index = length,\n            prereq = LodashWrapper.prototype.thru;\n\n        if (fromRight) {\n          funcs.reverse();\n        }\n        while (index--) {\n          var func = funcs[index];\n          if (typeof func != 'function') {\n            throw new TypeError(FUNC_ERROR_TEXT);\n          }\n          if (prereq && !wrapper && getFuncName(func) == 'wrapper') {\n            var wrapper = new LodashWrapper([], true);\n          }\n        }\n        index = wrapper ? index : length;\n        while (++index < length) {\n          func = funcs[index];\n\n          var funcName = getFuncName(func),\n              data = funcName == 'wrapper' ? getData(func) : undefined;\n\n          if (data && isLaziable(data[0]) && data[1] == (ARY_FLAG | CURRY_FLAG | PARTIAL_FLAG | REARG_FLAG) && !data[4].length && data[9] == 1) {\n            wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);\n          } else {\n            wrapper = (func.length == 1 && isLaziable(func)) ? wrapper[funcName]() : wrapper.thru(func);\n          }\n        }\n        return function() {\n          var args = arguments,\n              value = args[0];\n\n          if (wrapper && args.length == 1 && isArray(value) && value.length >= LARGE_ARRAY_SIZE) {\n            return wrapper.plant(value).value();\n          }\n          var index = 0,\n              result = length ? funcs[index].apply(this, args) : value;\n\n          while (++index < length) {\n            result = funcs[index].call(this, result);\n          }\n          return result;\n        };\n      });\n    }\n\n    /**\n     * Creates a function that wraps `func` to invoke it with optional `this`\n     * binding of `thisArg`, partial application, and currying.\n     *\n     * @private\n     * @param {Function|string} func The function or method name to wrap.\n     * @param {number} bitmask The bitmask of wrapper flags. See `createWrapper` for more details.\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @param {Array} [partials] The arguments to prepend to those provided to the new function.\n     * @param {Array} [holders] The `partials` placeholder indexes.\n     * @param {Array} [partialsRight] The arguments to append to those provided to the new function.\n     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.\n     * @param {Array} [argPos] The argument positions of the new function.\n     * @param {number} [ary] The arity cap of `func`.\n     * @param {number} [arity] The arity of `func`.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createHybridWrapper(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {\n      var isAry = bitmask & ARY_FLAG,\n          isBind = bitmask & BIND_FLAG,\n          isBindKey = bitmask & BIND_KEY_FLAG,\n          isCurry = bitmask & CURRY_FLAG,\n          isCurryRight = bitmask & CURRY_RIGHT_FLAG,\n          isFlip = bitmask & FLIP_FLAG,\n          Ctor = isBindKey ? undefined : createCtorWrapper(func);\n\n      function wrapper() {\n        var length = arguments.length,\n            index = length,\n            args = Array(length);\n\n        while (index--) {\n          args[index] = arguments[index];\n        }\n        if (partials) {\n          args = composeArgs(args, partials, holders);\n        }\n        if (partialsRight) {\n          args = composeArgsRight(args, partialsRight, holdersRight);\n        }\n        if (isCurry || isCurryRight) {\n          var placeholder = wrapper.placeholder,\n              argsHolders = replaceHolders(args, placeholder);\n\n          length -= argsHolders.length;\n          if (length < arity) {\n            return createRecurryWrapper(func, bitmask, createHybridWrapper, placeholder, thisArg, args, argsHolders, argPos, ary, arity - length);\n          }\n        }\n        var thisBinding = isBind ? thisArg : this,\n            fn = isBindKey ? thisBinding[func] : func;\n\n        if (argPos) {\n          args = reorder(args, argPos);\n        } else if (isFlip && args.length > 1) {\n          args.reverse();\n        }\n        if (isAry && ary < args.length) {\n          args.length = ary;\n        }\n        if (this && this !== root && this instanceof wrapper) {\n          fn = Ctor || createCtorWrapper(fn);\n        }\n        return fn.apply(thisBinding, args);\n      }\n      return wrapper;\n    }\n\n    /**\n     * Creates a function like `_.over`.\n     *\n     * @private\n     * @param {Function} arrayFunc The function to iterate over iteratees.\n     * @returns {Function} Returns the new invoker function.\n     */\n    function createOver(arrayFunc) {\n      return rest(function(iteratees) {\n        iteratees = arrayMap(baseFlatten(iteratees), getIteratee());\n        return rest(function(args) {\n          var thisArg = this;\n          return arrayFunc(iteratees, function(iteratee) {\n            return apply(iteratee, thisArg, args);\n          });\n        });\n      });\n    }\n\n    /**\n     * Creates the padding for `string` based on `length`. The `chars` string\n     * is truncated if the number of characters exceeds `length`.\n     *\n     * @private\n     * @param {string} string The string to create padding for.\n     * @param {number} [length=0] The padding length.\n     * @param {string} [chars=' '] The string used as padding.\n     * @returns {string} Returns the padding for `string`.\n     */\n    function createPadding(string, length, chars) {\n      length = toInteger(length);\n\n      var strLength = stringSize(string);\n      if (!length || strLength >= length) {\n        return '';\n      }\n      var padLength = length - strLength;\n      chars = chars === undefined ? ' ' : (chars + '');\n\n      var result = repeat(chars, nativeCeil(padLength / stringSize(chars)));\n      return reHasComplexSymbol.test(chars)\n        ? stringToArray(result).slice(0, padLength).join('')\n        : result.slice(0, padLength);\n    }\n\n    /**\n     * Creates a function that wraps `func` to invoke it with the optional `this`\n     * binding of `thisArg` and the `partials` prepended to those provided to\n     * the wrapper.\n     *\n     * @private\n     * @param {Function} func The function to wrap.\n     * @param {number} bitmask The bitmask of wrapper flags. See `createWrapper` for more details.\n     * @param {*} thisArg The `this` binding of `func`.\n     * @param {Array} partials The arguments to prepend to those provided to the new function.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createPartialWrapper(func, bitmask, thisArg, partials) {\n      var isBind = bitmask & BIND_FLAG,\n          Ctor = createCtorWrapper(func);\n\n      function wrapper() {\n        var argsIndex = -1,\n            argsLength = arguments.length,\n            leftIndex = -1,\n            leftLength = partials.length,\n            args = Array(leftLength + argsLength),\n            fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;\n\n        while (++leftIndex < leftLength) {\n          args[leftIndex] = partials[leftIndex];\n        }\n        while (argsLength--) {\n          args[leftIndex++] = arguments[++argsIndex];\n        }\n        return apply(fn, isBind ? thisArg : this, args);\n      }\n      return wrapper;\n    }\n\n    /**\n     * Creates a `_.range` or `_.rangeRight` function.\n     *\n     * @private\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Function} Returns the new range function.\n     */\n    function createRange(fromRight) {\n      return function(start, end, step) {\n        if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {\n          end = step = undefined;\n        }\n        // Ensure the sign of `-0` is preserved.\n        start = toNumber(start);\n        start = start === start ? start : 0;\n        if (end === undefined) {\n          end = start;\n          start = 0;\n        } else {\n          end = toNumber(end) || 0;\n        }\n        step = step === undefined ? (start < end ? 1 : -1) : (toNumber(step) || 0);\n        return baseRange(start, end, step, fromRight);\n      };\n    }\n\n    /**\n     * Creates a function that wraps `func` to continue currying.\n     *\n     * @private\n     * @param {Function} func The function to wrap.\n     * @param {number} bitmask The bitmask of wrapper flags. See `createWrapper` for more details.\n     * @param {Function} wrapFunc The function to create the `func` wrapper.\n     * @param {*} placeholder The placeholder to replace.\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @param {Array} [partials] The arguments to prepend to those provided to the new function.\n     * @param {Array} [holders] The `partials` placeholder indexes.\n     * @param {Array} [argPos] The argument positions of the new function.\n     * @param {number} [ary] The arity cap of `func`.\n     * @param {number} [arity] The arity of `func`.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createRecurryWrapper(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {\n      var isCurry = bitmask & CURRY_FLAG,\n          newArgPos = argPos ? copyArray(argPos) : undefined,\n          newsHolders = isCurry ? holders : undefined,\n          newHoldersRight = isCurry ? undefined : holders,\n          newPartials = isCurry ? partials : undefined,\n          newPartialsRight = isCurry ? undefined : partials;\n\n      bitmask |= (isCurry ? PARTIAL_FLAG : PARTIAL_RIGHT_FLAG);\n      bitmask &= ~(isCurry ? PARTIAL_RIGHT_FLAG : PARTIAL_FLAG);\n\n      if (!(bitmask & CURRY_BOUND_FLAG)) {\n        bitmask &= ~(BIND_FLAG | BIND_KEY_FLAG);\n      }\n      var newData = [func, bitmask, thisArg, newPartials, newsHolders, newPartialsRight, newHoldersRight, newArgPos, ary, arity],\n          result = wrapFunc.apply(undefined, newData);\n\n      if (isLaziable(func)) {\n        setData(result, newData);\n      }\n      result.placeholder = placeholder;\n      return result;\n    }\n\n    /**\n     * Creates a function like `_.round`.\n     *\n     * @private\n     * @param {string} methodName The name of the `Math` method to use when rounding.\n     * @returns {Function} Returns the new round function.\n     */\n    function createRound(methodName) {\n      var func = Math[methodName];\n      return function(number, precision) {\n        number = toNumber(number);\n        precision = toInteger(precision);\n        if (precision) {\n          // Shift with exponential notation to avoid floating-point issues.\n          // See [MDN](https://mdn.io/round#Examples) for more details.\n          var pair = (toString(number) + 'e').split('e'),\n              value = func(pair[0] + 'e' + (+pair[1] + precision));\n\n          pair = (toString(value) + 'e').split('e');\n          return +(pair[0] + 'e' + (+pair[1] - precision));\n        }\n        return func(number);\n      };\n    }\n\n    /**\n     * Creates a set of `values`.\n     *\n     * @private\n     * @param {Array} values The values to add to the set.\n     * @returns {Object} Returns the new set.\n     */\n    var createSet = !(Set && new Set([1, 2]).size === 2) ? noop : function(values) {\n      return new Set(values);\n    };\n\n    /**\n     * Creates a function that either curries or invokes `func` with optional\n     * `this` binding and partially applied arguments.\n     *\n     * @private\n     * @param {Function|string} func The function or method name to wrap.\n     * @param {number} bitmask The bitmask of wrapper flags.\n     *  The bitmask may be composed of the following flags:\n     *     1 - `_.bind`\n     *     2 - `_.bindKey`\n     *     4 - `_.curry` or `_.curryRight` of a bound function\n     *     8 - `_.curry`\n     *    16 - `_.curryRight`\n     *    32 - `_.partial`\n     *    64 - `_.partialRight`\n     *   128 - `_.rearg`\n     *   256 - `_.ary`\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @param {Array} [partials] The arguments to be partially applied.\n     * @param {Array} [holders] The `partials` placeholder indexes.\n     * @param {Array} [argPos] The argument positions of the new function.\n     * @param {number} [ary] The arity cap of `func`.\n     * @param {number} [arity] The arity of `func`.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createWrapper(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {\n      var isBindKey = bitmask & BIND_KEY_FLAG;\n      if (!isBindKey && typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      var length = partials ? partials.length : 0;\n      if (!length) {\n        bitmask &= ~(PARTIAL_FLAG | PARTIAL_RIGHT_FLAG);\n        partials = holders = undefined;\n      }\n      ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0);\n      arity = arity === undefined ? arity : toInteger(arity);\n      length -= holders ? holders.length : 0;\n\n      if (bitmask & PARTIAL_RIGHT_FLAG) {\n        var partialsRight = partials,\n            holdersRight = holders;\n\n        partials = holders = undefined;\n      }\n      var data = isBindKey ? undefined : getData(func),\n          newData = [func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity];\n\n      if (data) {\n        mergeData(newData, data);\n      }\n      func = newData[0];\n      bitmask = newData[1];\n      thisArg = newData[2];\n      partials = newData[3];\n      holders = newData[4];\n      arity = newData[9] = newData[9] == null\n        ? (isBindKey ? 0 : func.length)\n        : nativeMax(newData[9] - length, 0);\n\n      if (!arity && bitmask & (CURRY_FLAG | CURRY_RIGHT_FLAG)) {\n        bitmask &= ~(CURRY_FLAG | CURRY_RIGHT_FLAG);\n      }\n      if (!bitmask || bitmask == BIND_FLAG) {\n        var result = createBaseWrapper(func, bitmask, thisArg);\n      } else if (bitmask == CURRY_FLAG || bitmask == CURRY_RIGHT_FLAG) {\n        result = createCurryWrapper(func, bitmask, arity);\n      } else if ((bitmask == PARTIAL_FLAG || bitmask == (BIND_FLAG | PARTIAL_FLAG)) && !holders.length) {\n        result = createPartialWrapper(func, bitmask, thisArg, partials);\n      } else {\n        result = createHybridWrapper.apply(undefined, newData);\n      }\n      var setter = data ? baseSetData : setData;\n      return setter(result, newData);\n    }\n\n    /**\n     * A specialized version of `baseIsEqualDeep` for arrays with support for\n     * partial deep comparisons.\n     *\n     * @private\n     * @param {Array} array The array to compare.\n     * @param {Array} other The other array to compare.\n     * @param {Function} equalFunc The function to determine equivalents of values.\n     * @param {Function} [customizer] The function to customize comparisons.\n     * @param {number} [bitmask] The bitmask of comparison flags. See `baseIsEqual` for more details.\n     * @param {Object} [stack] Tracks traversed `array` and `other` objects.\n     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n     */\n    function equalArrays(array, other, equalFunc, customizer, bitmask, stack) {\n      var index = -1,\n          isPartial = bitmask & PARTIAL_COMPARE_FLAG,\n          isUnordered = bitmask & UNORDERED_COMPARE_FLAG,\n          arrLength = array.length,\n          othLength = other.length;\n\n      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n        return false;\n      }\n      // Assume cyclic values are equal.\n      var stacked = stack.get(array);\n      if (stacked) {\n        return stacked == other;\n      }\n      var result = true;\n      stack.set(array, other);\n\n      // Ignore non-index properties.\n      while (++index < arrLength) {\n        var arrValue = array[index],\n            othValue = other[index];\n\n        if (customizer) {\n          var compared = isPartial\n            ? customizer(othValue, arrValue, index, other, array, stack)\n            : customizer(arrValue, othValue, index, array, other, stack);\n        }\n        if (compared !== undefined) {\n          if (compared) {\n            continue;\n          }\n          result = false;\n          break;\n        }\n        // Recursively compare arrays (susceptible to call stack limits).\n        if (isUnordered) {\n          if (!arraySome(other, function(othValue) {\n                return arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack);\n              })) {\n            result = false;\n            break;\n          }\n        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {\n          result = false;\n          break;\n        }\n      }\n      stack['delete'](array);\n      return result;\n    }\n\n    /**\n     * A specialized version of `baseIsEqualDeep` for comparing objects of\n     * the same `toStringTag`.\n     *\n     * **Note:** This function only supports comparing values with tags of\n     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n     *\n     * @private\n     * @param {Object} object The object to compare.\n     * @param {Object} other The other object to compare.\n     * @param {string} tag The `toStringTag` of the objects to compare.\n     * @param {Function} equalFunc The function to determine equivalents of values.\n     * @param {Function} [customizer] The function to customize comparisons.\n     * @param {number} [bitmask] The bitmask of comparison flags. See `baseIsEqual` for more details.\n     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n     */\n    function equalByTag(object, other, tag, equalFunc, customizer, bitmask) {\n      switch (tag) {\n        case arrayBufferTag:\n          if ((object.byteLength != other.byteLength) ||\n              !equalFunc(new Uint8Array(object), new Uint8Array(other))) {\n            return false;\n          }\n          return true;\n\n        case boolTag:\n        case dateTag:\n          // Coerce dates and booleans to numbers, dates to milliseconds and booleans\n          // to `1` or `0` treating invalid dates coerced to `NaN` as not equal.\n          return +object == +other;\n\n        case errorTag:\n          return object.name == other.name && object.message == other.message;\n\n        case numberTag:\n          // Treat `NaN` vs. `NaN` as equal.\n          return (object != +object) ? other != +other : object == +other;\n\n        case regexpTag:\n        case stringTag:\n          // Coerce regexes to strings and treat strings primitives and string\n          // objects as equal. See https://es5.github.io/#x15.10.6.4 for more details.\n          return object == (other + '');\n\n        case mapTag:\n          var convert = mapToArray;\n\n        case setTag:\n          var isPartial = bitmask & PARTIAL_COMPARE_FLAG;\n          convert || (convert = setToArray);\n\n          // Recursively compare objects (susceptible to call stack limits).\n          return (isPartial || object.size == other.size) &&\n            equalFunc(convert(object), convert(other), customizer, bitmask | UNORDERED_COMPARE_FLAG);\n\n        case symbolTag:\n          return !!_Symbol && (symbolValueOf.call(object) == symbolValueOf.call(other));\n      }\n      return false;\n    }\n\n    /**\n     * A specialized version of `baseIsEqualDeep` for objects with support for\n     * partial deep comparisons.\n     *\n     * @private\n     * @param {Object} object The object to compare.\n     * @param {Object} other The other object to compare.\n     * @param {Function} equalFunc The function to determine equivalents of values.\n     * @param {Function} [customizer] The function to customize comparisons.\n     * @param {number} [bitmask] The bitmask of comparison flags. See `baseIsEqual` for more details.\n     * @param {Object} [stack] Tracks traversed `object` and `other` objects.\n     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n     */\n    function equalObjects(object, other, equalFunc, customizer, bitmask, stack) {\n      var isPartial = bitmask & PARTIAL_COMPARE_FLAG,\n          isUnordered = bitmask & UNORDERED_COMPARE_FLAG,\n          objProps = keys(object),\n          objLength = objProps.length,\n          othProps = keys(other),\n          othLength = othProps.length;\n\n      if (objLength != othLength && !isPartial) {\n        return false;\n      }\n      var index = objLength;\n      while (index--) {\n        var key = objProps[index];\n        if (!(isPartial ? key in other : baseHas(other, key)) ||\n            !(isUnordered || key == othProps[index])) {\n          return false;\n        }\n      }\n      // Assume cyclic values are equal.\n      var stacked = stack.get(object);\n      if (stacked) {\n        return stacked == other;\n      }\n      var result = true;\n      stack.set(object, other);\n\n      var skipCtor = isPartial;\n      while (++index < objLength) {\n        key = objProps[index];\n        var objValue = object[key],\n            othValue = other[key];\n\n        if (customizer) {\n          var compared = isPartial\n            ? customizer(othValue, objValue, key, other, object, stack)\n            : customizer(objValue, othValue, key, object, other, stack);\n        }\n        // Recursively compare objects (susceptible to call stack limits).\n        if (!(compared === undefined\n              ? (objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack))\n              : compared\n            )) {\n          result = false;\n          break;\n        }\n        skipCtor || (skipCtor = key == 'constructor');\n      }\n      if (result && !skipCtor) {\n        var objCtor = object.constructor,\n            othCtor = other.constructor;\n\n        // Non `Object` object instances with different constructors are not equal.\n        if (objCtor != othCtor &&\n            ('constructor' in object && 'constructor' in other) &&\n            !(typeof objCtor == 'function' && objCtor instanceof objCtor &&\n              typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n          result = false;\n        }\n      }\n      stack['delete'](object);\n      return result;\n    }\n\n    /**\n     * Gets metadata for `func`.\n     *\n     * @private\n     * @param {Function} func The function to query.\n     * @returns {*} Returns the metadata for `func`.\n     */\n    var getData = !metaMap ? noop : function(func) {\n      return metaMap.get(func);\n    };\n\n    /**\n     * Gets the name of `func`.\n     *\n     * @private\n     * @param {Function} func The function to query.\n     * @returns {string} Returns the function name.\n     */\n    function getFuncName(func) {\n      var result = (func.name + ''),\n          array = realNames[result],\n          length = array ? array.length : 0;\n\n      while (length--) {\n        var data = array[length],\n            otherFunc = data.func;\n        if (otherFunc == null || otherFunc == func) {\n          return data.name;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Gets the appropriate \"iteratee\" function. If the `_.iteratee` method is\n     * customized this function returns the custom method, otherwise it returns\n     * `baseIteratee`. If arguments are provided the chosen function is invoked\n     * with them and its result is returned.\n     *\n     * @private\n     * @param {*} [value] The value to convert to an iteratee.\n     * @param {number} [arity] The arity of the created iteratee.\n     * @returns {Function} Returns the chosen function or its result.\n     */\n    function getIteratee() {\n      var result = lodash.iteratee || iteratee;\n      result = result === iteratee ? baseIteratee : result;\n      return arguments.length ? result(arguments[0], arguments[1]) : result;\n    }\n\n    /**\n     * Gets the \"length\" property value of `object`.\n     *\n     * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)\n     * that affects Safari on at least iOS 8.1-8.3 ARM64.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {*} Returns the \"length\" value.\n     */\n    var getLength = baseProperty('length');\n\n    /**\n     * Gets the property names, values, and compare flags of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the match data of `object`.\n     */\n    function getMatchData(object) {\n      var result = toPairs(object),\n          length = result.length;\n\n      while (length--) {\n        result[length][2] = isStrictComparable(result[length][1]);\n      }\n      return result;\n    }\n\n    /**\n     * Gets the native function at `key` of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {string} key The key of the method to get.\n     * @returns {*} Returns the function if it's native, else `undefined`.\n     */\n    function getNative(object, key) {\n      var value = object == null ? undefined : object[key];\n      return isNative(value) ? value : undefined;\n    }\n\n    /**\n     * Creates an array of the own symbol properties of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of symbols.\n     */\n    var getSymbols = getOwnPropertySymbols || function() {\n      return [];\n    };\n\n    /**\n     * Gets the `toStringTag` of `value`.\n     *\n     * @private\n     * @param {*} value The value to query.\n     * @returns {string} Returns the `toStringTag`.\n     */\n    function getTag(value) {\n      return objectToString.call(value);\n    }\n\n    // Fallback for IE 11 providing `toStringTag` values for maps and sets.\n    if ((Map && getTag(new Map) != mapTag) || (Set && getTag(new Set) != setTag)) {\n      getTag = function(value) {\n        var result = objectToString.call(value),\n            Ctor = result == objectTag ? value.constructor : null,\n            ctorString = typeof Ctor == 'function' ? funcToString.call(Ctor) : '';\n\n        if (ctorString) {\n          if (ctorString == mapCtorString) {\n            return mapTag;\n          }\n          if (ctorString == setCtorString) {\n            return setTag;\n          }\n        }\n        return result;\n      };\n    }\n\n    /**\n     * Gets the view, applying any `transforms` to the `start` and `end` positions.\n     *\n     * @private\n     * @param {number} start The start of the view.\n     * @param {number} end The end of the view.\n     * @param {Array} transforms The transformations to apply to the view.\n     * @returns {Object} Returns an object containing the `start` and `end`\n     *  positions of the view.\n     */\n    function getView(start, end, transforms) {\n      var index = -1,\n          length = transforms.length;\n\n      while (++index < length) {\n        var data = transforms[index],\n            size = data.size;\n\n        switch (data.type) {\n          case 'drop':      start += size; break;\n          case 'dropRight': end -= size; break;\n          case 'take':      end = nativeMin(end, start + size); break;\n          case 'takeRight': start = nativeMax(start, end - size); break;\n        }\n      }\n      return { 'start': start, 'end': end };\n    }\n\n    /**\n     * Checks if `path` exists on `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path to check.\n     * @param {Function} hasFunc The function to check properties.\n     * @returns {boolean} Returns `true` if `path` exists, else `false`.\n     */\n    function hasPath(object, path, hasFunc) {\n      if (object == null) {\n        return false;\n      }\n      var result = hasFunc(object, path);\n      if (!result && !isKey(path)) {\n        path = baseToPath(path);\n        object = parent(object, path);\n        if (object != null) {\n          path = last(path);\n          result = hasFunc(object, path);\n        }\n      }\n      return result || (isLength(object && object.length) && isIndex(path, object.length) &&\n        (isArray(object) || isString(object) || isArguments(object)));\n    }\n\n    /**\n     * Initializes an array clone.\n     *\n     * @private\n     * @param {Array} array The array to clone.\n     * @returns {Array} Returns the initialized clone.\n     */\n    function initCloneArray(array) {\n      var length = array.length,\n          result = array.constructor(length);\n\n      // Add properties assigned by `RegExp#exec`.\n      if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {\n        result.index = array.index;\n        result.input = array.input;\n      }\n      return result;\n    }\n\n    /**\n     * Initializes an object clone.\n     *\n     * @private\n     * @param {Object} object The object to clone.\n     * @returns {Object} Returns the initialized clone.\n     */\n    function initCloneObject(object) {\n      var Ctor = object.constructor;\n      return baseCreate(isFunction(Ctor) ? Ctor.prototype : undefined);\n    }\n\n    /**\n     * Initializes an object clone based on its `toStringTag`.\n     *\n     * **Note:** This function only supports cloning values with tags of\n     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n     *\n     * @private\n     * @param {Object} object The object to clone.\n     * @param {string} tag The `toStringTag` of the object to clone.\n     * @param {boolean} [isDeep] Specify a deep clone.\n     * @returns {Object} Returns the initialized clone.\n     */\n    function initCloneByTag(object, tag, isDeep) {\n      var Ctor = object.constructor;\n      switch (tag) {\n        case arrayBufferTag:\n          return cloneBuffer(object);\n\n        case boolTag:\n        case dateTag:\n          return new Ctor(+object);\n\n        case float32Tag: case float64Tag:\n        case int8Tag: case int16Tag: case int32Tag:\n        case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:\n          return cloneTypedArray(object, isDeep);\n\n        case mapTag:\n          return cloneMap(object);\n\n        case numberTag:\n        case stringTag:\n          return new Ctor(object);\n\n        case regexpTag:\n          return cloneRegExp(object);\n\n        case setTag:\n          return cloneSet(object);\n\n        case symbolTag:\n          return cloneSymbol(object);\n      }\n    }\n\n    /**\n     * Creates an array of index keys for `object` values of arrays,\n     * `arguments` objects, and strings, otherwise `null` is returned.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array|null} Returns index keys, else `null`.\n     */\n    function indexKeys(object) {\n      var length = object ? object.length : undefined;\n      return (isLength(length) && (isArray(object) || isString(object) || isArguments(object)))\n        ? baseTimes(length, String)\n        : null;\n    }\n\n    /**\n     * Checks if the provided arguments are from an iteratee call.\n     *\n     * @private\n     * @param {*} value The potential iteratee value argument.\n     * @param {*} index The potential iteratee index or key argument.\n     * @param {*} object The potential iteratee object argument.\n     * @returns {boolean} Returns `true` if the arguments are from an iteratee call, else `false`.\n     */\n    function isIterateeCall(value, index, object) {\n      if (!isObject(object)) {\n        return false;\n      }\n      var type = typeof index;\n      if (type == 'number'\n          ? (isArrayLike(object) && isIndex(index, object.length))\n          : (type == 'string' && index in object)) {\n        return eq(object[index], value);\n      }\n      return false;\n    }\n\n    /**\n     * Checks if `value` is a property name and not a property path.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @param {Object} [object] The object to query keys on.\n     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n     */\n    function isKey(value, object) {\n      if (typeof value == 'number') {\n        return true;\n      }\n      return !isArray(value) &&\n        (reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n          (object != null && value in Object(object)));\n    }\n\n    /**\n     * Checks if `value` is suitable for use as unique object key.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n     */\n    function isKeyable(value) {\n      var type = typeof value;\n      return type == 'number' || type == 'boolean' ||\n        (type == 'string' && value !== '__proto__') || value == null;\n    }\n\n    /**\n     * Checks if `func` has a lazy counterpart.\n     *\n     * @private\n     * @param {Function} func The function to check.\n     * @returns {boolean} Returns `true` if `func` has a lazy counterpart, else `false`.\n     */\n    function isLaziable(func) {\n      var funcName = getFuncName(func),\n          other = lodash[funcName];\n\n      if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {\n        return false;\n      }\n      if (func === other) {\n        return true;\n      }\n      var data = getData(other);\n      return !!data && func === data[0];\n    }\n\n    /**\n     * Checks if `value` is likely a prototype object.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n     */\n    function isPrototype(value) {\n      var Ctor = value && value.constructor,\n          proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n      return value === proto;\n    }\n\n    /**\n     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` if suitable for strict\n     *  equality comparisons, else `false`.\n     */\n    function isStrictComparable(value) {\n      return value === value && !isObject(value);\n    }\n\n    /**\n     * Merges the function metadata of `source` into `data`.\n     *\n     * Merging metadata reduces the number of wrappers used to invoke a function.\n     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`\n     * may be applied regardless of execution order. Methods like `_.ary` and `_.rearg`\n     * modify function arguments, making the order in which they are executed important,\n     * preventing the merging of metadata. However, we make an exception for a safe\n     * combined case where curried functions have `_.ary` and or `_.rearg` applied.\n     *\n     * @private\n     * @param {Array} data The destination metadata.\n     * @param {Array} source The source metadata.\n     * @returns {Array} Returns `data`.\n     */\n    function mergeData(data, source) {\n      var bitmask = data[1],\n          srcBitmask = source[1],\n          newBitmask = bitmask | srcBitmask,\n          isCommon = newBitmask < (BIND_FLAG | BIND_KEY_FLAG | ARY_FLAG);\n\n      var isCombo =\n        (srcBitmask == ARY_FLAG && (bitmask == CURRY_FLAG)) ||\n        (srcBitmask == ARY_FLAG && (bitmask == REARG_FLAG) && (data[7].length <= source[8])) ||\n        (srcBitmask == (ARY_FLAG | REARG_FLAG) && (source[7].length <= source[8]) && (bitmask == CURRY_FLAG));\n\n      // Exit early if metadata can't be merged.\n      if (!(isCommon || isCombo)) {\n        return data;\n      }\n      // Use source `thisArg` if available.\n      if (srcBitmask & BIND_FLAG) {\n        data[2] = source[2];\n        // Set when currying a bound function.\n        newBitmask |= (bitmask & BIND_FLAG) ? 0 : CURRY_BOUND_FLAG;\n      }\n      // Compose partial arguments.\n      var value = source[3];\n      if (value) {\n        var partials = data[3];\n        data[3] = partials ? composeArgs(partials, value, source[4]) : copyArray(value);\n        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : copyArray(source[4]);\n      }\n      // Compose partial right arguments.\n      value = source[5];\n      if (value) {\n        partials = data[5];\n        data[5] = partials ? composeArgsRight(partials, value, source[6]) : copyArray(value);\n        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : copyArray(source[6]);\n      }\n      // Use source `argPos` if available.\n      value = source[7];\n      if (value) {\n        data[7] = copyArray(value);\n      }\n      // Use source `ary` if it's smaller.\n      if (srcBitmask & ARY_FLAG) {\n        data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);\n      }\n      // Use source `arity` if one is not provided.\n      if (data[9] == null) {\n        data[9] = source[9];\n      }\n      // Use source `func` and merge bitmasks.\n      data[0] = source[0];\n      data[1] = newBitmask;\n\n      return data;\n    }\n\n    /**\n     * Used by `_.defaultsDeep` to customize its `_.merge` use.\n     *\n     * @private\n     * @param {*} objValue The destination value.\n     * @param {*} srcValue The source value.\n     * @param {string} key The key of the property to merge.\n     * @param {Object} object The parent object of `objValue`.\n     * @param {Object} source The parent object of `srcValue`.\n     * @param {Object} [stack] Tracks traversed source values and their merged counterparts.\n     * @returns {*} Returns the value to assign.\n     */\n    function mergeDefaults(objValue, srcValue, key, object, source, stack) {\n      if (isObject(objValue) && isObject(srcValue)) {\n        stack.set(srcValue, objValue);\n        baseMerge(objValue, srcValue, mergeDefaults, stack);\n      }\n      return objValue === undefined ? baseClone(srcValue) : objValue;\n    }\n\n    /**\n     * Gets the parent value at `path` of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Array} path The path to get the parent value of.\n     * @returns {*} Returns the parent value.\n     */\n    function parent(object, path) {\n      return path.length == 1 ? object : get(object, baseSlice(path, 0, -1));\n    }\n\n    /**\n     * Reorder `array` according to the specified indexes where the element at\n     * the first index is assigned as the first element, the element at\n     * the second index is assigned as the second element, and so on.\n     *\n     * @private\n     * @param {Array} array The array to reorder.\n     * @param {Array} indexes The arranged array indexes.\n     * @returns {Array} Returns `array`.\n     */\n    function reorder(array, indexes) {\n      var arrLength = array.length,\n          length = nativeMin(indexes.length, arrLength),\n          oldArray = copyArray(array);\n\n      while (length--) {\n        var index = indexes[length];\n        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;\n      }\n      return array;\n    }\n\n    /**\n     * Sets metadata for `func`.\n     *\n     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short\n     * period of time, it will trip its breaker and transition to an identity function\n     * to avoid garbage collection pauses in V8. See [V8 issue 2070](https://code.google.com/p/v8/issues/detail?id=2070)\n     * for more details.\n     *\n     * @private\n     * @param {Function} func The function to associate metadata with.\n     * @param {*} data The metadata.\n     * @returns {Function} Returns `func`.\n     */\n    var setData = (function() {\n      var count = 0,\n          lastCalled = 0;\n\n      return function(key, value) {\n        var stamp = now(),\n            remaining = HOT_SPAN - (stamp - lastCalled);\n\n        lastCalled = stamp;\n        if (remaining > 0) {\n          if (++count >= HOT_COUNT) {\n            return key;\n          }\n        } else {\n          count = 0;\n        }\n        return baseSetData(key, value);\n      };\n    }());\n\n    /**\n     * Converts `string` to a property path array.\n     *\n     * @private\n     * @param {string} string The string to convert.\n     * @returns {Array} Returns the property path array.\n     */\n    function stringToPath(string) {\n      var result = [];\n      toString(string).replace(rePropName, function(match, number, quote, string) {\n        result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));\n      });\n      return result;\n    }\n\n    /**\n     * Converts `value` to an array-like object if it's not one.\n     *\n     * @private\n     * @param {*} value The value to process.\n     * @returns {Array} Returns the array-like object.\n     */\n    function toArrayLikeObject(value) {\n      return isArrayLikeObject(value) ? value : [];\n    }\n\n    /**\n     * Converts `value` to a function if it's not one.\n     *\n     * @private\n     * @param {*} value The value to process.\n     * @returns {Function} Returns the function.\n     */\n    function toFunction(value) {\n      return typeof value == 'function' ? value : identity;\n    }\n\n    /**\n     * Creates a clone of `wrapper`.\n     *\n     * @private\n     * @param {Object} wrapper The wrapper to clone.\n     * @returns {Object} Returns the cloned wrapper.\n     */\n    function wrapperClone(wrapper) {\n      if (wrapper instanceof LazyWrapper) {\n        return wrapper.clone();\n      }\n      var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);\n      result.__actions__ = copyArray(wrapper.__actions__);\n      result.__index__  = wrapper.__index__;\n      result.__values__ = wrapper.__values__;\n      return result;\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates an array of elements split into groups the length of `size`.\n     * If `array` can't be split evenly, the final chunk will be the remaining\n     * elements.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to process.\n     * @param {number} [size=0] The length of each chunk.\n     * @returns {Array} Returns the new array containing chunks.\n     * @example\n     *\n     * _.chunk(['a', 'b', 'c', 'd'], 2);\n     * // => [['a', 'b'], ['c', 'd']]\n     *\n     * _.chunk(['a', 'b', 'c', 'd'], 3);\n     * // => [['a', 'b', 'c'], ['d']]\n     */\n    function chunk(array, size) {\n      size = nativeMax(toInteger(size), 0);\n\n      var length = array ? array.length : 0;\n      if (!length || size < 1) {\n        return [];\n      }\n      var index = 0,\n          resIndex = -1,\n          result = Array(nativeCeil(length / size));\n\n      while (index < length) {\n        result[++resIndex] = baseSlice(array, index, (index += size));\n      }\n      return result;\n    }\n\n    /**\n     * Creates an array with all falsey values removed. The values `false`, `null`,\n     * `0`, `\"\"`, `undefined`, and `NaN` are falsey.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to compact.\n     * @returns {Array} Returns the new array of filtered values.\n     * @example\n     *\n     * _.compact([0, 1, false, 2, '', 3]);\n     * // => [1, 2, 3]\n     */\n    function compact(array) {\n      var index = -1,\n          length = array ? array.length : 0,\n          resIndex = -1,\n          result = [];\n\n      while (++index < length) {\n        var value = array[index];\n        if (value) {\n          result[++resIndex] = value;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Creates a new array concatenating `array` with any additional arrays\n     * and/or values.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to concatenate.\n     * @param {...*} [values] The values to concatenate.\n     * @returns {Array} Returns the new concatenated array.\n     * @example\n     *\n     * var array = [1];\n     * var other = _.concat(array, 2, [3], [[4]]);\n     *\n     * console.log(other);\n     * // => [1, 2, 3, [4]]\n     *\n     * console.log(array);\n     * // => [1]\n     */\n    var concat = rest(function(array, values) {\n      values = baseFlatten(values);\n      return arrayConcat(isArray(array) ? array : [Object(array)], values);\n    });\n\n    /**\n     * Creates an array of unique `array` values not included in the other\n     * provided arrays using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)\n     * for equality comparisons.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {...Array} [values] The values to exclude.\n     * @returns {Array} Returns the new array of filtered values.\n     * @example\n     *\n     * _.difference([3, 2, 1], [4, 2]);\n     * // => [3, 1]\n     */\n    var difference = rest(function(array, values) {\n      return isArrayLikeObject(array)\n        ? baseDifference(array, baseFlatten(values, false, true))\n        : [];\n    });\n\n    /**\n     * This method is like `_.difference` except that it accepts `iteratee` which\n     * is invoked for each element of `array` and `values` to generate the criterion\n     * by which uniqueness is computed. The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {...Array} [values] The values to exclude.\n     * @param {Function|Object|string} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Array} Returns the new array of filtered values.\n     * @example\n     *\n     * _.differenceBy([3.1, 2.2, 1.3], [4.4, 2.5], Math.floor);\n     * // => [3.1, 1.3]\n     *\n     * // using the `_.property` iteratee shorthand\n     * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');\n     * // => [{ 'x': 2 }]\n     */\n    var differenceBy = rest(function(array, values) {\n      var iteratee = last(values);\n      if (isArrayLikeObject(iteratee)) {\n        iteratee = undefined;\n      }\n      return isArrayLikeObject(array)\n        ? baseDifference(array, baseFlatten(values, false, true), getIteratee(iteratee))\n        : [];\n    });\n\n    /**\n     * This method is like `_.difference` except that it accepts `comparator`\n     * which is invoked to compare elements of `array` to `values`. The comparator\n     * is invoked with two arguments: (arrVal, othVal).\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {...Array} [values] The values to exclude.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of filtered values.\n     * @example\n     *\n     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\n     *\n     * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);\n     * // => [{ 'x': 2, 'y': 1 }]\n     */\n    var differenceWith = rest(function(array, values) {\n      var comparator = last(values);\n      if (isArrayLikeObject(comparator)) {\n        comparator = undefined;\n      }\n      return isArrayLikeObject(array)\n        ? baseDifference(array, baseFlatten(values, false, true), undefined, comparator)\n        : [];\n    });\n\n    /**\n     * Creates a slice of `array` with `n` elements dropped from the beginning.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {number} [n=1] The number of elements to drop.\n     * @param- {Object} [guard] Enables use as an iteratee for functions like `_.map`.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.drop([1, 2, 3]);\n     * // => [2, 3]\n     *\n     * _.drop([1, 2, 3], 2);\n     * // => [3]\n     *\n     * _.drop([1, 2, 3], 5);\n     * // => []\n     *\n     * _.drop([1, 2, 3], 0);\n     * // => [1, 2, 3]\n     */\n    function drop(array, n, guard) {\n      var length = array ? array.length : 0;\n      if (!length) {\n        return [];\n      }\n      n = (guard || n === undefined) ? 1 : toInteger(n);\n      return baseSlice(array, n < 0 ? 0 : n, length);\n    }\n\n    /**\n     * Creates a slice of `array` with `n` elements dropped from the end.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {number} [n=1] The number of elements to drop.\n     * @param- {Object} [guard] Enables use as an iteratee for functions like `_.map`.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.dropRight([1, 2, 3]);\n     * // => [1, 2]\n     *\n     * _.dropRight([1, 2, 3], 2);\n     * // => [1]\n     *\n     * _.dropRight([1, 2, 3], 5);\n     * // => []\n     *\n     * _.dropRight([1, 2, 3], 0);\n     * // => [1, 2, 3]\n     */\n    function dropRight(array, n, guard) {\n      var length = array ? array.length : 0;\n      if (!length) {\n        return [];\n      }\n      n = (guard || n === undefined) ? 1 : toInteger(n);\n      n = length - n;\n      return baseSlice(array, 0, n < 0 ? 0 : n);\n    }\n\n    /**\n     * Creates a slice of `array` excluding elements dropped from the end.\n     * Elements are dropped until `predicate` returns falsey. The predicate is\n     * invoked with three arguments: (value, index, array).\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {Function|Object|string} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': true },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': false }\n     * ];\n     *\n     * _.dropRightWhile(users, function(o) { return !o.active; });\n     * // => objects for ['barney']\n     *\n     * // using the `_.matches` iteratee shorthand\n     * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });\n     * // => objects for ['barney', 'fred']\n     *\n     * // using the `_.matchesProperty` iteratee shorthand\n     * _.dropRightWhile(users, ['active', false]);\n     * // => objects for ['barney']\n     *\n     * // using the `_.property` iteratee shorthand\n     * _.dropRightWhile(users, 'active');\n     * // => objects for ['barney', 'fred', 'pebbles']\n     */\n    function dropRightWhile(array, predicate) {\n      return (array && array.length)\n        ? baseWhile(array, getIteratee(predicate, 3), true, true)\n        : [];\n    }\n\n    /**\n     * Creates a slice of `array` excluding elements dropped from the beginning.\n     * Elements are dropped until `predicate` returns falsey. The predicate is\n     * invoked with three arguments: (value, index, array).\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {Function|Object|string} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': false },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': true }\n     * ];\n     *\n     * _.dropWhile(users, function(o) { return !o.active; });\n     * // => objects for ['pebbles']\n     *\n     * // using the `_.matches` iteratee shorthand\n     * _.dropWhile(users, { 'user': 'barney', 'active': false });\n     * // => objects for ['fred', 'pebbles']\n     *\n     * // using the `_.matchesProperty` iteratee shorthand\n     * _.dropWhile(users, ['active', false]);\n     * // => objects for ['pebbles']\n     *\n     * // using the `_.property` iteratee shorthand\n     * _.dropWhile(users, 'active');\n     * // => objects for ['barney', 'fred', 'pebbles']\n     */\n    function dropWhile(array, predicate) {\n      return (array && array.length)\n        ? baseWhile(array, getIteratee(predicate, 3), true)\n        : [];\n    }\n\n    /**\n     * Fills elements of `array` with `value` from `start` up to, but not\n     * including, `end`.\n     *\n     * **Note:** This method mutates `array`.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to fill.\n     * @param {*} value The value to fill `array` with.\n     * @param {number} [start=0] The start position.\n     * @param {number} [end=array.length] The end position.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = [1, 2, 3];\n     *\n     * _.fill(array, 'a');\n     * console.log(array);\n     * // => ['a', 'a', 'a']\n     *\n     * _.fill(Array(3), 2);\n     * // => [2, 2, 2]\n     *\n     * _.fill([4, 6, 8, 10], '*', 1, 3);\n     * // => [4, '*', '*', 10]\n     */\n    function fill(array, value, start, end) {\n      var length = array ? array.length : 0;\n      if (!length) {\n        return [];\n      }\n      if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {\n        start = 0;\n        end = length;\n      }\n      return baseFill(array, value, start, end);\n    }\n\n    /**\n     * This method is like `_.find` except that it returns the index of the first\n     * element `predicate` returns truthy for instead of the element itself.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to search.\n     * @param {Function|Object|string} [predicate=_.identity] The function invoked per iteration.\n     * @returns {number} Returns the index of the found element, else `-1`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': false },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': true }\n     * ];\n     *\n     * _.findIndex(users, function(o) { return o.user == 'barney'; });\n     * // => 0\n     *\n     * // using the `_.matches` iteratee shorthand\n     * _.findIndex(users, { 'user': 'fred', 'active': false });\n     * // => 1\n     *\n     * // using the `_.matchesProperty` iteratee shorthand\n     * _.findIndex(users, ['active', false]);\n     * // => 0\n     *\n     * // using the `_.property` iteratee shorthand\n     * _.findIndex(users, 'active');\n     * // => 2\n     */\n    function findIndex(array, predicate) {\n      return (array && array.length)\n        ? baseFindIndex(array, getIteratee(predicate, 3))\n        : -1;\n    }\n\n    /**\n     * This method is like `_.findIndex` except that it iterates over elements\n     * of `collection` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to search.\n     * @param {Function|Object|string} [predicate=_.identity] The function invoked per iteration.\n     * @returns {number} Returns the index of the found element, else `-1`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': true },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': false }\n     * ];\n     *\n     * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });\n     * // => 2\n     *\n     * // using the `_.matches` iteratee shorthand\n     * _.findLastIndex(users, { 'user': 'barney', 'active': true });\n     * // => 0\n     *\n     * // using the `_.matchesProperty` iteratee shorthand\n     * _.findLastIndex(users, ['active', false]);\n     * // => 2\n     *\n     * // using the `_.property` iteratee shorthand\n     * _.findLastIndex(users, 'active');\n     * // => 0\n     */\n    function findLastIndex(array, predicate) {\n      return (array && array.length)\n        ? baseFindIndex(array, getIteratee(predicate, 3), true)\n        : -1;\n    }\n\n    /**\n     * Creates an array of flattened values by running each element in `array`\n     * through `iteratee` and concating its result to the other mapped values.\n     * The iteratee is invoked with three arguments: (value, index|key, array).\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to iterate over.\n     * @param {Function|Object|string} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the new array.\n     * @example\n     *\n     * function duplicate(n) {\n     *   return [n, n];\n     * }\n     *\n     * _.flatMap([1, 2], duplicate);\n     * // => [1, 1, 2, 2]\n     */\n    function flatMap(array, iteratee) {\n      var length = array ? array.length : 0;\n      return length ? baseFlatten(arrayMap(array, getIteratee(iteratee, 3))) : [];\n    }\n\n    /**\n     * Flattens `array` a single level.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to flatten.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * _.flatten([1, [2, 3, [4]]]);\n     * // => [1, 2, 3, [4]]\n     */\n    function flatten(array) {\n      var length = array ? array.length : 0;\n      return length ? baseFlatten(array) : [];\n    }\n\n    /**\n     * This method is like `_.flatten` except that it recursively flattens `array`.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to recursively flatten.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * _.flattenDeep([1, [2, 3, [4]]]);\n     * // => [1, 2, 3, 4]\n     */\n    function flattenDeep(array) {\n      var length = array ? array.length : 0;\n      return length ? baseFlatten(array, true) : [];\n    }\n\n    /**\n     * The inverse of `_.toPairs`; this method returns an object composed\n     * from key-value `pairs`.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} pairs The key-value pairs.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * _.fromPairs([['fred', 30], ['barney', 40]]);\n     * // => { 'fred': 30, 'barney': 40 }\n     */\n    function fromPairs(pairs) {\n      var index = -1,\n          length = pairs ? pairs.length : 0,\n          result = {};\n\n      while (++index < length) {\n        var pair = pairs[index];\n        baseSet(result, pair[0], pair[1]);\n      }\n      return result;\n    }\n\n    /**\n     * Gets the first element of `array`.\n     *\n     * @static\n     * @memberOf _\n     * @alias first\n     * @category Array\n     * @param {Array} array The array to query.\n     * @returns {*} Returns the first element of `array`.\n     * @example\n     *\n     * _.head([1, 2, 3]);\n     * // => 1\n     *\n     * _.head([]);\n     * // => undefined\n     */\n    function head(array) {\n      return array ? array[0] : undefined;\n    }\n\n    /**\n     * Gets the index at which the first occurrence of `value` is found in `array`\n     * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)\n     * for equality comparisons. If `fromIndex` is negative, it's used as the offset\n     * from the end of `array`. If `array` is sorted providing `true` for `fromIndex`\n     * performs a faster binary search.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to search.\n     * @param {*} value The value to search for.\n     * @param {number} [fromIndex=0] The index to search from.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     * @example\n     *\n     * _.indexOf([1, 2, 1, 2], 2);\n     * // => 1\n     *\n     * // using `fromIndex`\n     * _.indexOf([1, 2, 1, 2], 2, 2);\n     * // => 3\n     */\n    function indexOf(array, value, fromIndex) {\n      var length = array ? array.length : 0;\n      if (!length) {\n        return -1;\n      }\n      fromIndex = toInteger(fromIndex);\n      if (fromIndex < 0) {\n        fromIndex = nativeMax(length + fromIndex, 0);\n      }\n      return baseIndexOf(array, value, fromIndex);\n    }\n\n    /**\n     * Gets all but the last element of `array`.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to query.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.initial([1, 2, 3]);\n     * // => [1, 2]\n     */\n    function initial(array) {\n      return dropRight(array, 1);\n    }\n\n    /**\n     * Creates an array of unique values that are included in all of the provided\n     * arrays using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)\n     * for equality comparisons.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @returns {Array} Returns the new array of shared values.\n     * @example\n     * _.intersection([2, 1], [4, 2], [1, 2]);\n     * // => [2]\n     */\n    var intersection = rest(function(arrays) {\n      var mapped = arrayMap(arrays, toArrayLikeObject);\n      return (mapped.length && mapped[0] === arrays[0])\n        ? baseIntersection(mapped)\n        : [];\n    });\n\n    /**\n     * This method is like `_.intersection` except that it accepts `iteratee`\n     * which is invoked for each element of each `arrays` to generate the criterion\n     * by which uniqueness is computed. The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function|Object|string} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Array} Returns the new array of shared values.\n     * @example\n     *\n     * _.intersectionBy([2.1, 1.2], [4.3, 2.4], Math.floor);\n     * // => [2.1]\n     *\n     * // using the `_.property` iteratee shorthand\n     * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');\n     * // => [{ 'x': 1 }]\n     */\n    var intersectionBy = rest(function(arrays) {\n      var iteratee = last(arrays),\n          mapped = arrayMap(arrays, toArrayLikeObject);\n\n      if (iteratee === last(mapped)) {\n        iteratee = undefined;\n      } else {\n        mapped.pop();\n      }\n      return (mapped.length && mapped[0] === arrays[0])\n        ? baseIntersection(mapped, getIteratee(iteratee))\n        : [];\n    });\n\n    /**\n     * This method is like `_.intersection` except that it accepts `comparator`\n     * which is invoked to compare elements of `arrays`. The comparator is invoked\n     * with two arguments: (arrVal, othVal).\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of shared values.\n     * @example\n     *\n     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\n     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];\n     *\n     * _.intersectionWith(objects, others, _.isEqual);\n     * // => [{ 'x': 1, 'y': 2 }]\n     */\n    var intersectionWith = rest(function(arrays) {\n      var comparator = last(arrays),\n          mapped = arrayMap(arrays, toArrayLikeObject);\n\n      if (comparator === last(mapped)) {\n        comparator = undefined;\n      } else {\n        mapped.pop();\n      }\n      return (mapped.length && mapped[0] === arrays[0])\n        ? baseIntersection(mapped, undefined, comparator)\n        : [];\n    });\n\n    /**\n     * Converts all elements in `array` into a string separated by `separator`.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to convert.\n     * @param {string} [separator=','] The element separator.\n     * @returns {string} Returns the joined string.\n     * @example\n     *\n     * _.join(['a', 'b', 'c'], '~');\n     * // => 'a~b~c'\n     */\n    function join(array, separator) {\n      return array ? nativeJoin.call(array, separator) : '';\n    }\n\n    /**\n     * Gets the last element of `array`.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to query.\n     * @returns {*} Returns the last element of `array`.\n     * @example\n     *\n     * _.last([1, 2, 3]);\n     * // => 3\n     */\n    function last(array) {\n      var length = array ? array.length : 0;\n      return length ? array[length - 1] : undefined;\n    }\n\n    /**\n     * This method is like `_.indexOf` except that it iterates over elements of\n     * `array` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to search.\n     * @param {*} value The value to search for.\n     * @param {number} [fromIndex=array.length-1] The index to search from.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     * @example\n     *\n     * _.lastIndexOf([1, 2, 1, 2], 2);\n     * // => 3\n     *\n     * // using `fromIndex`\n     * _.lastIndexOf([1, 2, 1, 2], 2, 2);\n     * // => 1\n     */\n    function lastIndexOf(array, value, fromIndex) {\n      var length = array ? array.length : 0;\n      if (!length) {\n        return -1;\n      }\n      var index = length;\n      if (fromIndex !== undefined) {\n        index = toInteger(fromIndex);\n        index = (index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1)) + 1;\n      }\n      if (value !== value) {\n        return indexOfNaN(array, index, true);\n      }\n      while (index--) {\n        if (array[index] === value) {\n          return index;\n        }\n      }\n      return -1;\n    }\n\n    /**\n     * Removes all provided values from `array` using\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)\n     * for equality comparisons.\n     *\n     * **Note:** Unlike `_.without`, this method mutates `array`.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {...*} [values] The values to remove.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = [1, 2, 3, 1, 2, 3];\n     *\n     * _.pull(array, 2, 3);\n     * console.log(array);\n     * // => [1, 1]\n     */\n    var pull = rest(pullAll);\n\n    /**\n     * This method is like `_.pull` except that it accepts an array of values to remove.\n     *\n     * **Note:** Unlike `_.difference`, this method mutates `array`.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {Array} values The values to remove.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = [1, 2, 3, 1, 2, 3];\n     *\n     * _.pull(array, [2, 3]);\n     * console.log(array);\n     * // => [1, 1]\n     */\n    function pullAll(array, values) {\n      return (array && array.length && values && values.length)\n        ? basePullAll(array, values)\n        : array;\n    }\n\n    /**\n     * This method is like `_.pullAll` except that it accepts `iteratee` which is\n     * invoked for each element of `array` and `values` to to generate the criterion\n     * by which uniqueness is computed. The iteratee is invoked with one argument: (value).\n     *\n     * **Note:** Unlike `_.differenceBy`, this method mutates `array`.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {Array} values The values to remove.\n     * @param {Function|Object|string} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];\n     *\n     * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');\n     * console.log(array);\n     * // => [{ 'x': 2 }]\n     */\n    function pullAllBy(array, values, iteratee) {\n      return (array && array.length && values && values.length)\n        ? basePullAllBy(array, values, getIteratee(iteratee))\n        : array;\n    }\n\n    /**\n     * Removes elements from `array` corresponding to `indexes` and returns an\n     * array of removed elements.\n     *\n     * **Note:** Unlike `_.at`, this method mutates `array`.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {...(number|number[])} [indexes] The indexes of elements to remove,\n     *  specified individually or in arrays.\n     * @returns {Array} Returns the new array of removed elements.\n     * @example\n     *\n     * var array = [5, 10, 15, 20];\n     * var evens = _.pullAt(array, 1, 3);\n     *\n     * console.log(array);\n     * // => [5, 15]\n     *\n     * console.log(evens);\n     * // => [10, 20]\n     */\n    var pullAt = rest(function(array, indexes) {\n      indexes = arrayMap(baseFlatten(indexes), String);\n\n      var result = baseAt(array, indexes);\n      basePullAt(array, indexes.sort(compareAscending));\n      return result;\n    });\n\n    /**\n     * Removes all elements from `array` that `predicate` returns truthy for\n     * and returns an array of the removed elements. The predicate is invoked with\n     * three arguments: (value, index, array).\n     *\n     * **Note:** Unlike `_.filter`, this method mutates `array`.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {Function|Object|string} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the new array of removed elements.\n     * @example\n     *\n     * var array = [1, 2, 3, 4];\n     * var evens = _.remove(array, function(n) {\n     *   return n % 2 == 0;\n     * });\n     *\n     * console.log(array);\n     * // => [1, 3]\n     *\n     * console.log(evens);\n     * // => [2, 4]\n     */\n    function remove(array, predicate) {\n      var result = [];\n      if (!(array && array.length)) {\n        return result;\n      }\n      var index = -1,\n          indexes = [],\n          length = array.length;\n\n      predicate = getIteratee(predicate, 3);\n      while (++index < length) {\n        var value = array[index];\n        if (predicate(value, index, array)) {\n          result.push(value);\n          indexes.push(index);\n        }\n      }\n      basePullAt(array, indexes);\n      return result;\n    }\n\n    /**\n     * Reverses `array` so that the first element becomes the last, the second\n     * element becomes the second to last, and so on.\n     *\n     * **Note:** This method mutates `array` and is based on\n     * [`Array#reverse`](https://mdn.io/Array/reverse).\n     *\n     * @memberOf _\n     * @category Array\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = [1, 2, 3];\n     *\n     * _.reverse(array);\n     * // => [3, 2, 1]\n     *\n     * console.log(array);\n     * // => [3, 2, 1]\n     */\n    function reverse(array) {\n      return array ? nativeReverse.call(array) : array;\n    }\n\n    /**\n     * Creates a slice of `array` from `start` up to, but not including, `end`.\n     *\n     * **Note:** This method is used instead of [`Array#slice`](https://mdn.io/Array/slice)\n     * to ensure dense arrays are returned.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to slice.\n     * @param {number} [start=0] The start position.\n     * @param {number} [end=array.length] The end position.\n     * @returns {Array} Returns the slice of `array`.\n     */\n    function slice(array, start, end) {\n      var length = array ? array.length : 0;\n      if (!length) {\n        return [];\n      }\n      if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {\n        start = 0;\n        end = length;\n      }\n      else {\n        start = start == null ? 0 : toInteger(start);\n        end = end === undefined ? length : toInteger(end);\n      }\n      return baseSlice(array, start, end);\n    }\n\n    /**\n     * Uses a binary search to determine the lowest index at which `value` should\n     * be inserted into `array` in order to maintain its sort order.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @returns {number} Returns the index at which `value` should be inserted into `array`.\n     * @example\n     *\n     * _.sortedIndex([30, 50], 40);\n     * // => 1\n     *\n     * _.sortedIndex([4, 5], 4);\n     * // => 0\n     */\n    function sortedIndex(array, value) {\n      return baseSortedIndex(array, value);\n    }\n\n    /**\n     * This method is like `_.sortedIndex` except that it accepts `iteratee`\n     * which is invoked for `value` and each element of `array` to compute their\n     * sort ranking. The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @param {Function|Object|string} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {number} Returns the index at which `value` should be inserted into `array`.\n     * @example\n     *\n     * var dict = { 'thirty': 30, 'forty': 40, 'fifty': 50 };\n     *\n     * _.sortedIndexBy(['thirty', 'fifty'], 'forty', _.propertyOf(dict));\n     * // => 1\n     *\n     * // using the `_.property` iteratee shorthand\n     * _.sortedIndexBy([{ 'x': 4 }, { 'x': 5 }], { 'x': 4 }, 'x');\n     * // => 0\n     */\n    function sortedIndexBy(array, value, iteratee) {\n      return baseSortedIndexBy(array, value, getIteratee(iteratee));\n    }\n\n    /**\n     * This method is like `_.indexOf` except that it performs a binary\n     * search on a sorted `array`.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to search.\n     * @param {*} value The value to search for.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     * @example\n     *\n     * _.sortedIndexOf([1, 1, 2, 2], 2);\n     * // => 2\n     */\n    function sortedIndexOf(array, value) {\n      var length = array ? array.length : 0;\n      if (length) {\n        var index = baseSortedIndex(array, value);\n        if (index < length && eq(array[index], value)) {\n          return index;\n        }\n      }\n      return -1;\n    }\n\n    /**\n     * This method is like `_.sortedIndex` except that it returns the highest\n     * index at which `value` should be inserted into `array` in order to\n     * maintain its sort order.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @returns {number} Returns the index at which `value` should be inserted into `array`.\n     * @example\n     *\n     * _.sortedLastIndex([4, 5], 4);\n     * // => 1\n     */\n    function sortedLastIndex(array, value) {\n      return baseSortedIndex(array, value, true);\n    }\n\n    /**\n     * This method is like `_.sortedLastIndex` except that it accepts `iteratee`\n     * which is invoked for `value` and each element of `array` to compute their\n     * sort ranking. The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @param {Function|Object|string} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {number} Returns the index at which `value` should be inserted into `array`.\n     * @example\n     *\n     * // using the `_.property` iteratee shorthand\n     * _.sortedLastIndexBy([{ 'x': 4 }, { 'x': 5 }], { 'x': 4 }, 'x');\n     * // => 1\n     */\n    function sortedLastIndexBy(array, value, iteratee) {\n      return baseSortedIndexBy(array, value, getIteratee(iteratee), true);\n    }\n\n    /**\n     * This method is like `_.lastIndexOf` except that it performs a binary\n     * search on a sorted `array`.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to search.\n     * @param {*} value The value to search for.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     * @example\n     *\n     * _.sortedLastIndexOf([1, 1, 2, 2], 2);\n     * // => 3\n     */\n    function sortedLastIndexOf(array, value) {\n      var length = array ? array.length : 0;\n      if (length) {\n        var index = baseSortedIndex(array, value, true) - 1;\n        if (eq(array[index], value)) {\n          return index;\n        }\n      }\n      return -1;\n    }\n\n    /**\n     * This method is like `_.uniq` except that it's designed and optimized\n     * for sorted arrays.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @returns {Array} Returns the new duplicate free array.\n     * @example\n     *\n     * _.sortedUniq([1, 1, 2]);\n     * // => [1, 2]\n     */\n    function sortedUniq(array) {\n      return (array && array.length)\n        ? baseSortedUniq(array)\n        : [];\n    }\n\n    /**\n     * This method is like `_.uniqBy` except that it's designed and optimized\n     * for sorted arrays.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @returns {Array} Returns the new duplicate free array.\n     * @example\n     *\n     * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);\n     * // => [1.1, 2.2]\n     */\n    function sortedUniqBy(array, iteratee) {\n      return (array && array.length)\n        ? baseSortedUniqBy(array, getIteratee(iteratee))\n        : [];\n    }\n\n    /**\n     * Gets all but the first element of `array`.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to query.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.tail([1, 2, 3]);\n     * // => [2, 3]\n     */\n    function tail(array) {\n      return drop(array, 1);\n    }\n\n    /**\n     * Creates a slice of `array` with `n` elements taken from the beginning.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {number} [n=1] The number of elements to take.\n     * @param- {Object} [guard] Enables use as an iteratee for functions like `_.map`.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.take([1, 2, 3]);\n     * // => [1]\n     *\n     * _.take([1, 2, 3], 2);\n     * // => [1, 2]\n     *\n     * _.take([1, 2, 3], 5);\n     * // => [1, 2, 3]\n     *\n     * _.take([1, 2, 3], 0);\n     * // => []\n     */\n    function take(array, n, guard) {\n      if (!(array && array.length)) {\n        return [];\n      }\n      n = (guard || n === undefined) ? 1 : toInteger(n);\n      return baseSlice(array, 0, n < 0 ? 0 : n);\n    }\n\n    /**\n     * Creates a slice of `array` with `n` elements taken from the end.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {number} [n=1] The number of elements to take.\n     * @param- {Object} [guard] Enables use as an iteratee for functions like `_.map`.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.takeRight([1, 2, 3]);\n     * // => [3]\n     *\n     * _.takeRight([1, 2, 3], 2);\n     * // => [2, 3]\n     *\n     * _.takeRight([1, 2, 3], 5);\n     * // => [1, 2, 3]\n     *\n     * _.takeRight([1, 2, 3], 0);\n     * // => []\n     */\n    function takeRight(array, n, guard) {\n      var length = array ? array.length : 0;\n      if (!length) {\n        return [];\n      }\n      n = (guard || n === undefined) ? 1 : toInteger(n);\n      n = length - n;\n      return baseSlice(array, n < 0 ? 0 : n, length);\n    }\n\n    /**\n     * Creates a slice of `array` with elements taken from the end. Elements are\n     * taken until `predicate` returns falsey. The predicate is invoked with three\n     * arguments: (value, index, array).\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {Function|Object|string} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': true },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': false }\n     * ];\n     *\n     * _.takeRightWhile(users, function(o) { return !o.active; });\n     * // => objects for ['fred', 'pebbles']\n     *\n     * // using the `_.matches` iteratee shorthand\n     * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });\n     * // => objects for ['pebbles']\n     *\n     * // using the `_.matchesProperty` iteratee shorthand\n     * _.takeRightWhile(users, ['active', false]);\n     * // => objects for ['fred', 'pebbles']\n     *\n     * // using the `_.property` iteratee shorthand\n     * _.takeRightWhile(users, 'active');\n     * // => []\n     */\n    function takeRightWhile(array, predicate) {\n      return (array && array.length)\n        ? baseWhile(array, getIteratee(predicate, 3), false, true)\n        : [];\n    }\n\n    /**\n     * Creates a slice of `array` with elements taken from the beginning. Elements\n     * are taken until `predicate` returns falsey. The predicate is invoked with\n     * three arguments: (value, index, array).\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {Function|Object|string} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': false },\n     *   { 'user': 'fred',    'active': false},\n     *   { 'user': 'pebbles', 'active': true }\n     * ];\n     *\n     * _.takeWhile(users, function(o) { return !o.active; });\n     * // => objects for ['barney', 'fred']\n     *\n     * // using the `_.matches` iteratee shorthand\n     * _.takeWhile(users, { 'user': 'barney', 'active': false });\n     * // => objects for ['barney']\n     *\n     * // using the `_.matchesProperty` iteratee shorthand\n     * _.takeWhile(users, ['active', false]);\n     * // => objects for ['barney', 'fred']\n     *\n     * // using the `_.property` iteratee shorthand\n     * _.takeWhile(users, 'active');\n     * // => []\n     */\n    function takeWhile(array, predicate) {\n      return (array && array.length)\n        ? baseWhile(array, getIteratee(predicate, 3))\n        : [];\n    }\n\n    /**\n     * Creates an array of unique values, in order, from all of the provided arrays\n     * using [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)\n     * for equality comparisons.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @returns {Array} Returns the new array of combined values.\n     * @example\n     *\n     * _.union([2, 1], [4, 2], [1, 2]);\n     * // => [2, 1, 4]\n     */\n    var union = rest(function(arrays) {\n      return baseUniq(baseFlatten(arrays, false, true));\n    });\n\n    /**\n     * This method is like `_.union` except that it accepts `iteratee` which is\n     * invoked for each element of each `arrays` to generate the criterion by which\n     * uniqueness is computed. The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function|Object|string} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Array} Returns the new array of combined values.\n     * @example\n     *\n     * _.unionBy([2.1, 1.2], [4.3, 2.4], Math.floor);\n     * // => [2.1, 1.2, 4.3]\n     *\n     * // using the `_.property` iteratee shorthand\n     * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');\n     * // => [{ 'x': 1 }, { 'x': 2 }]\n     */\n    var unionBy = rest(function(arrays) {\n      var iteratee = last(arrays);\n      if (isArrayLikeObject(iteratee)) {\n        iteratee = undefined;\n      }\n      return baseUniq(baseFlatten(arrays, false, true), getIteratee(iteratee));\n    });\n\n    /**\n     * This method is like `_.union` except that it accepts `comparator` which\n     * is invoked to compare elements of `arrays`. The comparator is invoked\n     * with two arguments: (arrVal, othVal).\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of combined values.\n     * @example\n     *\n     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\n     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];\n     *\n     * _.unionWith(objects, others, _.isEqual);\n     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]\n     */\n    var unionWith = rest(function(arrays) {\n      var comparator = last(arrays);\n      if (isArrayLikeObject(comparator)) {\n        comparator = undefined;\n      }\n      return baseUniq(baseFlatten(arrays, false, true), undefined, comparator);\n    });\n\n    /**\n     * Creates a duplicate-free version of an array, using\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)\n     * for equality comparisons, in which only the first occurrence of each element\n     * is kept.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @returns {Array} Returns the new duplicate free array.\n     * @example\n     *\n     * _.uniq([2, 1, 2]);\n     * // => [2, 1]\n     */\n    function uniq(array) {\n      return (array && array.length)\n        ? baseUniq(array)\n        : [];\n    }\n\n    /**\n     * This method is like `_.uniq` except that it accepts `iteratee` which is\n     * invoked for each element in `array` to generate the criterion by which\n     * uniqueness is computed. The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {Function|Object|string} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Array} Returns the new duplicate free array.\n     * @example\n     *\n     * _.uniqBy([2.1, 1.2, 2.3], Math.floor);\n     * // => [2.1, 1.2]\n     *\n     * // using the `_.property` iteratee shorthand\n     * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');\n     * // => [{ 'x': 1 }, { 'x': 2 }]\n     */\n    function uniqBy(array, iteratee) {\n      return (array && array.length)\n        ? baseUniq(array, getIteratee(iteratee))\n        : [];\n    }\n\n    /**\n     * This method is like `_.uniq` except that it accepts `comparator` which\n     * is invoked to compare elements of `array`. The comparator is invoked with\n     * two arguments: (arrVal, othVal).\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new duplicate free array.\n     * @example\n     *\n     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 },  { 'x': 1, 'y': 2 }];\n     *\n     * _.uniqWith(objects, _.isEqual);\n     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]\n     */\n    function uniqWith(array, comparator) {\n      return (array && array.length)\n        ? baseUniq(array, undefined, comparator)\n        : [];\n    }\n\n    /**\n     * This method is like `_.zip` except that it accepts an array of grouped\n     * elements and creates an array regrouping the elements to their pre-zip\n     * configuration.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array of grouped elements to process.\n     * @returns {Array} Returns the new array of regrouped elements.\n     * @example\n     *\n     * var zipped = _.zip(['fred', 'barney'], [30, 40], [true, false]);\n     * // => [['fred', 30, true], ['barney', 40, false]]\n     *\n     * _.unzip(zipped);\n     * // => [['fred', 'barney'], [30, 40], [true, false]]\n     */\n    function unzip(array) {\n      if (!(array && array.length)) {\n        return [];\n      }\n      var length = 0;\n      array = arrayFilter(array, function(group) {\n        if (isArrayLikeObject(group)) {\n          length = nativeMax(group.length, length);\n          return true;\n        }\n      });\n      return baseTimes(length, function(index) {\n        return arrayMap(array, baseProperty(index));\n      });\n    }\n\n    /**\n     * This method is like `_.unzip` except that it accepts `iteratee` to specify\n     * how regrouped values should be combined. The iteratee is invoked with the\n     * elements of each group: (...group).\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array of grouped elements to process.\n     * @param {Function} [iteratee=_.identity] The function to combine regrouped values.\n     * @returns {Array} Returns the new array of regrouped elements.\n     * @example\n     *\n     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);\n     * // => [[1, 10, 100], [2, 20, 200]]\n     *\n     * _.unzipWith(zipped, _.add);\n     * // => [3, 30, 300]\n     */\n    function unzipWith(array, iteratee) {\n      if (!(array && array.length)) {\n        return [];\n      }\n      var result = unzip(array);\n      if (iteratee == null) {\n        return result;\n      }\n      return arrayMap(result, function(group) {\n        return apply(iteratee, undefined, group);\n      });\n    }\n\n    /**\n     * Creates an array excluding all provided values using\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)\n     * for equality comparisons.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} array The array to filter.\n     * @param {...*} [values] The values to exclude.\n     * @returns {Array} Returns the new array of filtered values.\n     * @example\n     *\n     * _.without([1, 2, 1, 3], 1, 2);\n     * // => [3]\n     */\n    var without = rest(function(array, values) {\n      return isArrayLikeObject(array)\n        ? baseDifference(array, values)\n        : [];\n    });\n\n    /**\n     * Creates an array of unique values that is the [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)\n     * of the provided arrays.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @returns {Array} Returns the new array of values.\n     * @example\n     *\n     * _.xor([2, 1], [4, 2]);\n     * // => [1, 4]\n     */\n    var xor = rest(function(arrays) {\n      return baseXor(arrayFilter(arrays, isArrayLikeObject));\n    });\n\n    /**\n     * This method is like `_.xor` except that it accepts `iteratee` which is\n     * invoked for each element of each `arrays` to generate the criterion by which\n     * uniqueness is computed. The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function|Object|string} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Array} Returns the new array of values.\n     * @example\n     *\n     * _.xorBy([2.1, 1.2], [4.3, 2.4], Math.floor);\n     * // => [1.2, 4.3]\n     *\n     * // using the `_.property` iteratee shorthand\n     * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');\n     * // => [{ 'x': 2 }]\n     */\n    var xorBy = rest(function(arrays) {\n      var iteratee = last(arrays);\n      if (isArrayLikeObject(iteratee)) {\n        iteratee = undefined;\n      }\n      return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee));\n    });\n\n    /**\n     * This method is like `_.xor` except that it accepts `comparator` which is\n     * invoked to compare elements of `arrays`. The comparator is invoked with\n     * two arguments: (arrVal, othVal).\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of values.\n     * @example\n     *\n     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\n     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];\n     *\n     * _.xorWith(objects, others, _.isEqual);\n     * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]\n     */\n    var xorWith = rest(function(arrays) {\n      var comparator = last(arrays);\n      if (isArrayLikeObject(comparator)) {\n        comparator = undefined;\n      }\n      return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator);\n    });\n\n    /**\n     * Creates an array of grouped elements, the first of which contains the first\n     * elements of the given arrays, the second of which contains the second elements\n     * of the given arrays, and so on.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {...Array} [arrays] The arrays to process.\n     * @returns {Array} Returns the new array of grouped elements.\n     * @example\n     *\n     * _.zip(['fred', 'barney'], [30, 40], [true, false]);\n     * // => [['fred', 30, true], ['barney', 40, false]]\n     */\n    var zip = rest(unzip);\n\n    /**\n     * This method is like `_.fromPairs` except that it accepts two arrays,\n     * one of property names and one of corresponding values.\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {Array} [props=[]] The property names.\n     * @param {Array} [values=[]] The property values.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * _.zipObject(['fred', 'barney'], [30, 40]);\n     * // => { 'fred': 30, 'barney': 40 }\n     */\n    function zipObject(props, values) {\n      var index = -1,\n          length = props ? props.length : 0,\n          valsLength = values ? values.length : 0,\n          result = {};\n\n      while (++index < length) {\n        baseSet(result, props[index], index < valsLength ? values[index] : undefined);\n      }\n      return result;\n    }\n\n    /**\n     * This method is like `_.zip` except that it accepts `iteratee` to specify\n     * how grouped values should be combined. The iteratee is invoked with the\n     * elements of each group: (...group).\n     *\n     * @static\n     * @memberOf _\n     * @category Array\n     * @param {...Array} [arrays] The arrays to process.\n     * @param {Function} [iteratee=_.identity] The function to combine grouped values.\n     * @returns {Array} Returns the new array of grouped elements.\n     * @example\n     *\n     * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {\n     *   return a + b + c;\n     * });\n     * // => [111, 222]\n     */\n    var zipWith = rest(function(arrays) {\n      var length = arrays.length,\n          iteratee = length > 1 ? arrays[length - 1] : undefined;\n\n      iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined;\n      return unzipWith(arrays, iteratee);\n    });\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a `lodash` object that wraps `value` with explicit method chaining enabled.\n     * The result of such method chaining must be unwrapped with `_#value`.\n     *\n     * @static\n     * @memberOf _\n     * @category Seq\n     * @param {*} value The value to wrap.\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'age': 36 },\n     *   { 'user': 'fred',    'age': 40 },\n     *   { 'user': 'pebbles', 'age': 1 }\n     * ];\n     *\n     * var youngest = _\n     *   .chain(users)\n     *   .sortBy('age')\n     *   .map(function(o) {\n     *     return o.user + ' is ' + o.age;\n     *   })\n     *   .head()\n     *   .value();\n     * // => 'pebbles is 1'\n     */\n    function chain(value) {\n      var result = lodash(value);\n      result.__chain__ = true;\n      return result;\n    }\n\n    /**\n     * This method invokes `interceptor` and returns `value`. The interceptor is\n     * invoked with one argument; (value). The purpose of this method is to \"tap into\"\n     * a method chain in order to perform operations on intermediate results within\n     * the chain.\n     *\n     * @static\n     * @memberOf _\n     * @category Seq\n     * @param {*} value The value to provide to `interceptor`.\n     * @param {Function} interceptor The function to invoke.\n     * @returns {*} Returns `value`.\n     * @example\n     *\n     * _([1, 2, 3])\n     *  .tap(function(array) {\n     *    array.pop();\n     *  })\n     *  .reverse()\n     *  .value();\n     * // => [2, 1]\n     */\n    function tap(value, interceptor) {\n      interceptor(value);\n      return value;\n    }\n\n    /**\n     * This method is like `_.tap` except that it returns the result of `interceptor`.\n     *\n     * @static\n     * @memberOf _\n     * @category Seq\n     * @param {*} value The value to provide to `interceptor`.\n     * @param {Function} interceptor The function to invoke.\n     * @returns {*} Returns the result of `interceptor`.\n     * @example\n     *\n     * _('  abc  ')\n     *  .chain()\n     *  .trim()\n     *  .thru(function(value) {\n     *    return [value];\n     *  })\n     *  .value();\n     * // => ['abc']\n     */\n    function thru(value, interceptor) {\n      return interceptor(value);\n    }\n\n    /**\n     * This method is the wrapper version of `_.at`.\n     *\n     * @name at\n     * @memberOf _\n     * @category Seq\n     * @param {...(string|string[])} [paths] The property paths of elements to pick,\n     *  specified individually or in arrays.\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };\n     *\n     * _(object).at(['a[0].b.c', 'a[1]']).value();\n     * // => [3, 4]\n     *\n     * _(['a', 'b', 'c']).at(0, 2).value();\n     * // => ['a', 'c']\n     */\n    var wrapperAt = rest(function(paths) {\n      paths = baseFlatten(paths);\n      var length = paths.length,\n          start = length ? paths[0] : 0,\n          value = this.__wrapped__,\n          interceptor = function(object) { return baseAt(object, paths); };\n\n      if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {\n        return this.thru(interceptor);\n      }\n      value = value.slice(start, +start + (length ? 1 : 0));\n      value.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined });\n      return new LodashWrapper(value, this.__chain__).thru(function(array) {\n        if (length && !array.length) {\n          array.push(undefined);\n        }\n        return array;\n      });\n    });\n\n    /**\n     * Enables explicit method chaining on the wrapper object.\n     *\n     * @name chain\n     * @memberOf _\n     * @category Seq\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36 },\n     *   { 'user': 'fred',   'age': 40 }\n     * ];\n     *\n     * // without explicit chaining\n     * _(users).head();\n     * // => { 'user': 'barney', 'age': 36 }\n     *\n     * // with explicit chaining\n     * _(users)\n     *   .chain()\n     *   .head()\n     *   .pick('user')\n     *   .value();\n     * // => { 'user': 'barney' }\n     */\n    function wrapperChain() {\n      return chain(this);\n    }\n\n    /**\n     * Executes the chained sequence and returns the wrapped result.\n     *\n     * @name commit\n     * @memberOf _\n     * @category Seq\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var array = [1, 2];\n     * var wrapped = _(array).push(3);\n     *\n     * console.log(array);\n     * // => [1, 2]\n     *\n     * wrapped = wrapped.commit();\n     * console.log(array);\n     * // => [1, 2, 3]\n     *\n     * wrapped.last();\n     * // => 3\n     *\n     * console.log(array);\n     * // => [1, 2, 3]\n     */\n    function wrapperCommit() {\n      return new LodashWrapper(this.value(), this.__chain__);\n    }\n\n    /**\n     * This method is the wrapper version of `_.flatMap`.\n     *\n     * @static\n     * @memberOf _\n     * @category Seq\n     * @param {Function|Object|string} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * function duplicate(n) {\n     *   return [n, n];\n     * }\n     *\n     * _([1, 2]).flatMap(duplicate).value();\n     * // => [1, 1, 2, 2]\n     */\n    function wrapperFlatMap(iteratee) {\n      return this.map(iteratee).flatten();\n    }\n\n    /**\n     * Gets the next value on a wrapped object following the\n     * [iterator protocol](https://mdn.io/iteration_protocols#iterator).\n     *\n     * @name next\n     * @memberOf _\n     * @category Seq\n     * @returns {Object} Returns the next iterator value.\n     * @example\n     *\n     * var wrapped = _([1, 2]);\n     *\n     * wrapped.next();\n     * // => { 'done': false, 'value': 1 }\n     *\n     * wrapped.next();\n     * // => { 'done': false, 'value': 2 }\n     *\n     * wrapped.next();\n     * // => { 'done': true, 'value': undefined }\n     */\n    function wrapperNext() {\n      if (this.__values__ === undefined) {\n        this.__values__ = toArray(this.value());\n      }\n      var done = this.__index__ >= this.__values__.length,\n          value = done ? undefined : this.__values__[this.__index__++];\n\n      return { 'done': done, 'value': value };\n    }\n\n    /**\n     * Enables the wrapper to be iterable.\n     *\n     * @name Symbol.iterator\n     * @memberOf _\n     * @category Seq\n     * @returns {Object} Returns the wrapper object.\n     * @example\n     *\n     * var wrapped = _([1, 2]);\n     *\n     * wrapped[Symbol.iterator]() === wrapped;\n     * // => true\n     *\n     * Array.from(wrapped);\n     * // => [1, 2]\n     */\n    function wrapperToIterator() {\n      return this;\n    }\n\n    /**\n     * Creates a clone of the chained sequence planting `value` as the wrapped value.\n     *\n     * @name plant\n     * @memberOf _\n     * @category Seq\n     * @param {*} value The value to plant.\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * var wrapped = _([1, 2]).map(square);\n     * var other = wrapped.plant([3, 4]);\n     *\n     * other.value();\n     * // => [9, 16]\n     *\n     * wrapped.value();\n     * // => [1, 4]\n     */\n    function wrapperPlant(value) {\n      var result,\n          parent = this;\n\n      while (parent instanceof baseLodash) {\n        var clone = wrapperClone(parent);\n        clone.__index__ = 0;\n        clone.__values__ = undefined;\n        if (result) {\n          previous.__wrapped__ = clone;\n        } else {\n          result = clone;\n        }\n        var previous = clone;\n        parent = parent.__wrapped__;\n      }\n      previous.__wrapped__ = value;\n      return result;\n    }\n\n    /**\n     * This method is the wrapper version of `_.reverse`.\n     *\n     * **Note:** This method mutates the wrapped array.\n     *\n     * @name reverse\n     * @memberOf _\n     * @category Seq\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var array = [1, 2, 3];\n     *\n     * _(array).reverse().value()\n     * // => [3, 2, 1]\n     *\n     * console.log(array);\n     * // => [3, 2, 1]\n     */\n    function wrapperReverse() {\n      var value = this.__wrapped__;\n      if (value instanceof LazyWrapper) {\n        var wrapped = value;\n        if (this.__actions__.length) {\n          wrapped = new LazyWrapper(this);\n        }\n        wrapped = wrapped.reverse();\n        wrapped.__actions__.push({ 'func': thru, 'args': [reverse], 'thisArg': undefined });\n        return new LodashWrapper(wrapped, this.__chain__);\n      }\n      return this.thru(reverse);\n    }\n\n    /**\n     * Executes the chained sequence to extract the unwrapped value.\n     *\n     * @name value\n     * @memberOf _\n     * @alias run, toJSON, valueOf\n     * @category Seq\n     * @returns {*} Returns the resolved unwrapped value.\n     * @example\n     *\n     * _([1, 2, 3]).value();\n     * // => [1, 2, 3]\n     */\n    function wrapperValue() {\n      return baseWrapperValue(this.__wrapped__, this.__actions__);\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates an object composed of keys generated from the results of running\n     * each element of `collection` through `iteratee`. The corresponding value\n     * of each key is the number of times the key was returned by `iteratee`.\n     * The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function|Object|string} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Object} Returns the composed aggregate object.\n     * @example\n     *\n     * _.countBy([6.1, 4.2, 6.3], Math.floor);\n     * // => { '4': 1, '6': 2 }\n     *\n     * _.countBy(['one', 'two', 'three'], 'length');\n     * // => { '3': 2, '5': 1 }\n     */\n    var countBy = createAggregator(function(result, value, key) {\n      hasOwnProperty.call(result, key) ? ++result[key] : (result[key] = 1);\n    });\n\n    /**\n     * Checks if `predicate` returns truthy for **all** elements of `collection`.\n     * Iteration is stopped once `predicate` returns falsey. The predicate is\n     * invoked with three arguments: (value, index|key, collection).\n     *\n     * @static\n     * @memberOf _\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function|Object|string} [predicate=_.identity] The function invoked per iteration.\n     * @param- {Object} [guard] Enables use as an iteratee for functions like `_.map`.\n     * @returns {boolean} Returns `true` if all elements pass the predicate check, else `false`.\n     * @example\n     *\n     * _.every([true, 1, null, 'yes'], Boolean);\n     * // => false\n     *\n     * var users = [\n     *   { 'user': 'barney', 'active': false },\n     *   { 'user': 'fred',   'active': false }\n     * ];\n     *\n     * // using the `_.matches` iteratee shorthand\n     * _.every(users, { 'user': 'barney', 'active': false });\n     * // => false\n     *\n     * // using the `_.matchesProperty` iteratee shorthand\n     * _.every(users, ['active', false]);\n     * // => true\n     *\n     * // using the `_.property` iteratee shorthand\n     * _.every(users, 'active');\n     * // => false\n     */\n    function every(collection, predicate, guard) {\n      var func = isArray(collection) ? arrayEvery : baseEvery;\n      if (guard && isIterateeCall(collection, predicate, guard)) {\n        predicate = undefined;\n      }\n      return func(collection, getIteratee(predicate, 3));\n    }\n\n    /**\n     * Iterates over elements of `collection`, returning an array of all elements\n     * `predicate` returns truthy for. The predicate is invoked with three arguments:\n     * (value, index|key, collection).\n     *\n     * @static\n     * @memberOf _\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function|Object|string} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the new filtered array.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36, 'active': true },\n     *   { 'user': 'fred',   'age': 40, 'active': false }\n     * ];\n     *\n     * _.filter(users, function(o) { return !o.active; });\n     * // => objects for ['fred']\n     *\n     * // using the `_.matches` iteratee shorthand\n     * _.filter(users, { 'age': 36, 'active': true });\n     * // => objects for ['barney']\n     *\n     * // using the `_.matchesProperty` iteratee shorthand\n     * _.filter(users, ['active', false]);\n     * // => objects for ['fred']\n     *\n     * // using the `_.property` iteratee shorthand\n     * _.filter(users, 'active');\n     * // => objects for ['barney']\n     */\n    function filter(collection, predicate) {\n      var func = isArray(collection) ? arrayFilter : baseFilter;\n      return func(collection, getIteratee(predicate, 3));\n    }\n\n    /**\n     * Iterates over elements of `collection`, returning the first element\n     * `predicate` returns truthy for. The predicate is invoked with three arguments:\n     * (value, index|key, collection).\n     *\n     * @static\n     * @memberOf _\n     * @category Collection\n     * @param {Array|Object} collection The collection to search.\n     * @param {Function|Object|string} [predicate=_.identity] The function invoked per iteration.\n     * @returns {*} Returns the matched element, else `undefined`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'age': 36, 'active': true },\n     *   { 'user': 'fred',    'age': 40, 'active': false },\n     *   { 'user': 'pebbles', 'age': 1,  'active': true }\n     * ];\n     *\n     * _.find(users, function(o) { return o.age < 40; });\n     * // => object for 'barney'\n     *\n     * // using the `_.matches` iteratee shorthand\n     * _.find(users, { 'age': 1, 'active': true });\n     * // => object for 'pebbles'\n     *\n     * // using the `_.matchesProperty` iteratee shorthand\n     * _.find(users, ['active', false]);\n     * // => object for 'fred'\n     *\n     * // using the `_.property` iteratee shorthand\n     * _.find(users, 'active');\n     * // => object for 'barney'\n     */\n    function find(collection, predicate) {\n      predicate = getIteratee(predicate, 3);\n      if (isArray(collection)) {\n        var index = baseFindIndex(collection, predicate);\n        return index > -1 ? collection[index] : undefined;\n      }\n      return baseFind(collection, predicate, baseEach);\n    }\n\n    /**\n     * This method is like `_.find` except that it iterates over elements of\n     * `collection` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @category Collection\n     * @param {Array|Object} collection The collection to search.\n     * @param {Function|Object|string} [predicate=_.identity] The function invoked per iteration.\n     * @returns {*} Returns the matched element, else `undefined`.\n     * @example\n     *\n     * _.findLast([1, 2, 3, 4], function(n) {\n     *   return n % 2 == 1;\n     * });\n     * // => 3\n     */\n    function findLast(collection, predicate) {\n      predicate = getIteratee(predicate, 3);\n      if (isArray(collection)) {\n        var index = baseFindIndex(collection, predicate, true);\n        return index > -1 ? collection[index] : undefined;\n      }\n      return baseFind(collection, predicate, baseEachRight);\n    }\n\n    /**\n     * Iterates over elements of `collection` invoking `iteratee` for each element.\n     * The iteratee is invoked with three arguments: (value, index|key, collection).\n     * Iteratee functions may exit iteration early by explicitly returning `false`.\n     *\n     * **Note:** As with other \"Collections\" methods, objects with a \"length\" property\n     * are iterated like arrays. To avoid this behavior use `_.forIn` or `_.forOwn`\n     * for object iteration.\n     *\n     * @static\n     * @memberOf _\n     * @alias each\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Array|Object} Returns `collection`.\n     * @example\n     *\n     * _([1, 2]).forEach(function(value) {\n     *   console.log(value);\n     * });\n     * // => logs `1` then `2`\n     *\n     * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => logs 'a' then 'b' (iteration order is not guaranteed)\n     */\n    function forEach(collection, iteratee) {\n      return (typeof iteratee == 'function' && isArray(collection))\n        ? arrayEach(collection, iteratee)\n        : baseEach(collection, toFunction(iteratee));\n    }\n\n    /**\n     * This method is like `_.forEach` except that it iterates over elements of\n     * `collection` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @alias eachRight\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Array|Object} Returns `collection`.\n     * @example\n     *\n     * _.forEachRight([1, 2], function(value) {\n     *   console.log(value);\n     * });\n     * // => logs `2` then `1`\n     */\n    function forEachRight(collection, iteratee) {\n      return (typeof iteratee == 'function' && isArray(collection))\n        ? arrayEachRight(collection, iteratee)\n        : baseEachRight(collection, toFunction(iteratee));\n    }\n\n    /**\n     * Creates an object composed of keys generated from the results of running\n     * each element of `collection` through `iteratee`. The corresponding value\n     * of each key is an array of the elements responsible for generating the key.\n     * The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function|Object|string} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Object} Returns the composed aggregate object.\n     * @example\n     *\n     * _.groupBy([6.1, 4.2, 6.3], Math.floor);\n     * // => { '4': [4.2], '6': [6.1, 6.3] }\n     *\n     * // using the `_.property` iteratee shorthand\n     * _.groupBy(['one', 'two', 'three'], 'length');\n     * // => { '3': ['one', 'two'], '5': ['three'] }\n     */\n    var groupBy = createAggregator(function(result, value, key) {\n      if (hasOwnProperty.call(result, key)) {\n        result[key].push(value);\n      } else {\n        result[key] = [value];\n      }\n    });\n\n    /**\n     * Checks if `value` is in `collection`. If `collection` is a string it's checked\n     * for a substring of `value`, otherwise [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)\n     * is used for equality comparisons. If `fromIndex` is negative, it's used as\n     * the offset from the end of `collection`.\n     *\n     * @static\n     * @memberOf _\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to search.\n     * @param {*} value The value to search for.\n     * @param {number} [fromIndex=0] The index to search from.\n     * @param- {Object} [guard] Enables use as an iteratee for functions like `_.reduce`.\n     * @returns {boolean} Returns `true` if `value` is found, else `false`.\n     * @example\n     *\n     * _.includes([1, 2, 3], 1);\n     * // => true\n     *\n     * _.includes([1, 2, 3], 1, 2);\n     * // => false\n     *\n     * _.includes({ 'user': 'fred', 'age': 40 }, 'fred');\n     * // => true\n     *\n     * _.includes('pebbles', 'eb');\n     * // => true\n     */\n    function includes(collection, value, fromIndex, guard) {\n      collection = isArrayLike(collection) ? collection : values(collection);\n      fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;\n\n      var length = collection.length;\n      if (fromIndex < 0) {\n        fromIndex = nativeMax(length + fromIndex, 0);\n      }\n      return isString(collection)\n        ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)\n        : (!!length && baseIndexOf(collection, value, fromIndex) > -1);\n    }\n\n    /**\n     * Invokes the method at `path` of each element in `collection`, returning\n     * an array of the results of each invoked method. Any additional arguments\n     * are provided to each invoked method. If `methodName` is a function it's\n     * invoked for, and `this` bound to, each element in `collection`.\n     *\n     * @static\n     * @memberOf _\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Array|Function|string} path The path of the method to invoke or\n     *  the function invoked per iteration.\n     * @param {...*} [args] The arguments to invoke each method with.\n     * @returns {Array} Returns the array of results.\n     * @example\n     *\n     * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');\n     * // => [[1, 5, 7], [1, 2, 3]]\n     *\n     * _.invokeMap([123, 456], String.prototype.split, '');\n     * // => [['1', '2', '3'], ['4', '5', '6']]\n     */\n    var invokeMap = rest(function(collection, path, args) {\n      var index = -1,\n          isFunc = typeof path == 'function',\n          isProp = isKey(path),\n          result = isArrayLike(collection) ? Array(collection.length) : [];\n\n      baseEach(collection, function(value) {\n        var func = isFunc ? path : ((isProp && value != null) ? value[path] : undefined);\n        result[++index] = func ? apply(func, value, args) : baseInvoke(value, path, args);\n      });\n      return result;\n    });\n\n    /**\n     * Creates an object composed of keys generated from the results of running\n     * each element of `collection` through `iteratee`. The corresponding value\n     * of each key is the last element responsible for generating the key. The\n     * iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function|Object|string} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Object} Returns the composed aggregate object.\n     * @example\n     *\n     * var keyData = [\n     *   { 'dir': 'left', 'code': 97 },\n     *   { 'dir': 'right', 'code': 100 }\n     * ];\n     *\n     * _.keyBy(keyData, 'dir');\n     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }\n     *\n     * _.keyBy(keyData, function(o) {\n     *   return String.fromCharCode(o.code);\n     * });\n     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }\n     */\n    var keyBy = createAggregator(function(result, value, key) {\n      result[key] = value;\n    });\n\n    /**\n     * Creates an array of values by running each element in `collection` through\n     * `iteratee`. The iteratee is invoked with three arguments:\n     * (value, index|key, collection).\n     *\n     * Many lodash methods are guarded to work as iteratees for methods like\n     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.\n     *\n     * The guarded methods are:\n     * `ary`, `curry`, `curryRight`, `drop`, `dropRight`, `every`, `fill`,\n     * `invert`, `parseInt`, `random`, `range`, `rangeRight`, `slice`, `some`,\n     * `sortBy`, `take`, `takeRight`, `template`, `trim`, `trimEnd`, `trimStart`,\n     * and `words`\n     *\n     * @static\n     * @memberOf _\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function|Object|string} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the new mapped array.\n     * @example\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * _.map([1, 2], square);\n     * // => [3, 6]\n     *\n     * _.map({ 'a': 1, 'b': 2 }, square);\n     * // => [3, 6] (iteration order is not guaranteed)\n     *\n     * var users = [\n     *   { 'user': 'barney' },\n     *   { 'user': 'fred' }\n     * ];\n     *\n     * // using the `_.property` iteratee shorthand\n     * _.map(users, 'user');\n     * // => ['barney', 'fred']\n     */\n    function map(collection, iteratee) {\n      var func = isArray(collection) ? arrayMap : baseMap;\n      return func(collection, getIteratee(iteratee, 3));\n    }\n\n    /**\n     * This method is like `_.sortBy` except that it allows specifying the sort\n     * orders of the iteratees to sort by. If `orders` is unspecified, all values\n     * are sorted in ascending order. Otherwise, specify an order of \"desc\" for\n     * descending or \"asc\" for ascending sort order of corresponding values.\n     *\n     * @static\n     * @memberOf _\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function[]|Object[]|string[]} [iteratees=[_.identity]] The iteratees to sort by.\n     * @param {string[]} [orders] The sort orders of `iteratees`.\n     * @param- {Object} [guard] Enables use as an iteratee for functions like `_.reduce`.\n     * @returns {Array} Returns the new sorted array.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'fred',   'age': 48 },\n     *   { 'user': 'barney', 'age': 34 },\n     *   { 'user': 'fred',   'age': 42 },\n     *   { 'user': 'barney', 'age': 36 }\n     * ];\n     *\n     * // sort by `user` in ascending order and by `age` in descending order\n     * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);\n     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 42]]\n     */\n    function orderBy(collection, iteratees, orders, guard) {\n      if (collection == null) {\n        return [];\n      }\n      if (!isArray(iteratees)) {\n        iteratees = iteratees == null ? [] : [iteratees];\n      }\n      orders = guard ? undefined : orders;\n      if (!isArray(orders)) {\n        orders = orders == null ? [] : [orders];\n      }\n      return baseOrderBy(collection, iteratees, orders);\n    }\n\n    /**\n     * Creates an array of elements split into two groups, the first of which\n     * contains elements `predicate` returns truthy for, while the second of which\n     * contains elements `predicate` returns falsey for. The predicate is invoked\n     * with three arguments: (value, index|key, collection).\n     *\n     * @static\n     * @memberOf _\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function|Object|string} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the array of grouped elements.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'age': 36, 'active': false },\n     *   { 'user': 'fred',    'age': 40, 'active': true },\n     *   { 'user': 'pebbles', 'age': 1,  'active': false }\n     * ];\n     *\n     * _.partition(users, function(o) { return o.active; });\n     * // => objects for [['fred'], ['barney', 'pebbles']]\n     *\n     * // using the `_.matches` iteratee shorthand\n     * _.partition(users, { 'age': 1, 'active': false });\n     * // => objects for [['pebbles'], ['barney', 'fred']]\n     *\n     * // using the `_.matchesProperty` iteratee shorthand\n     * _.partition(users, ['active', false]);\n     * // => objects for [['barney', 'pebbles'], ['fred']]\n     *\n     * // using the `_.property` iteratee shorthand\n     * _.partition(users, 'active');\n     * // => objects for [['fred'], ['barney', 'pebbles']]\n     */\n    var partition = createAggregator(function(result, value, key) {\n      result[key ? 0 : 1].push(value);\n    }, function() { return [[], []]; });\n\n    /**\n     * Reduces `collection` to a value which is the accumulated result of running\n     * each element in `collection` through `iteratee`, where each successive\n     * invocation is supplied the return value of the previous. If `accumulator`\n     * is not provided the first element of `collection` is used as the initial\n     * value. The iteratee is invoked with four arguments:\n     * (accumulator, value, index|key, collection).\n     *\n     * Many lodash methods are guarded to work as iteratees for methods like\n     * `_.reduce`, `_.reduceRight`, and `_.transform`.\n     *\n     * The guarded methods are:\n     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,\n     * and `sortBy`\n     *\n     * @static\n     * @memberOf _\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {*} [accumulator] The initial value.\n     * @returns {*} Returns the accumulated value.\n     * @example\n     *\n     * _.reduce([1, 2], function(sum, n) {\n     *   return sum + n;\n     * });\n     * // => 3\n     *\n     * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {\n     *   (result[value] || (result[value] = [])).push(key);\n     *   return result;\n     * }, {});\n     * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)\n     */\n    function reduce(collection, iteratee, accumulator) {\n      var func = isArray(collection) ? arrayReduce : baseReduce,\n          initFromCollection = arguments.length < 3;\n\n      return func(collection, getIteratee(iteratee, 4), accumulator, initFromCollection, baseEach);\n    }\n\n    /**\n     * This method is like `_.reduce` except that it iterates over elements of\n     * `collection` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {*} [accumulator] The initial value.\n     * @returns {*} Returns the accumulated value.\n     * @example\n     *\n     * var array = [[0, 1], [2, 3], [4, 5]];\n     *\n     * _.reduceRight(array, function(flattened, other) {\n     *   return flattened.concat(other);\n     * }, []);\n     * // => [4, 5, 2, 3, 0, 1]\n     */\n    function reduceRight(collection, iteratee, accumulator) {\n      var func = isArray(collection) ? arrayReduceRight : baseReduce,\n          initFromCollection = arguments.length < 3;\n\n      return func(collection, getIteratee(iteratee, 4), accumulator, initFromCollection, baseEachRight);\n    }\n\n    /**\n     * The opposite of `_.filter`; this method returns the elements of `collection`\n     * that `predicate` does **not** return truthy for.\n     *\n     * @static\n     * @memberOf _\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function|Object|string} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the new filtered array.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36, 'active': false },\n     *   { 'user': 'fred',   'age': 40, 'active': true }\n     * ];\n     *\n     * _.reject(users, function(o) { return !o.active; });\n     * // => objects for ['fred']\n     *\n     * // using the `_.matches` iteratee shorthand\n     * _.reject(users, { 'age': 40, 'active': true });\n     * // => objects for ['barney']\n     *\n     * // using the `_.matchesProperty` iteratee shorthand\n     * _.reject(users, ['active', false]);\n     * // => objects for ['fred']\n     *\n     * // using the `_.property` iteratee shorthand\n     * _.reject(users, 'active');\n     * // => objects for ['barney']\n     */\n    function reject(collection, predicate) {\n      var func = isArray(collection) ? arrayFilter : baseFilter;\n      predicate = getIteratee(predicate, 3);\n      return func(collection, function(value, index, collection) {\n        return !predicate(value, index, collection);\n      });\n    }\n\n    /**\n     * Gets a random element from `collection`.\n     *\n     * @static\n     * @memberOf _\n     * @category Collection\n     * @param {Array|Object} collection The collection to sample.\n     * @returns {*} Returns the random element.\n     * @example\n     *\n     * _.sample([1, 2, 3, 4]);\n     * // => 2\n     */\n    function sample(collection) {\n      var array = isArrayLike(collection) ? collection : values(collection),\n          length = array.length;\n\n      return length > 0 ? array[baseRandom(0, length - 1)] : undefined;\n    }\n\n    /**\n     * Gets `n` random elements from `collection`.\n     *\n     * @static\n     * @memberOf _\n     * @category Collection\n     * @param {Array|Object} collection The collection to sample.\n     * @param {number} [n=0] The number of elements to sample.\n     * @returns {Array} Returns the random elements.\n     * @example\n     *\n     * _.sampleSize([1, 2, 3, 4], 2);\n     * // => [3, 1]\n     */\n    function sampleSize(collection, n) {\n      var index = -1,\n          result = toArray(collection),\n          length = result.length,\n          lastIndex = length - 1;\n\n      n = baseClamp(toInteger(n), 0, length);\n      while (++index < n) {\n        var rand = baseRandom(index, lastIndex),\n            value = result[rand];\n\n        result[rand] = result[index];\n        result[index] = value;\n      }\n      result.length = n;\n      return result;\n    }\n\n    /**\n     * Creates an array of shuffled values, using a version of the\n     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).\n     *\n     * @static\n     * @memberOf _\n     * @category Collection\n     * @param {Array|Object} collection The collection to shuffle.\n     * @returns {Array} Returns the new shuffled array.\n     * @example\n     *\n     * _.shuffle([1, 2, 3, 4]);\n     * // => [4, 1, 3, 2]\n     */\n    function shuffle(collection) {\n      return sampleSize(collection, MAX_ARRAY_LENGTH);\n    }\n\n    /**\n     * Gets the size of `collection` by returning its length for array-like\n     * values or the number of own enumerable properties for objects.\n     *\n     * @static\n     * @memberOf _\n     * @category Collection\n     * @param {Array|Object} collection The collection to inspect.\n     * @returns {number} Returns the collection size.\n     * @example\n     *\n     * _.size([1, 2, 3]);\n     * // => 3\n     *\n     * _.size({ 'a': 1, 'b': 2 });\n     * // => 2\n     *\n     * _.size('pebbles');\n     * // => 7\n     */\n    function size(collection) {\n      if (collection == null) {\n        return 0;\n      }\n      if (isArrayLike(collection)) {\n        var result = collection.length;\n        return (result && isString(collection)) ? stringSize(collection) : result;\n      }\n      return keys(collection).length;\n    }\n\n    /**\n     * Checks if `predicate` returns truthy for **any** element of `collection`.\n     * Iteration is stopped once `predicate` returns truthy. The predicate is\n     * invoked with three arguments: (value, index|key, collection).\n     *\n     * @static\n     * @memberOf _\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function|Object|string} [predicate=_.identity] The function invoked per iteration.\n     * @param- {Object} [guard] Enables use as an iteratee for functions like `_.map`.\n     * @returns {boolean} Returns `true` if any element passes the predicate check, else `false`.\n     * @example\n     *\n     * _.some([null, 0, 'yes', false], Boolean);\n     * // => true\n     *\n     * var users = [\n     *   { 'user': 'barney', 'active': true },\n     *   { 'user': 'fred',   'active': false }\n     * ];\n     *\n     * // using the `_.matches` iteratee shorthand\n     * _.some(users, { 'user': 'barney', 'active': false });\n     * // => false\n     *\n     * // using the `_.matchesProperty` iteratee shorthand\n     * _.some(users, ['active', false]);\n     * // => true\n     *\n     * // using the `_.property` iteratee shorthand\n     * _.some(users, 'active');\n     * // => true\n     */\n    function some(collection, predicate, guard) {\n      var func = isArray(collection) ? arraySome : baseSome;\n      if (guard && isIterateeCall(collection, predicate, guard)) {\n        predicate = undefined;\n      }\n      return func(collection, getIteratee(predicate, 3));\n    }\n\n    /**\n     * Creates an array of elements, sorted in ascending order by the results of\n     * running each element in a collection through each iteratee. This method\n     * performs a stable sort, that is, it preserves the original sort order of\n     * equal elements. The iteratees are invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {...(Function|Function[]|Object|Object[]|string|string[])} [iteratees=[_.identity]]\n     *  The iteratees to sort by, specified individually or in arrays.\n     * @returns {Array} Returns the new sorted array.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'fred',   'age': 48 },\n     *   { 'user': 'barney', 'age': 36 },\n     *   { 'user': 'fred',   'age': 42 },\n     *   { 'user': 'barney', 'age': 34 }\n     * ];\n     *\n     * _.sortBy(users, function(o) { return o.user; });\n     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 42]]\n     *\n     * _.sortBy(users, ['user', 'age']);\n     * // => objects for [['barney', 34], ['barney', 36], ['fred', 42], ['fred', 48]]\n     *\n     * _.sortBy(users, 'user', function(o) {\n     *   return Math.floor(o.age / 10);\n     * });\n     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 42]]\n     */\n    var sortBy = rest(function(collection, iteratees) {\n      if (collection == null) {\n        return [];\n      }\n      var length = iteratees.length;\n      if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {\n        iteratees = [];\n      } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {\n        iteratees.length = 1;\n      }\n      return baseOrderBy(collection, baseFlatten(iteratees), []);\n    });\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Gets the timestamp of the number of milliseconds that have elapsed since\n     * the Unix epoch (1 January 1970 00:00:00 UTC).\n     *\n     * @static\n     * @memberOf _\n     * @type Function\n     * @category Date\n     * @returns {number} Returns the timestamp.\n     * @example\n     *\n     * _.defer(function(stamp) {\n     *   console.log(_.now() - stamp);\n     * }, _.now());\n     * // => logs the number of milliseconds it took for the deferred function to be invoked\n     */\n    var now = Date.now;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * The opposite of `_.before`; this method creates a function that invokes\n     * `func` once it's called `n` or more times.\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {number} n The number of calls before `func` is invoked.\n     * @param {Function} func The function to restrict.\n     * @returns {Function} Returns the new restricted function.\n     * @example\n     *\n     * var saves = ['profile', 'settings'];\n     *\n     * var done = _.after(saves.length, function() {\n     *   console.log('done saving!');\n     * });\n     *\n     * _.forEach(saves, function(type) {\n     *   asyncSave({ 'type': type, 'complete': done });\n     * });\n     * // => logs 'done saving!' after the two async saves have completed\n     */\n    function after(n, func) {\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      n = toInteger(n);\n      return function() {\n        if (--n < 1) {\n          return func.apply(this, arguments);\n        }\n      };\n    }\n\n    /**\n     * Creates a function that accepts up to `n` arguments, ignoring any\n     * additional arguments.\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {Function} func The function to cap arguments for.\n     * @param {number} [n=func.length] The arity cap.\n     * @param- {Object} [guard] Enables use as an iteratee for functions like `_.map`.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * _.map(['6', '8', '10'], _.ary(parseInt, 1));\n     * // => [6, 8, 10]\n     */\n    function ary(func, n, guard) {\n      n = guard ? undefined : n;\n      n = (func && n == null) ? func.length : n;\n      return createWrapper(func, ARY_FLAG, undefined, undefined, undefined, undefined, n);\n    }\n\n    /**\n     * Creates a function that invokes `func`, with the `this` binding and arguments\n     * of the created function, while it's called less than `n` times. Subsequent\n     * calls to the created function return the result of the last `func` invocation.\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {number} n The number of calls at which `func` is no longer invoked.\n     * @param {Function} func The function to restrict.\n     * @returns {Function} Returns the new restricted function.\n     * @example\n     *\n     * jQuery(element).on('click', _.before(5, addContactToList));\n     * // => allows adding up to 4 contacts to the list\n     */\n    function before(n, func) {\n      var result;\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      n = toInteger(n);\n      return function() {\n        if (--n > 0) {\n          result = func.apply(this, arguments);\n        }\n        if (n <= 1) {\n          func = undefined;\n        }\n        return result;\n      };\n    }\n\n    /**\n     * Creates a function that invokes `func` with the `this` binding of `thisArg`\n     * and prepends any additional `_.bind` arguments to those provided to the\n     * bound function.\n     *\n     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,\n     * may be used as a placeholder for partially applied arguments.\n     *\n     * **Note:** Unlike native `Function#bind` this method doesn't set the \"length\"\n     * property of bound functions.\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {Function} func The function to bind.\n     * @param {*} thisArg The `this` binding of `func`.\n     * @param {...*} [partials] The arguments to be partially applied.\n     * @returns {Function} Returns the new bound function.\n     * @example\n     *\n     * var greet = function(greeting, punctuation) {\n     *   return greeting + ' ' + this.user + punctuation;\n     * };\n     *\n     * var object = { 'user': 'fred' };\n     *\n     * var bound = _.bind(greet, object, 'hi');\n     * bound('!');\n     * // => 'hi fred!'\n     *\n     * // using placeholders\n     * var bound = _.bind(greet, object, _, '!');\n     * bound('hi');\n     * // => 'hi fred!'\n     */\n    var bind = rest(function(func, thisArg, partials) {\n      var bitmask = BIND_FLAG;\n      if (partials.length) {\n        var holders = replaceHolders(partials, bind.placeholder);\n        bitmask |= PARTIAL_FLAG;\n      }\n      return createWrapper(func, bitmask, thisArg, partials, holders);\n    });\n\n    /**\n     * Creates a function that invokes the method at `object[key]` and prepends\n     * any additional `_.bindKey` arguments to those provided to the bound function.\n     *\n     * This method differs from `_.bind` by allowing bound functions to reference\n     * methods that may be redefined or don't yet exist.\n     * See [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)\n     * for more details.\n     *\n     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic\n     * builds, may be used as a placeholder for partially applied arguments.\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {Object} object The object to invoke the method on.\n     * @param {string} key The key of the method.\n     * @param {...*} [partials] The arguments to be partially applied.\n     * @returns {Function} Returns the new bound function.\n     * @example\n     *\n     * var object = {\n     *   'user': 'fred',\n     *   'greet': function(greeting, punctuation) {\n     *     return greeting + ' ' + this.user + punctuation;\n     *   }\n     * };\n     *\n     * var bound = _.bindKey(object, 'greet', 'hi');\n     * bound('!');\n     * // => 'hi fred!'\n     *\n     * object.greet = function(greeting, punctuation) {\n     *   return greeting + 'ya ' + this.user + punctuation;\n     * };\n     *\n     * bound('!');\n     * // => 'hiya fred!'\n     *\n     * // using placeholders\n     * var bound = _.bindKey(object, 'greet', _, '!');\n     * bound('hi');\n     * // => 'hiya fred!'\n     */\n    var bindKey = rest(function(object, key, partials) {\n      var bitmask = BIND_FLAG | BIND_KEY_FLAG;\n      if (partials.length) {\n        var holders = replaceHolders(partials, bindKey.placeholder);\n        bitmask |= PARTIAL_FLAG;\n      }\n      return createWrapper(key, bitmask, object, partials, holders);\n    });\n\n    /**\n     * Creates a function that accepts arguments of `func` and either invokes\n     * `func` returning its result, if at least `arity` number of arguments have\n     * been provided, or returns a function that accepts the remaining `func`\n     * arguments, and so on. The arity of `func` may be specified if `func.length`\n     * is not sufficient.\n     *\n     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,\n     * may be used as a placeholder for provided arguments.\n     *\n     * **Note:** This method doesn't set the \"length\" property of curried functions.\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {Function} func The function to curry.\n     * @param {number} [arity=func.length] The arity of `func`.\n     * @param- {Object} [guard] Enables use as an iteratee for functions like `_.map`.\n     * @returns {Function} Returns the new curried function.\n     * @example\n     *\n     * var abc = function(a, b, c) {\n     *   return [a, b, c];\n     * };\n     *\n     * var curried = _.curry(abc);\n     *\n     * curried(1)(2)(3);\n     * // => [1, 2, 3]\n     *\n     * curried(1, 2)(3);\n     * // => [1, 2, 3]\n     *\n     * curried(1, 2, 3);\n     * // => [1, 2, 3]\n     *\n     * // using placeholders\n     * curried(1)(_, 3)(2);\n     * // => [1, 2, 3]\n     */\n    function curry(func, arity, guard) {\n      arity = guard ? undefined : arity;\n      var result = createWrapper(func, CURRY_FLAG, undefined, undefined, undefined, undefined, undefined, arity);\n      result.placeholder = curry.placeholder;\n      return result;\n    }\n\n    /**\n     * This method is like `_.curry` except that arguments are applied to `func`\n     * in the manner of `_.partialRight` instead of `_.partial`.\n     *\n     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic\n     * builds, may be used as a placeholder for provided arguments.\n     *\n     * **Note:** This method doesn't set the \"length\" property of curried functions.\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {Function} func The function to curry.\n     * @param {number} [arity=func.length] The arity of `func`.\n     * @param- {Object} [guard] Enables use as an iteratee for functions like `_.map`.\n     * @returns {Function} Returns the new curried function.\n     * @example\n     *\n     * var abc = function(a, b, c) {\n     *   return [a, b, c];\n     * };\n     *\n     * var curried = _.curryRight(abc);\n     *\n     * curried(3)(2)(1);\n     * // => [1, 2, 3]\n     *\n     * curried(2, 3)(1);\n     * // => [1, 2, 3]\n     *\n     * curried(1, 2, 3);\n     * // => [1, 2, 3]\n     *\n     * // using placeholders\n     * curried(3)(1, _)(2);\n     * // => [1, 2, 3]\n     */\n    function curryRight(func, arity, guard) {\n      arity = guard ? undefined : arity;\n      var result = createWrapper(func, CURRY_RIGHT_FLAG, undefined, undefined, undefined, undefined, undefined, arity);\n      result.placeholder = curryRight.placeholder;\n      return result;\n    }\n\n    /**\n     * Creates a debounced function that delays invoking `func` until after `wait`\n     * milliseconds have elapsed since the last time the debounced function was\n     * invoked. The debounced function comes with a `cancel` method to cancel\n     * delayed `func` invocations and a `flush` method to immediately invoke them.\n     * Provide an options object to indicate whether `func` should be invoked on\n     * the leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n     * with the last arguments provided to the debounced function. Subsequent calls\n     * to the debounced function return the result of the last `func` invocation.\n     *\n     * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked\n     * on the trailing edge of the timeout only if the the debounced function is\n     * invoked more than once during the `wait` timeout.\n     *\n     * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)\n     * for details over the differences between `_.debounce` and `_.throttle`.\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {Function} func The function to debounce.\n     * @param {number} [wait=0] The number of milliseconds to delay.\n     * @param {Object} [options] The options object.\n     * @param {boolean} [options.leading=false] Specify invoking on the leading\n     *  edge of the timeout.\n     * @param {number} [options.maxWait] The maximum time `func` is allowed to be\n     *  delayed before it's invoked.\n     * @param {boolean} [options.trailing=true] Specify invoking on the trailing\n     *  edge of the timeout.\n     * @returns {Function} Returns the new debounced function.\n     * @example\n     *\n     * // avoid costly calculations while the window size is in flux\n     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n     *\n     * // invoke `sendMail` when clicked, debouncing subsequent calls\n     * jQuery(element).on('click', _.debounce(sendMail, 300, {\n     *   'leading': true,\n     *   'trailing': false\n     * }));\n     *\n     * // ensure `batchLog` is invoked once after 1 second of debounced calls\n     * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n     * var source = new EventSource('/stream');\n     * jQuery(source).on('message', debounced);\n     *\n     * // cancel a trailing debounced invocation\n     * jQuery(window).on('popstate', debounced.cancel);\n     */\n    function debounce(func, wait, options) {\n      var args,\n          maxTimeoutId,\n          result,\n          stamp,\n          thisArg,\n          timeoutId,\n          trailingCall,\n          lastCalled = 0,\n          leading = false,\n          maxWait = false,\n          trailing = true;\n\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      wait = toNumber(wait) || 0;\n      if (isObject(options)) {\n        leading = !!options.leading;\n        maxWait = 'maxWait' in options && nativeMax(toNumber(options.maxWait) || 0, wait);\n        trailing = 'trailing' in options ? !!options.trailing : trailing;\n      }\n\n      function cancel() {\n        if (timeoutId) {\n          clearTimeout(timeoutId);\n        }\n        if (maxTimeoutId) {\n          clearTimeout(maxTimeoutId);\n        }\n        lastCalled = 0;\n        args = maxTimeoutId = thisArg = timeoutId = trailingCall = undefined;\n      }\n\n      function complete(isCalled, id) {\n        if (id) {\n          clearTimeout(id);\n        }\n        maxTimeoutId = timeoutId = trailingCall = undefined;\n        if (isCalled) {\n          lastCalled = now();\n          result = func.apply(thisArg, args);\n          if (!timeoutId && !maxTimeoutId) {\n            args = thisArg = undefined;\n          }\n        }\n      }\n\n      function delayed() {\n        var remaining = wait - (now() - stamp);\n        if (remaining <= 0 || remaining > wait) {\n          complete(trailingCall, maxTimeoutId);\n        } else {\n          timeoutId = setTimeout(delayed, remaining);\n        }\n      }\n\n      function flush() {\n        if ((timeoutId && trailingCall) || (maxTimeoutId && trailing)) {\n          result = func.apply(thisArg, args);\n        }\n        cancel();\n        return result;\n      }\n\n      function maxDelayed() {\n        complete(trailing, timeoutId);\n      }\n\n      function debounced() {\n        args = arguments;\n        stamp = now();\n        thisArg = this;\n        trailingCall = trailing && (timeoutId || !leading);\n\n        if (maxWait === false) {\n          var leadingCall = leading && !timeoutId;\n        } else {\n          if (!maxTimeoutId && !leading) {\n            lastCalled = stamp;\n          }\n          var remaining = maxWait - (stamp - lastCalled),\n              isCalled = remaining <= 0 || remaining > maxWait;\n\n          if (isCalled) {\n            if (maxTimeoutId) {\n              maxTimeoutId = clearTimeout(maxTimeoutId);\n            }\n            lastCalled = stamp;\n            result = func.apply(thisArg, args);\n          }\n          else if (!maxTimeoutId) {\n            maxTimeoutId = setTimeout(maxDelayed, remaining);\n          }\n        }\n        if (isCalled && timeoutId) {\n          timeoutId = clearTimeout(timeoutId);\n        }\n        else if (!timeoutId && wait !== maxWait) {\n          timeoutId = setTimeout(delayed, wait);\n        }\n        if (leadingCall) {\n          isCalled = true;\n          result = func.apply(thisArg, args);\n        }\n        if (isCalled && !timeoutId && !maxTimeoutId) {\n          args = thisArg = undefined;\n        }\n        return result;\n      }\n      debounced.cancel = cancel;\n      debounced.flush = flush;\n      return debounced;\n    }\n\n    /**\n     * Defers invoking the `func` until the current call stack has cleared. Any\n     * additional arguments are provided to `func` when it's invoked.\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {Function} func The function to defer.\n     * @param {...*} [args] The arguments to invoke `func` with.\n     * @returns {number} Returns the timer id.\n     * @example\n     *\n     * _.defer(function(text) {\n     *   console.log(text);\n     * }, 'deferred');\n     * // logs 'deferred' after one or more milliseconds\n     */\n    var defer = rest(function(func, args) {\n      return baseDelay(func, 1, args);\n    });\n\n    /**\n     * Invokes `func` after `wait` milliseconds. Any additional arguments are\n     * provided to `func` when it's invoked.\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {Function} func The function to delay.\n     * @param {number} wait The number of milliseconds to delay invocation.\n     * @param {...*} [args] The arguments to invoke `func` with.\n     * @returns {number} Returns the timer id.\n     * @example\n     *\n     * _.delay(function(text) {\n     *   console.log(text);\n     * }, 1000, 'later');\n     * // => logs 'later' after one second\n     */\n    var delay = rest(function(func, wait, args) {\n      return baseDelay(func, toNumber(wait) || 0, args);\n    });\n\n    /**\n     * Creates a function that invokes `func` with arguments reversed.\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {Function} func The function to flip arguments for.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var flipped = _.flip(function() {\n     *   return _.toArray(arguments);\n     * });\n     *\n     * flipped('a', 'b', 'c', 'd');\n     * // => ['d', 'c', 'b', 'a']\n     */\n    function flip(func) {\n      return createWrapper(func, FLIP_FLAG);\n    }\n\n    /**\n     * Creates a function that memoizes the result of `func`. If `resolver` is\n     * provided it determines the cache key for storing the result based on the\n     * arguments provided to the memoized function. By default, the first argument\n     * provided to the memoized function is used as the map cache key. The `func`\n     * is invoked with the `this` binding of the memoized function.\n     *\n     * **Note:** The cache is exposed as the `cache` property on the memoized\n     * function. Its creation may be customized by replacing the `_.memoize.Cache`\n     * constructor with one whose instances implement the [`Map`](http://ecma-international.org/ecma-262/6.0/#sec-properties-of-the-map-prototype-object)\n     * method interface of `delete`, `get`, `has`, and `set`.\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {Function} func The function to have its output memoized.\n     * @param {Function} [resolver] The function to resolve the cache key.\n     * @returns {Function} Returns the new memoizing function.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': 2 };\n     * var other = { 'c': 3, 'd': 4 };\n     *\n     * var values = _.memoize(_.values);\n     * values(object);\n     * // => [1, 2]\n     *\n     * values(other);\n     * // => [3, 4]\n     *\n     * object.a = 2;\n     * values(object);\n     * // => [1, 2]\n     *\n     * // modifying the result cache\n     * values.cache.set(object, ['a', 'b']);\n     * values(object);\n     * // => ['a', 'b']\n     *\n     * // replacing `_.memoize.Cache`\n     * _.memoize.Cache = WeakMap;\n     */\n    function memoize(func, resolver) {\n      if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      var memoized = function() {\n        var args = arguments,\n            key = resolver ? resolver.apply(this, args) : args[0],\n            cache = memoized.cache;\n\n        if (cache.has(key)) {\n          return cache.get(key);\n        }\n        var result = func.apply(this, args);\n        memoized.cache = cache.set(key, result);\n        return result;\n      };\n      memoized.cache = new memoize.Cache;\n      return memoized;\n    }\n\n    /**\n     * Creates a function that negates the result of the predicate `func`. The\n     * `func` predicate is invoked with the `this` binding and arguments of the\n     * created function.\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {Function} predicate The predicate to negate.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * function isEven(n) {\n     *   return n % 2 == 0;\n     * }\n     *\n     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));\n     * // => [1, 3, 5]\n     */\n    function negate(predicate) {\n      if (typeof predicate != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      return function() {\n        return !predicate.apply(this, arguments);\n      };\n    }\n\n    /**\n     * Creates a function that is restricted to invoking `func` once. Repeat calls\n     * to the function return the value of the first invocation. The `func` is\n     * invoked with the `this` binding and arguments of the created function.\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {Function} func The function to restrict.\n     * @returns {Function} Returns the new restricted function.\n     * @example\n     *\n     * var initialize = _.once(createApplication);\n     * initialize();\n     * initialize();\n     * // `initialize` invokes `createApplication` once\n     */\n    function once(func) {\n      return before(2, func);\n    }\n\n    /**\n     * Creates a function that invokes `func` with arguments transformed by\n     * corresponding `transforms`.\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {Function} func The function to wrap.\n     * @param {...(Function|Function[])} [transforms] The functions to transform\n     * arguments, specified individually or in arrays.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * function doubled(n) {\n     *   return n * 2;\n     * }\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * var func = _.overArgs(function(x, y) {\n     *   return [x, y];\n     * }, square, doubled);\n     *\n     * func(9, 3);\n     * // => [81, 6]\n     *\n     * func(10, 5);\n     * // => [100, 10]\n     */\n    var overArgs = rest(function(func, transforms) {\n      transforms = arrayMap(baseFlatten(transforms), getIteratee());\n\n      var funcsLength = transforms.length;\n      return rest(function(args) {\n        var index = -1,\n            length = nativeMin(args.length, funcsLength);\n\n        while (++index < length) {\n          args[index] = transforms[index].call(this, args[index]);\n        }\n        return apply(func, this, args);\n      });\n    });\n\n    /**\n     * Creates a function that invokes `func` with `partial` arguments prepended\n     * to those provided to the new function. This method is like `_.bind` except\n     * it does **not** alter the `this` binding.\n     *\n     * The `_.partial.placeholder` value, which defaults to `_` in monolithic\n     * builds, may be used as a placeholder for partially applied arguments.\n     *\n     * **Note:** This method doesn't set the \"length\" property of partially\n     * applied functions.\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {Function} func The function to partially apply arguments to.\n     * @param {...*} [partials] The arguments to be partially applied.\n     * @returns {Function} Returns the new partially applied function.\n     * @example\n     *\n     * var greet = function(greeting, name) {\n     *   return greeting + ' ' + name;\n     * };\n     *\n     * var sayHelloTo = _.partial(greet, 'hello');\n     * sayHelloTo('fred');\n     * // => 'hello fred'\n     *\n     * // using placeholders\n     * var greetFred = _.partial(greet, _, 'fred');\n     * greetFred('hi');\n     * // => 'hi fred'\n     */\n    var partial = rest(function(func, partials) {\n      var holders = replaceHolders(partials, partial.placeholder);\n      return createWrapper(func, PARTIAL_FLAG, undefined, partials, holders);\n    });\n\n    /**\n     * This method is like `_.partial` except that partially applied arguments\n     * are appended to those provided to the new function.\n     *\n     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic\n     * builds, may be used as a placeholder for partially applied arguments.\n     *\n     * **Note:** This method doesn't set the \"length\" property of partially\n     * applied functions.\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {Function} func The function to partially apply arguments to.\n     * @param {...*} [partials] The arguments to be partially applied.\n     * @returns {Function} Returns the new partially applied function.\n     * @example\n     *\n     * var greet = function(greeting, name) {\n     *   return greeting + ' ' + name;\n     * };\n     *\n     * var greetFred = _.partialRight(greet, 'fred');\n     * greetFred('hi');\n     * // => 'hi fred'\n     *\n     * // using placeholders\n     * var sayHelloTo = _.partialRight(greet, 'hello', _);\n     * sayHelloTo('fred');\n     * // => 'hello fred'\n     */\n    var partialRight = rest(function(func, partials) {\n      var holders = replaceHolders(partials, partialRight.placeholder);\n      return createWrapper(func, PARTIAL_RIGHT_FLAG, undefined, partials, holders);\n    });\n\n    /**\n     * Creates a function that invokes `func` with arguments arranged according\n     * to the specified indexes where the argument value at the first index is\n     * provided as the first argument, the argument value at the second index is\n     * provided as the second argument, and so on.\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {Function} func The function to rearrange arguments for.\n     * @param {...(number|number[])} indexes The arranged argument indexes,\n     *  specified individually or in arrays.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var rearged = _.rearg(function(a, b, c) {\n     *   return [a, b, c];\n     * }, 2, 0, 1);\n     *\n     * rearged('b', 'c', 'a')\n     * // => ['a', 'b', 'c']\n     */\n    var rearg = rest(function(func, indexes) {\n      return createWrapper(func, REARG_FLAG, undefined, undefined, undefined, baseFlatten(indexes));\n    });\n\n    /**\n     * Creates a function that invokes `func` with the `this` binding of the\n     * created function and arguments from `start` and beyond provided as an array.\n     *\n     * **Note:** This method is based on the [rest parameter](https://mdn.io/rest_parameters).\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {Function} func The function to apply a rest parameter to.\n     * @param {number} [start=func.length-1] The start position of the rest parameter.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var say = _.rest(function(what, names) {\n     *   return what + ' ' + _.initial(names).join(', ') +\n     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);\n     * });\n     *\n     * say('hello', 'fred', 'barney', 'pebbles');\n     * // => 'hello fred, barney, & pebbles'\n     */\n    function rest(func, start) {\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      start = nativeMax(start === undefined ? (func.length - 1) : toInteger(start), 0);\n      return function() {\n        var args = arguments,\n            index = -1,\n            length = nativeMax(args.length - start, 0),\n            array = Array(length);\n\n        while (++index < length) {\n          array[index] = args[start + index];\n        }\n        switch (start) {\n          case 0: return func.call(this, array);\n          case 1: return func.call(this, args[0], array);\n          case 2: return func.call(this, args[0], args[1], array);\n        }\n        var otherArgs = Array(start + 1);\n        index = -1;\n        while (++index < start) {\n          otherArgs[index] = args[index];\n        }\n        otherArgs[start] = array;\n        return apply(func, this, otherArgs);\n      };\n    }\n\n    /**\n     * Creates a function that invokes `func` with the `this` binding of the created\n     * function and an array of arguments much like [`Function#apply`](https://es5.github.io/#x15.3.4.3).\n     *\n     * **Note:** This method is based on the [spread operator](https://mdn.io/spread_operator).\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {Function} func The function to spread arguments over.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var say = _.spread(function(who, what) {\n     *   return who + ' says ' + what;\n     * });\n     *\n     * say(['fred', 'hello']);\n     * // => 'fred says hello'\n     *\n     * // with a Promise\n     * var numbers = Promise.all([\n     *   Promise.resolve(40),\n     *   Promise.resolve(36)\n     * ]);\n     *\n     * numbers.then(_.spread(function(x, y) {\n     *   return x + y;\n     * }));\n     * // => a Promise of 76\n     */\n    function spread(func) {\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      return function(array) {\n        return apply(func, this, array);\n      };\n    }\n\n    /**\n     * Creates a throttled function that only invokes `func` at most once per\n     * every `wait` milliseconds. The throttled function comes with a `cancel`\n     * method to cancel delayed `func` invocations and a `flush` method to\n     * immediately invoke them. Provide an options object to indicate whether\n     * `func` should be invoked on the leading and/or trailing edge of the `wait`\n     * timeout. The `func` is invoked with the last arguments provided to the\n     * throttled function. Subsequent calls to the throttled function return the\n     * result of the last `func` invocation.\n     *\n     * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked\n     * on the trailing edge of the timeout only if the the throttled function is\n     * invoked more than once during the `wait` timeout.\n     *\n     * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)\n     * for details over the differences between `_.throttle` and `_.debounce`.\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {Function} func The function to throttle.\n     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.\n     * @param {Object} [options] The options object.\n     * @param {boolean} [options.leading=true] Specify invoking on the leading\n     *  edge of the timeout.\n     * @param {boolean} [options.trailing=true] Specify invoking on the trailing\n     *  edge of the timeout.\n     * @returns {Function} Returns the new throttled function.\n     * @example\n     *\n     * // avoid excessively updating the position while scrolling\n     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));\n     *\n     * // invoke `renewToken` when the click event is fired, but not more than once every 5 minutes\n     * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });\n     * jQuery(element).on('click', throttled);\n     *\n     * // cancel a trailing throttled invocation\n     * jQuery(window).on('popstate', throttled.cancel);\n     */\n    function throttle(func, wait, options) {\n      var leading = true,\n          trailing = true;\n\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      if (isObject(options)) {\n        leading = 'leading' in options ? !!options.leading : leading;\n        trailing = 'trailing' in options ? !!options.trailing : trailing;\n      }\n      return debounce(func, wait, { 'leading': leading, 'maxWait': wait, 'trailing': trailing });\n    }\n\n    /**\n     * Creates a function that accepts up to one argument, ignoring any\n     * additional arguments.\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {Function} func The function to cap arguments for.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * _.map(['6', '8', '10'], _.unary(parseInt));\n     * // => [6, 8, 10]\n     */\n    function unary(func) {\n      return ary(func, 1);\n    }\n\n    /**\n     * Creates a function that provides `value` to the wrapper function as its\n     * first argument. Any additional arguments provided to the function are\n     * appended to those provided to the wrapper function. The wrapper is invoked\n     * with the `this` binding of the created function.\n     *\n     * @static\n     * @memberOf _\n     * @category Function\n     * @param {*} value The value to wrap.\n     * @param {Function} wrapper The wrapper function.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var p = _.wrap(_.escape, function(func, text) {\n     *   return '<p>' + func(text) + '</p>';\n     * });\n     *\n     * p('fred, barney, & pebbles');\n     * // => '<p>fred, barney, &amp; pebbles</p>'\n     */\n    function wrap(value, wrapper) {\n      wrapper = wrapper == null ? identity : wrapper;\n      return partial(wrapper, value);\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a shallow clone of `value`.\n     *\n     * **Note:** This method is loosely based on the\n     * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)\n     * and supports cloning arrays, array buffers, booleans, date objects, maps,\n     * numbers, `Object` objects, regexes, sets, strings, symbols, and typed\n     * arrays. The own enumerable properties of `arguments` objects are cloned\n     * as plain objects. An empty object is returned for uncloneable values such\n     * as error objects, functions, DOM nodes, and WeakMaps.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to clone.\n     * @returns {*} Returns the cloned value.\n     * @example\n     *\n     * var objects = [{ 'a': 1 }, { 'b': 2 }];\n     *\n     * var shallow = _.clone(objects);\n     * console.log(shallow[0] === objects[0]);\n     * // => true\n     */\n    function clone(value) {\n      return baseClone(value);\n    }\n\n    /**\n     * This method is like `_.clone` except that it accepts `customizer` which\n     * is invoked to produce the cloned value. If `customizer` returns `undefined`\n     * cloning is handled by the method instead. The `customizer` is invoked with\n     * up to five arguments; (value [, index|key, object, stack]).\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to clone.\n     * @param {Function} [customizer] The function to customize cloning.\n     * @returns {*} Returns the cloned value.\n     * @example\n     *\n     * function customizer(value) {\n     *   if (_.isElement(value)) {\n     *     return value.cloneNode(false);\n     *   }\n     * }\n     *\n     * var el = _.clone(document.body, customizer);\n     *\n     * console.log(el === document.body);\n     * // => false\n     * console.log(el.nodeName);\n     * // => 'BODY'\n     * console.log(el.childNodes.length);\n     * // => 0\n     */\n    function cloneWith(value, customizer) {\n      return baseClone(value, false, customizer);\n    }\n\n    /**\n     * This method is like `_.clone` except that it recursively clones `value`.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to recursively clone.\n     * @returns {*} Returns the deep cloned value.\n     * @example\n     *\n     * var objects = [{ 'a': 1 }, { 'b': 2 }];\n     *\n     * var deep = _.cloneDeep(objects);\n     * console.log(deep[0] === objects[0]);\n     * // => false\n     */\n    function cloneDeep(value) {\n      return baseClone(value, true);\n    }\n\n    /**\n     * This method is like `_.cloneWith` except that it recursively clones `value`.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to recursively clone.\n     * @param {Function} [customizer] The function to customize cloning.\n     * @returns {*} Returns the deep cloned value.\n     * @example\n     *\n     * function customizer(value) {\n     *   if (_.isElement(value)) {\n     *     return value.cloneNode(true);\n     *   }\n     * }\n     *\n     * var el = _.cloneDeep(document.body, customizer);\n     *\n     * console.log(el === document.body);\n     * // => false\n     * console.log(el.nodeName);\n     * // => 'BODY'\n     * console.log(el.childNodes.length);\n     * // => 20\n     */\n    function cloneDeepWith(value, customizer) {\n      return baseClone(value, true, customizer);\n    }\n\n    /**\n     * Performs a [`SameValueZero`](http://ecma-international.org/ecma-262/6.0/#sec-samevaluezero)\n     * comparison between two values to determine if they are equivalent.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n     * @example\n     *\n     * var object = { 'user': 'fred' };\n     * var other = { 'user': 'fred' };\n     *\n     * _.eq(object, object);\n     * // => true\n     *\n     * _.eq(object, other);\n     * // => false\n     *\n     * _.eq('a', 'a');\n     * // => true\n     *\n     * _.eq('a', Object('a'));\n     * // => false\n     *\n     * _.eq(NaN, NaN);\n     * // => true\n     */\n    function eq(value, other) {\n      return value === other || (value !== value && other !== other);\n    }\n\n    /**\n     * Checks if `value` is greater than `other`.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is greater than `other`, else `false`.\n     * @example\n     *\n     * _.gt(3, 1);\n     * // => true\n     *\n     * _.gt(3, 3);\n     * // => false\n     *\n     * _.gt(1, 3);\n     * // => false\n     */\n    function gt(value, other) {\n      return value > other;\n    }\n\n    /**\n     * Checks if `value` is greater than or equal to `other`.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is greater than or equal to `other`, else `false`.\n     * @example\n     *\n     * _.gte(3, 1);\n     * // => true\n     *\n     * _.gte(3, 3);\n     * // => true\n     *\n     * _.gte(1, 3);\n     * // => false\n     */\n    function gte(value, other) {\n      return value >= other;\n    }\n\n    /**\n     * Checks if `value` is likely an `arguments` object.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n     * @example\n     *\n     * _.isArguments(function() { return arguments; }());\n     * // => true\n     *\n     * _.isArguments([1, 2, 3]);\n     * // => false\n     */\n    function isArguments(value) {\n      // Safari 8.1 incorrectly makes `arguments.callee` enumerable in strict mode.\n      return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&\n        (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);\n    }\n\n    /**\n     * Checks if `value` is classified as an `Array` object.\n     *\n     * @static\n     * @memberOf _\n     * @type Function\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n     * @example\n     *\n     * _.isArray([1, 2, 3]);\n     * // => true\n     *\n     * _.isArray(document.body.children);\n     * // => false\n     *\n     * _.isArray('abc');\n     * // => false\n     *\n     * _.isArray(_.noop);\n     * // => false\n     */\n    var isArray = Array.isArray;\n\n    /**\n     * Checks if `value` is array-like. A value is considered array-like if it's\n     * not a function and has a `value.length` that's an integer greater than or\n     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n     *\n     * @static\n     * @memberOf _\n     * @type Function\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n     * @example\n     *\n     * _.isArrayLike([1, 2, 3]);\n     * // => true\n     *\n     * _.isArrayLike(document.body.children);\n     * // => true\n     *\n     * _.isArrayLike('abc');\n     * // => true\n     *\n     * _.isArrayLike(_.noop);\n     * // => false\n     */\n    function isArrayLike(value) {\n      return value != null &&\n        !(typeof value == 'function' && isFunction(value)) && isLength(getLength(value));\n    }\n\n    /**\n     * This method is like `_.isArrayLike` except that it also checks if `value`\n     * is an object.\n     *\n     * @static\n     * @memberOf _\n     * @type Function\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an array-like object, else `false`.\n     * @example\n     *\n     * _.isArrayLikeObject([1, 2, 3]);\n     * // => true\n     *\n     * _.isArrayLikeObject(document.body.children);\n     * // => true\n     *\n     * _.isArrayLikeObject('abc');\n     * // => false\n     *\n     * _.isArrayLikeObject(_.noop);\n     * // => false\n     */\n    function isArrayLikeObject(value) {\n      return isObjectLike(value) && isArrayLike(value);\n    }\n\n    /**\n     * Checks if `value` is classified as a boolean primitive or object.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n     * @example\n     *\n     * _.isBoolean(false);\n     * // => true\n     *\n     * _.isBoolean(null);\n     * // => false\n     */\n    function isBoolean(value) {\n      return value === true || value === false ||\n        (isObjectLike(value) && objectToString.call(value) == boolTag);\n    }\n\n    /**\n     * Checks if `value` is classified as a `Date` object.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n     * @example\n     *\n     * _.isDate(new Date);\n     * // => true\n     *\n     * _.isDate('Mon April 23 2012');\n     * // => false\n     */\n    function isDate(value) {\n      return isObjectLike(value) && objectToString.call(value) == dateTag;\n    }\n\n    /**\n     * Checks if `value` is likely a DOM element.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.\n     * @example\n     *\n     * _.isElement(document.body);\n     * // => true\n     *\n     * _.isElement('<body>');\n     * // => false\n     */\n    function isElement(value) {\n      return !!value && value.nodeType === 1 && isObjectLike(value) && !isPlainObject(value);\n    }\n\n    /**\n     * Checks if `value` is empty. A value is considered empty unless it's an\n     * `arguments` object, array, string, or jQuery-like collection with a length\n     * greater than `0` or an object with own enumerable properties.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {Array|Object|string} value The value to inspect.\n     * @returns {boolean} Returns `true` if `value` is empty, else `false`.\n     * @example\n     *\n     * _.isEmpty(null);\n     * // => true\n     *\n     * _.isEmpty(true);\n     * // => true\n     *\n     * _.isEmpty(1);\n     * // => true\n     *\n     * _.isEmpty([1, 2, 3]);\n     * // => false\n     *\n     * _.isEmpty({ 'a': 1 });\n     * // => false\n     */\n    function isEmpty(value) {\n      return (!isObjectLike(value) || isFunction(value.splice))\n        ? !size(value)\n        : !keys(value).length;\n    }\n\n    /**\n     * Performs a deep comparison between two values to determine if they are\n     * equivalent.\n     *\n     * **Note:** This method supports comparing arrays, array buffers, booleans,\n     * date objects, error objects, maps, numbers, `Object` objects, regexes,\n     * sets, strings, symbols, and typed arrays. `Object` objects are compared\n     * by their own, not inherited, enumerable properties. Functions and DOM\n     * nodes are **not** supported.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n     * @example\n     *\n     * var object = { 'user': 'fred' };\n     * var other = { 'user': 'fred' };\n     *\n     * _.isEqual(object, other);\n     * // => true\n     *\n     * object === other;\n     * // => false\n     */\n    function isEqual(value, other) {\n      return baseIsEqual(value, other);\n    }\n\n    /**\n     * This method is like `_.isEqual` except that it accepts `customizer` which is\n     * invoked to compare values. If `customizer` returns `undefined` comparisons are\n     * handled by the method instead. The `customizer` is invoked with up to seven arguments:\n     * (objValue, othValue [, index|key, object, other, stack]).\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @param {Function} [customizer] The function to customize comparisons.\n     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n     * @example\n     *\n     * function isGreeting(value) {\n     *   return /^h(?:i|ello)$/.test(value);\n     * }\n     *\n     * function customizer(objValue, othValue) {\n     *   if (isGreeting(objValue) && isGreeting(othValue)) {\n     *     return true;\n     *   }\n     * }\n     *\n     * var array = ['hello', 'goodbye'];\n     * var other = ['hi', 'goodbye'];\n     *\n     * _.isEqualWith(array, other, customizer);\n     * // => true\n     */\n    function isEqualWith(value, other, customizer) {\n      customizer = typeof customizer == 'function' ? customizer : undefined;\n      var result = customizer ? customizer(value, other) : undefined;\n      return result === undefined ? baseIsEqual(value, other, customizer) : !!result;\n    }\n\n    /**\n     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,\n     * `SyntaxError`, `TypeError`, or `URIError` object.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.\n     * @example\n     *\n     * _.isError(new Error);\n     * // => true\n     *\n     * _.isError(Error);\n     * // => false\n     */\n    function isError(value) {\n      return isObjectLike(value) &&\n        typeof value.message == 'string' && objectToString.call(value) == errorTag;\n    }\n\n    /**\n     * Checks if `value` is a finite primitive number.\n     *\n     * **Note:** This method is based on [`Number.isFinite`](https://mdn.io/Number/isFinite).\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.\n     * @example\n     *\n     * _.isFinite(3);\n     * // => true\n     *\n     * _.isFinite(Number.MAX_VALUE);\n     * // => true\n     *\n     * _.isFinite(3.14);\n     * // => true\n     *\n     * _.isFinite(Infinity);\n     * // => false\n     */\n    function isFinite(value) {\n      return typeof value == 'number' && nativeIsFinite(value);\n    }\n\n    /**\n     * Checks if `value` is classified as a `Function` object.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n     * @example\n     *\n     * _.isFunction(_);\n     * // => true\n     *\n     * _.isFunction(/abc/);\n     * // => false\n     */\n    function isFunction(value) {\n      // The use of `Object#toString` avoids issues with the `typeof` operator\n      // in Safari 8 which returns 'object' for typed array constructors, and\n      // PhantomJS 1.9 which returns 'function' for `NodeList` instances.\n      var tag = isObject(value) ? objectToString.call(value) : '';\n      return tag == funcTag || tag == genTag;\n    }\n\n    /**\n     * Checks if `value` is an integer.\n     *\n     * **Note:** This method is based on [`Number.isInteger`](https://mdn.io/Number/isInteger).\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an integer, else `false`.\n     * @example\n     *\n     * _.isInteger(3);\n     * // => true\n     *\n     * _.isInteger(Number.MIN_VALUE);\n     * // => false\n     *\n     * _.isInteger(Infinity);\n     * // => false\n     *\n     * _.isInteger('3');\n     * // => false\n     */\n    function isInteger(value) {\n      return typeof value == 'number' && value == toInteger(value);\n    }\n\n    /**\n     * Checks if `value` is a valid array-like length.\n     *\n     * **Note:** This function is loosely based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n     * @example\n     *\n     * _.isLength(3);\n     * // => true\n     *\n     * _.isLength(Number.MIN_VALUE);\n     * // => false\n     *\n     * _.isLength(Infinity);\n     * // => false\n     *\n     * _.isLength('3');\n     * // => false\n     */\n    function isLength(value) {\n      return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n    }\n\n    /**\n     * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.\n     * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n     * @example\n     *\n     * _.isObject({});\n     * // => true\n     *\n     * _.isObject([1, 2, 3]);\n     * // => true\n     *\n     * _.isObject(_.noop);\n     * // => true\n     *\n     * _.isObject(null);\n     * // => false\n     */\n    function isObject(value) {\n      // Avoid a V8 JIT bug in Chrome 19-20.\n      // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n      var type = typeof value;\n      return !!value && (type == 'object' || type == 'function');\n    }\n\n    /**\n     * Checks if `value` is object-like. A value is object-like if it's not `null`\n     * and has a `typeof` result of \"object\".\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n     * @example\n     *\n     * _.isObjectLike({});\n     * // => true\n     *\n     * _.isObjectLike([1, 2, 3]);\n     * // => true\n     *\n     * _.isObjectLike(_.noop);\n     * // => false\n     *\n     * _.isObjectLike(null);\n     * // => false\n     */\n    function isObjectLike(value) {\n      return !!value && typeof value == 'object';\n    }\n\n    /**\n     * Performs a deep comparison between `object` and `source` to determine if\n     * `object` contains equivalent property values.\n     *\n     * **Note:** This method supports comparing the same values as `_.isEqual`.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {Object} object The object to inspect.\n     * @param {Object} source The object of property values to match.\n     * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n     * @example\n     *\n     * var object = { 'user': 'fred', 'age': 40 };\n     *\n     * _.isMatch(object, { 'age': 40 });\n     * // => true\n     *\n     * _.isMatch(object, { 'age': 36 });\n     * // => false\n     */\n    function isMatch(object, source) {\n      return object === source || baseIsMatch(object, source, getMatchData(source));\n    }\n\n    /**\n     * This method is like `_.isMatch` except that it accepts `customizer` which\n     * is invoked to compare values. If `customizer` returns `undefined` comparisons\n     * are handled by the method instead. The `customizer` is invoked with three\n     * arguments: (objValue, srcValue, index|key, object, source).\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {Object} object The object to inspect.\n     * @param {Object} source The object of property values to match.\n     * @param {Function} [customizer] The function to customize comparisons.\n     * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n     * @example\n     *\n     * function isGreeting(value) {\n     *   return /^h(?:i|ello)$/.test(value);\n     * }\n     *\n     * function customizer(objValue, srcValue) {\n     *   if (isGreeting(objValue) && isGreeting(srcValue)) {\n     *     return true;\n     *   }\n     * }\n     *\n     * var object = { 'greeting': 'hello' };\n     * var source = { 'greeting': 'hi' };\n     *\n     * _.isMatchWith(object, source, customizer);\n     * // => true\n     */\n    function isMatchWith(object, source, customizer) {\n      customizer = typeof customizer == 'function' ? customizer : undefined;\n      return baseIsMatch(object, source, getMatchData(source), customizer);\n    }\n\n    /**\n     * Checks if `value` is `NaN`.\n     *\n     * **Note:** This method is not the same as [`isNaN`](https://es5.github.io/#x15.1.2.4)\n     * which returns `true` for `undefined` and other non-numeric values.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.\n     * @example\n     *\n     * _.isNaN(NaN);\n     * // => true\n     *\n     * _.isNaN(new Number(NaN));\n     * // => true\n     *\n     * isNaN(undefined);\n     * // => true\n     *\n     * _.isNaN(undefined);\n     * // => false\n     */\n    function isNaN(value) {\n      // An `NaN` primitive is the only value that is not equal to itself.\n      // Perform the `toStringTag` check first to avoid errors with some ActiveX objects in IE.\n      return isNumber(value) && value != +value;\n    }\n\n    /**\n     * Checks if `value` is a native function.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a native function, else `false`.\n     * @example\n     *\n     * _.isNative(Array.prototype.push);\n     * // => true\n     *\n     * _.isNative(_);\n     * // => false\n     */\n    function isNative(value) {\n      if (value == null) {\n        return false;\n      }\n      if (isFunction(value)) {\n        return reIsNative.test(funcToString.call(value));\n      }\n      return isObjectLike(value) &&\n        (isHostObject(value) ? reIsNative : reIsHostCtor).test(value);\n    }\n\n    /**\n     * Checks if `value` is `null`.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.\n     * @example\n     *\n     * _.isNull(null);\n     * // => true\n     *\n     * _.isNull(void 0);\n     * // => false\n     */\n    function isNull(value) {\n      return value === null;\n    }\n\n    /**\n     * Checks if `value` is `null` or `undefined`.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is nullish, else `false`.\n     * @example\n     *\n     * _.isNil(null);\n     * // => true\n     *\n     * _.isNil(void 0);\n     * // => true\n     *\n     * _.isNil(NaN);\n     * // => false\n     */\n    function isNil(value) {\n      return value == null;\n    }\n\n    /**\n     * Checks if `value` is classified as a `Number` primitive or object.\n     *\n     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are classified\n     * as numbers, use the `_.isFinite` method.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n     * @example\n     *\n     * _.isNumber(3);\n     * // => true\n     *\n     * _.isNumber(Number.MIN_VALUE);\n     * // => true\n     *\n     * _.isNumber(Infinity);\n     * // => true\n     *\n     * _.isNumber('3');\n     * // => false\n     */\n    function isNumber(value) {\n      return typeof value == 'number' ||\n        (isObjectLike(value) && objectToString.call(value) == numberTag);\n    }\n\n    /**\n     * Checks if `value` is a plain object, that is, an object created by the\n     * `Object` constructor or one with a `[[Prototype]]` of `null`.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     * }\n     *\n     * _.isPlainObject(new Foo);\n     * // => false\n     *\n     * _.isPlainObject([1, 2, 3]);\n     * // => false\n     *\n     * _.isPlainObject({ 'x': 0, 'y': 0 });\n     * // => true\n     *\n     * _.isPlainObject(Object.create(null));\n     * // => true\n     */\n    function isPlainObject(value) {\n      if (!isObjectLike(value) || objectToString.call(value) != objectTag || isHostObject(value)) {\n        return false;\n      }\n      var proto = objectProto;\n      if (typeof value.constructor == 'function') {\n        proto = getPrototypeOf(value);\n      }\n      if (proto === null) {\n        return true;\n      }\n      var Ctor = proto.constructor;\n      return (typeof Ctor == 'function' &&\n        Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString);\n    }\n\n    /**\n     * Checks if `value` is classified as a `RegExp` object.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n     * @example\n     *\n     * _.isRegExp(/abc/);\n     * // => true\n     *\n     * _.isRegExp('/abc/');\n     * // => false\n     */\n    function isRegExp(value) {\n      return isObject(value) && objectToString.call(value) == regexpTag;\n    }\n\n    /**\n     * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754\n     * double precision number which isn't the result of a rounded unsafe integer.\n     *\n     * **Note:** This method is based on [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.\n     * @example\n     *\n     * _.isSafeInteger(3);\n     * // => true\n     *\n     * _.isSafeInteger(Number.MIN_VALUE);\n     * // => false\n     *\n     * _.isSafeInteger(Infinity);\n     * // => false\n     *\n     * _.isSafeInteger('3');\n     * // => false\n     */\n    function isSafeInteger(value) {\n      return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;\n    }\n\n    /**\n     * Checks if `value` is classified as a `String` primitive or object.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n     * @example\n     *\n     * _.isString('abc');\n     * // => true\n     *\n     * _.isString(1);\n     * // => false\n     */\n    function isString(value) {\n      return typeof value == 'string' ||\n        (!isArray(value) && isObjectLike(value) && objectToString.call(value) == stringTag);\n    }\n\n    /**\n     * Checks if `value` is classified as a `Symbol` primitive or object.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n     * @example\n     *\n     * _.isSymbol(Symbol.iterator);\n     * // => true\n     *\n     * _.isSymbol('abc');\n     * // => false\n     */\n    function isSymbol(value) {\n      return typeof value == 'symbol' ||\n        (isObjectLike(value) && objectToString.call(value) == symbolTag);\n    }\n\n    /**\n     * Checks if `value` is classified as a typed array.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n     * @example\n     *\n     * _.isTypedArray(new Uint8Array);\n     * // => true\n     *\n     * _.isTypedArray([]);\n     * // => false\n     */\n    function isTypedArray(value) {\n      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objectToString.call(value)];\n    }\n\n    /**\n     * Checks if `value` is `undefined`.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.\n     * @example\n     *\n     * _.isUndefined(void 0);\n     * // => true\n     *\n     * _.isUndefined(null);\n     * // => false\n     */\n    function isUndefined(value) {\n      return value === undefined;\n    }\n\n    /**\n     * Checks if `value` is less than `other`.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is less than `other`, else `false`.\n     * @example\n     *\n     * _.lt(1, 3);\n     * // => true\n     *\n     * _.lt(3, 3);\n     * // => false\n     *\n     * _.lt(3, 1);\n     * // => false\n     */\n    function lt(value, other) {\n      return value < other;\n    }\n\n    /**\n     * Checks if `value` is less than or equal to `other`.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is less than or equal to `other`, else `false`.\n     * @example\n     *\n     * _.lte(1, 3);\n     * // => true\n     *\n     * _.lte(3, 3);\n     * // => true\n     *\n     * _.lte(3, 1);\n     * // => false\n     */\n    function lte(value, other) {\n      return value <= other;\n    }\n\n    /**\n     * Converts `value` to an array.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {Array} Returns the converted array.\n     * @example\n     *\n     * _.toArray({ 'a': 1, 'b': 2 });\n     * // => [1, 2]\n     *\n     * _.toArray('abc');\n     * // => ['a', 'b', 'c']\n     *\n     * _.toArray(1);\n     * // => []\n     *\n     * _.toArray(null);\n     * // => []\n     */\n    function toArray(value) {\n      if (!value) {\n        return [];\n      }\n      if (isArrayLike(value)) {\n        return isString(value) ? stringToArray(value) : copyArray(value);\n      }\n      if (iteratorSymbol && value[iteratorSymbol]) {\n        return iteratorToArray(value[iteratorSymbol]());\n      }\n      var tag = getTag(value),\n          func = tag == mapTag ? mapToArray : (tag == setTag ? setToArray : values);\n\n      return func(value);\n    }\n\n    /**\n     * Converts `value` to an integer.\n     *\n     * **Note:** This function is loosely based on [`ToInteger`](http://www.ecma-international.org/ecma-262/6.0/#sec-tointeger).\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {number} Returns the converted integer.\n     * @example\n     *\n     * _.toInteger(3);\n     * // => 3\n     *\n     * _.toInteger(Number.MIN_VALUE);\n     * // => 0\n     *\n     * _.toInteger(Infinity);\n     * // => 1.7976931348623157e+308\n     *\n     * _.toInteger('3');\n     * // => 3\n     */\n    function toInteger(value) {\n      if (!value) {\n        return value === 0 ? value : 0;\n      }\n      value = toNumber(value);\n      if (value === INFINITY || value === -INFINITY) {\n        var sign = (value < 0 ? -1 : 1);\n        return sign * MAX_INTEGER;\n      }\n      var remainder = value % 1;\n      return value === value ? (remainder ? value - remainder : value) : 0;\n    }\n\n    /**\n     * Converts `value` to an integer suitable for use as the length of an\n     * array-like object.\n     *\n     * **Note:** This method is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @return {number} Returns the converted integer.\n     * @example\n     *\n     * _.toLength(3);\n     * // => 3\n     *\n     * _.toLength(Number.MIN_VALUE);\n     * // => 0\n     *\n     * _.toLength(Infinity);\n     * // => 4294967295\n     *\n     * _.toLength('3');\n     * // => 3\n     */\n    function toLength(value) {\n      return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;\n    }\n\n    /**\n     * Converts `value` to a number.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to process.\n     * @returns {number} Returns the number.\n     * @example\n     *\n     * _.toNumber(3);\n     * // => 3\n     *\n     * _.toNumber(Number.MIN_VALUE);\n     * // => 5e-324\n     *\n     * _.toNumber(Infinity);\n     * // => Infinity\n     *\n     * _.toNumber('3');\n     * // => 3\n     */\n    function toNumber(value) {\n      if (isObject(value)) {\n        var other = isFunction(value.valueOf) ? value.valueOf() : value;\n        value = isObject(other) ? (other + '') : other;\n      }\n      if (typeof value != 'string') {\n        return value === 0 ? value : +value;\n      }\n      value = value.replace(reTrim, '');\n      var isBinary = reIsBinary.test(value);\n      return (isBinary || reIsOctal.test(value))\n        ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n        : (reIsBadHex.test(value) ? NAN : +value);\n    }\n\n    /**\n     * Converts `value` to a plain object flattening inherited enumerable\n     * properties of `value` to own properties of the plain object.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {Object} Returns the converted plain object.\n     * @example\n     *\n     * function Foo() {\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.assign({ 'a': 1 }, new Foo);\n     * // => { 'a': 1, 'b': 2 }\n     *\n     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));\n     * // => { 'a': 1, 'b': 2, 'c': 3 }\n     */\n    function toPlainObject(value) {\n      return copyObject(value, keysIn(value));\n    }\n\n    /**\n     * Converts `value` to a safe integer. A safe integer can be compared and\n     * represented correctly.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {number} Returns the converted integer.\n     * @example\n     *\n     * _.toSafeInteger(3);\n     * // => 3\n     *\n     * _.toSafeInteger(Number.MIN_VALUE);\n     * // => 0\n     *\n     * _.toSafeInteger(Infinity);\n     * // => 9007199254740991\n     *\n     * _.toSafeInteger('3');\n     * // => 3\n     */\n    function toSafeInteger(value) {\n      return baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);\n    }\n\n    /**\n     * Converts `value` to a string if it's not one. An empty string is returned\n     * for `null` and `undefined` values. The sign of `-0` is preserved.\n     *\n     * @static\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to process.\n     * @returns {string} Returns the string.\n     * @example\n     *\n     * _.toString(null);\n     * // => ''\n     *\n     * _.toString(-0);\n     * // => '-0'\n     *\n     * _.toString([1, 2, 3]);\n     * // => '1,2,3'\n     */\n    function toString(value) {\n      // Exit early for strings to avoid a performance hit in some environments.\n      if (typeof value == 'string') {\n        return value;\n      }\n      if (value == null) {\n        return '';\n      }\n      if (isSymbol(value)) {\n        return _Symbol ? symbolToString.call(value) : '';\n      }\n      var result = (value + '');\n      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Assigns own enumerable properties of source objects to the destination\n     * object. Source objects are applied from left to right. Subsequent sources\n     * overwrite property assignments of previous sources.\n     *\n     * **Note:** This method mutates `object` and is loosely based on\n     * [`Object.assign`](https://mdn.io/Object/assign).\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} [sources] The source objects.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * function Foo() {\n     *   this.c = 3;\n     * }\n     *\n     * function Bar() {\n     *   this.e = 5;\n     * }\n     *\n     * Foo.prototype.d = 4;\n     * Bar.prototype.f = 6;\n     *\n     * _.assign({ 'a': 1 }, new Foo, new Bar);\n     * // => { 'a': 1, 'c': 3, 'e': 5 }\n     */\n    var assign = createAssigner(function(object, source) {\n      copyObject(source, keys(source), object);\n    });\n\n    /**\n     * This method is like `_.assign` except that it iterates over own and\n     * inherited source properties.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @alias extend\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} [sources] The source objects.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * function Foo() {\n     *   this.b = 2;\n     * }\n     *\n     * function Bar() {\n     *   this.d = 4;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     * Bar.prototype.e = 5;\n     *\n     * _.assignIn({ 'a': 1 }, new Foo, new Bar);\n     * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5 }\n     */\n    var assignIn = createAssigner(function(object, source) {\n      copyObject(source, keysIn(source), object);\n    });\n\n    /**\n     * This method is like `_.assignIn` except that it accepts `customizer` which\n     * is invoked to produce the assigned values. If `customizer` returns `undefined`\n     * assignment is handled by the method instead. The `customizer` is invoked\n     * with five arguments: (objValue, srcValue, key, object, source).\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @alias extendWith\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} sources The source objects.\n     * @param {Function} [customizer] The function to customize assigned values.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * function customizer(objValue, srcValue) {\n     *   return _.isUndefined(objValue) ? srcValue : objValue;\n     * }\n     *\n     * var defaults = _.partialRight(_.assignInWith, customizer);\n     *\n     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });\n     * // => { 'a': 1, 'b': 2 }\n     */\n    var assignInWith = createAssigner(function(object, source, customizer) {\n      copyObjectWith(source, keysIn(source), object, customizer);\n    });\n\n    /**\n     * This method is like `_.assign` except that it accepts `customizer` which\n     * is invoked to produce the assigned values. If `customizer` returns `undefined`\n     * assignment is handled by the method instead. The `customizer` is invoked\n     * with five arguments: (objValue, srcValue, key, object, source).\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} sources The source objects.\n     * @param {Function} [customizer] The function to customize assigned values.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * function customizer(objValue, srcValue) {\n     *   return _.isUndefined(objValue) ? srcValue : objValue;\n     * }\n     *\n     * var defaults = _.partialRight(_.assignWith, customizer);\n     *\n     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });\n     * // => { 'a': 1, 'b': 2 }\n     */\n    var assignWith = createAssigner(function(object, source, customizer) {\n      copyObjectWith(source, keys(source), object, customizer);\n    });\n\n    /**\n     * Creates an array of values corresponding to `paths` of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {...(string|string[])} [paths] The property paths of elements to pick,\n     *  specified individually or in arrays.\n     * @returns {Array} Returns the new array of picked elements.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };\n     *\n     * _.at(object, ['a[0].b.c', 'a[1]']);\n     * // => [3, 4]\n     *\n     * _.at(['a', 'b', 'c'], 0, 2);\n     * // => ['a', 'c']\n     */\n    var at = rest(function(object, paths) {\n      return baseAt(object, baseFlatten(paths));\n    });\n\n    /**\n     * Creates an object that inherits from the `prototype` object. If a `properties`\n     * object is provided its own enumerable properties are assigned to the created object.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} prototype The object to inherit from.\n     * @param {Object} [properties] The properties to assign to the object.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * function Shape() {\n     *   this.x = 0;\n     *   this.y = 0;\n     * }\n     *\n     * function Circle() {\n     *   Shape.call(this);\n     * }\n     *\n     * Circle.prototype = _.create(Shape.prototype, {\n     *   'constructor': Circle\n     * });\n     *\n     * var circle = new Circle;\n     * circle instanceof Circle;\n     * // => true\n     *\n     * circle instanceof Shape;\n     * // => true\n     */\n    function create(prototype, properties) {\n      var result = baseCreate(prototype);\n      return properties ? baseAssign(result, properties) : result;\n    }\n\n    /**\n     * Assigns own and inherited enumerable properties of source objects to the\n     * destination object for all destination properties that resolve to `undefined`.\n     * Source objects are applied from left to right. Once a property is set,\n     * additional values of the same property are ignored.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} [sources] The source objects.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * _.defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });\n     * // => { 'user': 'barney', 'age': 36 }\n     */\n    var defaults = rest(function(args) {\n      args.push(undefined, assignInDefaults);\n      return apply(assignInWith, undefined, args);\n    });\n\n    /**\n     * This method is like `_.defaults` except that it recursively assigns\n     * default properties.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} [sources] The source objects.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * _.defaultsDeep({ 'user': { 'name': 'barney' } }, { 'user': { 'name': 'fred', 'age': 36 } });\n     * // => { 'user': { 'name': 'barney', 'age': 36 } }\n     *\n     */\n    var defaultsDeep = rest(function(args) {\n      args.push(undefined, mergeDefaults);\n      return apply(mergeWith, undefined, args);\n    });\n\n    /**\n     * This method is like `_.find` except that it returns the key of the first\n     * element `predicate` returns truthy for instead of the element itself.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to search.\n     * @param {Function|Object|string} [predicate=_.identity] The function invoked per iteration.\n     * @returns {string|undefined} Returns the key of the matched element, else `undefined`.\n     * @example\n     *\n     * var users = {\n     *   'barney':  { 'age': 36, 'active': true },\n     *   'fred':    { 'age': 40, 'active': false },\n     *   'pebbles': { 'age': 1,  'active': true }\n     * };\n     *\n     * _.findKey(users, function(o) { return o.age < 40; });\n     * // => 'barney' (iteration order is not guaranteed)\n     *\n     * // using the `_.matches` iteratee shorthand\n     * _.findKey(users, { 'age': 1, 'active': true });\n     * // => 'pebbles'\n     *\n     * // using the `_.matchesProperty` iteratee shorthand\n     * _.findKey(users, ['active', false]);\n     * // => 'fred'\n     *\n     * // using the `_.property` iteratee shorthand\n     * _.findKey(users, 'active');\n     * // => 'barney'\n     */\n    function findKey(object, predicate) {\n      return baseFind(object, getIteratee(predicate, 3), baseForOwn, true);\n    }\n\n    /**\n     * This method is like `_.findKey` except that it iterates over elements of\n     * a collection in the opposite order.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to search.\n     * @param {Function|Object|string} [predicate=_.identity] The function invoked per iteration.\n     * @returns {string|undefined} Returns the key of the matched element, else `undefined`.\n     * @example\n     *\n     * var users = {\n     *   'barney':  { 'age': 36, 'active': true },\n     *   'fred':    { 'age': 40, 'active': false },\n     *   'pebbles': { 'age': 1,  'active': true }\n     * };\n     *\n     * _.findLastKey(users, function(o) { return o.age < 40; });\n     * // => returns 'pebbles' assuming `_.findKey` returns 'barney'\n     *\n     * // using the `_.matches` iteratee shorthand\n     * _.findLastKey(users, { 'age': 36, 'active': true });\n     * // => 'barney'\n     *\n     * // using the `_.matchesProperty` iteratee shorthand\n     * _.findLastKey(users, ['active', false]);\n     * // => 'fred'\n     *\n     * // using the `_.property` iteratee shorthand\n     * _.findLastKey(users, 'active');\n     * // => 'pebbles'\n     */\n    function findLastKey(object, predicate) {\n      return baseFind(object, getIteratee(predicate, 3), baseForOwnRight, true);\n    }\n\n    /**\n     * Iterates over own and inherited enumerable properties of an object invoking\n     * `iteratee` for each property. The iteratee is invoked with three arguments:\n     * (value, key, object). Iteratee functions may exit iteration early by explicitly\n     * returning `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.forIn(new Foo, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => logs 'a', 'b', then 'c' (iteration order is not guaranteed)\n     */\n    function forIn(object, iteratee) {\n      return object == null ? object : baseFor(object, toFunction(iteratee), keysIn);\n    }\n\n    /**\n     * This method is like `_.forIn` except that it iterates over properties of\n     * `object` in the opposite order.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.forInRight(new Foo, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'\n     */\n    function forInRight(object, iteratee) {\n      return object == null ? object : baseForRight(object, toFunction(iteratee), keysIn);\n    }\n\n    /**\n     * Iterates over own enumerable properties of an object invoking `iteratee`\n     * for each property. The iteratee is invoked with three arguments:\n     * (value, key, object). Iteratee functions may exit iteration early by\n     * explicitly returning `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.forOwn(new Foo, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => logs 'a' then 'b' (iteration order is not guaranteed)\n     */\n    function forOwn(object, iteratee) {\n      return object && baseForOwn(object, toFunction(iteratee));\n    }\n\n    /**\n     * This method is like `_.forOwn` except that it iterates over properties of\n     * `object` in the opposite order.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.forOwnRight(new Foo, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'\n     */\n    function forOwnRight(object, iteratee) {\n      return object && baseForOwnRight(object, toFunction(iteratee));\n    }\n\n    /**\n     * Creates an array of function property names from own enumerable properties\n     * of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to inspect.\n     * @returns {Array} Returns the new array of property names.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = _.constant('a');\n     *   this.b = _.constant('b');\n     * }\n     *\n     * Foo.prototype.c = _.constant('c');\n     *\n     * _.functions(new Foo);\n     * // => ['a', 'b']\n     */\n    function functions(object) {\n      return object == null ? [] : baseFunctions(object, keys(object));\n    }\n\n    /**\n     * Creates an array of function property names from own and inherited\n     * enumerable properties of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to inspect.\n     * @returns {Array} Returns the new array of property names.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = _.constant('a');\n     *   this.b = _.constant('b');\n     * }\n     *\n     * Foo.prototype.c = _.constant('c');\n     *\n     * _.functionsIn(new Foo);\n     * // => ['a', 'b', 'c']\n     */\n    function functionsIn(object) {\n      return object == null ? [] : baseFunctions(object, keysIn(object));\n    }\n\n    /**\n     * Gets the value at `path` of `object`. If the resolved value is\n     * `undefined` the `defaultValue` is used in its place.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path of the property to get.\n     * @param {*} [defaultValue] The value returned if the resolved value is `undefined`.\n     * @returns {*} Returns the resolved value.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n     *\n     * _.get(object, 'a[0].b.c');\n     * // => 3\n     *\n     * _.get(object, ['a', '0', 'b', 'c']);\n     * // => 3\n     *\n     * _.get(object, 'a.b.c', 'default');\n     * // => 'default'\n     */\n    function get(object, path, defaultValue) {\n      var result = object == null ? undefined : baseGet(object, path);\n      return result === undefined ? defaultValue : result;\n    }\n\n    /**\n     * Checks if `path` is a direct property of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path to check.\n     * @returns {boolean} Returns `true` if `path` exists, else `false`.\n     * @example\n     *\n     * var object = { 'a': { 'b': { 'c': 3 } } };\n     * var other = _.create({ 'a': _.create({ 'b': _.create({ 'c': 3 }) }) });\n     *\n     * _.has(object, 'a');\n     * // => true\n     *\n     * _.has(object, 'a.b.c');\n     * // => true\n     *\n     * _.has(object, ['a', 'b', 'c']);\n     * // => true\n     *\n     * _.has(other, 'a');\n     * // => false\n     */\n    function has(object, path) {\n      return hasPath(object, path, baseHas);\n    }\n\n    /**\n     * Checks if `path` is a direct or inherited property of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path to check.\n     * @returns {boolean} Returns `true` if `path` exists, else `false`.\n     * @example\n     *\n     * var object = _.create({ 'a': _.create({ 'b': _.create({ 'c': 3 }) }) });\n     *\n     * _.hasIn(object, 'a');\n     * // => true\n     *\n     * _.hasIn(object, 'a.b.c');\n     * // => true\n     *\n     * _.hasIn(object, ['a', 'b', 'c']);\n     * // => true\n     *\n     * _.hasIn(object, 'b');\n     * // => false\n     */\n    function hasIn(object, path) {\n      return hasPath(object, path, baseHasIn);\n    }\n\n    /**\n     * Creates an object composed of the inverted keys and values of `object`.\n     * If `object` contains duplicate values, subsequent values overwrite property\n     * assignments of previous values unless `multiVal` is `true`.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to invert.\n     * @param {boolean} [multiVal] Allow multiple values per key.\n     * @param- {Object} [guard] Enables use as an iteratee for functions like `_.map`.\n     * @returns {Object} Returns the new inverted object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': 2, 'c': 1 };\n     *\n     * _.invert(object);\n     * // => { '1': 'c', '2': 'b' }\n     *\n     * // with `multiVal`\n     * _.invert(object, true);\n     * // => { '1': ['a', 'c'], '2': ['b'] }\n     */\n    function invert(object, multiVal, guard) {\n      return arrayReduce(keys(object), function(result, key) {\n        var value = object[key];\n        if (multiVal && !guard) {\n          if (hasOwnProperty.call(result, value)) {\n            result[value].push(key);\n          } else {\n            result[value] = [key];\n          }\n        }\n        else {\n          result[value] = key;\n        }\n        return result;\n      }, {});\n    }\n\n    /**\n     * Invokes the method at `path` of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path of the method to invoke.\n     * @param {...*} [args] The arguments to invoke the method with.\n     * @returns {*} Returns the result of the invoked method.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };\n     *\n     * _.invoke(object, 'a[0].b.c.slice', 1, 3);\n     * // => [2, 3]\n     */\n    var invoke = rest(baseInvoke);\n\n    /**\n     * Creates an array of the own enumerable property names of `object`.\n     *\n     * **Note:** Non-object values are coerced to objects. See the\n     * [ES spec](http://ecma-international.org/ecma-262/6.0/#sec-object.keys)\n     * for more details.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.keys(new Foo);\n     * // => ['a', 'b'] (iteration order is not guaranteed)\n     *\n     * _.keys('hi');\n     * // => ['0', '1']\n     */\n    function keys(object) {\n      var isProto = isPrototype(object);\n      if (!(isProto || isArrayLike(object))) {\n        return baseKeys(object);\n      }\n      var indexes = indexKeys(object),\n          skipIndexes = !!indexes,\n          result = indexes || [],\n          length = result.length;\n\n      for (var key in object) {\n        if (baseHas(object, key) &&\n            !(skipIndexes && (key == 'length' || isIndex(key, length))) &&\n            !(isProto && key == 'constructor')) {\n          result.push(key);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Creates an array of the own and inherited enumerable property names of `object`.\n     *\n     * **Note:** Non-object values are coerced to objects.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.keysIn(new Foo);\n     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\n     */\n    function keysIn(object) {\n      var index = -1,\n          isProto = isPrototype(object),\n          props = baseKeysIn(object),\n          propsLength = props.length,\n          indexes = indexKeys(object),\n          skipIndexes = !!indexes,\n          result = indexes || [],\n          length = result.length;\n\n      while (++index < propsLength) {\n        var key = props[index];\n        if (!(skipIndexes && (key == 'length' || isIndex(key, length))) &&\n            !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {\n          result.push(key);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The opposite of `_.mapValues`; this method creates an object with the\n     * same values as `object` and keys generated by running each own enumerable\n     * property of `object` through `iteratee`.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function|Object|string} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns the new mapped object.\n     * @example\n     *\n     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {\n     *   return key + value;\n     * });\n     * // => { 'a1': 1, 'b2': 2 }\n     */\n    function mapKeys(object, iteratee) {\n      var result = {};\n      iteratee = getIteratee(iteratee, 3);\n\n      baseForOwn(object, function(value, key, object) {\n        result[iteratee(value, key, object)] = value;\n      });\n      return result;\n    }\n\n    /**\n     * Creates an object with the same keys as `object` and values generated by\n     * running each own enumerable property of `object` through `iteratee`. The\n     * iteratee function is invoked with three arguments: (value, key, object).\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function|Object|string} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns the new mapped object.\n     * @example\n     *\n     * var users = {\n     *   'fred':    { 'user': 'fred',    'age': 40 },\n     *   'pebbles': { 'user': 'pebbles', 'age': 1 }\n     * };\n     *\n     * _.mapValues(users, function(o) { return o.age; });\n     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)\n     *\n     * // using the `_.property` iteratee shorthand\n     * _.mapValues(users, 'age');\n     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)\n     */\n    function mapValues(object, iteratee) {\n      var result = {};\n      iteratee = getIteratee(iteratee, 3);\n\n      baseForOwn(object, function(value, key, object) {\n        result[key] = iteratee(value, key, object);\n      });\n      return result;\n    }\n\n    /**\n     * Recursively merges own and inherited enumerable properties of source\n     * objects into the destination object, skipping source properties that resolve\n     * to `undefined`. Array and plain object properties are merged recursively.\n     * Other objects and value types are overridden by assignment. Source objects\n     * are applied from left to right. Subsequent sources overwrite property\n     * assignments of previous sources.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} [sources] The source objects.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var users = {\n     *   'data': [{ 'user': 'barney' }, { 'user': 'fred' }]\n     * };\n     *\n     * var ages = {\n     *   'data': [{ 'age': 36 }, { 'age': 40 }]\n     * };\n     *\n     * _.merge(users, ages);\n     * // => { 'data': [{ 'user': 'barney', 'age': 36 }, { 'user': 'fred', 'age': 40 }] }\n     */\n    var merge = createAssigner(function(object, source) {\n      baseMerge(object, source);\n    });\n\n    /**\n     * This method is like `_.merge` except that it accepts `customizer` which\n     * is invoked to produce the merged values of the destination and source\n     * properties. If `customizer` returns `undefined` merging is handled by the\n     * method instead. The `customizer` is invoked with seven arguments:\n     * (objValue, srcValue, key, object, source, stack).\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} sources The source objects.\n     * @param {Function} customizer The function to customize assigned values.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * function customizer(objValue, srcValue) {\n     *   if (_.isArray(objValue)) {\n     *     return objValue.concat(srcValue);\n     *   }\n     * }\n     *\n     * var object = {\n     *   'fruits': ['apple'],\n     *   'vegetables': ['beet']\n     * };\n     *\n     * var other = {\n     *   'fruits': ['banana'],\n     *   'vegetables': ['carrot']\n     * };\n     *\n     * _.mergeWith(object, other, customizer);\n     * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot'] }\n     */\n    var mergeWith = createAssigner(function(object, source, customizer) {\n      baseMerge(object, source, customizer);\n    });\n\n    /**\n     * The opposite of `_.pick`; this method creates an object composed of the\n     * own and inherited enumerable properties of `object` that are not omitted.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The source object.\n     * @param {...(string|string[])} [props] The property names to omit, specified\n     *  individually or in arrays..\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': '2', 'c': 3 };\n     *\n     * _.omit(object, ['a', 'c']);\n     * // => { 'b': '2' }\n     */\n    var omit = rest(function(object, props) {\n      if (object == null) {\n        return {};\n      }\n      props = arrayMap(baseFlatten(props), String);\n      return basePick(object, baseDifference(keysIn(object), props));\n    });\n\n    /**\n     * The opposite of `_.pickBy`; this method creates an object composed of the\n     * own and inherited enumerable properties of `object` that `predicate`\n     * doesn't return truthy for.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The source object.\n     * @param {Function|Object|string} [predicate=_.identity] The function invoked per property.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': '2', 'c': 3 };\n     *\n     * _.omitBy(object, _.isNumber);\n     * // => { 'b': '2' }\n     */\n    function omitBy(object, predicate) {\n      predicate = getIteratee(predicate);\n      return basePickBy(object, function(value) {\n        return !predicate(value);\n      });\n    }\n\n    /**\n     * Creates an object composed of the picked `object` properties.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The source object.\n     * @param {...(string|string[])} [props] The property names to pick, specified\n     *  individually or in arrays.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': '2', 'c': 3 };\n     *\n     * _.pick(object, ['a', 'c']);\n     * // => { 'a': 1, 'c': 3 }\n     */\n    var pick = rest(function(object, props) {\n      return object == null ? {} : basePick(object, baseFlatten(props));\n    });\n\n    /**\n     * Creates an object composed of the `object` properties `predicate` returns\n     * truthy for. The predicate is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The source object.\n     * @param {Function|Object|string} [predicate=_.identity] The function invoked per property.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': '2', 'c': 3 };\n     *\n     * _.pickBy(object, _.isNumber);\n     * // => { 'a': 1, 'c': 3 }\n     */\n    function pickBy(object, predicate) {\n      return object == null ? {} : basePickBy(object, getIteratee(predicate));\n    }\n\n    /**\n     * This method is like `_.get` except that if the resolved value is a function\n     * it's invoked with the `this` binding of its parent object and its result\n     * is returned.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path of the property to resolve.\n     * @param {*} [defaultValue] The value returned if the resolved value is `undefined`.\n     * @returns {*} Returns the resolved value.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };\n     *\n     * _.result(object, 'a[0].b.c1');\n     * // => 3\n     *\n     * _.result(object, 'a[0].b.c2');\n     * // => 4\n     *\n     * _.result(object, 'a[0].b.c3', 'default');\n     * // => 'default'\n     *\n     * _.result(object, 'a[0].b.c3', _.constant('default'));\n     * // => 'default'\n     */\n    function result(object, path, defaultValue) {\n      if (!isKey(path, object)) {\n        path = baseToPath(path);\n        var result = get(object, path);\n        object = parent(object, path);\n      } else {\n        result = object == null ? undefined : object[path];\n      }\n      if (result === undefined) {\n        result = defaultValue;\n      }\n      return isFunction(result) ? result.call(object) : result;\n    }\n\n    /**\n     * Sets the value at `path` of `object`. If a portion of `path` doesn't exist\n     * it's created. Arrays are created for missing index properties while objects\n     * are created for all other missing properties. Use `_.setWith` to customize\n     * `path` creation.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to set.\n     * @param {*} value The value to set.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n     *\n     * _.set(object, 'a[0].b.c', 4);\n     * console.log(object.a[0].b.c);\n     * // => 4\n     *\n     * _.set(object, 'x[0].y.z', 5);\n     * console.log(object.x[0].y.z);\n     * // => 5\n     */\n    function set(object, path, value) {\n      return object == null ? object : baseSet(object, path, value);\n    }\n\n    /**\n     * This method is like `_.set` except that it accepts `customizer` which is\n     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`\n     * path creation is handled by the method instead. The `customizer` is invoked\n     * with three arguments: (nsValue, key, nsObject).\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to set.\n     * @param {*} value The value to set.\n     * @param {Function} [customizer] The function to customize assigned values.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * _.setWith({ '0': { 'length': 2 } }, '[0][1][2]', 3, Object);\n     * // => { '0': { '1': { '2': 3 }, 'length': 2 } }\n     */\n    function setWith(object, path, value, customizer) {\n      customizer = typeof customizer == 'function' ? customizer : undefined;\n      return object == null ? object : baseSet(object, path, value, customizer);\n    }\n\n    /**\n     * Creates an array of own enumerable key-value pairs for `object`.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the new array of key-value pairs.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.toPairs(new Foo);\n     * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)\n     */\n    function toPairs(object) {\n      return baseToPairs(object, keys(object));\n    }\n\n    /**\n     * Creates an array of own and inherited enumerable key-value pairs for `object`.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the new array of key-value pairs.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.toPairsIn(new Foo);\n     * // => [['a', 1], ['b', 2], ['c', 1]] (iteration order is not guaranteed)\n     */\n    function toPairsIn(object) {\n      return baseToPairs(object, keysIn(object));\n    }\n\n    /**\n     * An alternative to `_.reduce`; this method transforms `object` to a new\n     * `accumulator` object which is the result of running each of its own enumerable\n     * properties through `iteratee`, with each invocation potentially mutating\n     * the `accumulator` object. The iteratee is invoked with four arguments:\n     * (accumulator, value, key, object). Iteratee functions may exit iteration\n     * early by explicitly returning `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Array|Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {*} [accumulator] The custom accumulator value.\n     * @returns {*} Returns the accumulated value.\n     * @example\n     *\n     * _.transform([2, 3, 4], function(result, n) {\n     *   result.push(n *= n);\n     *   return n % 2 == 0;\n     * });\n     * // => [4, 9]\n     *\n     * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {\n     *   (result[value] || (result[value] = [])).push(key);\n     * });\n     * // => { '1': ['a', 'c'], '2': ['b'] }\n     */\n    function transform(object, iteratee, accumulator) {\n      var isArr = isArray(object) || isTypedArray(object);\n      iteratee = getIteratee(iteratee, 4);\n\n      if (accumulator == null) {\n        if (isArr || isObject(object)) {\n          var Ctor = object.constructor;\n          if (isArr) {\n            accumulator = isArray(object) ? new Ctor : [];\n          } else {\n            accumulator = baseCreate(isFunction(Ctor) ? Ctor.prototype : undefined);\n          }\n        } else {\n          accumulator = {};\n        }\n      }\n      (isArr ? arrayEach : baseForOwn)(object, function(value, index, object) {\n        return iteratee(accumulator, value, index, object);\n      });\n      return accumulator;\n    }\n\n    /**\n     * Removes the property at `path` of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to unset.\n     * @returns {boolean} Returns `true` if the property is deleted, else `false`.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 7 } }] };\n     * _.unset(object, 'a[0].b.c');\n     * // => true\n     *\n     * console.log(object);\n     * // => { 'a': [{ 'b': {} }] };\n     *\n     * _.unset(object, 'a[0].b.c');\n     * // => true\n     *\n     * console.log(object);\n     * // => { 'a': [{ 'b': {} }] };\n     */\n    function unset(object, path) {\n      return object == null ? true : baseUnset(object, path);\n    }\n\n    /**\n     * Creates an array of the own enumerable property values of `object`.\n     *\n     * **Note:** Non-object values are coerced to objects.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property values.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.values(new Foo);\n     * // => [1, 2] (iteration order is not guaranteed)\n     *\n     * _.values('hi');\n     * // => ['h', 'i']\n     */\n    function values(object) {\n      return object ? baseValues(object, keys(object)) : [];\n    }\n\n    /**\n     * Creates an array of the own and inherited enumerable property values of `object`.\n     *\n     * **Note:** Non-object values are coerced to objects.\n     *\n     * @static\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property values.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.valuesIn(new Foo);\n     * // => [1, 2, 3] (iteration order is not guaranteed)\n     */\n    function valuesIn(object) {\n      return object == null ? baseValues(object, keysIn(object)) : [];\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Clamps `number` within the inclusive `lower` and `upper` bounds.\n     *\n     * @static\n     * @memberOf _\n     * @category Number\n     * @param {number} number The number to clamp.\n     * @param {number} [lower] The lower bound.\n     * @param {number} upper The upper bound.\n     * @returns {number} Returns the clamped number.\n     * @example\n     *\n     * _.clamp(-10, -5, 5);\n     * // => -5\n     *\n     * _.clamp(10, -5, 5);\n     * // => 5\n     */\n    function clamp(number, lower, upper) {\n      if (upper === undefined) {\n        upper = lower;\n        lower = undefined;\n      }\n      if (upper !== undefined) {\n        upper = toNumber(upper);\n        upper = upper === upper ? upper : 0;\n      }\n      if (lower !== undefined) {\n        lower = toNumber(lower);\n        lower = lower === lower ? lower : 0;\n      }\n      return baseClamp(toNumber(number), lower, upper);\n    }\n\n    /**\n     * Checks if `n` is between `start` and up to but not including, `end`. If\n     * `end` is not specified it's set to `start` with `start` then set to `0`.\n     * If `start` is greater than `end` the params are swapped to support\n     * negative ranges.\n     *\n     * @static\n     * @memberOf _\n     * @category Number\n     * @param {number} number The number to check.\n     * @param {number} [start=0] The start of the range.\n     * @param {number} end The end of the range.\n     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.\n     * @example\n     *\n     * _.inRange(3, 2, 4);\n     * // => true\n     *\n     * _.inRange(4, 8);\n     * // => true\n     *\n     * _.inRange(4, 2);\n     * // => false\n     *\n     * _.inRange(2, 2);\n     * // => false\n     *\n     * _.inRange(1.2, 2);\n     * // => true\n     *\n     * _.inRange(5.2, 4);\n     * // => false\n     *\n     * _.inRange(-3, -2, -6);\n     * // => true\n     */\n    function inRange(number, start, end) {\n      start = toNumber(start) || 0;\n      if (end === undefined) {\n        end = start;\n        start = 0;\n      } else {\n        end = toNumber(end) || 0;\n      }\n      number = toNumber(number);\n      return baseInRange(number, start, end);\n    }\n\n    /**\n     * Produces a random number between the inclusive `lower` and `upper` bounds.\n     * If only one argument is provided a number between `0` and the given number\n     * is returned. If `floating` is `true`, or either `lower` or `upper` are floats,\n     * a floating-point number is returned instead of an integer.\n     *\n     * **Note:** JavaScript follows the IEEE-754 standard for resolving\n     * floating-point values which can produce unexpected results.\n     *\n     * @static\n     * @memberOf _\n     * @category Number\n     * @param {number} [lower=0] The lower bound.\n     * @param {number} [upper=1] The upper bound.\n     * @param {boolean} [floating] Specify returning a floating-point number.\n     * @returns {number} Returns the random number.\n     * @example\n     *\n     * _.random(0, 5);\n     * // => an integer between 0 and 5\n     *\n     * _.random(5);\n     * // => also an integer between 0 and 5\n     *\n     * _.random(5, true);\n     * // => a floating-point number between 0 and 5\n     *\n     * _.random(1.2, 5.2);\n     * // => a floating-point number between 1.2 and 5.2\n     */\n    function random(lower, upper, floating) {\n      if (floating && typeof floating != 'boolean' && isIterateeCall(lower, upper, floating)) {\n        upper = floating = undefined;\n      }\n      if (floating === undefined) {\n        if (typeof upper == 'boolean') {\n          floating = upper;\n          upper = undefined;\n        }\n        else if (typeof lower == 'boolean') {\n          floating = lower;\n          lower = undefined;\n        }\n      }\n      if (lower === undefined && upper === undefined) {\n        lower = 0;\n        upper = 1;\n      }\n      else {\n        lower = toNumber(lower) || 0;\n        if (upper === undefined) {\n          upper = lower;\n          lower = 0;\n        } else {\n          upper = toNumber(upper) || 0;\n        }\n      }\n      if (lower > upper) {\n        var temp = lower;\n        lower = upper;\n        upper = temp;\n      }\n      if (floating || lower % 1 || upper % 1) {\n        var rand = nativeRandom();\n        return nativeMin(lower + (rand * (upper - lower + freeParseFloat('1e-' + ((rand + '').length - 1)))), upper);\n      }\n      return baseRandom(lower, upper);\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the camel cased string.\n     * @example\n     *\n     * _.camelCase('Foo Bar');\n     * // => 'fooBar'\n     *\n     * _.camelCase('--foo-bar');\n     * // => 'fooBar'\n     *\n     * _.camelCase('__foo_bar__');\n     * // => 'fooBar'\n     */\n    var camelCase = createCompounder(function(result, word, index) {\n      word = word.toLowerCase();\n      return result + (index ? capitalize(word) : word);\n    });\n\n    /**\n     * Converts the first character of `string` to upper case and the remaining\n     * to lower case.\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to capitalize.\n     * @returns {string} Returns the capitalized string.\n     * @example\n     *\n     * _.capitalize('FRED');\n     * // => 'Fred'\n     */\n    function capitalize(string) {\n      return upperFirst(toString(string).toLowerCase());\n    }\n\n    /**\n     * Deburrs `string` by converting [latin-1 supplementary letters](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)\n     * to basic latin letters and removing [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to deburr.\n     * @returns {string} Returns the deburred string.\n     * @example\n     *\n     * _.deburr('déjà vu');\n     * // => 'deja vu'\n     */\n    function deburr(string) {\n      string = toString(string);\n      return string && string.replace(reLatin1, deburrLetter).replace(reComboMark, '');\n    }\n\n    /**\n     * Checks if `string` ends with the given target string.\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to search.\n     * @param {string} [target] The string to search for.\n     * @param {number} [position=string.length] The position to search from.\n     * @returns {boolean} Returns `true` if `string` ends with `target`, else `false`.\n     * @example\n     *\n     * _.endsWith('abc', 'c');\n     * // => true\n     *\n     * _.endsWith('abc', 'b');\n     * // => false\n     *\n     * _.endsWith('abc', 'b', 2);\n     * // => true\n     */\n    function endsWith(string, target, position) {\n      string = toString(string);\n      target = typeof target == 'string' ? target : (target + '');\n\n      var length = string.length;\n      position = position === undefined\n        ? length\n        : baseClamp(toInteger(position), 0, length);\n\n      position -= target.length;\n      return position >= 0 && string.indexOf(target, position) == position;\n    }\n\n    /**\n     * Converts the characters \"&\", \"<\", \">\", '\"', \"'\", and \"\\`\" in `string` to\n     * their corresponding HTML entities.\n     *\n     * **Note:** No other characters are escaped. To escape additional\n     * characters use a third-party library like [_he_](https://mths.be/he).\n     *\n     * Though the \">\" character is escaped for symmetry, characters like\n     * \">\" and \"/\" don't need escaping in HTML and have no special meaning\n     * unless they're part of a tag or unquoted attribute value.\n     * See [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)\n     * (under \"semi-related fun fact\") for more details.\n     *\n     * Backticks are escaped because in IE < 9, they can break out of\n     * attribute values or HTML comments. See [#59](https://html5sec.org/#59),\n     * [#102](https://html5sec.org/#102), [#108](https://html5sec.org/#108), and\n     * [#133](https://html5sec.org/#133) of the [HTML5 Security Cheatsheet](https://html5sec.org/)\n     * for more details.\n     *\n     * When working with HTML you should always [quote attribute values](http://wonko.com/post/html-escaping)\n     * to reduce XSS vectors.\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to escape.\n     * @returns {string} Returns the escaped string.\n     * @example\n     *\n     * _.escape('fred, barney, & pebbles');\n     * // => 'fred, barney, &amp; pebbles'\n     */\n    function escape(string) {\n      string = toString(string);\n      return (string && reHasUnescapedHtml.test(string))\n        ? string.replace(reUnescapedHtml, escapeHtmlChar)\n        : string;\n    }\n\n    /**\n     * Escapes the `RegExp` special characters \"^\", \"$\", \"\\\", \".\", \"*\", \"+\",\n     * \"?\", \"(\", \")\", \"[\", \"]\", \"{\", \"}\", and \"|\" in `string`.\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to escape.\n     * @returns {string} Returns the escaped string.\n     * @example\n     *\n     * _.escapeRegExp('[lodash](https://lodash.com/)');\n     * // => '\\[lodash\\]\\(https://lodash\\.com/\\)'\n     */\n    function escapeRegExp(string) {\n      string = toString(string);\n      return (string && reHasRegExpChar.test(string))\n        ? string.replace(reRegExpChar, '\\\\$&')\n        : string;\n    }\n\n    /**\n     * Converts `string` to [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the kebab cased string.\n     * @example\n     *\n     * _.kebabCase('Foo Bar');\n     * // => 'foo-bar'\n     *\n     * _.kebabCase('fooBar');\n     * // => 'foo-bar'\n     *\n     * _.kebabCase('__foo_bar__');\n     * // => 'foo-bar'\n     */\n    var kebabCase = createCompounder(function(result, word, index) {\n      return result + (index ? '-' : '') + word.toLowerCase();\n    });\n\n    /**\n     * Converts `string`, as space separated words, to lower case.\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the lower cased string.\n     * @example\n     *\n     * _.lowerCase('--Foo-Bar');\n     * // => 'foo bar'\n     *\n     * _.lowerCase('fooBar');\n     * // => 'foo bar'\n     *\n     * _.lowerCase('__FOO_BAR__');\n     * // => 'foo bar'\n     */\n    var lowerCase = createCompounder(function(result, word, index) {\n      return result + (index ? ' ' : '') + word.toLowerCase();\n    });\n\n    /**\n     * Converts the first character of `string` to lower case.\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the converted string.\n     * @example\n     *\n     * _.lowerFirst('Fred');\n     * // => 'fred'\n     *\n     * _.lowerFirst('FRED');\n     * // => 'fRED'\n     */\n    var lowerFirst = createCaseFirst('toLowerCase');\n\n    /**\n     * Converts the first character of `string` to upper case.\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the converted string.\n     * @example\n     *\n     * _.upperFirst('fred');\n     * // => 'Fred'\n     *\n     * _.upperFirst('FRED');\n     * // => 'FRED'\n     */\n    var upperFirst = createCaseFirst('toUpperCase');\n\n    /**\n     * Pads `string` on the left and right sides if it's shorter than `length`.\n     * Padding characters are truncated if they can't be evenly divided by `length`.\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to pad.\n     * @param {number} [length=0] The padding length.\n     * @param {string} [chars=' '] The string used as padding.\n     * @returns {string} Returns the padded string.\n     * @example\n     *\n     * _.pad('abc', 8);\n     * // => '  abc   '\n     *\n     * _.pad('abc', 8, '_-');\n     * // => '_-abc_-_'\n     *\n     * _.pad('abc', 3);\n     * // => 'abc'\n     */\n    function pad(string, length, chars) {\n      string = toString(string);\n      length = toInteger(length);\n\n      var strLength = stringSize(string);\n      if (!length || strLength >= length) {\n        return string;\n      }\n      var mid = (length - strLength) / 2,\n          leftLength = nativeFloor(mid),\n          rightLength = nativeCeil(mid);\n\n      return createPadding('', leftLength, chars) + string + createPadding('', rightLength, chars);\n    }\n\n    /**\n     * Pads `string` on the right side if it's shorter than `length`. Padding\n     * characters are truncated if they exceed `length`.\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to pad.\n     * @param {number} [length=0] The padding length.\n     * @param {string} [chars=' '] The string used as padding.\n     * @returns {string} Returns the padded string.\n     * @example\n     *\n     * _.padEnd('abc', 6);\n     * // => 'abc   '\n     *\n     * _.padEnd('abc', 6, '_-');\n     * // => 'abc_-_'\n     *\n     * _.padEnd('abc', 3);\n     * // => 'abc'\n     */\n    function padEnd(string, length, chars) {\n      string = toString(string);\n      return string + createPadding(string, length, chars);\n    }\n\n    /**\n     * Pads `string` on the left side if it's shorter than `length`. Padding\n     * characters are truncated if they exceed `length`.\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to pad.\n     * @param {number} [length=0] The padding length.\n     * @param {string} [chars=' '] The string used as padding.\n     * @returns {string} Returns the padded string.\n     * @example\n     *\n     * _.padStart('abc', 6);\n     * // => '   abc'\n     *\n     * _.padStart('abc', 6, '_-');\n     * // => '_-_abc'\n     *\n     * _.padStart('abc', 3);\n     * // => 'abc'\n     */\n    function padStart(string, length, chars) {\n      string = toString(string);\n      return createPadding(string, length, chars) + string;\n    }\n\n    /**\n     * Converts `string` to an integer of the specified radix. If `radix` is\n     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a hexadecimal,\n     * in which case a `radix` of `16` is used.\n     *\n     * **Note:** This method aligns with the [ES5 implementation](https://es5.github.io/#E)\n     * of `parseInt`.\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} string The string to convert.\n     * @param {number} [radix] The radix to interpret `value` by.\n     * @param- {Object} [guard] Enables use as an iteratee for functions like `_.map`.\n     * @returns {number} Returns the converted integer.\n     * @example\n     *\n     * _.parseInt('08');\n     * // => 8\n     *\n     * _.map(['6', '08', '10'], _.parseInt);\n     * // => [6, 8, 10]\n     */\n    function parseInt(string, radix, guard) {\n      // Chrome fails to trim leading <BOM> whitespace characters.\n      // See https://code.google.com/p/v8/issues/detail?id=3109 for more details.\n      if (guard || radix == null) {\n        radix = 0;\n      } else if (radix) {\n        radix = +radix;\n      }\n      string = toString(string).replace(reTrim, '');\n      return nativeParseInt(string, radix || (reHasHexPrefix.test(string) ? 16 : 10));\n    }\n\n    /**\n     * Repeats the given string `n` times.\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to repeat.\n     * @param {number} [n=0] The number of times to repeat the string.\n     * @returns {string} Returns the repeated string.\n     * @example\n     *\n     * _.repeat('*', 3);\n     * // => '***'\n     *\n     * _.repeat('abc', 2);\n     * // => 'abcabc'\n     *\n     * _.repeat('abc', 0);\n     * // => ''\n     */\n    function repeat(string, n) {\n      string = toString(string);\n      n = toInteger(n);\n\n      var result = '';\n      if (!string || n < 1 || n > MAX_SAFE_INTEGER) {\n        return result;\n      }\n      // Leverage the exponentiation by squaring algorithm for a faster repeat.\n      // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.\n      do {\n        if (n % 2) {\n          result += string;\n        }\n        n = nativeFloor(n / 2);\n        string += string;\n      } while (n);\n\n      return result;\n    }\n\n    /**\n     * Replaces matches for `pattern` in `string` with `replacement`.\n     *\n     * **Note:** This method is based on [`String#replace`](https://mdn.io/String/replace).\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to modify.\n     * @param {RegExp|string} pattern The pattern to replace.\n     * @param {Function|string} replacement The match replacement.\n     * @returns {string} Returns the modified string.\n     * @example\n     *\n     * _.replace('Hi Fred', 'Fred', 'Barney');\n     * // => 'Hi Barney'\n     */\n    function replace() {\n      var args = arguments,\n          string = toString(args[0]);\n\n      return args.length < 3 ? string : string.replace(args[1], args[2]);\n    }\n\n    /**\n     * Converts `string` to [snake case](https://en.wikipedia.org/wiki/Snake_case).\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the snake cased string.\n     * @example\n     *\n     * _.snakeCase('Foo Bar');\n     * // => 'foo_bar'\n     *\n     * _.snakeCase('fooBar');\n     * // => 'foo_bar'\n     *\n     * _.snakeCase('--foo-bar');\n     * // => 'foo_bar'\n     */\n    var snakeCase = createCompounder(function(result, word, index) {\n      return result + (index ? '_' : '') + word.toLowerCase();\n    });\n\n    /**\n     * Splits `string` by `separator`.\n     *\n     * **Note:** This method is based on [`String#split`](https://mdn.io/String/split).\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to split.\n     * @param {RegExp|string} separator The separator pattern to split by.\n     * @param {number} [limit] The length to truncate results to.\n     * @returns {Array} Returns the new array of string segments.\n     * @example\n     *\n     * _.split('a-b-c', '-', 2);\n     * // => ['a', 'b']\n     */\n    function split(string, separator, limit) {\n      return toString(string).split(separator, limit);\n    }\n\n    /**\n     * Converts `string` to [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the start cased string.\n     * @example\n     *\n     * _.startCase('--foo-bar');\n     * // => 'Foo Bar'\n     *\n     * _.startCase('fooBar');\n     * // => 'Foo Bar'\n     *\n     * _.startCase('__foo_bar__');\n     * // => 'Foo Bar'\n     */\n    var startCase = createCompounder(function(result, word, index) {\n      return result + (index ? ' ' : '') + capitalize(word);\n    });\n\n    /**\n     * Checks if `string` starts with the given target string.\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to search.\n     * @param {string} [target] The string to search for.\n     * @param {number} [position=0] The position to search from.\n     * @returns {boolean} Returns `true` if `string` starts with `target`, else `false`.\n     * @example\n     *\n     * _.startsWith('abc', 'a');\n     * // => true\n     *\n     * _.startsWith('abc', 'b');\n     * // => false\n     *\n     * _.startsWith('abc', 'b', 1);\n     * // => true\n     */\n    function startsWith(string, target, position) {\n      string = toString(string);\n      position = baseClamp(toInteger(position), 0, string.length);\n      return string.lastIndexOf(target, position) == position;\n    }\n\n    /**\n     * Creates a compiled template function that can interpolate data properties\n     * in \"interpolate\" delimiters, HTML-escape interpolated data properties in\n     * \"escape\" delimiters, and execute JavaScript in \"evaluate\" delimiters. Data\n     * properties may be accessed as free variables in the template. If a setting\n     * object is provided it takes precedence over `_.templateSettings` values.\n     *\n     * **Note:** In the development build `_.template` utilizes\n     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)\n     * for easier debugging.\n     *\n     * For more information on precompiling templates see\n     * [lodash's custom builds documentation](https://lodash.com/custom-builds).\n     *\n     * For more information on Chrome extension sandboxes see\n     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The template string.\n     * @param {Object} [options] The options object.\n     * @param {RegExp} [options.escape] The HTML \"escape\" delimiter.\n     * @param {RegExp} [options.evaluate] The \"evaluate\" delimiter.\n     * @param {Object} [options.imports] An object to import into the template as free variables.\n     * @param {RegExp} [options.interpolate] The \"interpolate\" delimiter.\n     * @param {string} [options.sourceURL] The sourceURL of the template's compiled source.\n     * @param {string} [options.variable] The data object variable name.\n     * @param- {Object} [guard] Enables use as an iteratee for functions like `_.map`.\n     * @returns {Function} Returns the compiled template function.\n     * @example\n     *\n     * // using the \"interpolate\" delimiter to create a compiled template\n     * var compiled = _.template('hello <%= user %>!');\n     * compiled({ 'user': 'fred' });\n     * // => 'hello fred!'\n     *\n     * // using the HTML \"escape\" delimiter to escape data property values\n     * var compiled = _.template('<b><%- value %></b>');\n     * compiled({ 'value': '<script>' });\n     * // => '<b>&lt;script&gt;</b>'\n     *\n     * // using the \"evaluate\" delimiter to execute JavaScript and generate HTML\n     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');\n     * compiled({ 'users': ['fred', 'barney'] });\n     * // => '<li>fred</li><li>barney</li>'\n     *\n     * // using the internal `print` function in \"evaluate\" delimiters\n     * var compiled = _.template('<% print(\"hello \" + user); %>!');\n     * compiled({ 'user': 'barney' });\n     * // => 'hello barney!'\n     *\n     * // using the ES delimiter as an alternative to the default \"interpolate\" delimiter\n     * var compiled = _.template('hello ${ user }!');\n     * compiled({ 'user': 'pebbles' });\n     * // => 'hello pebbles!'\n     *\n     * // using custom template delimiters\n     * _.templateSettings.interpolate = /{{([\\s\\S]+?)}}/g;\n     * var compiled = _.template('hello {{ user }}!');\n     * compiled({ 'user': 'mustache' });\n     * // => 'hello mustache!'\n     *\n     * // using backslashes to treat delimiters as plain text\n     * var compiled = _.template('<%= \"\\\\<%- value %\\\\>\" %>');\n     * compiled({ 'value': 'ignored' });\n     * // => '<%- value %>'\n     *\n     * // using the `imports` option to import `jQuery` as `jq`\n     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';\n     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });\n     * compiled({ 'users': ['fred', 'barney'] });\n     * // => '<li>fred</li><li>barney</li>'\n     *\n     * // using the `sourceURL` option to specify a custom sourceURL for the template\n     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });\n     * compiled(data);\n     * // => find the source of \"greeting.jst\" under the Sources tab or Resources panel of the web inspector\n     *\n     * // using the `variable` option to ensure a with-statement isn't used in the compiled template\n     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });\n     * compiled.source;\n     * // => function(data) {\n     * //   var __t, __p = '';\n     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';\n     * //   return __p;\n     * // }\n     *\n     * // using the `source` property to inline compiled templates for meaningful\n     * // line numbers in error messages and a stack trace\n     * fs.writeFileSync(path.join(cwd, 'jst.js'), '\\\n     *   var JST = {\\\n     *     \"main\": ' + _.template(mainText).source + '\\\n     *   };\\\n     * ');\n     */\n    function template(string, options, guard) {\n      // Based on John Resig's `tmpl` implementation (http://ejohn.org/blog/javascript-micro-templating/)\n      // and Laura Doktorova's doT.js (https://github.com/olado/doT).\n      var settings = lodash.templateSettings;\n\n      if (guard && isIterateeCall(string, options, guard)) {\n        options = undefined;\n      }\n      string = toString(string);\n      options = assignInWith({}, options, settings, assignInDefaults);\n\n      var imports = assignInWith({}, options.imports, settings.imports, assignInDefaults),\n          importsKeys = keys(imports),\n          importsValues = baseValues(imports, importsKeys);\n\n      var isEscaping,\n          isEvaluating,\n          index = 0,\n          interpolate = options.interpolate || reNoMatch,\n          source = \"__p += '\";\n\n      // Compile the regexp to match each delimiter.\n      var reDelimiters = RegExp(\n        (options.escape || reNoMatch).source + '|' +\n        interpolate.source + '|' +\n        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +\n        (options.evaluate || reNoMatch).source + '|$'\n      , 'g');\n\n      // Use a sourceURL for easier debugging.\n      var sourceURL = '//# sourceURL=' +\n        ('sourceURL' in options\n          ? options.sourceURL\n          : ('lodash.templateSources[' + (++templateCounter) + ']')\n        ) + '\\n';\n\n      string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {\n        interpolateValue || (interpolateValue = esTemplateValue);\n\n        // Escape characters that can't be included in string literals.\n        source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);\n\n        // Replace delimiters with snippets.\n        if (escapeValue) {\n          isEscaping = true;\n          source += \"' +\\n__e(\" + escapeValue + \") +\\n'\";\n        }\n        if (evaluateValue) {\n          isEvaluating = true;\n          source += \"';\\n\" + evaluateValue + \";\\n__p += '\";\n        }\n        if (interpolateValue) {\n          source += \"' +\\n((__t = (\" + interpolateValue + \")) == null ? '' : __t) +\\n'\";\n        }\n        index = offset + match.length;\n\n        // The JS engine embedded in Adobe products needs `match` returned in\n        // order to produce the correct `offset` value.\n        return match;\n      });\n\n      source += \"';\\n\";\n\n      // If `variable` is not specified wrap a with-statement around the generated\n      // code to add the data object to the top of the scope chain.\n      var variable = options.variable;\n      if (!variable) {\n        source = 'with (obj) {\\n' + source + '\\n}\\n';\n      }\n      // Cleanup code by stripping empty strings.\n      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)\n        .replace(reEmptyStringMiddle, '$1')\n        .replace(reEmptyStringTrailing, '$1;');\n\n      // Frame code as the function body.\n      source = 'function(' + (variable || 'obj') + ') {\\n' +\n        (variable\n          ? ''\n          : 'obj || (obj = {});\\n'\n        ) +\n        \"var __t, __p = ''\" +\n        (isEscaping\n           ? ', __e = _.escape'\n           : ''\n        ) +\n        (isEvaluating\n          ? ', __j = Array.prototype.join;\\n' +\n            \"function print() { __p += __j.call(arguments, '') }\\n\"\n          : ';\\n'\n        ) +\n        source +\n        'return __p\\n}';\n\n      var result = attempt(function() {\n        return Function(importsKeys, sourceURL + 'return ' + source).apply(undefined, importsValues);\n      });\n\n      // Provide the compiled function's source by its `toString` method or\n      // the `source` property as a convenience for inlining compiled templates.\n      result.source = source;\n      if (isError(result)) {\n        throw result;\n      }\n      return result;\n    }\n\n    /**\n     * Converts `string`, as a whole, to lower case.\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the lower cased string.\n     * @example\n     *\n     * _.toLower('--Foo-Bar');\n     * // => '--foo-bar'\n     *\n     * _.toLower('fooBar');\n     * // => 'foobar'\n     *\n     * _.toLower('__FOO_BAR__');\n     * // => '__foo_bar__'\n     */\n    function toLower(value) {\n      return toString(value).toLowerCase();\n    }\n\n    /**\n     * Converts `string`, as a whole, to upper case.\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the upper cased string.\n     * @example\n     *\n     * _.toUpper('--foo-bar');\n     * // => '--FOO-BAR'\n     *\n     * _.toUpper('fooBar');\n     * // => 'FOOBAR'\n     *\n     * _.toUpper('__foo_bar__');\n     * // => '__FOO_BAR__'\n     */\n    function toUpper(value) {\n      return toString(value).toUpperCase();\n    }\n\n    /**\n     * Removes leading and trailing whitespace or specified characters from `string`.\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to trim.\n     * @param {string} [chars=whitespace] The characters to trim.\n     * @param- {Object} [guard] Enables use as an iteratee for functions like `_.map`.\n     * @returns {string} Returns the trimmed string.\n     * @example\n     *\n     * _.trim('  abc  ');\n     * // => 'abc'\n     *\n     * _.trim('-_-abc-_-', '_-');\n     * // => 'abc'\n     *\n     * _.map(['  foo  ', '  bar  '], _.trim);\n     * // => ['foo', 'bar']\n     */\n    function trim(string, chars, guard) {\n      string = toString(string);\n      if (!string) {\n        return string;\n      }\n      if (guard || chars === undefined) {\n        return string.replace(reTrim, '');\n      }\n      chars = (chars + '');\n      if (!chars) {\n        return string;\n      }\n      var strSymbols = stringToArray(string),\n          chrSymbols = stringToArray(chars);\n\n      return strSymbols.slice(charsStartIndex(strSymbols, chrSymbols), charsEndIndex(strSymbols, chrSymbols) + 1).join('');\n    }\n\n    /**\n     * Removes trailing whitespace or specified characters from `string`.\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to trim.\n     * @param {string} [chars=whitespace] The characters to trim.\n     * @param- {Object} [guard] Enables use as an iteratee for functions like `_.map`.\n     * @returns {string} Returns the trimmed string.\n     * @example\n     *\n     * _.trimEnd('  abc  ');\n     * // => '  abc'\n     *\n     * _.trimEnd('-_-abc-_-', '_-');\n     * // => '-_-abc'\n     */\n    function trimEnd(string, chars, guard) {\n      string = toString(string);\n      if (!string) {\n        return string;\n      }\n      if (guard || chars === undefined) {\n        return string.replace(reTrimEnd, '');\n      }\n      chars = (chars + '');\n      if (!chars) {\n        return string;\n      }\n      var strSymbols = stringToArray(string);\n      return strSymbols.slice(0, charsEndIndex(strSymbols, stringToArray(chars)) + 1).join('');\n    }\n\n    /**\n     * Removes leading whitespace or specified characters from `string`.\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to trim.\n     * @param {string} [chars=whitespace] The characters to trim.\n     * @param- {Object} [guard] Enables use as an iteratee for functions like `_.map`.\n     * @returns {string} Returns the trimmed string.\n     * @example\n     *\n     * _.trimStart('  abc  ');\n     * // => 'abc  '\n     *\n     * _.trimStart('-_-abc-_-', '_-');\n     * // => 'abc-_-'\n     */\n    function trimStart(string, chars, guard) {\n      string = toString(string);\n      if (!string) {\n        return string;\n      }\n      if (guard || chars === undefined) {\n        return string.replace(reTrimStart, '');\n      }\n      chars = (chars + '');\n      if (!chars) {\n        return string;\n      }\n      var strSymbols = stringToArray(string);\n      return strSymbols.slice(charsStartIndex(strSymbols, stringToArray(chars))).join('');\n    }\n\n    /**\n     * Truncates `string` if it's longer than the given maximum string length.\n     * The last characters of the truncated string are replaced with the omission\n     * string which defaults to \"...\".\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to truncate.\n     * @param {Object} [options] The options object.\n     * @param {number} [options.length=30] The maximum string length.\n     * @param {string} [options.omission='...'] The string to indicate text is omitted.\n     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.\n     * @returns {string} Returns the truncated string.\n     * @example\n     *\n     * _.truncate('hi-diddly-ho there, neighborino');\n     * // => 'hi-diddly-ho there, neighbo...'\n     *\n     * _.truncate('hi-diddly-ho there, neighborino', {\n     *   'length': 24,\n     *   'separator': ' '\n     * });\n     * // => 'hi-diddly-ho there,...'\n     *\n     * _.truncate('hi-diddly-ho there, neighborino', {\n     *   'length': 24,\n     *   'separator': /,? +/\n     * });\n     * // => 'hi-diddly-ho there...'\n     *\n     * _.truncate('hi-diddly-ho there, neighborino', {\n     *   'omission': ' [...]'\n     * });\n     * // => 'hi-diddly-ho there, neig [...]'\n     */\n    function truncate(string, options) {\n      var length = DEFAULT_TRUNC_LENGTH,\n          omission = DEFAULT_TRUNC_OMISSION;\n\n      if (isObject(options)) {\n        var separator = 'separator' in options ? options.separator : separator;\n        length = 'length' in options ? toInteger(options.length) : length;\n        omission = 'omission' in options ? toString(options.omission) : omission;\n      }\n      string = toString(string);\n\n      var strLength = string.length;\n      if (reHasComplexSymbol.test(string)) {\n        var strSymbols = stringToArray(string);\n        strLength = strSymbols.length;\n      }\n      if (length >= strLength) {\n        return string;\n      }\n      var end = length - stringSize(omission);\n      if (end < 1) {\n        return omission;\n      }\n      var result = strSymbols\n        ? strSymbols.slice(0, end).join('')\n        : string.slice(0, end);\n\n      if (separator === undefined) {\n        return result + omission;\n      }\n      if (strSymbols) {\n        end += (result.length - end);\n      }\n      if (isRegExp(separator)) {\n        if (string.slice(end).search(separator)) {\n          var match,\n              substring = result;\n\n          if (!separator.global) {\n            separator = RegExp(separator.source, toString(reFlags.exec(separator)) + 'g');\n          }\n          separator.lastIndex = 0;\n          while ((match = separator.exec(substring))) {\n            var newEnd = match.index;\n          }\n          result = result.slice(0, newEnd === undefined ? end : newEnd);\n        }\n      } else if (string.indexOf(separator, end) != end) {\n        var index = result.lastIndexOf(separator);\n        if (index > -1) {\n          result = result.slice(0, index);\n        }\n      }\n      return result + omission;\n    }\n\n    /**\n     * The inverse of `_.escape`; this method converts the HTML entities\n     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, `&#39;`, and `&#96;` in `string` to their\n     * corresponding characters.\n     *\n     * **Note:** No other HTML entities are unescaped. To unescape additional HTML\n     * entities use a third-party library like [_he_](https://mths.be/he).\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to unescape.\n     * @returns {string} Returns the unescaped string.\n     * @example\n     *\n     * _.unescape('fred, barney, &amp; pebbles');\n     * // => 'fred, barney, & pebbles'\n     */\n    function unescape(string) {\n      string = toString(string);\n      return (string && reHasEscapedHtml.test(string))\n        ? string.replace(reEscapedHtml, unescapeHtmlChar)\n        : string;\n    }\n\n    /**\n     * Converts `string`, as space separated words, to upper case.\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the upper cased string.\n     * @example\n     *\n     * _.upperCase('--foo-bar');\n     * // => 'FOO BAR'\n     *\n     * _.upperCase('fooBar');\n     * // => 'FOO BAR'\n     *\n     * _.upperCase('__foo_bar__');\n     * // => 'FOO BAR'\n     */\n    var upperCase = createCompounder(function(result, word, index) {\n      return result + (index ? ' ' : '') + word.toUpperCase();\n    });\n\n    /**\n     * Splits `string` into an array of its words.\n     *\n     * @static\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to inspect.\n     * @param {RegExp|string} [pattern] The pattern to match words.\n     * @param- {Object} [guard] Enables use as an iteratee for functions like `_.map`.\n     * @returns {Array} Returns the words of `string`.\n     * @example\n     *\n     * _.words('fred, barney, & pebbles');\n     * // => ['fred', 'barney', 'pebbles']\n     *\n     * _.words('fred, barney, & pebbles', /[^, ]+/g);\n     * // => ['fred', 'barney', '&', 'pebbles']\n     */\n    function words(string, pattern, guard) {\n      string = toString(string);\n      pattern = guard ? undefined : pattern;\n\n      if (pattern === undefined) {\n        pattern = reHasComplexWord.test(string) ? reComplexWord : reBasicWord;\n      }\n      return string.match(pattern) || [];\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Attempts to invoke `func`, returning either the result or the caught error\n     * object. Any additional arguments are provided to `func` when it's invoked.\n     *\n     * @static\n     * @memberOf _\n     * @category Util\n     * @param {Function} func The function to attempt.\n     * @returns {*} Returns the `func` result or error object.\n     * @example\n     *\n     * // avoid throwing errors for invalid selectors\n     * var elements = _.attempt(function(selector) {\n     *   return document.querySelectorAll(selector);\n     * }, '>_>');\n     *\n     * if (_.isError(elements)) {\n     *   elements = [];\n     * }\n     */\n    var attempt = rest(function(func, args) {\n      try {\n        return apply(func, undefined, args);\n      } catch (e) {\n        return isError(e) ? e : new Error(e);\n      }\n    });\n\n    /**\n     * Binds methods of an object to the object itself, overwriting the existing\n     * method.\n     *\n     * **Note:** This method doesn't set the \"length\" property of bound functions.\n     *\n     * @static\n     * @memberOf _\n     * @category Util\n     * @param {Object} object The object to bind and assign the bound methods to.\n     * @param {...(string|string[])} methodNames The object method names to bind,\n     *  specified individually or in arrays.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var view = {\n     *   'label': 'docs',\n     *   'onClick': function() {\n     *     console.log('clicked ' + this.label);\n     *   }\n     * };\n     *\n     * _.bindAll(view, 'onClick');\n     * jQuery(element).on('click', view.onClick);\n     * // => logs 'clicked docs' when clicked\n     */\n    var bindAll = rest(function(object, methodNames) {\n      arrayEach(baseFlatten(methodNames), function(key) {\n        object[key] = bind(object[key], object);\n      });\n      return object;\n    });\n\n    /**\n     * Creates a function that iterates over `pairs` invoking the corresponding\n     * function of the first predicate to return truthy. The predicate-function\n     * pairs are invoked with the `this` binding and arguments of the created\n     * function.\n     *\n     * @static\n     * @memberOf _\n     * @category Util\n     * @param {Array} pairs The predicate-function pairs.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var func = _.cond([\n     *   [_.matches({ 'a': 1 }),           _.constant('matches A')],\n     *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],\n     *   [_.constant(true),                _.constant('no match')]\n     * ])\n     *\n     * func({ 'a': 1, 'b': 2 });\n     * // => 'matches A'\n     *\n     * func({ 'a': 0, 'b': 1 });\n     * // => 'matches B'\n     *\n     * func({ 'a': '1', 'b': '2' });\n     * // => 'no match'\n     */\n    function cond(pairs) {\n      var length = pairs ? pairs.length : 0,\n          toIteratee = getIteratee();\n\n      pairs = !length ? [] : arrayMap(pairs, function(pair) {\n        if (typeof pair[1] != 'function') {\n          throw new TypeError(FUNC_ERROR_TEXT);\n        }\n        return [toIteratee(pair[0]), pair[1]];\n      });\n\n      return rest(function(args) {\n        var index = -1;\n        while (++index < length) {\n          var pair = pairs[index];\n          if (apply(pair[0], this, args)) {\n            return apply(pair[1], this, args);\n          }\n        }\n      });\n    }\n\n    /**\n     * Creates a function that invokes the predicate properties of `source` with\n     * the corresponding property values of a given object, returning `true` if\n     * all predicates return truthy, else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Util\n     * @param {Object} source The object of property predicates to conform to.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36 },\n     *   { 'user': 'fred',   'age': 40 }\n     * ];\n     *\n     * _.filter(users, _.conforms({ 'age': _.partial(_.gt, _, 38) }));\n     * // => [{ 'user': 'fred', 'age': 40 }]\n     */\n    function conforms(source) {\n      return baseConforms(baseClone(source, true));\n    }\n\n    /**\n     * Creates a function that returns `value`.\n     *\n     * @static\n     * @memberOf _\n     * @category Util\n     * @param {*} value The value to return from the new function.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var object = { 'user': 'fred' };\n     * var getter = _.constant(object);\n     *\n     * getter() === object;\n     * // => true\n     */\n    function constant(value) {\n      return function() {\n        return value;\n      };\n    }\n\n    /**\n     * Creates a function that returns the result of invoking the provided\n     * functions with the `this` binding of the created function, where each\n     * successive invocation is supplied the return value of the previous.\n     *\n     * @static\n     * @memberOf _\n     * @category Util\n     * @param {...(Function|Function[])} [funcs] Functions to invoke.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * var addSquare = _.flow(_.add, square);\n     * addSquare(1, 2);\n     * // => 9\n     */\n    var flow = createFlow();\n\n    /**\n     * This method is like `_.flow` except that it creates a function that\n     * invokes the provided functions from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @category Util\n     * @param {...(Function|Function[])} [funcs] Functions to invoke.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * var addSquare = _.flowRight(square, _.add);\n     * addSquare(1, 2);\n     * // => 9\n     */\n    var flowRight = createFlow(true);\n\n    /**\n     * This method returns the first argument provided to it.\n     *\n     * @static\n     * @memberOf _\n     * @category Util\n     * @param {*} value Any value.\n     * @returns {*} Returns `value`.\n     * @example\n     *\n     * var object = { 'user': 'fred' };\n     *\n     * _.identity(object) === object;\n     * // => true\n     */\n    function identity(value) {\n      return value;\n    }\n\n    /**\n     * Creates a function that invokes `func` with the arguments of the created\n     * function. If `func` is a property name the created callback returns the\n     * property value for a given element. If `func` is an object the created\n     * callback returns `true` for elements that contain the equivalent object properties, otherwise it returns `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Util\n     * @param {*} [func=_.identity] The value to convert to a callback.\n     * @returns {Function} Returns the callback.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36 },\n     *   { 'user': 'fred',   'age': 40 }\n     * ];\n     *\n     * // create custom iteratee shorthands\n     * _.iteratee = _.wrap(_.iteratee, function(callback, func) {\n     *   var p = /^(\\S+)\\s*([<>])\\s*(\\S+)$/.exec(func);\n     *   return !p ? callback(func) : function(object) {\n     *     return (p[2] == '>' ? object[p[1]] > p[3] : object[p[1]] < p[3]);\n     *   };\n     * });\n     *\n     * _.filter(users, 'age > 36');\n     * // => [{ 'user': 'fred', 'age': 40 }]\n     */\n    function iteratee(func) {\n      return (isObjectLike(func) && !isArray(func))\n        ? matches(func)\n        : baseIteratee(func);\n    }\n\n    /**\n     * Creates a function that performs a deep partial comparison between a given\n     * object and `source`, returning `true` if the given object has equivalent\n     * property values, else `false`.\n     *\n     * **Note:** This method supports comparing the same values as `_.isEqual`.\n     *\n     * @static\n     * @memberOf _\n     * @category Util\n     * @param {Object} source The object of property values to match.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36, 'active': true },\n     *   { 'user': 'fred',   'age': 40, 'active': false }\n     * ];\n     *\n     * _.filter(users, _.matches({ 'age': 40, 'active': false }));\n     * // => [{ 'user': 'fred', 'age': 40, 'active': false }]\n     */\n    function matches(source) {\n      return baseMatches(baseClone(source, true));\n    }\n\n    /**\n     * Creates a function that performs a deep partial comparison between the\n     * value at `path` of a given object to `srcValue`, returning `true` if the\n     * object value is equivalent, else `false`.\n     *\n     * **Note:** This method supports comparing the same values as `_.isEqual`.\n     *\n     * @static\n     * @memberOf _\n     * @category Util\n     * @param {Array|string} path The path of the property to get.\n     * @param {*} srcValue The value to match.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney' },\n     *   { 'user': 'fred' }\n     * ];\n     *\n     * _.find(users, _.matchesProperty('user', 'fred'));\n     * // => { 'user': 'fred' }\n     */\n    function matchesProperty(path, srcValue) {\n      return baseMatchesProperty(path, baseClone(srcValue, true));\n    }\n\n    /**\n     * Creates a function that invokes the method at `path` of a given object.\n     * Any additional arguments are provided to the invoked method.\n     *\n     * @static\n     * @memberOf _\n     * @category Util\n     * @param {Array|string} path The path of the method to invoke.\n     * @param {...*} [args] The arguments to invoke the method with.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var objects = [\n     *   { 'a': { 'b': { 'c': _.constant(2) } } },\n     *   { 'a': { 'b': { 'c': _.constant(1) } } }\n     * ];\n     *\n     * _.map(objects, _.method('a.b.c'));\n     * // => [2, 1]\n     *\n     * _.invokeMap(_.sortBy(objects, _.method(['a', 'b', 'c'])), 'a.b.c');\n     * // => [1, 2]\n     */\n    var method = rest(function(path, args) {\n      return function(object) {\n        return baseInvoke(object, path, args);\n      };\n    });\n\n    /**\n     * The opposite of `_.method`; this method creates a function that invokes\n     * the method at a given path of `object`. Any additional arguments are\n     * provided to the invoked method.\n     *\n     * @static\n     * @memberOf _\n     * @category Util\n     * @param {Object} object The object to query.\n     * @param {...*} [args] The arguments to invoke the method with.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var array = _.times(3, _.constant),\n     *     object = { 'a': array, 'b': array, 'c': array };\n     *\n     * _.map(['a[2]', 'c[0]'], _.methodOf(object));\n     * // => [2, 0]\n     *\n     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));\n     * // => [2, 0]\n     */\n    var methodOf = rest(function(object, args) {\n      return function(path) {\n        return baseInvoke(object, path, args);\n      };\n    });\n\n    /**\n     * Adds all own enumerable function properties of a source object to the\n     * destination object. If `object` is a function then methods are added to\n     * its prototype as well.\n     *\n     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to\n     * avoid conflicts caused by modifying the original.\n     *\n     * @static\n     * @memberOf _\n     * @category Util\n     * @param {Function|Object} [object=lodash] The destination object.\n     * @param {Object} source The object of functions to add.\n     * @param {Object} [options] The options object.\n     * @param {boolean} [options.chain=true] Specify whether the functions added\n     *  are chainable.\n     * @returns {Function|Object} Returns `object`.\n     * @example\n     *\n     * function vowels(string) {\n     *   return _.filter(string, function(v) {\n     *     return /[aeiou]/i.test(v);\n     *   });\n     * }\n     *\n     * _.mixin({ 'vowels': vowels });\n     * _.vowels('fred');\n     * // => ['e']\n     *\n     * _('fred').vowels().value();\n     * // => ['e']\n     *\n     * _.mixin({ 'vowels': vowels }, { 'chain': false });\n     * _('fred').vowels();\n     * // => ['e']\n     */\n    function mixin(object, source, options) {\n      var props = keys(source),\n          methodNames = baseFunctions(source, props);\n\n      if (options == null &&\n          !(isObject(source) && (methodNames.length || !props.length))) {\n        options = source;\n        source = object;\n        object = this;\n        methodNames = baseFunctions(source, keys(source));\n      }\n      var chain = (isObject(options) && 'chain' in options) ? options.chain : true,\n          isFunc = isFunction(object);\n\n      arrayEach(methodNames, function(methodName) {\n        var func = source[methodName];\n        object[methodName] = func;\n        if (isFunc) {\n          object.prototype[methodName] = function() {\n            var chainAll = this.__chain__;\n            if (chain || chainAll) {\n              var result = object(this.__wrapped__),\n                  actions = result.__actions__ = copyArray(this.__actions__);\n\n              actions.push({ 'func': func, 'args': arguments, 'thisArg': object });\n              result.__chain__ = chainAll;\n              return result;\n            }\n            return func.apply(object, arrayPush([this.value()], arguments));\n          };\n        }\n      });\n\n      return object;\n    }\n\n    /**\n     * Reverts the `_` variable to its previous value and returns a reference to\n     * the `lodash` function.\n     *\n     * @static\n     * @memberOf _\n     * @category Util\n     * @returns {Function} Returns the `lodash` function.\n     * @example\n     *\n     * var lodash = _.noConflict();\n     */\n    function noConflict() {\n      root._ = oldDash;\n      return this;\n    }\n\n    /**\n     * A no-operation function that returns `undefined` regardless of the\n     * arguments it receives.\n     *\n     * @static\n     * @memberOf _\n     * @category Util\n     * @example\n     *\n     * var object = { 'user': 'fred' };\n     *\n     * _.noop(object) === undefined;\n     * // => true\n     */\n    function noop() {\n      // No operation performed.\n    }\n\n    /**\n     * Creates a function that returns its nth argument.\n     *\n     * @static\n     * @memberOf _\n     * @category Util\n     * @param {number} [n=0] The index of the argument to return.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var func = _.nthArg(1);\n     *\n     * func('a', 'b', 'c');\n     * // => 'b'\n     */\n    function nthArg(n) {\n      n = toInteger(n);\n      return function() {\n        return arguments[n];\n      };\n    }\n\n    /**\n     * Creates a function that invokes `iteratees` with the arguments provided\n     * to the created function and returns their results.\n     *\n     * @static\n     * @memberOf _\n     * @category Util\n     * @param {...(Function|Function[])} iteratees The iteratees to invoke.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var func = _.over(Math.max, Math.min);\n     *\n     * func(1, 2, 3, 4);\n     * // => [4, 1]\n     */\n    var over = createOver(arrayMap);\n\n    /**\n     * Creates a function that checks if **all** of the `predicates` return\n     * truthy when invoked with the arguments provided to the created function.\n     *\n     * @static\n     * @memberOf _\n     * @category Util\n     * @param {...(Function|Function[])} predicates The predicates to check.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var func = _.overEvery(Boolean, isFinite);\n     *\n     * func('1');\n     * // => true\n     *\n     * func(null);\n     * // => false\n     *\n     * func(NaN);\n     * // => false\n     */\n    var overEvery = createOver(arrayEvery);\n\n    /**\n     * Creates a function that checks if **any** of the `predicates` return\n     * truthy when invoked with the arguments provided to the created function.\n     *\n     * @static\n     * @memberOf _\n     * @category Util\n     * @param {...(Function|Function[])} predicates The predicates to check.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var func = _.overSome(Boolean, isFinite);\n     *\n     * func('1');\n     * // => true\n     *\n     * func(null);\n     * // => true\n     *\n     * func(NaN);\n     * // => false\n     */\n    var overSome = createOver(arraySome);\n\n    /**\n     * Creates a function that returns the value at `path` of a given object.\n     *\n     * @static\n     * @memberOf _\n     * @category Util\n     * @param {Array|string} path The path of the property to get.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var objects = [\n     *   { 'a': { 'b': { 'c': 2 } } },\n     *   { 'a': { 'b': { 'c': 1 } } }\n     * ];\n     *\n     * _.map(objects, _.property('a.b.c'));\n     * // => [2, 1]\n     *\n     * _.map(_.sortBy(objects, _.property(['a', 'b', 'c'])), 'a.b.c');\n     * // => [1, 2]\n     */\n    function property(path) {\n      return isKey(path) ? baseProperty(path) : basePropertyDeep(path);\n    }\n\n    /**\n     * The opposite of `_.property`; this method creates a function that returns\n     * the value at a given path of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @category Util\n     * @param {Object} object The object to query.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var array = [0, 1, 2],\n     *     object = { 'a': array, 'b': array, 'c': array };\n     *\n     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));\n     * // => [2, 0]\n     *\n     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));\n     * // => [2, 0]\n     */\n    function propertyOf(object) {\n      return function(path) {\n        return object == null ? undefined : baseGet(object, path);\n      };\n    }\n\n    /**\n     * Creates an array of numbers (positive and/or negative) progressing from\n     * `start` up to, but not including, `end`. A step of `-1` is used if a negative\n     * `start` is specified without an `end` or `step`. If `end` is not specified\n     * it's set to `start` with `start` then set to `0`.  If `end` is less than\n     * `start` a zero-length range is created unless a negative `step` is specified.\n     *\n     * **Note:** JavaScript follows the IEEE-754 standard for resolving\n     * floating-point values which can produce unexpected results.\n     *\n     * @static\n     * @memberOf _\n     * @category Util\n     * @param {number} [start=0] The start of the range.\n     * @param {number} end The end of the range.\n     * @param {number} [step=1] The value to increment or decrement by.\n     * @returns {Array} Returns the new array of numbers.\n     * @example\n     *\n     * _.range(4);\n     * // => [0, 1, 2, 3]\n     *\n     * _.range(-4);\n     * // => [0, -1, -2, -3]\n     *\n     * _.range(1, 5);\n     * // => [1, 2, 3, 4]\n     *\n     * _.range(0, 20, 5);\n     * // => [0, 5, 10, 15]\n     *\n     * _.range(0, -4, -1);\n     * // => [0, -1, -2, -3]\n     *\n     * _.range(1, 4, 0);\n     * // => [1, 1, 1]\n     *\n     * _.range(0);\n     * // => []\n     */\n    var range = createRange();\n\n    /**\n     * This method is like `_.range` except that it populates values in\n     * descending order.\n     *\n     * @static\n     * @memberOf _\n     * @category Util\n     * @param {number} [start=0] The start of the range.\n     * @param {number} end The end of the range.\n     * @param {number} [step=1] The value to increment or decrement by.\n     * @returns {Array} Returns the new array of numbers.\n     * @example\n     *\n     * _.rangeRight(4);\n     * // => [3, 2, 1, 0]\n     *\n     * _.rangeRight(-4);\n     * // => [-3, -2, -1, 0]\n     *\n     * _.rangeRight(1, 5);\n     * // => [4, 3, 2, 1]\n     *\n     * _.rangeRight(0, 20, 5);\n     * // => [15, 10, 5, 0]\n     *\n     * _.rangeRight(0, -4, -1);\n     * // => [-3, -2, -1, 0]\n     *\n     * _.rangeRight(1, 4, 0);\n     * // => [1, 1, 1]\n     *\n     * _.rangeRight(0);\n     * // => []\n     */\n    var rangeRight = createRange(true);\n\n    /**\n     * Invokes the iteratee function `n` times, returning an array of the results\n     * of each invocation. The iteratee is invoked with one argument; (index).\n     *\n     * @static\n     * @memberOf _\n     * @category Util\n     * @param {number} n The number of times to invoke `iteratee`.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the array of results.\n     * @example\n     *\n     * _.times(3, String);\n     * // => ['0', '1', '2']\n     *\n     *  _.times(4, _.constant(true));\n     * // => [true, true, true, true]\n     */\n    function times(n, iteratee) {\n      n = toInteger(n);\n      if (n < 1 || n > MAX_SAFE_INTEGER) {\n        return [];\n      }\n      var index = MAX_ARRAY_LENGTH,\n          length = nativeMin(n, MAX_ARRAY_LENGTH);\n\n      iteratee = toFunction(iteratee);\n      n -= MAX_ARRAY_LENGTH;\n\n      var result = baseTimes(length, iteratee);\n      while (++index < n) {\n        iteratee(index);\n      }\n      return result;\n    }\n\n    /**\n     * Converts `value` to a property path array.\n     *\n     * @static\n     * @memberOf _\n     * @category Util\n     * @param {*} value The value to convert.\n     * @returns {Array} Returns the new property path array.\n     * @example\n     *\n     * _.toPath('a.b.c');\n     * // => ['a', 'b', 'c']\n     *\n     * _.toPath('a[0].b.c');\n     * // => ['a', '0', 'b', 'c']\n     *\n     * var path = ['a', 'b', 'c'],\n     *     newPath = _.toPath(path);\n     *\n     * console.log(newPath);\n     * // => ['a', 'b', 'c']\n     *\n     * console.log(path === newPath);\n     * // => false\n     */\n    function toPath(value) {\n      return isArray(value) ? arrayMap(value, String) : stringToPath(value);\n    }\n\n    /**\n     * Generates a unique ID. If `prefix` is provided the ID is appended to it.\n     *\n     * @static\n     * @memberOf _\n     * @category Util\n     * @param {string} [prefix] The value to prefix the ID with.\n     * @returns {string} Returns the unique ID.\n     * @example\n     *\n     * _.uniqueId('contact_');\n     * // => 'contact_104'\n     *\n     * _.uniqueId();\n     * // => '105'\n     */\n    function uniqueId(prefix) {\n      var id = ++idCounter;\n      return toString(prefix) + id;\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Adds two numbers.\n     *\n     * @static\n     * @memberOf _\n     * @category Math\n     * @param {number} augend The first number in an addition.\n     * @param {number} addend The second number in an addition.\n     * @returns {number} Returns the total.\n     * @example\n     *\n     * _.add(6, 4);\n     * // => 10\n     */\n    function add(augend, addend) {\n      var result;\n      if (augend !== undefined) {\n        result = augend;\n      }\n      if (addend !== undefined) {\n        result = result === undefined ? addend : (result + addend);\n      }\n      return result;\n    }\n\n    /**\n     * Computes `number` rounded up to `precision`.\n     *\n     * @static\n     * @memberOf _\n     * @category Math\n     * @param {number} number The number to round up.\n     * @param {number} [precision=0] The precision to round up to.\n     * @returns {number} Returns the rounded up number.\n     * @example\n     *\n     * _.ceil(4.006);\n     * // => 5\n     *\n     * _.ceil(6.004, 2);\n     * // => 6.01\n     *\n     * _.ceil(6040, -2);\n     * // => 6100\n     */\n    var ceil = createRound('ceil');\n\n    /**\n     * Computes `number` rounded down to `precision`.\n     *\n     * @static\n     * @memberOf _\n     * @category Math\n     * @param {number} number The number to round down.\n     * @param {number} [precision=0] The precision to round down to.\n     * @returns {number} Returns the rounded down number.\n     * @example\n     *\n     * _.floor(4.006);\n     * // => 4\n     *\n     * _.floor(0.046, 2);\n     * // => 0.04\n     *\n     * _.floor(4060, -2);\n     * // => 4000\n     */\n    var floor = createRound('floor');\n\n    /**\n     * Computes the maximum value of `array`. If `array` is empty or falsey\n     * `undefined` is returned.\n     *\n     * @static\n     * @memberOf _\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @returns {*} Returns the maximum value.\n     * @example\n     *\n     * _.max([4, 2, 8, 6]);\n     * // => 8\n     *\n     * _.max([]);\n     * // => undefined\n     */\n    function max(array) {\n      return (array && array.length)\n        ? baseExtremum(array, identity, gt)\n        : undefined;\n    }\n\n    /**\n     * This method is like `_.max` except that it accepts `iteratee` which is\n     * invoked for each element in `array` to generate the criterion by which\n     * the value is ranked. The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @param {Function|Object|string} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {*} Returns the maximum value.\n     * @example\n     *\n     * var objects = [{ 'n': 1 }, { 'n': 2 }];\n     *\n     * _.maxBy(objects, function(o) { return o.a; });\n     * // => { 'n': 2 }\n     *\n     * // using the `_.property` iteratee shorthand\n     * _.maxBy(objects, 'n');\n     * // => { 'n': 2 }\n     */\n    function maxBy(array, iteratee) {\n      return (array && array.length)\n        ? baseExtremum(array, getIteratee(iteratee), gt)\n        : undefined;\n    }\n\n    /**\n     * Computes the mean of the values in `array`.\n     *\n     * @static\n     * @memberOf _\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @returns {number} Returns the mean.\n     * @example\n     *\n     * _.mean([4, 2, 8, 6]);\n     * // => 5\n     */\n    function mean(array) {\n      return sum(array) / (array ? array.length : 0);\n    }\n\n    /**\n     * Computes the minimum value of `array`. If `array` is empty or falsey\n     * `undefined` is returned.\n     *\n     * @static\n     * @memberOf _\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @returns {*} Returns the minimum value.\n     * @example\n     *\n     * _.min([4, 2, 8, 6]);\n     * // => 2\n     *\n     * _.min([]);\n     * // => undefined\n     */\n    function min(array) {\n      return (array && array.length)\n        ? baseExtremum(array, identity, lt)\n        : undefined;\n    }\n\n    /**\n     * This method is like `_.min` except that it accepts `iteratee` which is\n     * invoked for each element in `array` to generate the criterion by which\n     * the value is ranked. The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @param {Function|Object|string} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {*} Returns the minimum value.\n     * @example\n     *\n     * var objects = [{ 'n': 1 }, { 'n': 2 }];\n     *\n     * _.minBy(objects, function(o) { return o.a; });\n     * // => { 'n': 1 }\n     *\n     * // using the `_.property` iteratee shorthand\n     * _.minBy(objects, 'n');\n     * // => { 'n': 1 }\n     */\n    function minBy(array, iteratee) {\n      return (array && array.length)\n        ? baseExtremum(array, getIteratee(iteratee), lt)\n        : undefined;\n    }\n\n    /**\n     * Computes `number` rounded to `precision`.\n     *\n     * @static\n     * @memberOf _\n     * @category Math\n     * @param {number} number The number to round.\n     * @param {number} [precision=0] The precision to round to.\n     * @returns {number} Returns the rounded number.\n     * @example\n     *\n     * _.round(4.006);\n     * // => 4\n     *\n     * _.round(4.006, 2);\n     * // => 4.01\n     *\n     * _.round(4060, -2);\n     * // => 4100\n     */\n    var round = createRound('round');\n\n    /**\n     * Subtract two numbers.\n     *\n     * @static\n     * @memberOf _\n     * @category Math\n     * @param {number} minuend The first number in a subtraction.\n     * @param {number} subtrahend The second number in a subtraction.\n     * @returns {number} Returns the difference.\n     * @example\n     *\n     * _.subtract(6, 4);\n     * // => 2\n     */\n    function subtract(minuend, subtrahend) {\n      var result;\n      if (minuend !== undefined) {\n        result = minuend;\n      }\n      if (subtrahend !== undefined) {\n        result = result === undefined ? subtrahend : (result - subtrahend);\n      }\n      return result;\n    }\n\n    /**\n     * Computes the sum of the values in `array`.\n     *\n     * @static\n     * @memberOf _\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @returns {number} Returns the sum.\n     * @example\n     *\n     * _.sum([4, 2, 8, 6]);\n     * // => 20\n     */\n    function sum(array) {\n      return (array && array.length)\n        ? baseSum(array, identity)\n        : undefined;\n    }\n\n    /**\n     * This method is like `_.sum` except that it accepts `iteratee` which is\n     * invoked for each element in `array` to generate the value to be summed.\n     * The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @param {Function|Object|string} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {number} Returns the sum.\n     * @example\n     *\n     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];\n     *\n     * _.sumBy(objects, function(o) { return o.n; });\n     * // => 20\n     *\n     * // using the `_.property` iteratee shorthand\n     * _.sumBy(objects, 'n');\n     * // => 20\n     */\n    function sumBy(array, iteratee) {\n      return (array && array.length)\n        ? baseSum(array, getIteratee(iteratee))\n        : undefined;\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    // Ensure wrappers are instances of `baseLodash`.\n    lodash.prototype = baseLodash.prototype;\n\n    LodashWrapper.prototype = baseCreate(baseLodash.prototype);\n    LodashWrapper.prototype.constructor = LodashWrapper;\n\n    LazyWrapper.prototype = baseCreate(baseLodash.prototype);\n    LazyWrapper.prototype.constructor = LazyWrapper;\n\n    // Avoid inheriting from `Object.prototype` when possible.\n    Hash.prototype = nativeCreate ? nativeCreate(null) : objectProto;\n\n    // Add functions to the `MapCache`.\n    MapCache.prototype.clear = mapClear;\n    MapCache.prototype['delete'] = mapDelete;\n    MapCache.prototype.get = mapGet;\n    MapCache.prototype.has = mapHas;\n    MapCache.prototype.set = mapSet;\n\n    // Add functions to the `SetCache`.\n    SetCache.prototype.push = cachePush;\n\n    // Add functions to the `Stack` cache.\n    Stack.prototype.clear = stackClear;\n    Stack.prototype['delete'] = stackDelete;\n    Stack.prototype.get = stackGet;\n    Stack.prototype.has = stackHas;\n    Stack.prototype.set = stackSet;\n\n    // Assign cache to `_.memoize`.\n    memoize.Cache = MapCache;\n\n    // Add functions that return wrapped values when chaining.\n    lodash.after = after;\n    lodash.ary = ary;\n    lodash.assign = assign;\n    lodash.assignIn = assignIn;\n    lodash.assignInWith = assignInWith;\n    lodash.assignWith = assignWith;\n    lodash.at = at;\n    lodash.before = before;\n    lodash.bind = bind;\n    lodash.bindAll = bindAll;\n    lodash.bindKey = bindKey;\n    lodash.chain = chain;\n    lodash.chunk = chunk;\n    lodash.compact = compact;\n    lodash.concat = concat;\n    lodash.cond = cond;\n    lodash.conforms = conforms;\n    lodash.constant = constant;\n    lodash.countBy = countBy;\n    lodash.create = create;\n    lodash.curry = curry;\n    lodash.curryRight = curryRight;\n    lodash.debounce = debounce;\n    lodash.defaults = defaults;\n    lodash.defaultsDeep = defaultsDeep;\n    lodash.defer = defer;\n    lodash.delay = delay;\n    lodash.difference = difference;\n    lodash.differenceBy = differenceBy;\n    lodash.differenceWith = differenceWith;\n    lodash.drop = drop;\n    lodash.dropRight = dropRight;\n    lodash.dropRightWhile = dropRightWhile;\n    lodash.dropWhile = dropWhile;\n    lodash.fill = fill;\n    lodash.filter = filter;\n    lodash.flatMap = flatMap;\n    lodash.flatten = flatten;\n    lodash.flattenDeep = flattenDeep;\n    lodash.flip = flip;\n    lodash.flow = flow;\n    lodash.flowRight = flowRight;\n    lodash.fromPairs = fromPairs;\n    lodash.functions = functions;\n    lodash.functionsIn = functionsIn;\n    lodash.groupBy = groupBy;\n    lodash.initial = initial;\n    lodash.intersection = intersection;\n    lodash.intersectionBy = intersectionBy;\n    lodash.intersectionWith = intersectionWith;\n    lodash.invert = invert;\n    lodash.invokeMap = invokeMap;\n    lodash.iteratee = iteratee;\n    lodash.keyBy = keyBy;\n    lodash.keys = keys;\n    lodash.keysIn = keysIn;\n    lodash.map = map;\n    lodash.mapKeys = mapKeys;\n    lodash.mapValues = mapValues;\n    lodash.matches = matches;\n    lodash.matchesProperty = matchesProperty;\n    lodash.memoize = memoize;\n    lodash.merge = merge;\n    lodash.mergeWith = mergeWith;\n    lodash.method = method;\n    lodash.methodOf = methodOf;\n    lodash.mixin = mixin;\n    lodash.negate = negate;\n    lodash.nthArg = nthArg;\n    lodash.omit = omit;\n    lodash.omitBy = omitBy;\n    lodash.once = once;\n    lodash.orderBy = orderBy;\n    lodash.over = over;\n    lodash.overArgs = overArgs;\n    lodash.overEvery = overEvery;\n    lodash.overSome = overSome;\n    lodash.partial = partial;\n    lodash.partialRight = partialRight;\n    lodash.partition = partition;\n    lodash.pick = pick;\n    lodash.pickBy = pickBy;\n    lodash.property = property;\n    lodash.propertyOf = propertyOf;\n    lodash.pull = pull;\n    lodash.pullAll = pullAll;\n    lodash.pullAllBy = pullAllBy;\n    lodash.pullAt = pullAt;\n    lodash.range = range;\n    lodash.rangeRight = rangeRight;\n    lodash.rearg = rearg;\n    lodash.reject = reject;\n    lodash.remove = remove;\n    lodash.rest = rest;\n    lodash.reverse = reverse;\n    lodash.sampleSize = sampleSize;\n    lodash.set = set;\n    lodash.setWith = setWith;\n    lodash.shuffle = shuffle;\n    lodash.slice = slice;\n    lodash.sortBy = sortBy;\n    lodash.sortedUniq = sortedUniq;\n    lodash.sortedUniqBy = sortedUniqBy;\n    lodash.split = split;\n    lodash.spread = spread;\n    lodash.tail = tail;\n    lodash.take = take;\n    lodash.takeRight = takeRight;\n    lodash.takeRightWhile = takeRightWhile;\n    lodash.takeWhile = takeWhile;\n    lodash.tap = tap;\n    lodash.throttle = throttle;\n    lodash.thru = thru;\n    lodash.toArray = toArray;\n    lodash.toPairs = toPairs;\n    lodash.toPairsIn = toPairsIn;\n    lodash.toPath = toPath;\n    lodash.toPlainObject = toPlainObject;\n    lodash.transform = transform;\n    lodash.unary = unary;\n    lodash.union = union;\n    lodash.unionBy = unionBy;\n    lodash.unionWith = unionWith;\n    lodash.uniq = uniq;\n    lodash.uniqBy = uniqBy;\n    lodash.uniqWith = uniqWith;\n    lodash.unset = unset;\n    lodash.unzip = unzip;\n    lodash.unzipWith = unzipWith;\n    lodash.values = values;\n    lodash.valuesIn = valuesIn;\n    lodash.without = without;\n    lodash.words = words;\n    lodash.wrap = wrap;\n    lodash.xor = xor;\n    lodash.xorBy = xorBy;\n    lodash.xorWith = xorWith;\n    lodash.zip = zip;\n    lodash.zipObject = zipObject;\n    lodash.zipWith = zipWith;\n\n    // Add aliases.\n    lodash.each = forEach;\n    lodash.eachRight = forEachRight;\n    lodash.extend = assignIn;\n    lodash.extendWith = assignInWith;\n\n    // Add functions to `lodash.prototype`.\n    mixin(lodash, lodash);\n\n    /*------------------------------------------------------------------------*/\n\n    // Add functions that return unwrapped values when chaining.\n    lodash.add = add;\n    lodash.attempt = attempt;\n    lodash.camelCase = camelCase;\n    lodash.capitalize = capitalize;\n    lodash.ceil = ceil;\n    lodash.clamp = clamp;\n    lodash.clone = clone;\n    lodash.cloneDeep = cloneDeep;\n    lodash.cloneDeepWith = cloneDeepWith;\n    lodash.cloneWith = cloneWith;\n    lodash.deburr = deburr;\n    lodash.endsWith = endsWith;\n    lodash.eq = eq;\n    lodash.escape = escape;\n    lodash.escapeRegExp = escapeRegExp;\n    lodash.every = every;\n    lodash.find = find;\n    lodash.findIndex = findIndex;\n    lodash.findKey = findKey;\n    lodash.findLast = findLast;\n    lodash.findLastIndex = findLastIndex;\n    lodash.findLastKey = findLastKey;\n    lodash.floor = floor;\n    lodash.forEach = forEach;\n    lodash.forEachRight = forEachRight;\n    lodash.forIn = forIn;\n    lodash.forInRight = forInRight;\n    lodash.forOwn = forOwn;\n    lodash.forOwnRight = forOwnRight;\n    lodash.get = get;\n    lodash.gt = gt;\n    lodash.gte = gte;\n    lodash.has = has;\n    lodash.hasIn = hasIn;\n    lodash.head = head;\n    lodash.identity = identity;\n    lodash.includes = includes;\n    lodash.indexOf = indexOf;\n    lodash.inRange = inRange;\n    lodash.invoke = invoke;\n    lodash.isArguments = isArguments;\n    lodash.isArray = isArray;\n    lodash.isArrayLike = isArrayLike;\n    lodash.isArrayLikeObject = isArrayLikeObject;\n    lodash.isBoolean = isBoolean;\n    lodash.isDate = isDate;\n    lodash.isElement = isElement;\n    lodash.isEmpty = isEmpty;\n    lodash.isEqual = isEqual;\n    lodash.isEqualWith = isEqualWith;\n    lodash.isError = isError;\n    lodash.isFinite = isFinite;\n    lodash.isFunction = isFunction;\n    lodash.isInteger = isInteger;\n    lodash.isLength = isLength;\n    lodash.isMatch = isMatch;\n    lodash.isMatchWith = isMatchWith;\n    lodash.isNaN = isNaN;\n    lodash.isNative = isNative;\n    lodash.isNil = isNil;\n    lodash.isNull = isNull;\n    lodash.isNumber = isNumber;\n    lodash.isObject = isObject;\n    lodash.isObjectLike = isObjectLike;\n    lodash.isPlainObject = isPlainObject;\n    lodash.isRegExp = isRegExp;\n    lodash.isSafeInteger = isSafeInteger;\n    lodash.isString = isString;\n    lodash.isSymbol = isSymbol;\n    lodash.isTypedArray = isTypedArray;\n    lodash.isUndefined = isUndefined;\n    lodash.join = join;\n    lodash.kebabCase = kebabCase;\n    lodash.last = last;\n    lodash.lastIndexOf = lastIndexOf;\n    lodash.lowerCase = lowerCase;\n    lodash.lowerFirst = lowerFirst;\n    lodash.lt = lt;\n    lodash.lte = lte;\n    lodash.max = max;\n    lodash.maxBy = maxBy;\n    lodash.mean = mean;\n    lodash.min = min;\n    lodash.minBy = minBy;\n    lodash.noConflict = noConflict;\n    lodash.noop = noop;\n    lodash.now = now;\n    lodash.pad = pad;\n    lodash.padEnd = padEnd;\n    lodash.padStart = padStart;\n    lodash.parseInt = parseInt;\n    lodash.random = random;\n    lodash.reduce = reduce;\n    lodash.reduceRight = reduceRight;\n    lodash.repeat = repeat;\n    lodash.replace = replace;\n    lodash.result = result;\n    lodash.round = round;\n    lodash.runInContext = runInContext;\n    lodash.sample = sample;\n    lodash.size = size;\n    lodash.snakeCase = snakeCase;\n    lodash.some = some;\n    lodash.sortedIndex = sortedIndex;\n    lodash.sortedIndexBy = sortedIndexBy;\n    lodash.sortedIndexOf = sortedIndexOf;\n    lodash.sortedLastIndex = sortedLastIndex;\n    lodash.sortedLastIndexBy = sortedLastIndexBy;\n    lodash.sortedLastIndexOf = sortedLastIndexOf;\n    lodash.startCase = startCase;\n    lodash.startsWith = startsWith;\n    lodash.subtract = subtract;\n    lodash.sum = sum;\n    lodash.sumBy = sumBy;\n    lodash.template = template;\n    lodash.times = times;\n    lodash.toInteger = toInteger;\n    lodash.toLength = toLength;\n    lodash.toLower = toLower;\n    lodash.toNumber = toNumber;\n    lodash.toSafeInteger = toSafeInteger;\n    lodash.toString = toString;\n    lodash.toUpper = toUpper;\n    lodash.trim = trim;\n    lodash.trimEnd = trimEnd;\n    lodash.trimStart = trimStart;\n    lodash.truncate = truncate;\n    lodash.unescape = unescape;\n    lodash.uniqueId = uniqueId;\n    lodash.upperCase = upperCase;\n    lodash.upperFirst = upperFirst;\n\n    // Add aliases.\n    lodash.first = head;\n\n    mixin(lodash, (function() {\n      var source = {};\n      baseForOwn(lodash, function(func, methodName) {\n        if (!hasOwnProperty.call(lodash.prototype, methodName)) {\n          source[methodName] = func;\n        }\n      });\n      return source;\n    }()), { 'chain': false });\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * The semantic version number.\n     *\n     * @static\n     * @memberOf _\n     * @type string\n     */\n    lodash.VERSION = VERSION;\n\n    // Assign default placeholders.\n    arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {\n      lodash[methodName].placeholder = lodash;\n    });\n\n    // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.\n    arrayEach(['drop', 'take'], function(methodName, index) {\n      LazyWrapper.prototype[methodName] = function(n) {\n        var filtered = this.__filtered__;\n        if (filtered && !index) {\n          return new LazyWrapper(this);\n        }\n        n = n === undefined ? 1 : nativeMax(toInteger(n), 0);\n\n        var result = this.clone();\n        if (filtered) {\n          result.__takeCount__ = nativeMin(n, result.__takeCount__);\n        } else {\n          result.__views__.push({ 'size': nativeMin(n, MAX_ARRAY_LENGTH), 'type': methodName + (result.__dir__ < 0 ? 'Right' : '') });\n        }\n        return result;\n      };\n\n      LazyWrapper.prototype[methodName + 'Right'] = function(n) {\n        return this.reverse()[methodName](n).reverse();\n      };\n    });\n\n    // Add `LazyWrapper` methods that accept an `iteratee` value.\n    arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {\n      var type = index + 1,\n          isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;\n\n      LazyWrapper.prototype[methodName] = function(iteratee) {\n        var result = this.clone();\n        result.__iteratees__.push({ 'iteratee': getIteratee(iteratee, 3), 'type': type });\n        result.__filtered__ = result.__filtered__ || isFilter;\n        return result;\n      };\n    });\n\n    // Add `LazyWrapper` methods for `_.head` and `_.last`.\n    arrayEach(['head', 'last'], function(methodName, index) {\n      var takeName = 'take' + (index ? 'Right' : '');\n\n      LazyWrapper.prototype[methodName] = function() {\n        return this[takeName](1).value()[0];\n      };\n    });\n\n    // Add `LazyWrapper` methods for `_.initial` and `_.tail`.\n    arrayEach(['initial', 'tail'], function(methodName, index) {\n      var dropName = 'drop' + (index ? '' : 'Right');\n\n      LazyWrapper.prototype[methodName] = function() {\n        return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);\n      };\n    });\n\n    LazyWrapper.prototype.compact = function() {\n      return this.filter(identity);\n    };\n\n    LazyWrapper.prototype.find = function(predicate) {\n      return this.filter(predicate).head();\n    };\n\n    LazyWrapper.prototype.findLast = function(predicate) {\n      return this.reverse().find(predicate);\n    };\n\n    LazyWrapper.prototype.invokeMap = rest(function(path, args) {\n      if (typeof path == 'function') {\n        return new LazyWrapper(this);\n      }\n      return this.map(function(value) {\n        return baseInvoke(value, path, args);\n      });\n    });\n\n    LazyWrapper.prototype.reject = function(predicate) {\n      predicate = getIteratee(predicate, 3);\n      return this.filter(function(value) {\n        return !predicate(value);\n      });\n    };\n\n    LazyWrapper.prototype.slice = function(start, end) {\n      start = toInteger(start);\n\n      var result = this;\n      if (result.__filtered__ && (start > 0 || end < 0)) {\n        return new LazyWrapper(result);\n      }\n      if (start < 0) {\n        result = result.takeRight(-start);\n      } else if (start) {\n        result = result.drop(start);\n      }\n      if (end !== undefined) {\n        end = toInteger(end);\n        result = end < 0 ? result.dropRight(-end) : result.take(end - start);\n      }\n      return result;\n    };\n\n    LazyWrapper.prototype.takeRightWhile = function(predicate) {\n      return this.reverse().takeWhile(predicate).reverse();\n    };\n\n    LazyWrapper.prototype.toArray = function() {\n      return this.take(MAX_ARRAY_LENGTH);\n    };\n\n    // Add `LazyWrapper` methods to `lodash.prototype`.\n    baseForOwn(LazyWrapper.prototype, function(func, methodName) {\n      var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName),\n          isTaker = /^(?:head|last)$/.test(methodName),\n          lodashFunc = lodash[isTaker ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName],\n          retUnwrapped = isTaker || /^find/.test(methodName);\n\n      if (!lodashFunc) {\n        return;\n      }\n      lodash.prototype[methodName] = function() {\n        var value = this.__wrapped__,\n            args = isTaker ? [1] : arguments,\n            isLazy = value instanceof LazyWrapper,\n            iteratee = args[0],\n            useLazy = isLazy || isArray(value);\n\n        var interceptor = function(value) {\n          var result = lodashFunc.apply(lodash, arrayPush([value], args));\n          return (isTaker && chainAll) ? result[0] : result;\n        };\n\n        if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {\n          // Avoid lazy use if the iteratee has a \"length\" value other than `1`.\n          isLazy = useLazy = false;\n        }\n        var chainAll = this.__chain__,\n            isHybrid = !!this.__actions__.length,\n            isUnwrapped = retUnwrapped && !chainAll,\n            onlyLazy = isLazy && !isHybrid;\n\n        if (!retUnwrapped && useLazy) {\n          value = onlyLazy ? value : new LazyWrapper(this);\n          var result = func.apply(value, args);\n          result.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined });\n          return new LodashWrapper(result, chainAll);\n        }\n        if (isUnwrapped && onlyLazy) {\n          return func.apply(this, args);\n        }\n        result = this.thru(interceptor);\n        return isUnwrapped ? (isTaker ? result.value()[0] : result.value()) : result;\n      };\n    });\n\n    // Add `Array` and `String` methods to `lodash.prototype`.\n    arrayEach(['pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function(methodName) {\n      var func = arrayProto[methodName],\n          chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',\n          retUnwrapped = /^(?:pop|shift)$/.test(methodName);\n\n      lodash.prototype[methodName] = function() {\n        var args = arguments;\n        if (retUnwrapped && !this.__chain__) {\n          return func.apply(this.value(), args);\n        }\n        return this[chainName](function(value) {\n          return func.apply(value, args);\n        });\n      };\n    });\n\n    // Map minified function names to their real names.\n    baseForOwn(LazyWrapper.prototype, function(func, methodName) {\n      var lodashFunc = lodash[methodName];\n      if (lodashFunc) {\n        var key = (lodashFunc.name + ''),\n            names = realNames[key] || (realNames[key] = []);\n\n        names.push({ 'name': methodName, 'func': lodashFunc });\n      }\n    });\n\n    realNames[createHybridWrapper(undefined, BIND_KEY_FLAG).name] = [{ 'name': 'wrapper', 'func': undefined }];\n\n    // Add functions to the lazy wrapper.\n    LazyWrapper.prototype.clone = lazyClone;\n    LazyWrapper.prototype.reverse = lazyReverse;\n    LazyWrapper.prototype.value = lazyValue;\n\n    // Add chaining functions to the `lodash` wrapper.\n    lodash.prototype.at = wrapperAt;\n    lodash.prototype.chain = wrapperChain;\n    lodash.prototype.commit = wrapperCommit;\n    lodash.prototype.flatMap = wrapperFlatMap;\n    lodash.prototype.next = wrapperNext;\n    lodash.prototype.plant = wrapperPlant;\n    lodash.prototype.reverse = wrapperReverse;\n    lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;\n\n    if (iteratorSymbol) {\n      lodash.prototype[iteratorSymbol] = wrapperToIterator;\n    }\n    return lodash;\n  }\n\n  /*--------------------------------------------------------------------------*/\n\n  // Export lodash.\n  var _ = runInContext();\n\n  // Expose lodash on the free variable `window` or `self` when available. This\n  // prevents errors in cases where lodash is loaded by a script tag in the presence\n  // of an AMD loader. See http://requirejs.org/docs/errors.html#mismatch for more details.\n  (freeWindow || freeSelf || {})._ = _;\n\n  // Some AMD build optimizers like r.js check for condition patterns like the following:\n  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {\n    // Define as an anonymous module so, through path mapping, it can be\n    // referenced as the \"underscore\" module.\n    define(function() {\n      return _;\n    });\n  }\n  // Check for `exports` after `define` in case a build optimizer adds an `exports` object.\n  else if (freeExports && freeModule) {\n    // Export for Node.js.\n    if (moduleExports) {\n      (freeModule.exports = _)._ = _;\n    }\n    // Export for CommonJS support.\n    freeExports._ = _;\n  }\n  else {\n    // Export to the global object.\n    root._ = _;\n  }\n}.call(this));\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lodash/lodash.js\n ** module id = 102\n ** module chunks = 0\n **/","var h = require('ub-virtualdom/lib/h');\nclass TodoItem {\n  constructor(emit, eventBus) {\n    this.emit = emit;\n    this.eventBus = eventBus;\n  }\n\n  cssClass(item) {\n    if (item.completed === true) {\n      return 'completed';\n    } else if (item.editing === true) {\n      return 'editing';\n    } else {\n      return '';\n    }\n  }\n\n  render([id, item]) {\n    let cssClass = this.cssClass(item),\n        save = (ev) => {\n          if(ev.keyCode == 13) {\n            this.emit({\n              id: id,\n              action: 'save',\n              text: ev.target.value\n            });\n          }\n        },\n        emit = (action) => { return (ev) => { this.emit({action: action, id: id})}};\n    return (\n      h('li', {class: cssClass }, [\n        h('div', {class: \"view\"}, [\n          h('input', {class: \"toggle\",\n            type: \"checkbox\",\n            'ev-click':  emit(item.completed ? 'uncomplete' : 'complete'),\n            checked:  item.completed ? true : undefined}),\n          h('label', {'ev-dblclick':  emit('edit') }, [ item.text]),\n          h('button', {class: \"destroy\", 'ev-click':  emit('destroy') })\n        ]),\n        h('input', {class: \"edit\",\n          value:  item.text,\n          'ev-keyup': save,\n          'ev-blur':  emit('unedit'),\n          autofocus:  item.editing ? true : undefined})\n      ])\n    )\n  }\n\n}\n\nmodule.exports = TodoItem;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/todo-item.jsx\n **/","module.exports = () => {\n  return Math.random().toString(36).substring(7);\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/gen-id.js\n **/"],"sourceRoot":""}